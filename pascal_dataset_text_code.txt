program aula01; // função quadrática com a, b, c definido vs1.0<N><N>uses<N>    crt, math; //bibliotecas<N><N>var<N>    a, b, c, delta, x1, x2: real;<N>    tempx1, tempx2, tempdelta: string;<N><N>begin<N>    writeln('Função quadrática');<N><N>    a:= 1;<N>    b:= -2;<N>    c:= 3;<N><N>
    delta:= b*b-4*a*c; // delta<N><N>    if delta >= 0 then<N>    begin<N>        x1:= (-b + sqrt(delta))/(2*a); // bhaskara<N>        x2:= (-b - sqrt(delta))/(2*a); // bhaskara<N><N>        str(x1, tempx1);<N>        str(x2, tempx2);<N><N>        writeln('x1 = ' + tempx1);<N>        writeln('x1 = ' + tempx2);<N>    end<N>    else<N>    begin<N>        str(delta, tempdelta);<N>        writeln('Sorry! Delta = ' + tempdelta);<N>    end;<N><N>
program aula02; // resolvendo funçao quadrática vs2.0<N><N>var<N>    a, b, c, x1, x2, tempdelta: real;<N>    <N>begin<N>    write('Entre com o "a": ');<N>    readln(a);<N><N>    while a <> 0 do<N>    begin<N>        write('Entre com o "b": ');<N>        readln(b);<N>        write('Entre com o "c": ');<N>        readln(c);<N>        writeln;<N><N>
        tempdelta:= b*b-4*a*c; // delta<N><N>        if tempdelta >= 0 then<N>        begin<N>            x1:= (-b + sqrt(tempdelta))/(2*a); // bhaskara<N>            x2:= (-b - sqrt(tempdelta))/(2*a); // bhaskara<N><N>            writeln(#9 + 'x1 = ', x1:0:2); // x1<N>            writeln(#9 + 'x2 = ', x2:0:2); // x2<N>        end;<N><N>
        writeln(#9 + 'Delta = ', tempdelta:0:2); // delta igual a...<N>        writeln;<N>        <N>        writeln('Para sair digite 0.'+ #9);<N>        writeln;<N><N>        write('Entre com o "a": ');<N>        readln(a);<N>    end;<N><N>    writeln('Fim.')<N>end.<N><N>
program exercicio03; // resolvendo uma função afim pelo valor de dois pontos<N><N>var<N>    a, b, x1, x2, y1, y2: real;<N>    info: char;<N><N>function getA(x1, x2, y1, y2:real):real;<N>begin<N>    getA:= (y2-y1)/(x2-x1); // coeficiente angular<N>end;<N><N>
function getB(x1, x2, y1, y2:real):real;<N>begin<N>    getB:= (y1*x2-y2*x1)/(x2-x1); // coeficiente linear<N>end;<N><N>begin // principal<N>    info:= 'y';<N><N>    while (info = 'y') do<N>    begin<N>        // (x1, y1)<N>        write('Entre com x1: ');<N>        read(x1);<N>        write('Entre com y1: ');<N>        read(y1);<N>        // (x2, y2)<N>        write('Entre com x2: ');<N>        read(x2);<N>        write('Entre com y2: ');<N>        readln(y2);<N><N>
        a:= getA(x1, x2, y1, y2); // coeficiente angular<N>        b:= getB(x1, x2, y1, y2); // coeficiente linear<N><N>        writeln;<N>        writeln(#9, 'a = ', a:0:2); // coeficiente angular<N>        writeln(#9, 'b = ', b:0:2); // coeficiente linear<N>        writeln(#9, 'f(x) = ', a:0:2,'x + ', b:0:2); // função afim y = ax + b<N>        writeln;<N><N>
program exercicio01; // resolvendo funções afim vs1.0<N><N>var<N>    a, b, x: real;<N><N>function getX(a, b: real): real; // f(x)= ax + b = 0 -> x = -b / a<N>begin<N>    getX:= -b/a;<N>end;<N><N>begin // início do programa<N>    write('Entre com o a: '); //coeficiente angular<N>    readln(a);<N> <N>    while a <> 0 do<N>    begin<N>        write('Entre com o b: '); // coeficiente linear<N>        readln(b);<N><N>
        x:= getX(a, b);<N>        writeln;<N><N>        writeln(#9 + 'x = ', x:0:2);<N>        writeln;<N><N>        writeln('Para sair digite 0.');<N>        writeln;<N>        <N>        write('Entre com o a: '); //coeficiente angular<N>        readln(a);<N>    end;<N><N>
program exercicio02; // resolvendo funções afim vs2.0<N><N>var<N>    a, b, x: real;<N><N>function getX(a, b: real): real; // f(x)= ax + b = 0 -> x = -b / a<N>begin<N>    getX:= -b/a;<N>end;<N><N>begin // início do programa<N>    write('Entre com o a: '); //coeficiente angular<N>    readln(a);<N> <N>    while a <> 0 do<N>    begin<N>        write('Entre com o b: '); // coeficiente linear<N>        readln(b);<N><N>
        x:= getX(a, b);<N>        writeln;<N><N>        writeln(#9 + 'x = ', x:0:2);<N>        writeln;<N><N>        writeln('Para sair digite 0.');<N>        writeln;<N>        <N>        write('Entre com o a: '); //coeficiente angular<N>        readln(a);<N>    end;<N>        <N>    if a = 0 then<N>    begin<N>      write('Entre com o b: '); // coeficiente linear<N>      readln(b);<N>      writeln;<N>      <N>      writeln('y = ', b, ', reta paralela ao eixo x.');<N>      writeln;<N>    end;<N><N>
program aula03; // função quadrática com código inteligente vs3.0<N><N>var<N>    a, b, c, x1, x2, delta: real;<N>    <N>function getDelta(a, b, c: real): real; // delta<N>    begin<N>        getDelta:= b*b-4*a*c;<N>    end;<N><N>function  getX1(a, b, delta: real): real; // bhaskara<N>    begin<N>        getX1:= (-b + sqrt(delta))/(2*a);<N>    end;<N><N>
function  getX2(a, b, delta: real): real; // bhaskara<N>    begin<N>        getX2:= (-b - sqrt(delta))/(2*a);<N>    end;<N><N>begin // início do programa<N>    write('Entre com o "a": ');<N>    readln(a);<N><N>    while a <> 0 do<N>    begin<N>        write('Entre com o "b": ');<N>        readln(b);<N>        write('Entre com o "c": ');<N>        readln(c);<N>        writeln;<N><N>
unit UntFormulario;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, UntPessoa, Vcl.StdCtrls,<N>  System.Generics.Collections, Data.DB, MemDS, DBAccess, Ora, Vcl.Grids,<N>  Vcl.DBGrids, OraCall, Vcl.ExtCtrls, Vcl.DBCtrls, Vcl.Mask, Vcl.ComCtrls,<N>  Vcl.ToolWin, System.ImageList, Vcl.ImgList;<N><N>
unit frmCodecaveScannerUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  jwawindows, windows,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ComCtrls,{$ifndef net}NewKernelHandler,{$endif}CEFuncProc,<N>  ExtCtrls, Menus, Clipbrd, LResources, commonTypeDefs, symbolhandler, betterControls;<N><N>
type TCodeCaveScanner=class(tthread)<N>  private<N>    found:qword;<N>    progress:integer;<N>    curraddr:qword;<N>    procedure updatelabel;<N>    procedure updateprogressbar;<N>    procedure done;<N>    procedure foundone;<N>  public<N>    startaddress:ptrUint;<N>    stopaddress:ptrUint;<N>    size:qword;<N>    alsonx:boolean;<N>    procedure execute; override;<N>end;<N><N>
unit LuaMemoryRecord;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, MemoryRecordUnit, plugin, pluginexports, lua, lualib,<N>  lauxlib, LuaHandler, LuaCaller, CEFuncProc, ComCtrls, Graphics, commonTypeDefs;<N><N>procedure initializeLuaMemoryRecord;<N><N>
implementation<N><N>uses luaclass, LuaObject;<N><N>function memoryrecord_getOffsetCount(L: PLUA_State): integer; cdecl;<N>var<N>  memrec: TMemoryRecord;<N>begin<N>  memrec:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, memrec.offsetCount);<N>  result:=1;<N>end;<N><N>
unit LuaListItem;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, ComCtrls, lua, lualib, lauxlib, typinfo;<N><N>procedure initializeLuaListItem;<N><N>implementation<N><N>uses luaclass, luahandler, LuaObject;<N><N>function listitem_delete(L: Plua_State): integer; cdecl;<N>var<N>  listitem: Tlistitem;<N>begin<N>  result:=0;<N>  listitem:=luaclass_getClassObject(L);<N>  listitem.Delete;<N>end;<N><N>
function listitem_getIndex(L: PLua_State): integer; cdecl;<N>var<N>  listitem: Tlistitem;<N>begin<N>  listitem:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, listitem.Index);<N>  result:=1;<N>end;<N><N>function listitem_getImageIndex(L: PLua_State): integer; cdecl;<N>begin<N>  lua_pushinteger(L, Tlistitem(luaclass_getClassObject(L)).ImageIndex);<N>  result:=1;<N>end;<N><N>
function listitem_setImageIndex(L: PLua_State): integer; cdecl;<N>begin<N>  Tlistitem(luaclass_getClassObject(L)).ImageIndex:=lua_tointeger(L,1);<N>  result:=0;<N>end;<N><N>function listitem_getStateIndex(L: PLua_State): integer; cdecl;<N>begin<N>  lua_pushinteger(L, Tlistitem(luaclass_getClassObject(L)).StateIndex);<N>  result:=1;<N>end;<N><N>
function listitem_setStateIndex(L: PLua_State): integer; cdecl;<N>begin<N>  Tlistitem(luaclass_getClassObject(L)).StateIndex:=lua_tointeger(L,1);<N>  result:=0;<N>end;<N><N>function listitem_getSelected(L: PLua_State): integer; cdecl;<N>var<N>  listitem: Tlistitem;<N>begin<N>  listitem:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, listitem.Selected);<N>  result:=1;<N>end;<N><N>
function listitem_setSelected(L: PLua_State): integer; cdecl;<N>var<N>  listitem: Tlistitem;<N>begin<N>  listitem:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    listitem.Selected:=lua_tovariant(L, -1);<N><N>  result:=0;<N>end;<N><N>function listitem_getData(L: PLua_State): integer; cdecl;<N>var<N>  listitem: Tlistitem;<N>begin<N>  listitem:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, ptruint(listitem.Data));<N>  result:=1;<N>end;<N><N>
function listitem_setData(L: PLua_State): integer; cdecl;<N>var<N>  listitem: Tlistitem;<N>begin<N>  listitem:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    listitem.Data:=pointer(lua_tointeger(L, -1));<N><N>  result:=0;<N>end;<N><N>function listitem_getOwner(L: PLua_State): integer; cdecl;<N>var<N>  listitem: Tlistitem;<N>begin<N>  listitem:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, listitem.Owner);<N>  result:=1;<N>end;<N><N>
function listitem_getCaption(L: PLua_State): integer; cdecl;<N>var<N>  listitem: Tlistitem;<N>begin<N>  listitem:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, listitem.Caption);<N>  result:=1;<N>end;<N><N>function listitem_setCaption(L: PLua_State): integer; cdecl;<N>var<N>  listitem: Tlistitem;<N>begin<N>  listitem:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    listitem.Caption:=lua_tovariant(L, -1);<N><N>
  result:=0;<N>end;<N><N>function listitem_getChecked(L: PLua_State): integer; cdecl;<N>var<N>  listitem: Tlistitem;<N>begin<N>  listitem:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, listitem.Checked);<N>  result:=1;<N>end;<N><N>function listitem_setChecked(L: PLua_State): integer; cdecl;<N>var<N>  listitem: Tlistitem;<N>begin<N>  listitem:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    listitem.Checked:=lua_tovariant(L, -1);<N><N>
  result:=0;<N>end;<N><N>function listitem_setSubItems(L: PLua_State): integer; cdecl;<N>var<N>  listitem: Tlistitem;<N>begin<N>  listitem:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=1 then<N>    listitem.SubItems:=lua_ToCEUserData(L, 1);<N><N>  result:=1;<N>end;<N><N>
unit LuaObject;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils,lua, lualib, lauxlib, math, typinfo, Controls,<N>  ComCtrls, StdCtrls, Forms;<N><N>procedure InitializeLuaObject;<N>procedure object_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N><N>
function lua_getProperty(L: PLua_state): integer; cdecl;<N>function lua_setProperty(L: PLua_state): integer; cdecl;<N><N><N>implementation<N><N>uses LuaClass, LuaHandler, pluginexports, LuaCaller, symbolhandler;<N><N>resourcestring<N>  rsThisIsAnInvalidClassOrMethodProperty = 'This is an invalid class or method property';<N>  rsThisTypeOfMethod = 'This type of method:';<N>  rsIsNotYetSupported = ' is not yet supported';<N><N>
function object_destroy(L: PLua_State): integer; cdecl;<N>var c: TObject;<N>  metatable: integer;<N>  i,count: integer;<N>  proplist: PPropList;<N>  m: TMethod;<N>  ma: array of TMethod;<N>begin<N>  result:=0;<N><N>  i:=ifthen(lua_type(L, lua_upvalueindex(1))=LUA_TUSERDATA, lua_upvalueindex(1), 1);<N>  c:=lua_toceuserdata(L, i);<N>  lua_getmetatable(L, i);<N>  metatable:=lua_gettop(L);<N><N>
  try<N>    //now cleanup the callers<N><N>    if (c is TCustomForm) and assigned(TCustomForm(c).OnDestroy) then<N>    begin<N>      try<N>        TCustomForm(c).OnDestroy(c);<N>      except<N>        //don't care<N>      end;<N>      TCustomForm(c):=nil;<N>    end;<N><N>
    count:=GetPropList(c, proplist);<N>    for i:=0 to count-1 do<N>    begin<N>      if proplist[i]^.PropType.Kind=tkMethod then<N>      begin<N>        m:=GetMethodProp(c, proplist[i]);<N><N>        if (proplist[i]^.Name='OnDestroy') then<N>        begin<N>          if (m.Code<>nil) and (m.data<>nil) then<N>            TNotifyEvent(m)(c);<N>        end;<N><N>
        CleanupLuaCall(m);<N>        m.Code:=nil;<N>        m.data:=nil;<N>        SetMethodProp(c, proplist[i], m);<N>      end;<N>    end;<N><N>    c.free;<N>  except<N>  end;<N><N>  if lua_type(L, metatable)=LUA_TTABLE then<N>  begin<N>    lua_pushstring(L, '__autodestroy');<N>    lua_pushboolean(L, false); //make it so it doesn't need to be destroyed (again)<N>    lua_settable(L, metatable);<N>  end;<N>end;<N><N>
function object_getClassName(L: PLua_state): integer; cdecl;<N>var c: TObject;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushstring(L, c.ClassName);<N>  result:=1;<N>end;<N><N>function object_fieldAddress(L: PLua_state): integer; cdecl;<N>var c: TObject;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, ptruint(c.FieldAddress(lua_tostring(L,1))));<N>  result:=1;<N>end;<N><N>
function object_methodAddress(L: PLua_state): integer; cdecl;<N>var c: TObject;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, ptruint(c.MethodAddress(lua_tostring(L,1))));<N>  result:=1;<N>end;<N><N>function object_methodName(L: PLua_state): integer; cdecl;<N>var c: TObject;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushstring(L, c.MethodName(pointer(lua_tointeger(L,1))));<N>  result:=1;<N>end;<N><N>
unit addressparser;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}macport,{$endif}<N>  LCLIntf,SysUtils,dialogs,symbolhandler, NewKernelHandler;<N><N>resourcestring<N>  rsAPThisIsNotAValidAddress = 'This is not a valid address';<N><N>type<N>  TSeperator = (plus,minus,multiply); //the things the disassembler shows (NO DIVIDE)<N><N>
  TAddressParser=class<N>  private<N>    STR: string;<N>    blurb: string;<N>    ch: integer;<N>    address: ptruint;<N>    increase: boolean;<N>    total: array of byte; //0=seperator 1=value<N>    values: array of int64;<N>    seperators: array of TSeperator;<N><N>
//copyright Cheat Engine 2022. All rights reserved<N>unit disassemblerArm32Thumb;<N><N>{$mode objfpc}{$H+}<N>{$WARN 3177 off : Some fields coming after "$1" were not initialized}<N>interface<N><N>uses<N>  Classes, SysUtils, LastDisassembleData;<N><N><N><N>
type<N>  TInstructionGroupPointerType=(igpGroup, igpInstructions);<N>  TInstructionGroup=record<N>    mask: DWORD;<N>    value: DWORD;<N>    list: pointer;<N>    listType: TInstructionGroupPointerType;<N>    name: string;<N>  end;<N>  TInstructionGroupArray=array of TInstructionGroup;<N>  PInstructionGroupArray=^TInstructionGroupArray;<N><N>
unit LuaHeaderSections;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib, LuaHandler, cefuncproc, commonTypeDefs;<N><N>implementation<N><N>uses luaclass, LuaCollection, comctrls;<N><N><N>function headersections_add(L: PLua_State): integer; cdecl;<N>begin<N>  luaclass_newClass(L, THeaderSections(luaclass_getClassObject(L)).add);<N>  result:=1;<N>end;<N><N>
function headersections_insert(L: PLua_State): integer; cdecl;<N>begin<N>  if lua_gettop(L)>=1 then<N>  begin<N>    luaclass_newClass(L, THeaderSections(luaclass_getClassObject(L)).insert(lua_tointeger(L,1)));<N>    result:=1;<N>  end<N>  else<N>    result:=0;<N>end;<N><N>
unit addresslisthandlerunit;<N>{<N>obsolete<N><N>the addresslisthandler is a class which will deal with the general address list<N>functions, like allocating memory, adding/removing from the list, finding the<N>correct address if it's a pointer, etc...<N>}<N><N>
{obsolete, handling is now done in addresslist}<N><N>{$mode DELPHI}<N><N>interface<N><N>uses<N>  Classes, SysUtils, controls, stdctrls, comctrls, MemoryRecordUnit, symbolhandler, cefuncproc,newkernelhandler, addresslist;<N><N>resourcestring<N>  rsALHAGroupWithTheName = 'A group with the name ';<N>  rsALHAlreadyExists = ' already exists';<N><N>
unit frmCR3SwitcherUnit;<N><N>//for runtime switching between CR3 targets<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, LResources, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  Menus, maps;<N><N>type<N><N>  { TfrmCR3Switcher }<N><N>
unit frmDebuggerAttachTimeoutUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, LResources, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ExtCtrls, syncobjs, betterControls;<N><N>type<N><N>  { TfrmDebuggerAttachTimeout }<N><N>  TfrmDebuggerAttachTimeout = class(TForm)<N>    Button1: TButton;<N>    Label1: TLabel;<N>    lblStatus: TLabel;<N>    Timer1: TTimer;<N>    procedure FormShow(Sender: TObject);<N>    procedure Timer1Timer(Sender: TObject);<N>  private<N><N>
  public<N>    event: TEvent;<N>  end;<N><N><N><N>implementation<N><N>uses DebuggerInterfaceAPIWrapper;<N><N>{ TfrmDebuggerAttachTimeout }<N><N>procedure TfrmDebuggerAttachTimeout.FormShow(Sender: TObject);<N>begin<N>  constraints.MinWidth:=canvas.TextWidth('xxx xxxxx xxxxxx xx xxxxxx x xxxxxx xxxx xx xxxxx xxxx xxxxx xxx xxxx');<N>end;<N><N>
procedure TfrmDebuggerAttachTimeout.Timer1Timer(Sender: TObject);<N>var r: TWaitResult;<N>begin<N>  r:=event.WaitFor(1);<N><N>  if r=wrSignaled then<N>  begin<N>    modalresult:=mrok;<N>    exit;<N>  end<N>  else<N>  if r<>wrTimeout then<N>  begin<N>    modalresult:=mrAbort;<N>    exit;<N>  end;<N><N>
unit NewKernelHandler;<N><N>{$MODE Delphi}<N><N>interface<N><N>{$ifdef darwin}<N>uses SysUtils, MacOSAll, MacOSXPosix, macport, macportdefines;<N>{$else}<N>uses jwawindows, windows,LCLIntf,sysutils, dialogs, classes, controls,<N>     {$ifndef STANDALONECH}dbk32functions, vmxfunctions,debug, multicpuexecution,globals,{$endif} contnrs, Clipbrd;<N>{$endif}<N><N>
unit hypermode;<N><N>{$MODE Delphi}<N><N>{obsolete}<N><N>interface<N><N>uses classes,LCLIntf,sysutils,messages;<N><N>implementation<N><N>end.<N>
unit diagram;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, LCLIntf,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, controls,Types, graphics, diagramblock, diagramlink, diagramtypes,<N>  LMessages, GL, glu, GLext, dialogs, StdCtrls, ExtCtrls, betterControls;<N><N>
const diagramversion=1;<N><N>type<N>  TDiagram=class(TCustomControl)<N>  private<N>    blocks: TList;<N>    links: TList;<N>    draggedblock: record<N>      block: TDiagramBlock;<N>      point: TPoint;<N>    end;<N><N><N>    draggedPoint: record<N>      link: TDiagramLink;<N>      pointindex: integer;<N>    end;<N><N>
    draggedSideAttachPoint: record<N>      block: TDiagramBlock;<N>      link: TDiagramLink;<N>    end;<N><N>    resizing: record<N>      block: TDiagramBlock;<N>      side: TDiagramBlockSide;<N>    end;<N><N>    fAllowUserToCreatePlotPoints: boolean;<N>    fAllowUserToMovePlotPoints: boolean;<N>    fAllowUserToResizeBlocks: boolean;<N>    fAllowUserToMoveBlocks: boolean;<N>    fAllowUserToChangeAttachPoints: boolean;<N><N>
    //ogl<N>    {$IFDEF windows}<N>    fUseOpenGL: boolean;<N>    hglrc: HGLRC;<N>    {$ENDIF}<N>    fzoom: single;<N><N>    diagramConfig: TDiagramConfig;<N><N>    scrollbarbottompanel: TPanel;<N>    hscrollbar: TScrollBar;<N>    vscrollbar: TScrollbar;<N><N>
unit TypePopup;<N><N>{$MODE Delphi}<N><N>  //norm<N><N>interface<N><N>uses<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  StdCtrls, ExtCtrls, LResources, MemoryRecordUnit, CEFuncProc, CustomTypeHandler, commonTypeDefs, betterControls;<N><N>
unit LuaDissectCode;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}MacPort,{$endif}Classes, SysUtils, lua, lauxlib, lualib;<N><N>procedure initializeLuaDissectCode;<N><N>implementation<N><N>uses DissectCodeThread, luahandler, LuaClass, LuaObject, symbolhandler, symbolhandlerstructs,<N>  newkernelhandler, ProcessHandlerUnit;<N><N>
resourcestring<N>  rsTheModuleNamed = 'The module named ';<N>  rsCouldNotBeFound = ' could not be found';<N>  rsInvalidParametersForDissect = 'Invalid parameters for dissect';<N><N>function getDissectCode(L: PLua_State): integer; cdecl;<N>begin<N>  if dissectcode=nil then<N>    dissectcode:=TDissectCodeThread.create(false);<N><N>
  luaclass_newClass(L, dissectcode);<N>  result:=1;<N>end;<N><N>function dissectcode_dissect(L: PLua_State): integer; cdecl;<N>var dc: TDissectCodeThread;<N>  start: ptruint;<N>  size: integer;<N>  mi: TModuleInfo;<N>  modulename: string;<N>begin<N>  //2 versions, modulename and base,size<N>  //base can be a string too, so check paramcount<N><N>
  result:=0;<N>  dc:=luaclass_getClassObject(L);<N>  dc.waitTillDone; //just in case...<N><N>  if lua_gettop(L)=1 then<N>  begin<N>    //modulename<N>    modulename:=Lua_ToString(L,1);<N>    if symhandler.getmodulebyname(modulename, mi) then<N>    begin<N>      start:=mi.baseaddress;<N>      size:=mi.basesize;<N>    end<N>    else<N>      raise exception.create(rsTheModuleNamed+modulename+rsCouldNotBeFound)<N><N>
  end<N>  else<N>  if lua_gettop(L)=2 then<N>  begin<N>    if lua_type(L,1)=LUA_TSTRING then<N>      start:=symhandler.getAddressFromName(Lua_ToString(L,1))<N>    else<N>      start:=lua_tointeger(L,1);<N><N>    size:=lua_tointeger(L, 2);<N><N>  end<N>  else<N>    raise exception.create(rsInvalidParametersForDissect);<N><N>
<N>  //all date is here, setup a scan config<N>  setlength(dissectcode.memoryregion,1);<N>  dissectcode.memoryregion[0].BaseAddress:=start;<N>  dissectcode.memoryregion[0].MemorySize:=size;<N><N><N><N>  dc.dowork;<N>  dc.waitTillDone;<N>  result:=0;<N>end;<N><N>
unit frmBusyUnit;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ExtCtrls, memscan, syncobjs, betterControls,SyncObjs2;<N><N>
type<N><N>  { TfrmBusy }<N><N>  TfrmBusy = class(TForm)<N>    Label1: TLabel;<N>    Timer1: TTimer;<N>    procedure FormCloseQuery(Sender: TObject; var CanClose: boolean);<N>    procedure FormShow(Sender: TObject);<N>    procedure Timer1Timer(Sender: TObject);<N>  private<N>    { private declarations }<N>    oktoclose: boolean;<N>    fReason: TPostScanState;<N>    procedure setReason(r: TPostScanState);<N>  public<N>    { public declarations }<N><N>
//copyright Cheat Engine 2022. All rights reserved<N>unit DisAssemblerARM32;<N><N>{$mode objfpc}{$H+}<N>{$WARN 3177 off : Some fields coming after "$1" were not initialized}<N>interface<N><N>//last update at :a7<N><N>uses<N>  Classes, SysUtils, LastDisassembleData;<N><N>
<N><N>type<N>  TInstructionGroupPointerType=(igpGroup, igpInstructions);<N>  TInstructionGroup=record<N>    mask: DWORD;<N>    value: DWORD;<N>    list: pointer;<N>    listType: TInstructionGroupPointerType;<N>    name: string;<N>  end;<N>  TInstructionGroupArray=array of TInstructionGroup;<N>  PInstructionGroupArray=^TInstructionGroupArray;<N><N>
unit userbytedisassembler;<N>{<N>Lets the user input bytes and those will then get disassembled<N>}<N><N>{$mode ObjFPC}{$H+}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$else}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, disassembler,math;<N><N>
type<N>  TUserByteDisassembler=class(TDisassembler)<N>  private<N>    bytes: pointer;<N>    bytecount: integer;<N>  protected<N>    function readMemory(address: ptruint; destination: pointer; size: integer): integer; override;<N>  public<N>    procedure setBytes(b: pointer; size: integer);<N>    destructor destroy; override;<N>  end;<N><N>
<N>implementation<N><N>function TUserByteDisassembler.readMemory(address: ptruint; destination: pointer; size: integer): integer;<N>begin<N>  if bytes=nil then exit(0);<N><N>  result:=min(size, bytecount);<N>  CopyMemory(destination, bytes, result);<N>end;<N><N>
procedure TUserByteDisassembler.setBytes(b: pointer; size: integer);<N>begin<N>  bytecount:=size;<N><N>  if bytes<>nil then FreeMemAndNil(bytes);<N><N>  if size>0 then<N>  begin<N>    getmem(bytes, size);<N>    copymemory(bytes,b,size);<N>  end;<N>end;<N><N>
unit tcclib;<N><N>{$mode objfpc}{$H+}<N><N><N>interface<N><N>uses<N>  {$ifdef windows}windows,{$endif}<N>  {$ifdef darwin}macport, dl,macportdefines, {$endif}<N>  Classes, SysUtils, syncobjs, maps, math, Generics.Collections;<N><N><N>type<N>  TTCCTarget=(x86_64,i386{$ifdef windows}, x86_64_sysv, i386_sysv{$endif} {$ifdef darwin},aarch64{$endif});<N>  PTCCState=pointer;<N>  {$ifdef standalonetest}<N>  TSymbolListHandler=pointer;<N>  {$endif}<N><N>
  TTCCRegionInfo=record<N>     address: ptruint;<N>     size: integer;<N>     protection: dword;<N>  end;<N><N>  TTCCRegionList=specialize tlist<TTCCRegionInfo>;<N><N><N><N>  TTCCMemorystream=class(TMemoryStream)<N>  private<N>    protections: array of TTCCRegionInfo;<N><N>
//copyright Cheat Engine 2022. All rights reserved<N>unit DisAssemblerARM64;<N><N>{$mode objfpc}{$H+}<N>{$WARN 3177 off : Some fields coming after "$1" were not initialized}<N>interface<N><N>uses<N>  {$ifdef darwin}macport,{$endif}{$ifdef windows}windows,{$endif}Classes, SysUtils, LastDisassembleData;<N><N>
type<N>  <N>  TInstructionGroupPointerType=(igpGroup, igpInstructions);<N>  TInstructionGroup=record<N>    mask: DWORD;<N>    value: DWORD;<N>    list: pointer;<N>    listType: TInstructionGroupPointerType;<N>  end;<N>  TInstructionGroupArray=array of TInstructionGroup;<N>  PInstructionGroupArray=^TInstructionGroupArray;<N><N>
unit libcepack;<N><N>{$mode ObjFPC}{$H+}<N><N>//library to pack/unpack files in the CE install distribution<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>procedure cepackfile(source, destination: string);<N>procedure ceunpackfile(source, destination: string; askpermission: boolean);<N><N>
implementation<N><N>uses zstream, dialogs{$ifndef cepackexe}, controls{$endif};<N><N>{$ifndef cepackexe}<N>resourcestring<N>  askpermission='Extract %s to %s?';<N><N>function askPermissionToUnpack(source, destination: string): boolean;<N>begin<N>  result:=false;<N>  if MainThreadID=MainThreadID then //make sure it's not a new thread<N>    result:=MessageDlg(format(askpermission, [ExtractFileName(source), ExtractFileName(destination)]), mtWarning, [mbyes,mbno],0)=mryes;<N>end;<N>{$endif}<N><N>
procedure cepackfile(source, destination: string);<N>var m: tmemorystream=nil;<N>  s: string;<N>  o: tmemorystream=nil;<N>  oz: Tcompressionstream=nil;<N>begin<N>  m:=TMemoryStream.Create;<N>  m.LoadFromFile(source);<N>  try<N>    o:=tmemorystream.create;<N>    s:='CEPACK';<N>    o.WriteBuffer(s[1],length(s));<N>    o.WriteDWord(m.size);<N>    oz:=Tcompressionstream.create(clmax, o,true);<N>    oz.CopyFrom(m,0);<N>    oz.flush;<N><N>
    o.SaveToFile(destination);<N>  finally<N>    if oz<>nil then<N>      freeandnil(oz);<N><N>    if o<>nil then<N>      freeandnil(o);<N><N>    if m<>nil then<N>      freeandnil(m);<N>  end;<N>end;<N><N>procedure ceunpackfile(source, destination: string; askpermission: boolean);<N>var<N>  i: tmemorystream=nil;<N>  iz: Tdecompressionstream=nil;<N><N>
  o: tmemorystream=nil;<N>  header: pchar=nil;<N>  size: dword;<N>begin<N>  {$ifndef cepackexe}<N>  if askpermission then<N>  begin<N>    if not askPermissionToUnpack(source,destination) then<N>      raise exception.create('Permission denied');<N>  end;<N>  {$endif}<N><N>
  i:=TMemoryStream.Create;<N>  try<N>    i.LoadFromFile(source);<N><N>    header:=nil;<N>    getmem(header,7);<N>    i.position:=0;<N>    i.ReadBuffer(header^,6);<N>    header[6]:=#0;<N>    if header='CEPACK' then<N>    begin<N>      size:=i.ReadDWord;<N>      iz:=Tdecompressionstream.create(i,true);<N><N>
      o:=tmemorystream.create;<N>      o.CopyFrom(iz,size);<N>      o.SaveToFile(destination);<N>      freeandnil(o);<N>    end<N>    else<N>      raise exception.create('invalid inputfile (wrong header)');<N><N>  finally<N>    if iz<>nil then<N>      freeandnil(iz);<N><N>
unit frmpointerrescanconnectdialogunit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ExtCtrls, resolve, Sockets, betterControls;<N><N>type<N><N>  { TfrmPointerrescanConnectDialog }<N><N>
  TfrmPointerrescanConnectDialog = class(TForm)<N>    btnCancel: TButton;<N>    btnOK: TButton;<N>    edtHost: TEdit;<N>    edtPort: TEdit;<N>    lblHost: TLabel;<N>    lblPort: TLabel;<N>    Panel1: TPanel;<N>    procedure btnOKClick(Sender: TObject);<N>    procedure FormCreate(Sender: TObject);<N>  private<N>    { private declarations }<N>  public<N>    { public declarations }<N>    host: THostAddr;<N>    port: integer;<N>  end;<N><N>
var<N>  frmPointerrescanConnectDialog: TfrmPointerrescanConnectDialog;<N><N>implementation<N><N>{$R *.lfm}<N><N>resourcestring<N>  rsHost = 'host:';<N>  rsCouldNotBeResolved = ' could not be resolved';<N><N>{ TfrmPointerrescanConnectDialog }<N><N>procedure TfrmPointerrescanConnectDialog.btnOKClick(Sender: TObject);<N>var hr:THostResolver;<N>begin<N>  hr:=THostResolver.Create(nil);<N>  try<N><N>
    host:=StrToNetAddr(edtHost.text);<N><N>    if host.s_bytes[4]=0 then<N>    begin<N>      if hr.NameLookup(edtHost.text) then<N>        host:=hr.NetHostAddress<N>      else<N>        raise exception.create(rsHost+edtHost.text+rsCouldNotBeResolved);<N>    end;<N><N>
unit guisafecriticalsection;<N><N>{<N>This critical section implementation allows synchronize events to be fired from<N>inside a thread while it has a lock<N><N>Of course, do keep on the lookout that watching that the synchronize routines<N>don't acquire a lock themselves.<N>}<N><N>
unit LuaFileDialog;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, dialogs, lua, lauxlib, lualib;<N><N>implementation<N><N>uses LuaClass, LuaHandler, LuaCommonDialog;<N><N>function filedialog_getFiles(L: Plua_State): integer; cdecl;<N>var<N>  t: TFileDialog;<N>begin<N>  t:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, t.Files);<N>  result:=1;<N>end;<N><N>
procedure filedialog_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>begin<N>  //only export "Files", the rest is already published (and Execute is part of commondialog)<N>  commondialog_addMetaData(L, metatable, userdata);<N>  Luaclass_addPropertyToTable(L, metatable, userdata, 'Files', filedialog_getFiles, nil);<N>end;<N><N>
unit FoundCodeUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, math,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  LCLIntf, LResources, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, Dialogs, StdCtrls, disassembler, ExtCtrls, Menus,<N>  NewKernelHandler, clipbrd, ComCtrls, fgl, formChangedAddresses, LastDisassembleData,<N>  vmxfunctions, betterControls,  Maps, syncobjs, contexthandler;<N><N>
type<N>  Tcoderecord = class<N>  private<N>    fhitcount: integer;<N>    fcontext: pointer;<N>    contexthandler: TContextInfo;<N>    function getContext: pointer;<N>    procedure setContext(ctx: Pointer);<N><N>    procedure setHitcount(c: integer);<N>  public<N>    firstSeen: TDateTime;<N>    lastSeen: TDateTime;<N>    addressString: string;<N>    address: ptrUint;<N>    size: integer;<N>    opcode: string;<N>    description: string;<N><N>
    stack: record<N>      savedsize: ptruint;<N>      stack: pbyte;<N>    end;<N><N>    ipt: record<N>      log: pointer;<N>      size: integer;<N>    end;<N><N>    dbvmcontextbasic:    PPageEventBasic;<N><N><N>    diffcount: integer;<N>    LastDisassembleData: TLastDisassembleData;<N><N>
    formChangedAddresses: TfrmChangedAddresses;<N><N>    property hitcount: integer read fhitcount write setHitcount;<N>    property context: pointer read getContext write setContext;<N>    procedure savestack;<N>    constructor create;<N>    destructor destroy; override;<N>end;<N><N>
type<N><N>  { TFoundCodeDialog }<N>  TFoundCodeDialog=class;<N><N>  {$ifdef windows}<N>  TDBVMWatchPollThread=class(TThread)<N>  private<N>    results: PPageEventListDescriptor;<N>    resultsize: integer;<N><N>    cr3disassembler: Tcr3Disassembler;<N>    procedure addEntriesToList;<N>  public<N>    id: integer;<N>    fcd: TFoundCodeDialog;<N>    procedure execute; override;<N>  end;<N>  {$endif}<N><N>
unit frmFillMemoryUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, math,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Variants, Classes, Graphics, Controls,<N>  Forms, Dialogs, StdCtrls, CEFuncProc, NewKernelHandler, LResources, ExtCtrls, betterControls;<N><N>
unit LuaDiagram;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib,LuaHandler, diagram, diagramblock,<N>  diagramlink, diagramtypes, typinfo, betterControls;<N><N>procedure initializeLuaDiagram;<N><N>function lua_toDiagramBlockSideDescriptor(L: PLua_state; index: integer): TDiagramBlockSideDescriptor;<N>procedure lua_pushDiagramBlockSideDescriptor(L: PLua_state; dbsd: TDiagramBlockSideDescriptor);<N><N>
implementation<N><N>uses controls, luaclass, LuaCustomControl, LuaObject;<N><N>procedure lua_pushDiagramBlockSideDescriptor(L: PLua_state; dbsd: TDiagramBlockSideDescriptor);<N>var i: integer;<N>begin<N>  lua_newtable(L);<N>  i:=lua_gettop(L);<N><N>  lua_pushstring(L, 'Block');<N>  luaclass_newClass(L, dbsd.block);<N>  lua_settable(L,i);<N><N>
  lua_pushstring(L, 'Side');<N>  lua_pushinteger(L,integer(dbsd.side));<N>  lua_settable(L,i);<N><N>  lua_pushstring(L, 'Position');<N>  lua_pushinteger(L,dbsd.sideposition);<N>  lua_settable(L,i);<N>end;<N><N>function lua_toDiagramBlockSideDescriptor(L: PLua_state; index: integer): TDiagramBlockSideDescriptor;<N>var<N>  r: TDiagramBlockSideDescriptor;<N>  i: integer;<N>begin<N>  r.block:=nil;<N>  r.side:=dbsTop;<N>  r.sideposition:=0;<N><N>
  i:=lua_absindex(L,index);<N><N>  if lua_istable(L,i) then<N>  begin<N>    lua_pushstring(L,'Block');<N>    lua_gettable(L,i);<N><N>    if not lua_isnil(L,-1) then<N>      r.block:=lua_ToCEUserData(L,-1)<N>    else<N>    begin<N>      lua_pop(l,1);<N>      //try integer (perhaps it's just a block and no side)<N>      lua_pushinteger(L,1);<N>      lua_gettable(L,i);<N><N>
unit frameHotkeyConfigUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ExtCtrls, LResources, Menus, Buttons, CEFuncProc,<N>  commonTypeDefs, LCLType, betterControls;<N><N>
unit pointervaluelist;<N><N>{$MODE Delphi}<N><N>{<N>The pointerlist will hold a map of all possible pointer values, and the addresses that link to them<N>it also contains some extra information like if it's static just so the pointerscan can save some calls doing it itself eachtime<N><N>
unit LuaThread;<N><N>{<N>This unit contains the class used to control the threads spawned by lua<N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows, comobj,<N>  {$endif}<N>  Classes, SysUtils,lua, lualib, lauxlib, LuaHandler, syncobjs,<N>  SyncObjs2;<N><N>
procedure initializeLuaThread;<N><N>implementation<N><N>uses LuaClass, LuaObject;<N><N>resourcestring<N>  rsErrorInNativeThreadCalled = 'Error in native thread called ';<N>  rsInNativeCode = ' in native code:';<N>  rsInvalidFirstParameterForCreateNativeThread = 'Invalid first parameter for createNativeThread';<N><N>
unit LuaByteTable;<N><N>//ByteTable related functions<N><N>//A byte table is just a normal table with element ranging from 0 to 255<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua;<N><N>procedure initializeLuaByteTable;<N>procedure readBytesFromTable(L: PLua_State; tableindex: integer; p: PByteArray; maxsize: integer);<N>procedure CreateByteTableFromPointer(L: PLua_state; p: pbytearray; size: integer );<N><N>
implementation<N><N>uses luahandler, frmFloatingPointPanelUnit{$ifdef darwin},mactypes{$endif};<N><N>procedure CreateByteTableFromPointer(L: PLua_state; p: pbytearray; size: integer );<N>var t,i: integer;<N>begin<N>  lua_createtable(L, size, 0);<N><N>  //lua_newtable(L);<N>  t:=lua_gettop(L);<N>  for i:=1 to size do<N>  begin<N>//    lua_pushinteger(L, i);<N>    lua_pushinteger(L, p[i-1]);<N>    //lua_settable(L, t);<N>    lua_rawseti(L, t, i);<N>  end;<N>end;<N><N>
procedure readBytesFromTable(L: PLua_State; tableindex: integer; p: PByteArray; maxsize: integer);<N>var i,j,x: integer;<N>begin<N>  for i:=1 to maxsize do<N>  begin<N>    lua_pushinteger(L, i);<N>    lua_gettable(L, tableindex);<N><N>    if lua_isnil(L,-1) then<N>    begin<N>      lua_pop(L,1);<N>      for j:=i-1 to maxsize-1 do //zero out the rest<N>        p[j]:=0;<N><N>
      exit;<N>    end;<N><N>    p[i-1]:=lua_tointeger(L, -1);<N>    lua_pop(L,1);<N>  end;<N>end;<N><N>function wordToByteTable(L: PLua_state): integer; cdecl;<N>var v: word;<N>begin<N>  result:=0;<N>  if lua_gettop(L)=1 then<N>  begin<N>    v:=lua_tointeger(L, 1);<N>    CreateByteTableFromPointer(L, @v, sizeof(v));<N>    result:=1;<N>  end;<N>end;<N><N>
function dwordToByteTable(L: PLua_state): integer; cdecl;<N>var v: dword;<N>begin<N>  result:=0;<N>  if lua_gettop(L)=1 then<N>  begin<N>    v:=lua_tointeger(L, 1);<N>    CreateByteTableFromPointer(L, @v, sizeof(v));<N>    result:=1;<N>  end;<N>end;<N><N>function qwordToByteTable(L: PLua_state): integer; cdecl;<N>var v: qword;<N>begin<N>  result:=0;<N>  if lua_gettop(L)=1 then<N>  begin<N>    v:=lua_tointeger(L, 1);<N>    CreateByteTableFromPointer(L, @v, sizeof(v));<N>    result:=1;<N>  end;<N>end;<N><N>
function floatToByteTable(L: PLua_state): integer; cdecl;<N>var v: single;<N>begin<N>  result:=0;<N>  if lua_gettop(L)=1 then<N>  begin<N>    v:=lua_tonumber(L, 1);<N>    CreateByteTableFromPointer(L, @v, sizeof(v));<N>    result:=1;<N>  end;<N>end;<N><N>function doubleToByteTable(L: PLua_state): integer; cdecl;<N>var v: double;<N>begin<N>  result:=0;<N>  if lua_gettop(L)=1 then<N>  begin<N>    v:=lua_tonumber(L, 1);<N>    CreateByteTableFromPointer(L, @v, sizeof(v));<N>    result:=1;<N>  end;<N>end;<N><N>
function extendedToByteTable(L: PLua_state): integer; cdecl;<N>var<N>  v: double;<N>  e: Extended;<N>  ex: array [0..9] of byte;<N><N>begin<N>  result:=0;<N>  if lua_gettop(L)=1 then<N>  begin<N>    v:=lua_tonumber(L, 1);<N>{$ifdef cpux86_64}<N>    doubletoextended(@v,@ex[0]);<N>    CreateByteTableFromPointer(L, @ex[0], 10);<N>{$else}<N>    e:=v;<N>    CreateByteTableFromPointer(L, @e, sizeof(e));<N>{$endif}<N><N>
    result:=1;<N>  end;<N>end;<N><N>function stringToByteTable(L: PLua_state): integer; cdecl;<N>var s: pchar;<N>  len: size_t;<N>begin<N>  result:=0;<N>  if lua_gettop(L)=1 then<N>  begin<N>    s:=lua_tolstring(L, 1, @len);<N><N>    CreateByteTableFromPointer(L, pbytearray(s), len);<N>    result:=1;<N>  end;<N>end;<N><N>
function widestringToByteTable(L: PLua_state): integer; cdecl;<N>var s: string;<N>  ws: widestring;<N>begin<N>  result:=0;<N>  if lua_gettop(L)=1 then<N>  begin<N>    s:=Lua_ToString(L, 1);<N>    ws:=s;<N>    CreateByteTableFromPointer(L, @ws[1], length(ws)*2);<N>    result:=1;<N>  end;<N>end;<N><N>
function byteTableToWord(L: PLua_state): integer; cdecl;<N>var<N>  v: word;<N>begin<N>  result:=0;<N>  if lua_gettop(L)>=1 then<N>  begin<N>    readBytesFromTable(L, 1, @v, sizeof(v));<N>    if (lua_gettop(L)>=2) and lua_toboolean(L,2) then<N>      lua_pushinteger(L,smallint(v))<N>    else<N>      lua_pushinteger(L,v);<N>    result:=1;<N>  end;<N>end;<N><N>
function byteTableToDWord(L: PLua_state): integer; cdecl;<N>var v: dword;<N>begin<N>  result:=0;<N>  if lua_gettop(L)>=1 then<N>  begin<N>    readBytesFromTable(L, 1, @v, sizeof(v));<N>    if (lua_gettop(L)>=2) and lua_toboolean(L,2) then<N>      lua_pushinteger(L,integer(v))<N>    else<N>      lua_pushinteger(L,v);<N><N>
    result:=1;<N>  end;<N>end;<N><N>function byteTableToQWord(L: PLua_state): integer; cdecl;<N>var v: qword;<N>begin<N>  result:=0;<N>  if lua_gettop(L)=1 then<N>  begin<N>    readBytesFromTable(L, 1, @v, sizeof(v));<N>    lua_pushinteger(L,v);<N>    result:=1;<N>  end;<N>end;<N><N>
function byteTableToFloat(L: PLua_state): integer; cdecl;<N>var v: single;<N>begin<N>  result:=0;<N>  if lua_gettop(L)=1 then<N>  begin<N>    readBytesFromTable(L, 1, @v, sizeof(v));<N>    lua_pushnumber(L,v);<N>    result:=1;<N>  end;<N>end;<N><N><N><N>function byteTableToDouble(L: PLua_state): integer; cdecl;<N>var v: Double;<N>begin<N>  result:=0;<N>  if lua_gettop(L)=1 then<N>  begin<N>    readBytesFromTable(L, 1, @v, sizeof(v));<N>    lua_pushnumber(L,v);<N>    result:=1;<N>  end;<N>end;<N><N>
<N>function byteTableToExtended(L: PLua_state): integer; cdecl;<N>var<N>  ex: array [0..9] of byte;<N>  v: double;<N>  e: extended;<N>begin<N>  result:=0;<N>  if lua_gettop(L)=1 then<N>  begin<N><N>{$ifdef cpux86_64}<N>    readBytesFromTable(L, 1, @ex[0], 10);<N>    extendedtodouble(@ex[0],v);<N>{$else}<N>    readBytesFromTable(L, 1, @e, sizeof(e));<N>    v:=e;<N>{$endif}<N>    lua_pushnumber(L,v);<N>    result:=1;<N>  end;<N>end;<N><N>
function byteTableToString(L: PLua_state): integer; cdecl;<N>var s: pchar;<N>  len: integer;<N>begin<N>  result:=0;<N>  if lua_gettop(L)=1 then<N>  begin<N>    len:=lua_objlen(L, 1);<N>    getmem(s, len);<N><N>    readBytesFromTable(L, 1, @s[0], len);<N>    lua_pushlstring(L, s,len);<N>    result:=1;<N>  end;<N>end;<N><N>
function byteTableToWideString(L: PLua_state): integer; cdecl;<N>var s: pwidechar;<N>  s2: pchar;<N><N>  ansis: string;<N>  len: integer;<N>begin<N>  result:=0;<N>  if lua_gettop(L)=1 then<N>  begin<N>    len:=lua_objlen(L, 1);<N>    getmem(s, len+2);<N><N>
    s2:=pointer(s);<N><N>    readBytesFromTable(L, 1, @s[0], len);<N>    s2[len]:=#0;<N>    s2[len+1]:=#0;<N><N>    ansis:=s;<N>    lua_pushstring(L, pchar(ansis));<N>    result:=1;<N>  end;<N>end;<N><N>procedure initializeLuaByteTable;<N>begin<N><N>  lua_register(LuaVM, 'wordToByteTable', wordToByteTable);<N>  lua_register(LuaVM, 'dwordToByteTable', dwordToByteTable);<N>  lua_register(LuaVM, 'qwordToByteTable', qwordToByteTable);<N><N>
  lua_register(LuaVM, 'floatToByteTable', floatToByteTable);<N>  lua_register(LuaVM, 'doubleToByteTable', doubleToByteTable);<N>  lua_register(LuaVM, 'extendedToByteTable', extendedToByteTable);<N>  lua_register(LuaVM, 'stringToByteTable', stringToByteTable);<N>  lua_register(LuaVM, 'wideStringToByteTable', wideStringToByteTable);<N><N>
unit PointerscanStructures;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, Classes, SysUtils, Sockets, CELazySocket, commonTypeDefs;<N>  {$endif}<N>  {$ifdef windows}<N>  windows, Classes, SysUtils, winsock, CELazySocket, commonTypeDefs;<N>  {$endif}<N><N>
const<N>  MAXQUEUESIZE=64;<N>  pointerscanfileversion=2;<N><N>type<N><N><N><N>  TPathQueueElement=record<N>    tempresults: array of dword;<N>    valuelist: array of qword;<N>    valuetofind: qword;<N>    startlevel: integer;<N>  end;<N>  PPathQueueElement=^TPathQueueElement;<N><N>
<N>  TMainPathQueue=array [0..MAXQUEUESIZE-1] of TPathQueueElement;<N><N>  PMainPathQueue=^TMainPathQueue;<N>  TDynPathQueue=array of TPathQueueElement;<N><N>  TPointerscanControllerParent=record<N>    socket: TSocketstream;<N>    scanid: dword;<N>    name: string;<N><N>
    iConnectedTo: boolean;<N>    connectdata: record<N>      ip: string;<N>      port: word;<N>      password: string;<N>    end;<N>    ip: string;<N>    port: word;<N><N>    trustsme: boolean;<N>    knowsIAmTerminating: boolean;<N>    connecttime: qword;<N>  end;<N><N>
  PPointerscanControllerParent=^TPointerscanControllerParent;<N><N>  TPointerscancontrollerchild=record   //todo: maybe turn this into a class with methods to call child commands ?<N>    socket: TSocketstream;<N>    MissingSince: qword; //holds the time when the connection was lost. If this is set to 0 the child info will be deleted<N>    Error: string;<N><N>
    iConnectedTo: boolean;<N>    connectdata: record<N>      ip: string;<N>      port: word;<N>      password: string;<N>    end;<N>    ip: string;<N>    port: word;<N>    childid: integer;<N>    trusted: boolean;<N>    takePathsAndDisconnect: boolean;<N>    terminating: boolean;<N><N>
    idle: boolean;<N>    //pathspersecond: qword;<N><N>    totalPathsEvaluated: qword;<N>    pathqueuesize: integer;<N>    totalpathqueuesize: integer;<N>    potentialthreadcount: integer;<N>    actualthreadcount: integer;<N><N>    resultsfound: qword;<N><N>
    queued: boolean;<N>    queuepos: dword;<N>    queuesize: dword;<N><N>    trustlevel: integer;<N>    nontrustedlastpaths: TDynPathQueue;<N>    nontrustedlastpathstime: qword;<N><N><N>    scandatauploader: TThread;<N>    ScanDataSent: qword;<N>    ScanDataTotalSize: qword;<N>    ScanDataStartTime: qword;<N>    hasReceivedScandata: boolean;<N><N>
    LastUpdateReceived: qword;<N><N>    scanresultDownloader: TThread; //not nil if the results it has sent me are still being processed<N>    resultstream: TFilestream; //if initializer this holds an open filestream to the .ptr associated with this child<N>  end;<N><N>
unit LuaPipe;<N><N>{$mode delphi}<N><N>//pipe class specifically made for lua. Only 1 client and 1 server connection at a time<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,  macpipe, mactypes,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, lua, LuaClass, syncobjs, guisafecriticalsection, newkernelhandler;<N><N>
type<N>  TPipeConnection=class<N>  private<N>    fOnTimeout: TNotifyEvent;<N>    fOnError: TNotifyEvent;<N>    procedure CloseConnection(n: TNotifyEvent);<N><N>    {$ifdef windows}<N>    function ProcessOverlappedOperation(o: POVERLAPPED): boolean;<N>    {$endif}<N>  protected<N>    pipe: THandle;<N>    fconnected: boolean;<N>    cs: TGuiSafeCriticalSection;<N>    foverlapped: boolean;<N>    ftimeout: integer;<N><N>
  public<N>    procedure lock;<N>    procedure unlock;<N>    function WriteBytes(bytes: pointer; size: integer): boolean;<N>    function ReadBytes(bytes: pointer; size: integer): boolean;<N><N>    function readDouble: double;<N>    function readFloat: single;<N><N>
    function readQword: qword;<N>    function readDword: dword;<N>    function readWord: word;<N>    function readByte: byte;<N><N>    function readString(size: integer): string;<N>    function readWideString(size: integer): widestring;<N><N>    procedure writeDouble(v: double);<N>    procedure writeFloat(v: single);<N>    procedure writeQword(v: qword);<N>    procedure writeDword(v: dword);<N>    procedure writeWord(v: word);<N>    procedure writeByte(v: byte);<N><N>
    procedure writeString(str: string; include0terminator: boolean);<N>    procedure writeWideString(str: widestring; include0terminator: boolean);<N>    constructor create;<N>    destructor destroy; override;<N>  published<N>    property connected: boolean read fConnected;<N>    property OnTimeout: TNotifyEvent read fOnTimeout write fOnTimeout;<N>    property OnError: TNotifyEvent read fOnError write fOnError;<N>    property Handle: THandle read pipe write pipe;<N>  end;<N><N>
procedure pipecontrol_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N><N><N>implementation<N><N><N>uses LuaObject, LuaByteTable, networkInterface, networkInterfaceApi;<N><N>threadvar WaitEvent: THandle;<N><N>destructor TPipeConnection.destroy;<N>begin<N>  if (pipe<>0) and (pipe<>INVALID_HANDLE_VALUE) then<N>    closehandle(pipe);<N><N>
  if cs<>nil then<N>    freeandnil(cs);<N><N>  inherited destroy;<N>end;<N><N>constructor TPipeConnection.create;<N>begin<N>  ftimeout :=5000;<N>  cs:=TGuiSafeCriticalSection.Create;<N>end;<N><N>procedure TPipeConnection.lock;<N>begin<N>  cs.Enter;<N>end;<N><N>
procedure TPipeconnection.unlock;<N>begin<N>  cs.leave;<N>end;<N><N>procedure TPipeConnection.writeDouble(v:double);<N>begin<N>  writeBytes(@v, 8);<N>end;<N><N>procedure TPipeConnection.writeFloat(v:single);<N>begin<N>  writeBytes(@v, 4);<N>end;<N><N>procedure TPipeConnection.writeQword(v:qword);<N>begin<N>  writeBytes(@v, 8);<N>end;<N><N>
procedure TPipeConnection.writeDword(v:dword);<N>begin<N>  writeBytes(@v, 4);<N>end;<N><N>procedure TPipeConnection.writeWord(v:word);<N>begin<N>  writeBytes(@v, 2);<N>end;<N><N>procedure TPipeConnection.writeByte(v:byte);<N>begin<N>  writeBytes(@v, 1);<N>end;<N><N>
function TPipeConnection.readDouble: double;<N>begin<N>  readbytes(@result, 8);<N>end;<N><N>function TPipeConnection.readFloat: single;<N>begin<N>  readbytes(@result, 4);<N>end;<N><N>function TPipeConnection.readQword: qword;<N>begin<N>  readbytes(@result, 8);<N>end;<N><N>
function TPipeConnection.readDword: dword;<N>begin<N>  readbytes(@result, 4);<N>end;<N><N>function TPipeConnection.readWord: word;<N>begin<N>  readbytes(@result, 2);<N>end;<N><N>function TPipeConnection.readByte: byte;<N>begin<N>  readbytes(@result, 1);<N>end;<N><N>
<N>procedure TPipeConnection.writeString(str: string; include0terminator: boolean);<N>begin<N>  if include0terminator then<N>    writebytes(@str[1], length(str)+1)<N>  else<N>    writebytes(@str[1], length(str));<N>end;<N><N>procedure TPipeConnection.writeWideString(str: widestring; include0terminator: boolean);<N>begin<N>  if include0terminator then<N>    writebytes(@str[1], (length(str)+1)*2)<N>  else<N>    writebytes(@str[1], (length(str)+1)*2);<N>end;<N><N>
function TPipeConnection.readString(size: integer): string;<N>var x: pchar;<N>begin<N>  getmem(x, size+1);<N>  readbytes(x, size);<N>  x[size]:=#0;<N><N>  result:=x;<N><N>  FreeMemAndNil(x);<N>end;<N><N>function TPipeConnection.readWideString(size: integer): widestring;<N>var x: pwidechar;<N>begin<N>  getmem(x, size+2);<N>  readbytes(x, size);<N><N>
  x[size]:=#0;<N>  x[size+1]:=#0;<N><N>  result:=x;<N>  FreeMemAndNil(x);<N>end;<N><N>{$ifdef windows}<N><N>function TPipeConnection.ProcessOverlappedOperation(o: POVERLAPPED): boolean;<N>var<N>  starttime: qword;<N>  i: integer;<N>  bt: dword;<N>  r: dword;<N>begin<N>  starttime:=GetTickCount64;<N>  while fconnected and ((ftimeout=0) or (gettickcount64<starttime+ftimeout)) do<N>  begin<N>    if MainThreadID=GetCurrentThreadId then<N>    begin<N>      CheckSynchronize;<N><N>
unit LuaStrings;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils,lua, lualib, lauxlib;<N><N>procedure initializeLuaStrings;<N>procedure strings_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N><N>implementation<N><N>
unit frmPagingUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, LResources, Forms, Controls, Graphics, Dialogs,<N>  StdCtrls, ComCtrls, ExtCtrls, Menus,newkernelhandler,cefuncproc, commonTypeDefs,<N>  betterControls, DBK32functions;<N><N>
unit LuaFindDialog;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, dialogs, luaclass, lua, lauxlib, luahandler, betterControls;<N><N>procedure initializeLuaFindDialog;<N><N>implementation<N><N>uses LuaCommonDialog;<N><N>function finddialog_getLeft(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushinteger(L, tfinddialog(luaclass_getClassObject(L)).Left);<N>  result:=1;<N>end;<N><N>
function finddialog_setLeft(L: Plua_State): integer; cdecl;<N>begin<N>  tfinddialog(luaclass_getClassObject(L)).Left:=lua_tointeger(L,1);<N>  result:=0;<N>end;<N><N>function finddialog_getTop(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushinteger(L, tfinddialog(luaclass_getClassObject(L)).Top);<N>  result:=1;<N>end;<N><N>
function finddialog_setTop(L: Plua_State): integer; cdecl;<N>begin<N>  tfinddialog(luaclass_getClassObject(L)).Top:=lua_tointeger(L,1);<N>  result:=0;<N>end;<N><N>function finddialog_getWidth(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushinteger(L, tfinddialog(luaclass_getClassObject(L)).Width);<N>  result:=1;<N>end;<N><N>
function finddialog_setWidth(L: Plua_State): integer; cdecl;<N>begin<N>  tfinddialog(luaclass_getClassObject(L)).Width:=lua_tointeger(L,1);<N>  result:=0;<N>end;<N><N>function finddialog_getHeight(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushinteger(L, tfinddialog(luaclass_getClassObject(L)).Height);<N>  result:=1;<N>end;<N><N>
function finddialog_setHeight(L: Plua_State): integer; cdecl;<N>begin<N>  tfinddialog(luaclass_getClassObject(L)).Height:=lua_tointeger(L,1);<N>  result:=0;<N>end;<N><N>function createFindDialog(L: Plua_State): integer; cdecl;<N>var fd: TFindDialog;<N>begin<N>  luaclass_newClass(L, TFindDialog.Create(lua_ToCEUserData(L, -1)));<N>  result:=1;<N>end;<N><N>
unit LuaImage;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib, ExtCtrls;<N><N>procedure initializeLuaImage;<N><N>implementation<N><N>uses luaclass, luahandler, LuaGraphicControl, pluginexports;<N><N>function createImage(L: Plua_State): integer; cdecl;<N>var parameters: integer;<N>  f,p: pointer;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters=1 then<N>  begin<N>    f:=lua_toceuserdata(L, -1);<N>    p:=ce_createImage(f);<N><N>
unit diagramtypes;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Graphics, Controls{$ifdef windows}, GL{$endif}, betterControls;<N><N>type<N>  TDiagramBlockSide=(dbsTop, dbsLeft, dbsRight, dbsBottom, dbsTopLeft, dbsTopRight, dbsBottomLeft, dbsBottomRight);<N><N>
  TArrowStyle=(asOrigin, asDestination, asPoints, asCenterBetweenPoints, asCenter); //centerbetweenpoints and asCenter will eat you cpu<N>  TArrowStyles=set of TArrowStyle;<N><N><N>  TDiagramConfig=class<N>  public<N>    owner: TCustomControl;<N>    canvas: TCanvas;<N>    LineThickness: integer;<N>    LineColor: TColor;<N>    PlotPointColor: TColor;<N>    PlotPointSize: integer;<N>    backgroundColor: TColor;<N>    drawPlotPoints: boolean;<N><N>
    blockTextColorNoMarkup: tcolor;<N>    BlockBackground: tcolor;<N><N>    arrowStyles: TArrowStyles;<N>    arrowSize: integer;<N>    scrollx, scrolly, maxscrollx, maxscrolly: integer;<N>    zoom: single;<N><N>    {$ifdef windows}<N>    UseOpenGL: boolean;<N>    {$endif}<N>    CanUsebuffers: boolean;<N><N>
<N>    {$ifdef windows}<N>    plotpointvertexbuf: GLint;<N>    plotpointindexbuf: GLint;<N>    {$endif}<N><N><N>    constructor create(_owner: TCustomControl);<N>  end;<N><N>implementation<N><N>constructor TDiagramConfig.create(_owner: TCustomControl);<N>begin<N>  owner:=_owner;<N>  canvas:=_owner.Canvas;<N>  LineThickness:=3;<N>  LineColor:=clBlack;<N>  PlotPointColor:=3;<N>  PlotPointSize:=4;<N>  backgroundcolor:=clGreen;<N>  drawPlotPoints:=true;<N>  BlockBackground:=$d0d0d0;<N><N>
unit frmDisassemblyscanunit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs,disassembler,{$ifndef net}NewKernelHandler,{$endif}CEFuncProc, ExtCtrls, StdCtrls,<N>  ComCtrls, LResources, LCLProc, Menus, strutils, OldRegExpr, RegExpr, Clipbrd, betterControls;<N><N>
unit LuaListbox;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib, stdctrls, controls, betterControls;<N><N>procedure initializeLuaListbox;<N>procedure listbox_addMetaData(L: PLua_state; metatable: integer; userdata: integer);<N><N>
implementation<N><N>uses luahandler, luaclass, LuaWinControl;<N><N>function createListBox(L: Plua_State): integer; cdecl;<N>var<N>  ListBox: TListBox;<N>  parameters: integer;<N>  owner: TWincontrol;<N>begin<N>  result:=0;<N><N>  parameters:=lua_gettop(L);<N>  if parameters>=1 then<N>    owner:=lua_toceuserdata(L, -parameters)<N>  else<N>    owner:=nil;<N><N>
  lua_pop(L, lua_gettop(L));<N><N><N>  ListBox:=TListBox.Create(owner);<N>  if owner<>nil then<N>    ListBox.Parent:=owner;<N><N>  luaclass_newClass(L, ListBox);<N>  result:=1;<N>end;<N><N>function listbox_clear(L: Plua_State): integer; cdecl;<N>var<N>  listbox: tcustomlistbox;<N>begin<N>  listbox:=luaclass_getClassObject(L);<N>  listbox.clear;<N>  result:=0;<N>end;<N><N>
function listbox_clearSelection(L: Plua_State): integer; cdecl;<N>var<N>  listbox: tcustomlistbox;<N>begin<N>  listbox:=luaclass_getClassObject(L);<N>  listbox.ClearSelection;<N>  result:=0;<N>end;<N><N>function listbox_selectAll(L: Plua_State): integer; cdecl;<N>var<N>  listbox: tcustomlistbox;<N>begin<N>  listbox:=luaclass_getClassObject(L);<N>  listbox.SelectAll;<N>  result:=0;<N>end;<N><N>
<N>function listbox_getItems(L: PLua_State): integer; cdecl;<N>var<N>  listbox: TCustomlistbox;<N>begin<N>  listbox:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, listbox.Items);<N>  result:=1;<N>end;<N><N>function listbox_setItems(L: PLua_State): integer; cdecl;<N>var<N>  listbox: TCustomlistbox;<N>begin<N>  listbox:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=1 then<N>    listbox.Items:=tstrings(lua_ToCEUserData(L, 1));<N><N>
  result:=1;<N>end;<N><N>function listbox_getItemIndex(L: PLua_State): integer; cdecl;<N>var<N>  listbox: TCustomlistbox;<N>begin<N>  listbox:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, listbox.ItemIndex);<N>  result:=1;<N><N>end;<N><N>function listbox_setItemIndex(L: PLua_State): integer; cdecl;<N>var<N>  listbox: Tcustomlistbox;<N>begin<N>  result:=0;<N>  listbox:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    listbox.itemindex:=lua_tointeger(L,-1);<N>end;<N><N>
unit VirtualQueryExCache;<N>{<N>Caching system that could be useful in some slow lookup/emulation situations<N>For windows there's no good way to 'cache' the VQE call, but on linux where<N>normally the full /proc/pid/map file is parsed for every call this can speed<N>things up considerably<N>}<N><N>
{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  {$ifdef JNI}<N>  Classes, SysUtils, ctypes,syncobjs, newkernelhandler, unixporthelper;<N>  {$else}<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  jwawindows, windows,<N>  {$endif} Classes, SysUtils, newkernelhandler, math;<N>  {$endif}<N><N>
type<N>  TVirtualQueryExCache=class<N>  private<N>    lastAccessed: integer;<N>    fhandle: THandle;<N>    regions: TList; //list of sorted TMEMORYBASICINFORMATION entries<N>  public<N>    function getRegion(BaseAddress: ptruint; out mbi: TMEMORYBASICINFORMATION): boolean;<N>    procedure AddRegion(mbi: TMemoryBasicInformation);<N>    constructor create(phandle: THandle);<N>    destructor destroy; override;<N>    property Handle: THandle read fHandle;<N>  end;<N><N>
implementation<N><N>destructor  TVirtualQueryExCache.destroy;<N>begin<N>  if regions<>nil then<N>    freeandnil(regions);<N><N>  inherited destroy;<N>end;<N><N>constructor TVirtualQueryExCache.create(phandle: THandle);<N>begin<N>  fhandle:=phandle;<N>  lastAccessed:=-1;<N><N>
  regions:=tlist.create;<N>end;<N><N>function TVirtualQueryExCache.getRegion(BaseAddress: ptruint; out mbi: TMEMORYBASICINFORMATION): boolean;<N>var<N>  i: integer;<N><N>//usually vqe accesses are sequential so check the next one fist (if there is one)<N>begin<N>  result:=false;<N>  if regions.count>0 then<N>  begin<N><N>
    for i:=lastAccessed+1 to regions.count-1 do<N>    begin<N>      if BaseAddress<ptruint(PMEMORYBASICINFORMATION(regions[i])^.BaseAddress) then break;<N><N>      if BaseAddress>=ptruint(PMEMORYBASICINFORMATION(regions[i])^.BaseAddress) then<N>      begin<N>        if baseaddress<ptruint(PMEMORYBASICINFORMATION(regions[i])^.BaseAddress)+PMEMORYBASICINFORMATION(regions[i])^.RegionSize then<N>        begin<N>          mbi:=PMEMORYBASICINFORMATION(regions[i])^;<N><N>
          mbi.BaseAddress:=pointer(ptruint(baseaddress) and qword($fffffffffffff000));<N>          result:=true;<N>          lastAccessed:=i;<N>          exit;<N>        end;<N>      end;<N>    end;<N><N>    if lastAccessed<>-1 then<N>    begin<N>      for i:=lastAccessed downto 0 do<N>      begin<N>        if BaseAddress>ptruint(PMEMORYBASICINFORMATION(regions[i])^.BaseAddress)+PMEMORYBASICINFORMATION(regions[i])^.RegionSize then break;  //won't be found<N><N>
unit LuaInternet;<N><N>{$mode delphi}<N><N>interface<N><N><N><N><N>uses<N>  Classes, SysUtils<N>  {$ifdef windows}, wininet<N>  {$else}<N>  , fphttpclient,opensslsockets,openssl, StringHashList<N><N>  {$endif}<N>  ;<N><N>{$ifndef standalone}<N>procedure initializeLuaInternet;<N>{$endif}<N><N>
unit formsettingsunit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, macexceptiondebuggerinterface,<N>  {$endif}<N>  {$ifdef windows}<N>  windows, win32proc,<N>  {$endif}LCLProc, LCLIntf, LCLType, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  StdCtrls,registry, Menus,ComCtrls,CEFuncProc,ExtCtrls,{tlhelp32,}CheckLst,<N>  Buttons, LResources, frameHotkeyConfigUnit, math,<N><N>
  KernelDebugger,plugin,NewKernelHandler,CEDebugger,hotkeyhandler, debugHelper,<N>  formhotkeyunit, debuggertypedefinitions, FileUtil, IniFiles, betterControls;<N><N><N>type Tpathspecifier=class(TObject)<N>  public<N>    path: string;<N>end;<N><N>type<N><N>
unit tableconverter;<N>{<N>Converts Cheat engine 5.6 tables to xmlformat tables<N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, dom, xmlread, xmlwrite, cefuncproc, commonTypeDefs;<N><N><N>function ConvertCheatTableToXML(filename: string): TXMLDocument;<N><N>
unit MemoryQuery;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>{$ifdef jni}<N>uses<N>  Classes, SysUtils, unixporthelper, NewKernelHandler;<N>{$endif}<N><N>{$ifdef windows}<N>uses<N>  Classes, SysUtils, windows, CEFuncProc, NewKernelHandler;<N>{$endif}<N><N>
{$ifdef darwin}<N>uses<N>  Classes, SysUtils, macport, CEFuncProc, NewKernelHandler;<N>{$endif}<N><N>function FindFreeBlockForRegion(base: ptrUint; size: dword): pointer;<N>function isAddress(address: ptrUint):boolean;<N>function isExecutableAddress(address: ptrUint):boolean;<N><N>
implementation<N><N>uses networkInterface, networkInterfaceApi, ProcessHandlerUnit;<N><N>{$ifdef jni}<N>var<N>  systeminfo:record<N>    lpMinimumApplicationAddress: ptruint;<N>    lpMaximumApplicationAddress: ptruint;<N>    dwAllocationGranularity: ptruint;<N>  end;<N>{$endif}<N><N>
<N>function isAddress(address: ptruint): boolean;<N>var<N>{$ifdef jni}<N>    x: byte;<N>    br: ptruint;<N>{$endif}<N>  mbi: TMemoryBasicInformation;<N>begin<N>  if address=0 then exit(false);<N>  {$ifdef jni}<N>  exit(ReadProcessMemory(processhandle, pointer(address), @x, 1, br));<N>  {$endif}<N><N>
unit elfsymbols;<N><N>{$mode OBJFPC}<N><N>interface<N><N>uses<N>{$ifdef JNI}<N>  Classes, SysUtils, elftypes, elfconsts, networkInterface, unixporthelper, newkernelhandler, processhandlerunit;<N>{$else}<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  Classes, SysUtils, elftypes, elfconsts, networkInterface, cefuncproc, newkernelhandler, processhandlerunit;<N>{$endif}<N><N>
unit pluginexports;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses {$ifdef darwin}macport,macportdefines,{$endif}<N>     {$ifdef windows}jwawindows, windows,{$endif}<N>     ExtCtrls , comctrls, Graphics, forms, StdCtrls,sysutils,Controls,<N>     SyncObjs,dialogs,LCLIntf,classes,autoassembler,<N>     CEFuncProc,NewKernelHandler,CEDebugger,KernelDebugger, plugin, math,<N>     debugHelper, debuggertypedefinitions, typinfo, ceguicomponents, strutils,<N>     commonTypeDefs, luahandler, lua, betterControls;<N><N>
unit RipRelativeScanner;<N>{<N>This class will scan a given module and return the rip relative instructions<N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  Windows,<N>  {$endif}<N>  Classes, SysUtils, disassembler, symbolhandler, symbolhandlerstructs,<N>  processhandlerunit, NewKernelHandler, CEFuncProc;<N><N>
type<N>  TRIPRelativeScanner=class<N>  private<N>    modulebase: ptruint;<N>    modulesize: dword;<N><N>    executablelist: array of record<N>                          base: ptruint;<N>                          size: dword;<N>                    end;<N><N>
unit LuaGenericHotkey;<N><N>{$mode delphi}<N><N>//todo: add table support<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, lua, lauxlib, lualib, genericHotkey, CEFuncProc,<N>  math, commonTypeDefs;<N><N>
<N>procedure initializeLuaGenericHotkey;<N><N>implementation<N><N>uses luaclass, luaobject, luahandler, luacaller;<N><N><N>function createHotkey(L: Plua_State): integer; cdecl;<N>var parameters: integer;<N>  h: TGenericHotkey;<N>  routine: string;<N><N>  lc: TLuaCaller;<N><N>
  i: integer;<N>  keys: TKeycombo;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters>=2 then //(function, key, ...)<N>  begin<N>    lc:=TLuaCaller.create;<N><N>    if lua_isfunction(L, 1) then<N>    begin<N>      lua_pushvalue(L, 1);<N>      lc.luaroutineindex:=luaL_ref(L,LUA_REGISTRYINDEX)<N>    end<N>    else<N>      lc.luaroutine:=lua_tostring(L,1);<N><N>
unit Valuechange;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  StdCtrls, LResources, ExtCtrls, commonTypeDefs,NewKernelHandler, CEFuncProc, betterControls;<N>                                       <N>type<N><N>
unit frmStructuresConfigUnit;<N><N>{$MODE Delphi}<N><N>{<N>Note: The "Selected" part has been removed<N>}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, FileUtil, LResources, Forms, Controls, Graphics, Dialogs,<N>  ComCtrls, StdCtrls, ExtCtrls, registry, fontSaveLoadRegistry, betterControls;<N><N>
unit CommentsUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ExtCtrls, LResources, ComCtrls, CEFuncProc, betterControls;<N><N>
unit LuaClass;<N><N>//Handles some of the common used class code<N><N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, controls, lua, lauxlib, lualib, math, AvgLvlTree, syncobjs;<N><N>type TAddMetaDataFunction=procedure(L: PLua_state; metatable: integer; userdata: integer );<N><N>
unit bigmemallochandler;<N><N>{$MODE Delphi}<N><N><N>{<N>This unit will provide a class (TBigMemoryAllocHandler) that will allocate more<N>memory than it actually needs and just returns pointers to buffers. No tracking<N>of individual memory allocs, so no data loss for allocating small chunks of memory<N>}<N><N>
interface<N><N>uses {$ifdef darwin}macport,mactypes,math,{$endif}{$ifdef windows}windows,{$endif}classes,sysutils, newkernelhandler, LCLIntf;<N><N>type TBigMemoryAllocHandler=class<N>private<N>  allocs: array of pointer;<N>  allocspos: integer;<N>  allocssize: integer;<N><N>
  currentBuffer: pointer; //current memory region to use //updated on each alloc<N>  lastsize: integer;<N>  memoryleft: integer;<N>public<N>  constructor create;<N>  destructor destroy; override;<N>  function alloc(size: integer):pointer;<N>  function realloc(oldaddress: pointer; oldsize: integer; size: integer): pointer;//just throws away the old region<N>end;<N><N>
implementation<N><N>resourcestring<N>  rsAllocError = 'VirtualAlloc failed to allocate %d bytes. You probably don''t have enough system '<N>    +'memory free. Either install more RAM, or increase the maximum allowed '<N>    +'paging size';<N>  rsCEPointerscanMemoryManager = 'CE Pointerscan memory manager';<N>  rsBMAVirtualAllocFailedYouProbablyDontHaveEnoughtVirtualMemoryFreeEtc = 'VirtualAlloc failed. You probably don''t have enough virtual memory free. Use the 64-bit version instead';<N><N>
constructor TBigMemoryAllocHandler.create;<N>begin<N>  currentbuffer:=nil;<N>  memoryleft:=0;<N>  lastsize:=1;<N><N><N>  allocssize:=32;<N>  allocspos:=0;<N>  setlength(allocs,32);<N>end;<N><N>destructor TBigMemoryAllocHandler.destroy;<N>var i: integer;<N>begin<N>  for i:=0 to length(allocs)-1 do<N>    VirtualFree(allocs[i],0,MEM_RELEASE);<N><N>
  setlength(allocs,0);<N><N>  inherited destroy;<N>end;<N><N><N>function TBigMemoryAllocHandler.alloc(size: integer):pointer;<N>var newsize: size_t;<N>  flAllocationType : dword;<N>  lpm: size_t;<N>  e: integer;<N>begin<N>  try<N>    if size>memoryleft then<N>    begin<N>      //need to alloce a new memory regions<N>      lpm:=GetLargePageMinimum;<N>      newsize:=lpm;<N>      if newsize=0 then<N>        newsize:=2*1024*1024; //2mb<N><N>
      newsize:=newsize*lastsize;<N>      if newsize<16*1024*1024 then<N>        inc(lastsize); //next time allocate more memory<N><N>      while newsize<size do<N>      begin<N>        newsize:=newsize*lastsize;<N>        if newsize<16*1024*1024 then<N>          inc(lastsize); //next time allocate more memory<N><N>
//        raise Exception.create('some really fucked up parameter is given for size:'+inttostr(size));<N>      end;<N><N>      flAllocationType:=MEM_COMMIT or MEM_RESERVE;<N>      if lpm>0 then //cpu supports large pages<N>        flAllocationType:=flAllocationType or MEM_LARGE_PAGES;<N><N>
<N>      currentbuffer:=VirtualAlloc(nil,newsize, flAllocationType , PAGE_READWRITE);<N>      while (currentbuffer=nil) and (newsize>size) do<N>      begin<N>        currentbuffer:=VirtualAlloc(nil,newsize, MEM_COMMIT or MEM_RESERVE , PAGE_READWRITE);<N>        if currentbuffer=nil then<N>          newsize:=newsize div 2;<N>      end;<N><N>
      if currentbuffer=nil then<N>      begin<N>        {$ifdef cpu64}<N>          raise exception.create(format(rsAllocError,[newsize]));<N>        {$else}<N>          raise exception.create(rsBMAVirtualAllocFailedYouProbablyDontHaveEnoughtVirtualMemoryFreeEtc);<N>        {$endif}<N>      end;<N><N>
      allocs[allocspos]:=currentbuffer;<N>      inc(allocspos);<N>      if allocspos>=allocssize then<N>      begin<N>        allocssize:=min(allocssize*2, allocssize+4096); //allocate twice the ammount it was, with a max of 4096<N>        setlength(allocs,allocssize);<N>      end;<N><N>
<N>      memoryleft:=newsize;<N>    end;<N><N><N>    result:=currentBuffer;<N>    inc(pbyte(currentbuffer),size); //adjust the pointer to point to the next free spot<N>    dec(memoryleft,size);<N>  except<N>    on e: Exception do<N>    begin<N>      messagebox(0, pchar(e.message), pchar(rsCEPointerscanMemoryManager), 0);<N>      raise exception.create(e.message);<N>    end;<N>  end;<N><N>
unit LuaPicture;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Graphics,lua, lualib, lauxlib, LuaHandler;<N><N>procedure initializeLuaPicture;<N><N>implementation<N><N>uses luaclass, LuaObject;<N><N>function createPicture(L: PLua_State): integer; cdecl;<N>begin<N>  luaclass_newClass(L, TPicture.Create);<N>  result:=1;<N>end;<N><N>
function picture_loadFromFile(L: PLua_State): integer; cdecl;<N>var<N>  picture: Tpicture;<N>begin<N>  result:=0;<N>  picture:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=1 then<N>  begin<N>    try<N>      picture.LoadFromFile(Lua_ToString(L, -1));<N>      lua_pushboolean(L,true);<N>      result:=1;<N>    except<N>      on e: exception do<N>      begin<N>        lua_pushboolean(L, false);<N>        lua_pushstring(L, e.Message);<N>        result:=2;<N>      end;<N><N>
    end;<N>  end;<N>end;<N><N>function picture_saveToFile(L: PLua_State): integer; cdecl;<N>var<N>  picture: Tpicture;<N>begin<N>  result:=0;<N>  picture:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=1 then<N>    picture.SaveToFile(Lua_ToString(L, 1));<N>end;<N><N>
function picture_loadFromStream(L: PLua_State): integer; cdecl;<N>var<N>  paramstart, paramcount: integer;<N>  picture: Tpicture;<N>  stream: TStream;<N>  ext: string;<N>begin<N>  result:=0;<N>  picture:=luaclass_getClassObject(L, @paramstart, @paramcount);<N><N>
  if paramcount>=1 then<N>  begin<N>    stream:=lua_ToCEUserData(L, paramstart);<N><N>    if paramstart=2 then //6.2 compat, there i set the position to 0. In 6.3+ I will have the user set it to the position they want first<N>      stream.Position:=0;<N><N>
    try<N>      if paramcount=2 then<N>      begin<N>        ext:=Lua_ToString(L, paramstart+1);<N>        picture.LoadFromStreamWithFileExt(stream,ext);<N>      end<N>      else<N>      if paramcount=1 then<N>        picture.LoadFromStream(stream);<N><N>      lua_pushboolean(L,true);<N>      result:=1;<N>    except<N>      on e:exception do<N>      begin<N>        lua_pushboolean(L, false);<N>        lua_pushstring(L,e.message);<N>        result:=2;<N>      end;<N>    end;<N>  end;<N>end;<N><N>
function picture_assign(L: PLua_State): integer; cdecl;<N>var<N>  picture, picture2: Tpicture;<N>begin<N>  result:=0;<N>  picture:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=1 then<N>  begin<N>    picture2:=lua_ToCEUserData(L, -1);<N>    picture.Assign(picture2);<N>  end;<N>end;<N><N>
function picture_getIcon(L: PLua_State): integer; cdecl;<N>begin<N>  luaclass_newClass(L, TPicture(luaclass_getClassObject(L)).Icon);<N>  result:=1;<N>end;<N><N>function picture_setIcon(L: PLua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  TPicture(luaclass_getClassObject(L)).Icon:=lua_ToCEUserData(L, 1);<N>end;<N><N>
<N>function picture_getGraphic(L: PLua_State): integer; cdecl;<N>var<N>  picture: Tpicture;<N>begin<N>  picture:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, picture.Graphic);<N>  result:=1;<N>end;<N><N>function picture_setGraphic(L: PLua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  TPicture(luaclass_getClassObject(L)).Graphic:=lua_ToCEUserData(L, 1);<N>end;<N><N>
<N>function picture_getPNG(L: PLua_State): integer; cdecl;<N>var<N>  picture: Tpicture;<N>begin<N>  picture:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, picture.PNG);<N>  result:=1;<N>end;<N><N>function picture_setPNG(L: PLua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  TPicture(luaclass_getClassObject(L)).PNG:=lua_ToCEUserData(L, 1);<N>end;<N><N>
<N>function picture_getBitmap(L: PLua_State): integer; cdecl;<N>var<N>  picture: Tpicture;<N>begin<N>  picture:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, picture.Bitmap);<N>  result:=1;<N>end;<N><N>function picture_setBitmap(L: PLua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  TPicture(luaclass_getClassObject(L)).Bitmap:=lua_ToCEUserData(L, 1);<N>end;<N><N>
<N>function picture_getJpeg(L: PLua_State): integer; cdecl;<N>var<N>  picture: Tpicture;<N>begin<N>  picture:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, picture.Jpeg);<N>  result:=1;<N>end;<N><N>function picture_setJpeg(L: PLua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  TPicture(luaclass_getClassObject(L)).Jpeg:=lua_ToCEUserData(L, 1);<N>end;<N><N>
<N>procedure picture_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>begin<N>  object_addMetaData(L, metatable, userdata);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'loadFromFile',picture_loadFromFile);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'saveToFile',picture_saveToFile);<N><N>
unit LuaApplication;<N>{<N>This unit will be used to register TCanvas class methods to lua<N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, forms, lua, lualib, lauxlib, LuaHandler, fpcanvas, LCLType, LCLIntf;<N><N><N>implementation<N><N>
uses luaclass, luaobject;<N><N>function application_bringToFront(L: PLua_State): integer; cdecl;<N>begin<N>  TApplication(luaclass_getClassObject(L)).BringToFront;<N>  result:=0;<N>end;<N><N>function application_processMessages(L: PLua_State): integer; cdecl;<N>begin<N>  TApplication(luaclass_getClassObject(L)).ProcessMessages;<N>  result:=0;<N>end;<N><N>
function application_terminate(L: PLua_State): integer; cdecl;<N>begin<N>  TApplication(luaclass_getClassObject(L)).Terminate;<N>  result:=0;<N>end;<N><N>function application_minimize(L: PLua_State): integer; cdecl;<N>begin<N>  TApplication(luaclass_getClassObject(L)).Minimize;<N>  result:=0;<N>end;<N><N>
function application_getExeName(L: PLua_State): integer; cdecl;<N>var<N>  app: TApplication;<N>begin<N>  result:=0;<N>  app:=luaclass_getClassObject(L);<N>  lua_pushstring(L, app.ExeName);<N>  result:=1;<N>end;<N><N>function application_getMainFormOnTaskBar(L: PLua_State): integer; cdecl;<N>var<N>  app: TApplication;<N>begin<N>  result:=0;<N>  app:=luaclass_getClassObject(L);<N>  lua_pushboolean(L, not app.MainFormOnTaskBar);  //bug in laz 2.0.6, it's inverted<N>  result:=1;<N>end;<N><N>
function application_setMainFormOnTaskBar(L: PLua_State): integer; cdecl;<N>var<N>  app: TApplication;<N>begin<N>  result:=0;<N>  if lua_gettop(L)>=1 then<N>  begin<N>    app:=luaclass_getClassObject(L);<N>    app.MainFormOnTaskBar:=not lua_toboolean(L,1);<N>  end;<N>end;<N><N>
<N><N>function application_getTitle(L: PLua_State): integer; cdecl;<N>var<N>  app: TApplication;<N>begin<N>  result:=0;<N>  app:=luaclass_getClassObject(L);<N>  lua_pushstring(L, app.Title);<N>  result:=1;<N>end;<N><N>function application_setTitle(L: PLua_State): integer; cdecl;<N>begin<N>  TApplication(luaclass_getClassObject(L)).title:=Lua_ToString(L, 1);<N>  result:=0;<N>end;<N><N>
function application_getIcon(L: PLua_State): integer; cdecl;<N>begin<N>  luaclass_newClass(L, TApplication(luaclass_getClassObject(L)).Icon);<N>  result:=1;<N>end;<N><N>function application_setIcon(L: PLua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  TApplication(luaclass_getClassObject(L)).icon:=lua_ToCEUserData(L, 1);<N><N>
unit PageMap;<N>{<N>A container specifically for storing and looking up pages<N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef windows}<N>  windows, Classes, SysUtils;<N>  {$endif}<N>  {$ifdef darwin}<N>  macport, Classes, SysUtils;<N>  {$endif}<N><N>
type<N>  TPageInfo=record<N>    data: PByteArray;<N>  end;<N>  PPageInfo=^TPageInfo;<N><N>  PPageEntryTable=^TPageEntryTable;<N>  PPageEntryArray=^TPageEntryArray;<N>  TPageEntryTable=record<N>    case integer of<N>      1: (pageinfo: PPageInfo); //if this is the last level (maxlevel) this is an PPointerList<N>      2: (PageEntryArray: PPageEntryArray);   //else it's a PReversePointerListArray<N>  end;<N>  TPageEntryArray=array [0..15] of TPageEntryTable;<N><N>
<N>  TPageMap=class<N>  private<N>    level0list: TPageEntryArray;<N>    maxlevel: integer;<N>    procedure DeletePath(list: PPageEntryArray; level: integer);<N>  public<N>    function Add(pageindex: integer; pagedata: pointer): PPageInfo;<N>    function GetPageInfo(pageindex: integer): PPageInfo;<N>    constructor create;<N>    destructor destroy; override;<N>  end;<N><N>
implementation<N><N>function TPagemap.GetPageInfo(pageindex: integer): PPageInfo;<N>var<N>  level: integer;<N>  maxlevel: integer;<N>  currentarray: PPageEntryArray;<N>  entrynr: integer;<N>begin<N>  result:=nil;<N>  maxlevel:=self.maxlevel;<N>  currentarray:=@level0list;<N><N>
  level:=0;<N><N>  while level<maxlevel do<N>  begin<N><N>    entrynr:=pageindex shr ((maxlevel-level)*4) and $f;<N>    if currentarray[entrynr].PageEntryArray=nil then exit; //not found<N><N>    currentarray:=currentarray[entrynr].PageEntryArray;<N>    inc(level);<N>  end;<N><N>
  //got till level (maxlevel)<N>  entrynr:=pageindex shr ((maxlevel-level)*4) and $f;<N>  result:=currentarray[entrynr].pageinfo;   //can be nil<N>end;<N><N>function TPagemap.Add(pageindex: integer; pagedata: pointer): PPageInfo;<N>{<N>add a page to the map<N>precondition: only one thread can call this at a time. Not thread safe<N>}<N>var<N>  level: integer;<N>  maxlevel: integer;<N>  temp, currentarray: PPageEntryArray;<N>  entrynr: integer;<N><N>
unit LuaWinControl;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef windows}windows,{$endif}<N><N>  Classes, SysUtils, controls, lua, lualib, lauxlib,LuaHandler, graphics;<N><N>procedure initializeLuaWinControl;<N>procedure wincontrol_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N><N>
implementation<N><N>uses LuaCaller, luacontrol, luaclass;<N><N>function wincontrol_getHandle(L: PLua_State): integer; cdecl;<N>begin<N>  lua_pushinteger(L, twincontrol(luaclass_getClassObject(L)).Handle);<N>  result:=1;<N>end;<N><N>function wincontrol_getDoubleBuffered(L: PLua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, twincontrol(luaclass_getClassObject(L)).DoubleBuffered);<N>  result:=1;<N>end;<N><N>
function wincontrol_setDoubleBuffered(L: PLua_State): integer; cdecl;<N>begin<N>  if lua_gettop(L)=1 then<N>    twincontrol(luaclass_getClassObject(L)).DoubleBuffered:=lua_toboolean(L, 1);<N><N>  result:=0;<N>end;<N><N><N>function wincontrol_getControlCount(L: PLua_State): integer; cdecl;<N>begin<N>  lua_pushinteger(L, twincontrol(luaclass_getClassObject(L)).ControlCount);<N>  result:=1;<N>end;<N><N>
function wincontrol_getControl(L: PLua_State): integer; cdecl;<N>var<N>  wincontrol: TWinControl;<N>  index: integer;<N>begin<N>  wincontrol:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>  begin<N>    index:=lua_tointeger(L,-1);<N>    luaclass_newClass(L, wincontrol.Controls[index]);<N>  end<N>  else<N>    lua_pushnil(L);<N><N>
  result:=1;<N>end;<N><N>function wincontrol_getControlAtPos(L: PLua_State): integer; cdecl;<N>var<N>  wincontrol: TWinControl;<N>  x,y: integer;<N>  paramstart, paramcount: integer;<N>begin<N>  wincontrol:=luaclass_getClassObject(L, @paramstart, @paramcount);<N>  result:=0;<N><N>
  if paramcount>=2 then<N>  begin<N>    x:=lua_tointeger(L,paramstart);<N>    y:=lua_tointeger(L,paramstart+1);<N><N>    luaclass_newClass(L, wincontrol.ControlAtPos(point(x,y),[capfOnlyClientAreas, capfAllowWinControls, capfRecursive]));<N>    result:=1;<N>  end;<N>end;<N><N>
function wincontrol_getOnEnter(L: PLua_State): integer; cdecl;<N>var<N>  c: twincontrol;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  LuaCaller_pushMethodProperty(L, TMethod(c.OnEnter), 'TNotifyEvent');<N>  result:=1;<N>end;<N><N>function wincontrol_setOnEnter(L: PLua_State): integer; cdecl;<N>var<N>  wincontrol: TWinControl;<N>  f: integer;<N>  routine: string;<N><N>
  lc: TLuaCaller;<N>begin<N>  wincontrol:=luaclass_getClassObject(L);<N>  result:=0;<N><N>  if lua_gettop(L)>=1 then<N>  begin<N>    CleanupLuaCall(tmethod(wincontrol.OnEnter));<N>    wincontrol.OnEnter:=nil;<N><N>    if lua_isfunction(L,-1) then<N>    begin<N>      routine:=Lua_ToString(L,-1);<N>      f:=luaL_ref(L,LUA_REGISTRYINDEX);<N><N>
      lc:=TLuaCaller.create;<N>      lc.luaroutineIndex:=f;<N>      wincontrol.OnEnter:=lc.NotifyEvent;<N>    end<N>    else<N>    if lua_isstring(L,-1) then<N>    begin<N>      routine:=lua_tostring(L,-1);<N>      lc:=TLuaCaller.create;<N>      lc.luaroutine:=routine;<N>      wincontrol.OnEnter:=lc.NotifyEvent;<N>    end;<N><N>
  end;<N>end;<N><N>function wincontrol_getOnExit(L: PLua_State): integer; cdecl;<N>var<N>  c: twincontrol;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  LuaCaller_pushMethodProperty(L, TMethod(c.OnExit), 'TNotifyEvent');<N>  result:=1;<N>end;<N><N>function wincontrol_setOnExit(L: PLua_State): integer; cdecl;<N>var<N>  wincontrol: TWinControl;<N>  f: integer;<N>  routine: string;<N><N>
  lc: TLuaCaller;<N>begin<N>  wincontrol:=luaclass_getClassObject(L);<N>  result:=0;<N>  if lua_gettop(L)>=1 then<N>  begin<N><N>    CleanupLuaCall(tmethod(wincontrol.onExit));<N>    wincontrol.onExit:=nil;<N><N>    if lua_isfunction(L,-1) then<N>    begin<N>      routine:=Lua_ToString(L,-1);<N>      f:=luaL_ref(L,LUA_REGISTRYINDEX);<N><N>
      lc:=TLuaCaller.create;<N>      lc.luaroutineIndex:=f;<N>      wincontrol.OnExit:=lc.NotifyEvent;<N>    end<N>    else<N>    if lua_isstring(L,-1) then<N>    begin<N>      routine:=lua_tostring(L,-1);<N>      lc:=TLuaCaller.create;<N>      lc.luaroutine:=routine;<N>      wincontrol.OnExit:=lc.NotifyEvent;<N>    end;<N><N>
  end;<N>end;<N><N>function wincontrol_canFocus(L: PLua_State): integer; cdecl;<N>var<N>  wincontrol: TWinControl;<N>begin<N>  wincontrol:=luaclass_getClassObject(L);<N>  lua_pushboolean(L, wincontrol.CanFocus);<N>  result:=1;<N>end;<N><N>function wincontrol_focused(L: PLua_State): integer; cdecl;<N>var<N>  wincontrol: TWinControl;<N>begin<N>  wincontrol:=luaclass_getClassObject(L);<N>  lua_pushboolean(L, wincontrol.Focused);<N>  result:=1;<N>end;<N><N>
function wincontrol_setFocus(L: PLua_State): integer; cdecl;<N>var<N>  wincontrol: TWinControl;<N>begin<N>  wincontrol:=luaclass_getClassObject(L);<N>  wincontrol.SetFocus;<N>  result:=0<N>end;<N><N>function wincontrol_setShape(L: PLua_State): integer; cdecl;<N>var<N>  wincontrol: TWinControl;<N>  x: TObject;<N>begin<N>  wincontrol:=luaclass_getClassObject(L);<N>  result:=0;<N>  if lua_gettop(L)>=1 then<N>  begin<N>    x:=lua_toceuserdata(L, -1);<N><N>
    if (x is TBitmap) then<N>      wincontrol.SetShape(TBitmap(x))<N>    else<N>    if (x is TRegion) then<N>      wincontrol.SetShape(TRegion(x));<N>  end;<N>end;<N><N><N>function wincontrol_setLayeredAttributes(L: PLua_State): integer; cdecl;<N>var<N>  h: thandle;<N>  key: dword;<N>  alpha: byte;<N>  flags: byte;<N>begin<N>  //only works on forms in windows 7 and earlier, but also works on child components in windows 8 and later<N>  result:=0;<N><N>
  {$ifdef windows}<N><N>  if lua_gettop(L)>=3 then<N>  begin<N>    h:=twincontrol(luaclass_getClassObject(L)).handle;<N>    if SetWindowLong(h, GWL_EXSTYLE, GetWindowLong(h, GWL_EXSTYLE) or WS_EX_LAYERED)=0 then<N>    begin<N>      result:=1;<N>      lua_pushboolean(L, false);<N>      exit; //not supported<N>    end;<N><N>
unit PointerscanSettingsIPConnectionList;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, ExtCtrls, StdCtrls, Controls;<N><N>resourcestring<N>  rsPSSICLAdd = 'Add';<N>  rsPSSICLRemove = 'Remove';<N>  rsPSSICLHost = 'Host';<N>  rsPSSICLPort = 'Port';<N>  rsPSSICLPassword = 'Password';<N>  rsPSSICLStable = 'Stable';<N><N>
unit PointerscanNetworkCommands;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N><N>//--------Network commands--------<N>{<N>const<N>  //pointerscan commands<N>  //client->server commands<N>  CMD_GETSCANPARAMETERS=0;<N>  CMD_UPDATEWORKERSTATUS=1;<N>  //server->client commands<N>    CMDUPDATEREPLY_EVERYTHINGOK=0;<N>    CMDUPDATEREPLY_HEREARESOMEPATHSTOEVALUATE=1;<N>    CMDUPDATEREPLY_PLEASESENDMESOMEPATHS=2;<N>    CMDUPDATEREPLY_GOKILLYOURSELF=3;<N><N>
unit frmChangedAddressesCommonalityScannerUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs,<N>  ComCtrls, StdCtrls, ExtCtrls, formChangedAddresses, betterControls;<N><N>
type<N><N>  { TfrmChangedAddressesCommonalityScanner }<N><N>  TfrmChangedAddressesCommonalityScanner = class(TForm)<N>    lvRegisters: TListView;<N>    procedure FormClose(Sender: TObject; var CloseAction: TCloseAction);<N>    procedure FormCreate(Sender: TObject);<N>    procedure FormDestroy(Sender: TObject);<N>    procedure lvRegistersDblClick(Sender: TObject);<N>  private<N>    { private declarations }<N><N>
    group: array [1..2] of array of TAddressEntry;<N>  public<N>    { public declarations }<N><N>    procedure setGroup(groupnr: integer; const grouplist: array of TAddressEntry);<N>    procedure initlist;<N>  end;<N><N><N>implementation<N><N>{$R *.lfm}<N><N>
uses cefuncproc, ProcessHandlerUnit, frmstructurecompareunit, NewKernelHandler;<N><N>resourcestring<N>  rsDblClickLaunchComp = 'Doubleclick to launch structure compare';<N>  rsShowResults = 'Doubleclick to show scanner/results';<N>  rsBaseAddress = 'Base Address';<N><N>
type<N>  TRegisterInfo=class<N>  private<N>    owner: TfrmChangedAddressesCommonalityScanner;<N>    regnr: integer;<N><N>    g1same, g2same: boolean;<N>    validaddress: boolean;<N>  public<N>    running: boolean;<N>    done: boolean;<N>    scanner: TfrmStructureCompare;<N><N>
    values: array [1..2] of array of ptruint;<N><N>    oldscannerdestroy: TNotifyEvent;<N><N>    procedure scannerdestroy(sender: tobject);<N><N>    constructor create(o: TfrmChangedAddressesCommonalityScanner; r: integer);<N>    destructor destroy; override;<N>  end;<N><N>
procedure TRegisterInfo.scannerdestroy(sender: tobject);<N>begin<N>  if self=nil then exit;<N>  scanner:=nil;<N>  oldscannerdestroy(sender);<N>end;<N><N>destructor TRegisterInfo.destroy;<N>begin<N>  if scanner<>nil then<N>    scanner.OnDestroy:=oldscannerdestroy;<N><N>
  inherited destroy;<N>end;<N><N>constructor TRegisterInfo.create(o: TfrmChangedAddressesCommonalityScanner; r: integer);<N>var<N>  x: TContext;<N>  v: ptruint;<N>  i,j: integer;<N>  contextoffset: dword;<N><N>  c: TCONTEXT;<N><N>begin<N>  owner:=o;<N>  regnr:=r;<N><N>
unit fontSaveLoadRegistry;<N><N>{Responsible for saving and loading a font from the registry}<N><N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, registry, Graphics, LazUTF8;<N><N>procedure SaveFontToRegistry(f: TFont; reg: TRegistry);<N>procedure LoadFontFromRegistry(f: TFont; reg: TRegistry);<N><N>
unit MemoryRecordUnit;<N><N>{$mode DELPHI}<N><N>interface<N><N>{$ifdef windows}<N>uses<N>  jwawindows, Windows, forms, graphics, Classes, SysUtils, controls, stdctrls, comctrls,<N>  symbolhandler, SymbolListHandler, cefuncproc,newkernelhandler, hotkeyhandler,<N>  dom, XMLRead,XMLWrite, customtypehandler, fileutil, LCLProc, commonTypeDefs,<N>  pointerparser, LazUTF8, LuaClass, math, betterControls, memrecDataStructures;<N>{$endif}<N><N>
{$ifdef darwin}<N>uses<N>  macport, forms, graphics, Classes, SysUtils, controls, stdctrls, comctrls,<N>  symbolhandler, SymbolListHandler, cefuncproc,newkernelhandler, hotkeyhandler,<N>  dom, XMLRead,XMLWrite, CustomTypeHandler, fileutil, LCLProc, commonTypeDefs,<N>  pointerparser, LazUTF8, LuaClass, math,memrecDataStructures;<N>{$endif}<N><N>
{$ifdef jni}<N>//only used as a class to store entries and freeze/setvalue. It won't have a link with the addresslist and does not decide it's position<N>uses<N>  unixporthelper, Classes, sysutils, symbolhandler, NewKernelHandler, DOM,<N>  XMLRead, XMLWrite, CustomTypeHandler, FileUtil, commonTypeDefs, math, pointerparser;<N>{$endif}<N><N>
unit olddebugger;<N><N>{$mode delphi}<N><N>interface<N><N>uses windows, Classes,LCLIntf,sysutils,CEFuncProc,Messages,forms,SyncObjs,<N>     dialogs,controls,Graphics,NewKernelHandler,symbolhandler,StrUtils,<N>     ComCtrls ,Assemblerunit,addressparser, debughelper;<N><N>
<N>type TReadonly = record<N>  pagebase: uint_ptr;<N>  pagesize: uint_ptr;<N>  Address: uint_ptr;<N>  size: integer;<N>  originalprotection:  dword;<N>end;<N><N>type tThreadEntry=record<N>  threadHandle: thandle;<N>  address: uint_ptr;<N>end;<N><N><N>type Process=record<N>  ProcessID: dword;<N>  running: boolean;<N>end;<N><N>
<N><N><N><N><N><N>type TDebugger = class(TThread)<N>  private<N>    originalbyte: byte;<N>    filename: String;<N>    parameters: string;<N>    CreateAProcess: boolean;<N>    OpenProcessID: Thandle;<N><N>    AddressFound: Dword;<N>    HideDebugger: boolean;<N>    HandleBreakpoints: boolean;<N><N>
    CanUseDebugRegs: boolean;<N>    createdusingprocesswindow:boolean;<N><N>    CurrentProcess: integer;<N><N><N>    {$ifdef netserver}<N>    coderecords: array of dword;<N>    {$endif}<N><N>    procedure addtochangeslist;<N><N><N>    procedure RestoreNTOpenProcess;<N><N>
    procedure ResetBreakpoint;<N>    procedure SetSingleStepping(Threadid: dword);<N>    procedure AddDebugString;<N>    function injectcode(AddressOfEntryPoint:dword;processhandle:thandle):dword;<N>    function handledebuggerplugins(devent:PDebugEvent):integer;<N><N>
    procedure tracersync;<N>    function tracer(devent: _Debug_EVENT):boolean;<N><N>  public<N>    //semaphore: THandle;<N>    Processes: array of process;<N>    Newprocesses: array of TNewProcedureData;<N><N><N>    pausedthreadhandle: thandle;<N><N>    running: boolean;<N>    continueprocess: boolean;<N>    continuehow: integer;<N><N>
    DRRegs: _CONTEXT;<N><N>    FindWriter2: boolean;<N><N><N>(*    attaching: boolean;*)<N>    attached: boolean;<N>    attachedevent: Tevent;<N><N>    context: _CONTEXT;<N>    debugging: boolean;<N>    stepping: boolean;<N>    HowToContinue: integer;<N>    removed: boolean;<N><N>
    readonly: TReadonly;<N>    readonlyset: boolean;<N>    readonlyremoved: boolean;<N><N>    findreaderset: boolean;<N>    findreader: TReadOnly;<N>    findreaderremoved:boolean;<N><N>    alsowrites: boolean;<N><N>    breakpointset: boolean;<N>    breakpointaddress: dword;<N>    lastbreakpoint: dword;<N>    temps: string;<N><N>
    whattodo: integer; //ignore, continue, showwindow etc....<N><N>    userisdebugging: boolean;<N>    userbreakpoints: array of dword;<N>    registermodificationBPs: array of tregistermodificationBP;<N><N>    int3userbreakpoints: array of tbreakpoint;<N>    int3CEBreakpoint: TBreakpoint;<N><N>
    threadlist: array of array [0..4] of dword;<N>    threadinfo: array of dword;<N><N><N>    testje: string;<N><N>    breakpointlistsection: TCriticalSection;<N>    threadentrys: array of tThreadEntry;<N><N>    traceaddress: dword;<N>    tracecount: integer;<N>    Constructor MyCreate(filenm: String);<N>    Constructor MyCreate2(processID: THandle);<N>    destructor Destroy; override;<N>    procedure Execute; override;<N>    procedure Debuginfo;<N>    procedure waitforattach;<N><N>
unit frmBreakThreadUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, LResources, ExtCtrls,CEDebugger, debughelper, betterControls;<N><N>type<N><N>  { Tfrmbreakthread }<N><N>
  Tfrmbreakthread = class(TForm)<N>    Label1: TLabel;<N>    Panel1: TPanel;<N>    Threadlistbox: TListBox;<N>    Button1: TButton;<N>    Button2: TButton;<N>    procedure Button1Click(Sender: TObject);<N>    procedure FormCreate(Sender: TObject);<N>    procedure FormShow(Sender: TObject);<N>    procedure ThreadlistboxDblClick(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>    threadhandle: thandle;<N>  end;<N><N>
unit IconStuff;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, LCLIntf, math,<N>  {$endif}<N>  {$ifdef windows}<N>  windows, CommCtrl,<N>  {$endif}<N>  Classes, SysUtils,controls, dialogs, Graphics, forms, ExtCtrls, StdCtrls;<N><N>
resourcestring<N>  rsFailureOpen = 'Failure opening ';<N>  rsUnhandledExt = 'Unhandled file extension';<N>  rsIconPicker = 'Icon picker';<N>  rsNoIconFound = 'No icon found in this file';<N><N><N>type TICONDIRENTRY=packed record<N>  bWidth: byte;<N>  bHeight: byte;<N>  bColorCount: byte;<N>  bReserved: byte;<N>  wPlanes: word;<N>  wBitCount: word;<N>  dwBytesInRes: DWORD;<N>  dwImageOffset: DWORD;<N>end;<N><N>
type TICONDIR=packed record<N>  idReserved: word; //0<N>  idType: word; //1=icon<N>  idCount: word; //nrofentries<N>  icondirentry: array [0..255] of TICONDIRENTRY;<N>end;<N><N>type TGRPICONDIRENTRY=packed record<N>  bWidth: byte;<N>  bHeight: byte;<N>  bColorCount: byte;<N>  bReserved: byte;<N>  wPlanes: word;<N>  wBitCount: word;<N>  dwBytesInRes: DWORD;<N>  id: DWORD;<N>end;<N><N>
type TGRPICONDIR=packed record<N>  idReserved: word; //0<N>  idType: word; //1=icon<N>  idCount: word; //nrofentries<N>  icondirentry: array [0..255] of TGRPICONDIRENTRY;<N>end;<N><N><N>type PICONDIR=^TICONDIR;<N>type PGRPICONDIR=^TGRPICONDIR;<N><N><N>function pickIcon: TIcon; //small memleak, I can live with it<N><N>
<N>implementation<N><N>type TIconPicker=class(Tcustomform)<N>  public<N>    usedIcon: integer;<N>    procedure choose(sender: tobject);<N>end;<N><N><N>procedure TIconPicker.choose(sender: TObject);<N>begin<N>  usedicon:=(sender as TImage).tag;<N>  ModalResult:=mrok;<N>end;<N><N>
<N>procedure dealWithIconStream(s: tmemorystream; iconlist: tlist);<N>var<N>  icondir: PICONDIR;<N><N>  newiconstream: Tmemorystream;<N>  newicondir: PICONDIR;<N><N>  icon: TIcon;<N>  i: integer;<N>begin<N>  icondir:=s.Memory;<N><N>  for i:=0 to icondir.idCount-1 do<N>  begin<N>    //more than 1 icon<N><N>
    newiconstream:=tmemorystream.Create;<N>    newiconstream.Size:=12+sizeof(TICONDIRENTRY);<N>    newiconstream.Position:=12+sizeof(TICONDIRENTRY);<N><N>    newicondir:=newiconstream.memory;<N>    newicondir.idCount:=1;<N>    newicondir.idType:=icondir.idType;<N>    newicondir.idReserved:=icondir.idReserved;<N>    newicondir.icondirentry[0]:=icondir.icondirentry[i];<N>    newicondir.icondirentry[0].dwImageOffset:=newiconstream.size;<N><N>
    s.Position:=icondir.icondirentry[i].dwImageOffset;<N>    newiconstream.CopyFrom(s, icondir.icondirentry[i].dwBytesInRes);<N><N><N>    newiconstream.position:=0;<N><N>    icon:=ticon.create;<N>    icon.LoadFromStream(newiconstream);<N><N>    newiconstream.free;<N><N>
    iconlist.add(icon);<N><N>  end;<N>end;<N><N><N>function enumfunc(hModule:HANDLE; lpszType:pchar; lpszName:pchar; lParam: PtrInt):WINBOOL;stdcall;<N>var<N>  allicons: tmemorystream;<N>  icon: TIcon;<N>begin<N>  icon:=ticon.create;<N><N><N>  if ptruint(lpszName)>$10000 then<N>    Icon.LoadFromResourceName(hModule,lpszName)<N>  else<N>    Icon.LoadFromResourceID(hModule,ptruint(lpszName));<N><N>
  allicons:=Tmemorystream.Create;<N>  icon.SaveToStream(allicons);<N>  icon.free;<N><N>  dealWithIconStream(allicons, tlist(lParam));<N>  allicons.free;<N><N><N>  result:=true;<N>end;<N><N>//type<N>//  ENUMRESNAMEPROC2 = function (_para1:HANDLE; _para2:LPCTSTR; _para3:LPTSTR; _para4:LONG_PTR):WINBOOL; stdcall;<N>//function EnumResourceNames(hModule:HINST; lpType:LPCSTR; lpEnumFunc:ENUMRESNAMEPROC2; lParam:LONG_PTR):WINBOOL; external 'kernel32' name 'EnumResourceNamesA';<N><N>
function pickIcon: TIcon;<N>var opendialog: Topendialog;<N>  iconlist: Tlist;<N>  filename: string;<N>  ext: string;<N>  i: integer;<N>  modulehandle: THandle;<N>  m: tmemorystream;<N><N>  iconpicker: TIconPicker;<N>  maxheight: integer;<N>  nextpos: integer;<N><N>
unit LuaRemoteExecutor;<N>{<N>Remote Executor is a thread that runs inside the target process. It waits for a "HasFunctionAndParametersReadyForExecution" event, and executes it according to ExecuteMethod parameters<N><N>Each executor has it's own parameter store in shared memory accessible by both CE and the target, and only executes one function at a time<N><N>
A process can have more than one executor thread at the same time<N><N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N><N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N><N>  Classes, SysUtils, math;    //todo: port to mac<N><N>
type<N>  TStubdata=record<N>    address: ptruint;<N>    parameters: array of integer;<N>  end;<N><N><N><N>type<N>  TRemoteExecutorSharedMemory=record<N>    HasDataEventHandle: QWORD;       //0<N>    HasProcessedDataEventHandle: QWORD; //8<N>    Command: QWORD; //10<N>    Address: QWORD; //18  (inithandle)<N>    ReturnValue: QWORD;<N>    ParamStart: byte;<N>    //....   (pointers to strings will point inside this block, based on the target process's executor map address)<N>  end;<N><N>
  PRemoteExecutorSharedMemory=^TRemoteExecutorSharedMemory;<N><N>  TExecBuffer=record<N>    parameternr: integer;<N>    data: ptruint;<N>    length: integer;<N>  end;<N><N>  Tvalueinfo=record<N>    value: qword;<N>    bytesize: integer; //only used for bytetables<N>  end;<N><N>
  TExecBufferArray=array of TExecBuffer;<N><N><N>  TRemoteExecutor=class<N>  private<N>    targetedProcessID: dword;<N>    HasDataEventHandle: THandle;<N>    HasProcessedDataEventHandle: THandle;<N><N>    sharedMemorySize: integer;<N>    sharedMemory: PRemoteExecutorSharedMemory;<N>    sharedMemoryClientLocation: QWORD;<N><N>
unit symbolhandler;<N><N>{$MODE Delphi}<N><N>interface<N><N><N>{$ifdef jni}<N>uses unixporthelper, Classes, sysutils, NewKernelHandler, syncobjs, SymbolListHandler,<N>  fgl, typinfo, cvconst, DotNetPipe, DotNetTypes, commonTypeDefs, math;<N>{$else}<N>uses<N>  {$ifdef darwin}<N>  macport, coresymbolication,<N>  {$endif}<N><N>
  {$ifdef windows}<N>  jwawindows, windows,<N>  {$endif}<N>  classes,LCLIntf{$ifdef windows},imagehlp{$endif},sysutils, CEFuncProc,<N>  NewKernelHandler,syncobjs, SymbolListHandler, fgl, typinfo, cvconst, PEInfoFunctions,<N>  DotNetPipe, DotNetTypes, commonTypeDefs, math, LazUTF8, contnrs, LazFileUtils,<N>  db, sqldb, sqlite3dyn, sqlite3conn, registry, symbolhandlerstructs, forms, controls,<N>  AvgLvlTree,contexthandler<N>  {$ifdef darwin}<N>  ,macportdefines<N>  {$endif};<N>{$endif}<N><N>
<N>{$ifdef windows}<N>Procedure Free (P : pointer); cdecl; external 'msvcrt' name 'free';<N>{$endif}<N><N>{$ifdef autoassemblerdll}<N>var<N>  processid: dword;<N>  processhandle: thandle;<N><N>Type TMemoryRegion = record<N>  BaseAddress: ptrUint;<N>  MemorySize: Dword;<N>  IsChild: boolean;<N>  startaddress: pointer;<N>  end;<N>type TMemoryregions = array of tmemoryregion;<N><N>
{$endif}<N><N><N><N>type<N>  TUserdefinedSymbolCallbackPart=(suUserdefinedSymbol, suSymbolList);<N>  TUserdefinedSymbolCallback=procedure(item: TUserdefinedSymbolCallbackPart=suUserdefinedSymbol);<N><N><N>type<N>  TSymHandlerTokenType=(ttByte, ttWord, ttDword, ttQword, ttShortInt, ttSmallint, ttLongint, ttInt64);<N>  TSymHandler=class;<N><N>
<N>  TSymbolLoaderThreadEvent=class(tobject)<N>  private<N>    done: TEvent;<N>    ownersymhandler: TSymHandler;<N>  public<N>    symbolname: string;<N>    address: ptruint;<N>    abandoned: boolean;<N><N>    procedure waittilldone;<N>    constructor create(sh: TSymHandler);<N>    destructor destroy; override;<N>  end;<N><N>
  TGetAddressFromSymbolThreadEvent=class(TSymbolLoaderThreadEvent);<N>  TGetSymbolFromAddressThreadEvent=class(TSymbolLoaderThreadEvent);<N>  TGetStructureFromNameThreadEvent=class(TSymbolLoaderThreadEvent)<N>  public<N>    //symbolname is structname in this case<N>    structure: TStringList;<N>  end;<N><N>
unit CodeFilterCallOrAllDialog;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ExtCtrls, betterControls;<N><N>type<N><N>  { TCallOrAllDialog }<N><N>  TCallOrAllDialog = class(TForm)<N>    Button1: TButton;<N>    Button2: TButton;<N>    Button3: TButton;<N>    Label1: TLabel;<N>    Panel1: TPanel;<N>  private<N>    { private declarations }<N>  public<N>    { public declarations }<N>  end;<N><N>implementation<N><N>{$R *.lfm}<N><N>end.<N><N>
unit bogus; <N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, LResources, Forms, Controls, Graphics, Dialogs; <N><N>type<N>  TForm1 = class(TForm)<N>  private<N>    { private declarations }<N>  public<N>    { public declarations }<N>  end; <N><N>var<N>  Form1: TForm1; <N><N>implementation<N><N>initialization<N>  {$I bogus.lrs}<N><N>end.<N><N>
unit frmReferencedStringsUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, ComCtrls, ExtCtrls, StdCtrls, syncobjs, CEFuncProc, NewKernelHandler,<N>  math, Menus, LResources, betterControls;<N><N>
type<N>  TfrmReferencedStrings=class;<N>  TDelayedStringfiller = class(TThread)<N>  private<N>  public<N>    s: tstringlist;<N>    csList: TCriticalSection;<N>    procedure execute; override;<N>    constructor create(suspended: boolean);<N>    destructor destroy; override;<N>  end;<N><N>
unit BetterDLLSearchPath;<N><N>{$mode delphi}<N><N>interface<N><N>{$ifdef windows}<N><N>uses<N>  windows, sysutils;<N><N>const<N>  LOAD_LIBRARY_SEARCH_DEFAULT_DIRS=$1000;<N>  LOAD_LIBRARY_SEARCH_USER_DIRS=$400;<N><N>var<N>  AddDllDirectory: function(dir: PWideChar):pointer; stdcall;<N>  RemoveDllDirectory: function(cookie: pointer): BOOL; stdcall;<N>  SetDefaultDllDirectories: function(v: dword):BOOL; stdcall;<N><N>
  DLLDirectoryCookie: pointer=nil;<N>{$endif}<N><N>implementation<N><N>{$ifdef windows}<N>function AddDllDirectoryNI(dir: PWideChar):pointer; stdcall;<N>begin<N>  result:=nil;<N>end;<N><N>function RemoveDllDirectoryNI(cookie: pointer): BOOL; stdcall;<N>begin<N>  result:=true;<N>end;<N><N>
function SetDefaultDllDirectoriesNI(v:dword):BOOL; stdcall;<N>begin<N>  result:=false;<N>end;<N><N>procedure BetterDLLSearchPathInit;<N>var<N>  k: THandle;<N>  p: widestring;<N>begin<N>  k:=LoadLibrary('kernel32.dll');<N>  SetDefaultDllDirectories:=GetProcAddress(k,'SetDefaultDllDirectories');<N>  AddDllDirectory:=GetProcAddress(k,'AddDllDirectory');<N>  RemoveDllDirectory:=GetProcAddress(k,'AddDllDirectory');<N><N>
unit scrollTreeView;<N>{Helper class for treeviews that need more control over the horizontal scroll}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, controls, StdCtrls, ExtCtrls, comctrls, lmessages,betterControls;<N><N>type<N><N><N>  //-----old imp-----------<N><N>
<N>  THScrollEvent=procedure (sender: TObject; scrolledleft, maxscrolledleft: integer) of object;<N><N><N>  TTreeView = class({$ifdef windows}betterControls.{$else}comctrls.{$endif}TTreeView)<N>  private<N>    fOnHScroll: THScrollEvent;<N>    fOnVScroll: TNotifyEvent;<N>  public<N>    procedure WMHScroll(var Msg: TLMScroll); message LM_HSCROLL;<N>    procedure WMVScroll(var Msg: TLMScroll); message LM_VSCROLL;<N>    procedure ForceScrollbarChange;<N><N>
unit CEDebugger;<N>//OLD debugger. Obsolete , just here till all old references have been removed<N><N>{$MODE Delphi}<N><N>interface<N><N>uses {$ifdef darwin}<N>     macport, macportdefines,<N>     {$endif}<N>     {$ifdef windows}<N>     windows,<N>     {$endif}<N>     Classes,LCLIntf,sysutils,CEFuncProc,Messages,forms,SyncObjs,<N>     dialogs,controls,Graphics,NewKernelHandler,symbolhandler,StrUtils,<N>     ComCtrls ,Assemblerunit,addressparser, vmxfunctions;<N><N>
<N>type TReadonly = record<N>  pagebase: uint_ptr;<N>  pagesize: uint_ptr;<N>  Address: uint_ptr;<N>  size: integer;<N>  originalprotection:  dword;<N>end;<N><N>type tThreadEntry=record<N>  threadHandle: thandle;<N>  address: uint_ptr;<N>end;<N><N><N>type Process=record<N>  ProcessID: dword;<N>  running: boolean;<N>end;<N><N>
unit exceptionhandler;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  jwawindows, //I use jwawindows only for the purpose of the structure declaration of PVECTORED_EXCEPTION_HANDLER, I declare and assign AddVectoredExceptionHandler myself<N>  windows, Classes, SysUtils;<N><N>
unit formFoundcodeListExtraUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$else}<N>  windows,<N>  {$endif}<N>  LResources, LCLIntf, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, Dialogs, StdCtrls, Menus,Clipbrd, ExtCtrls, Buttons,<N>  frmFloatingPointPanelUnit, NewKernelHandler,cefuncproc, frmStackViewUnit, betterControls;<N><N>
unit ExtraTrainerComponents;<N><N>interface<N><N>{$mode DELPHI}<N><N>uses controls,StdCtrls,classes,Graphics,ExtCtrls, sysutils, betterControls;<N><N>type TLabel2 = class (TLabel)<N>  public<N>    command: string;<N>end;<N><N>type TImage2 = class (Timage)<N>  public<N>    extension: string;<N>    imagedata: tmemorystream;<N>    command: string;<N>end;<N><N>
type TButton2 = class (TButton)<N>  public<N>    command: string;<N>end;<N><N>type tcheat = class (twincontrol)<N>//a cheat exists of 2 parts, the hotkey and the description   (what about cheats that enable you to change values them?)<N>  private<N>    hotkeylabel: tlabel;<N>    descriptionlabel: tlabel;<N>    edit:tedit;<N>    checkbox: tcheckbox;<N>    ftextcolor: tcolor;<N>    factivated: boolean;<N><N>
unit speedhack2;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses Classes,LCLIntf, SysUtils, NewKernelHandler,CEFuncProc, symbolhandler, symbolhandlerstructs,<N>     autoassembler, dialogs,Clipbrd, commonTypeDefs, controls{$ifdef darwin},macport, FileUtil{$endif};<N><N>
type TSpeedhack=class<N>  private<N>    fProcessId: dword;<N>    initaddress: ptrUint;<N>    lastSpeed: single;<N>  public<N>    procedure setSpeed(speed: single);<N>    function getSpeed: single;<N>    property processid: dword read fProcessId;<N>    constructor create;<N>    destructor destroy; override;<N>  end;<N><N>
var speedhack: TSpeedhack;<N><N>implementation<N><N>uses frmAutoInjectUnit, networkInterface, networkInterfaceApi, ProcessHandlerUnit, Globals;<N><N>resourcestring<N>  rsFailureEnablingSpeedhackDLLInjectionFailed = 'Failure enabling speedhack. (DLL injection failed)';<N>  rsFailureConfiguringSpeedhackPart = 'Failure configuring speedhack part';<N>  rsFailureSettingSpeed = 'Failure setting speed';<N><N>
constructor TSpeedhack.create;<N>var i: integer;<N>    script: tstringlist;<N><N>    disableinfo: TDisableInfo;<N>    x: ptrUint;<N>//      y: dword;<N>    a,b: ptrUint;<N>    c: TCEConnection;<N>    e: boolean;<N><N>    fname: string;<N>    err: boolean;<N><N>
    path: string;<N><N>    QPCAddress: ptruint;<N>    mi: TModuleInfo;<N>    mat: qword;<N>    machmodulebase: qword;<N>    machmodulesize: qword;<N><N>    HookMachAbsoluteTime: boolean;<N><N>    nokernelbase: boolean=false;<N>    NoGetTickCount: boolean=false;<N>    NoQPC: boolean=false;<N>    NoGetTickCount64: boolean=false;<N><N>
begin<N>  initaddress:=0;<N><N>  if processhandler.isNetwork then<N>  begin<N>    c:=getconnection;<N>    c.loadExtension(processhandle); //just to be sure<N><N>    symhandler.reinitialize;<N>    symhandler.waitforsymbolsloaded(true);<N>  end<N>  else<N>  begin<N>    try<N>      {$ifdef darwin}<N>      if not FileExists('/usr/local/lib/libspeedhack.dylib') then<N>      begin<N>        ForceDirectories('/usr/local/lib/');<N><N>
        path:=cheatenginedir+'libspeedhack.dylib';<N>        if CopyFile(path, '/usr/local/lib/libspeedhack.dylib', true)=false then<N>        begin<N>          raise exception.create('Failure copying libspeedhack.dylib to /usr/local/lib');<N>        end;<N>      end;<N><N>
      if symhandler.getmodulebyname('libspeedhack.dylib', mi)=false then<N>      begin<N>        injectdll('/usr/local/lib/libspeedhack.dylib','');<N>        symhandler.reinitialize;<N>      end;<N><N>      {$endif}<N><N>      {$ifdef windows}<N>      if processhandler.is64bit then<N>        fname:='speedhack-x86_64.dll'<N>      else<N>        fname:='speedhack-i386.dll';<N><N>
unit frmSetCrosshairUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, ExtCtrls,<N>  Menus, StdCtrls, ExtDlgs, ComCtrls, d3dhookUnit, betterControls;<N><N>type<N><N>  { TfrmSetCrosshair }<N><N>
unit ThreadlistExFRM;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  jwawindows, windows,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ComCtrls,NewKernelHandler,{tlhelp32,}CEFuncProc,<N>  ExtCtrls, LResources, betterControls;<N><N>
type<N>  TfrmThreadlistEx = class(TForm)<N>    TreeView1: TTreeView;<N>    Panel1: TPanel;<N>    Button1: TButton;<N>    procedure FormClose(Sender: TObject; var Action: TCloseAction);<N>    procedure Button1Click(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>    procedure updatelist;<N>  end;<N><N>
unit autoassemblerexeptionhandler;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, NewKernelHandler, Clipbrd, betterControls;<N><N>type<N>  TAAExceptionInfo=record<N>    trylabel: string;<N>    exceptlabel: string;<N>  end;<N><N>
  TAAExceptionInfoList=array of TAAExceptionInfo;<N><N>  {$ifdef onebytejumps}<N>  TAAExceptionRIPChangeInfo=record<N>    originaddress: ptruint;<N>    destinationlabel: string;<N>  end;<N><N>  TAAExceptionRIPChangeInfoList=array of TAAExceptionRIPChangeInfo;<N>  {$endif}<N><N>
unit LuaMemscan;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib, symbolhandler, LuaHandler, cefuncproc,<N>  memscan, foundlisthelper, forms, commonTypeDefs;<N><N>procedure initializeMemscan;<N><N>implementation<N><N>
uses luaclass, LuaObject, savedscanhandler;<N><N>resourcestring<N>  rsNotAllParametersHaveBeenProvided = 'Not all parameters have been provided';<N><N>//memscan_firstScan(memscan, scanOption, vartype, roundingtype, input1, input2, startAddress,<N>//                  stopAddress, protectionflags, alignmenttype, "alignmentparam", isHexadecimalInput,<N>//                  isNotABinaryString, isunicodescan, iscasesensitive, ispercentagescan);<N><N>
unit LuaCollection;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils,Lua, Lualib, lauxlib;<N><N>procedure collection_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>procedure initializeLuaCollection;<N><N><N>implementation<N><N>
uses luaclass, luahandler, LuaObject;<N><N>function collection_clear(L: Plua_State): integer; cdecl;<N>var<N>  collection: TCollection;<N>begin<N>  collection:=luaclass_getClassObject(L);<N>  collection.clear;<N>  result:=0;<N>end;<N><N>function collection_getCount(L: PLua_State): integer; cdecl;<N>var<N>  collection: TCollection;<N>begin<N>  collection:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, collection.Count);<N>  result:=1;<N>end;<N><N>
unit frmDriverLoadedUnit;<N>//just something funny<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef windows}windows,{$endif} LCLIntf, Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, ExtCtrls,<N>  StdCtrls, betterControls;<N><N>type<N><N>
  { TfrmDriverLoaded }<N><N>  TfrmDriverLoaded = class(TForm)<N>    Label1: TLabel;<N>    Timer1: TTimer;<N>    Timer2: TTimer;<N>    procedure FormShow(Sender: TObject);<N>    procedure Timer1Timer(Sender: TObject);<N>    procedure Timer2Timer(Sender: TObject);<N>  private<N>    { private declarations }<N><N>
  public<N>    { public declarations }<N>  end;<N><N>procedure ShowDriverLoaded;<N><N>implementation<N><N>{$R *.lfm}<N><N>uses mainunit, pluginexports;<N><N><N>procedure ShowDriverLoaded;<N>var<N>  frmDriverLoaded: TfrmDriverLoaded;<N>  s,s2,t: string;<N>  i: integer;<N><N>
  a,b: array [0..1] of boolean;<N><N><N>begin<N>//  TfrmDriverLoaded.ClassName;<N>  {$IFDEF windows}<N>  s:='';<N>  s2:='';<N>  for i:=1 to 5+random(5) do<N>  begin<N>    s:=s+chr(31+random(96));<N>    s2:=s2+chr(31+random(96));<N>  end;<N><N>  a[0]:=true;<N>  a[1]:=false;<N>  for i:=0 to random(10) do<N>  begin<N>    a[0]:=not a[0];<N>    a[1]:=not a[1];<N>    t:=s;<N>    s:=s2;<N>    s2:=t;<N>  end;<N><N>
<N>  frmDriverLoaded:=TfrmDriverLoaded.Create(nil);<N>  if a[0] then frmDriverLoaded.caption:=s else frmDriverLoaded.caption:=s2;<N><N><N><N>  frmDriverLoaded.show;<N><N><N>  b[0]:=false;<N>  b[1]:=false;<N>  while (b[0]=false) and (b[1]=false) do<N>  begin<N>    application.ProcessMessages;<N>    b[0]:=IsWindowVisible(FindWindow('Window',pchar(s)));<N>    b[1]:=IsWindowVisible(FindWindow('Window',pchar(s2)));<N>  end;<N><N>
  if (a[0]<>b[0]) or (a[1]<>b[1]) or (a[0]=a[1]) or (b[0]=b[1]) then<N>  begin<N>    TerminateProcess(GetCurrentProcess,0);<N>    ExitProcess(0);<N>    MainForm.free;<N>    application.Terminate;<N>    while true do ;<N>  end;<N><N>  frmDriverLoaded.timer1.Enabled:=true;<N>  {$ENDIF}<N><N>
end;<N><N>procedure TfrmDriverLoaded.Timer1Timer(Sender: TObject);<N>var s: integer;<N>begin<N>  {$IFDEF windows}<N>  s:=AlphaBlendValue-2;<N>  AlphaBlendValue:=s;<N>  if s<=0 then<N>    close;<N>  {$ENDIF}<N>end;<N><N>procedure TfrmDriverLoaded.FormShow(Sender: TObject);<N>begin<N>  top:=0;<N>  left:=0;<N>end;<N><N>
unit frmRegistersunit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, LCLProc, math,<N>  {$endif}<N>  {$ifdef windows}<N>  win32proc, jwawindows, windows,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, Buttons, ExtCtrls, StdCtrls, frmFloatingPointPanelUnit, NewKernelHandler,<N>  cefuncproc, LResources,Clipbrd, Menus, frmStackViewunit, betterControls, strutils, contexthandler;<N><N>
unit GnuAssembler;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, NewKernelHandler, ProcessHandlerUnit, strutils,<N>  dialogs, commonTypeDefs;<N><N>
{<N>      //scan for .extraparams_as <string><N>      //scan for .extraparams_ld <string><N><N>      //scan the script for .asection , .msection and .aobscan<N>      //1:<N>      //.aobscan <name> "ceaobscanformat"<N>      //Internally ->:<N>      //.msection <name> <aobscanresult><N>      //->see .msection<N><N>
unit ScrollBoxEx;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lmessages, forms, messages, betterControls;<N><N>type<N>  TScrollBox=class({$ifdef windows}betterControls.{$else}Forms.{$endif}TScrollbox)<N>  private<N>    procedure WMVScroll(var Msg: TMessage); message WM_VSCROLL;<N>  public<N>    OnVScroll: TNotifyEvent;<N>end;<N><N>implementation<N><N>procedure TScrollBox.WMVScroll(var Msg: TMessage);<N>begin<N>  if assigned(OnVScroll) then OnVScroll(self);<N><N>  inherited;<N>end;<N><N>end.<N><N>
unit frmDotNetObjectListUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, ComCtrls, betterControls;<N><N>type<N><N>  { TfrmDotNetObjectList }<N><N>  TfrmDotNetObjectList = class(TForm)<N>    ListView1: TListView;<N>  private<N>    { private declarations }<N>  public<N>    { public declarations }<N>    procedure loadlist;<N>  end;<N><N>
var<N>  frmDotNetObjectList: TfrmDotNetObjectList;<N><N>implementation<N><N>uses symbolhandler, DotNetPipe, maps;<N><N>{$R *.lfm}<N><N>type<N>  TLoadListThread=class(TThread)<N>  private<N>    flushcount: integer;<N>    e: array [0..9] of TDotNetObject;<N><N>
    procedure flush;<N>  public<N>    procedure Execute; override;<N>  end;<N><N>var loadListThread: TLoadListThread;<N><N>procedure TLoadListThread.flush;    //synchronize routine<N>var<N>  i: integer;<N>  li: tlistitem;<N>begin<N>  for i:=0 to flushcount-1 do<N>  begin<N>    li:=frmDotNetObjectList.ListView1.Items.Add;<N>    li.caption:=inttohex(e[i].startaddress,8);<N>    li.subitems.add(e[i].classname);<N>  end;<N><N>
  flushcount:=0;<N>end;<N><N>procedure TLoadListThread.execute;<N>var<N>  l: TDOTNETObjectList;<N>  li: TMapIterator;<N>  i: integer;<N>begin<N>  FreeOnTerminate:=true;<N>  try<N>    //get the list<N>    l:=symhandler.getdotnetobjectlist;<N><N>    if l<>nil then<N>    begin<N>      li:=TMapIterator.create(l);<N>      li.first;<N>      flushcount:=0;<N>      while not li.eom do<N>      begin<N>        //add to frmDotNetObjectList<N>        li.GetData(e[flushcount]);<N><N>
        inc(flushcount);<N>        if flushcount>=10 then<N>          synchronize(flush);<N><N>        li.next;<N>      end;<N><N>      if flushcount>0 then<N>        synchronize(flush);<N><N>      symhandler.freedotnetobjectlist(l);<N>    end;<N>  finally<N>    loadListThread:=nil;<N>  end;<N>end;<N><N>
unit dbvmPhysicalMemoryHandler;<N><N>{$MODE Delphi}<N><N>{<N>implement replaced handlers for ReadProcessMemory and WriteProcessMemory so it<N>reads/writes to the physical memory instead<N>}<N><N>interface<N><N>{$IFDEF windows}<N>uses windows, LCLIntf, vmxfunctions;<N><N>
function ReadProcessMemoryPhys(hProcess: THandle; const lpBaseAddress: Pointer; lpBuffer: Pointer;  nSize: DWORD; var lpNumberOfBytesRead: DWORD): BOOL; stdcall;<N>function WriteProcessMemoryPhys(hProcess: THandle; const lpBaseAddress: Pointer; lpBuffer: Pointer; nSize: DWORD; var lpNumberOfBytesWritten: DWORD): BOOL; stdcall;<N>function VirtualQueryExPhys(hProcess: THandle; lpAddress: Pointer; var lpBuffer: TMemoryBasicInformation; dwLength: DWORD): DWORD; stdcall;<N>{$ENDIF}<N><N>
<N>implementation<N><N>{$IFDEF windows}<N>uses NewKernelHandler, DBK32functions;<N><N>function ReadProcessMemoryPhys(hProcess: THandle; const lpBaseAddress: Pointer; lpBuffer: Pointer;  nSize: DWORD; var lpNumberOfBytesRead: DWORD): BOOL; stdcall;<N>begin<N>  lpNumberOfBytesRead:=dbvm_read_physical_memory(uint64(ptrUint(lpBaseAddress)),lpBuffer,nSize);<N>  result:=lpNumberOfBytesRead>0;<N>end;<N><N>
function WriteProcessMemoryPhys(hProcess: THandle; const lpBaseAddress: Pointer; lpBuffer: Pointer; nSize: DWORD; var lpNumberOfBytesWritten: DWORD): BOOL; stdcall;<N>begin<N>  lpNumberOfBytesWritten:=dbvm_write_physical_memory(uint64(ptrUint(lpBaseAddress)),lpBuffer,nSize);<N>  result:=lpNumberOfBytesWritten>0;<N>end;<N><N>
unit LuaTrackbar;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, controls, comctrls, lua, lualib, lauxlib, betterControls;<N><N>procedure initializeLuaTrackbar;<N><N>implementation<N><N>uses luahandler, luaclass, luacaller, LuaWinControl;<N><N>
//trackbar<N>function createTrackBar(L: Plua_State): integer; cdecl;<N>var<N>  TrackBar: TTrackBar;<N>  parameters: integer;<N>  owner: TWincontrol;<N>begin<N>  result:=0;<N><N>  parameters:=lua_gettop(L);<N>  if parameters>=1 then<N>    owner:=lua_toceuserdata(L, -parameters)<N>  else<N>    owner:=nil;<N><N>
  lua_pop(L, lua_gettop(L));<N><N><N>  TrackBar:=TTrackBar.Create(owner);<N>  if owner<>nil then<N>    TrackBar.Parent:=owner;<N><N>  luaclass_newClass(L, TrackBar);<N>  result:=1;<N>end;<N><N>function trackbar_getMax(L: PLua_State): integer; cdecl;<N>var<N>  trackbar: Tcustomtrackbar;<N>begin<N>  trackbar:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, trackbar.max);<N>  result:=1;<N>end;<N><N>
function trackbar_setMax(L: PLua_State): integer; cdecl;<N>var<N>  trackbar: Tcustomtrackbar;<N>begin<N>  result:=0;<N>  trackbar:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=1 then<N>    trackbar.max:=lua_tointeger(L,-1);<N>end;<N><N>function trackbar_getMin(L: PLua_State): integer; cdecl;<N>var<N>  trackbar: Tcustomtrackbar;<N>begin<N>  trackbar:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, trackbar.Min);<N>  result:=1;<N>end;<N><N>
function trackbar_setMin(L: PLua_State): integer; cdecl;<N>var<N>  trackbar: Tcustomtrackbar;<N>begin<N>  result:=0;<N>  trackbar:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=1 then<N>    trackbar.Min:=lua_tointeger(L,-1);<N>end;<N><N><N>function trackbar_getPosition(L: PLua_State): integer; cdecl;<N>var<N>  trackbar: Tcustomtrackbar;<N>begin<N>  trackbar:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, trackbar.Position);<N>  result:=1;<N>end;<N><N>
function trackbar_setPosition(L: PLua_State): integer; cdecl;<N>var<N>  trackbar: Tcustomtrackbar;<N>begin<N>  result:=0;<N>  trackbar:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=1 then<N>    trackbar.Position:=lua_tointeger(L,-1);<N>end;<N><N>function trackbar_getonChange(L: PLua_State): integer; cdecl;<N>var<N>  c: TCustomTrackBar;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  LuaCaller_pushMethodProperty(L, TMethod(c.OnChange), 'TNotifyEvent');<N>  result:=1;<N>end;<N><N>
function trackbar_setonChange(L: PLua_State): integer; cdecl;<N>var<N>  control: TCustomTrackBar;<N>  f: integer;<N>  routine: string;<N>  lc: TLuaCaller;<N>begin<N>  result:=0;<N>  control:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>  begin<N>    CleanupLuaCall(tmethod(control.onChange));<N>    control.onChange:=nil;<N><N>
    if lua_isfunction(L,-1) then<N>    begin<N>      routine:=Lua_ToString(L,-1);<N>      f:=luaL_ref(L,LUA_REGISTRYINDEX);<N><N>      lc:=TLuaCaller.create;<N>      lc.luaroutineIndex:=f;<N>      control.OnChange:=lc.NotifyEvent;<N>    end<N>    else<N>    if lua_isstring(L,-1) then<N>    begin<N>      routine:=lua_tostring(L,-1);<N>      lc:=TLuaCaller.create;<N>      lc.luaroutine:=routine;<N>      control.OnChange:=lc.NotifyEvent;<N>    end;<N><N>
unit LuaListItems;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, ComCtrls, lua, lualib, lauxlib;<N><N>procedure initializeLuaListItems;<N><N>implementation<N><N>uses luaclass, luahandler, LuaObject;<N><N>function listitems_beginUpdate(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  Tlistitems(luaclass_getClassObject(L)).BeginUpdate;<N>end;<N><N>
function listitems_endUpdate(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  Tlistitems(luaclass_getClassObject(L)).EndUpdate;<N>end;<N><N>function listitems_clear(L: Plua_State): integer; cdecl;<N>var<N>  listitems: Tlistitems;<N>begin<N>  result:=0;<N>  listitems:=luaclass_getClassObject(L);<N>  listitems.clear;<N>end;<N><N>
function listitems_getItem(L: PLua_State): integer; cdecl;<N>var<N>  listitems: Tlistitems;<N>  index: integer;<N>begin<N>  result:=0;<N>  listitems:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=1 then<N>  begin<N>    index:=lua_tointeger(L,-1);<N>    luaclass_newClass(L, listitems.Item[index]);<N>    result:=1;<N>  end;<N>end;<N><N>
function listitems_setItem(L: PLua_State): integer; cdecl;<N>var<N>  listitems: Tlistitems;<N>  index: integer;<N>  item:TListItem;<N>begin<N>  result:=0;<N>  listitems:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=2 then<N>  begin<N>    index:=lua_tointeger(L,-2);<N>    item:=lua_ToCEUserData(L, -1);<N>    listitems.Item[index]:=item;<N>  end;<N>end;<N><N>
function listitems_setCount(L: PLua_State): integer; cdecl;<N>var<N>  listitems: Tlistitems;<N>begin<N>  result:=0;<N>  listitems:=luaclass_getClassObject(L);<N>  listitems.Count:=lua_tovariant(L, 1);<N>end;<N><N>function listitems_getCount(L: PLua_State): integer; cdecl;<N>var<N>  listitems: Tlistitems;<N>begin<N>  listitems:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, listitems.Count);<N>  result:=1;<N><N>
unit memdisplay;<N>{<N>Will render a memory block using an opengl drawPixel command. Display options are userchangable<N><N>Should also have the ability to highlight blocks of memory with a specific color<N><N>setPointer(block, address)<N>setWidth(integer)<N>setFormat(x)<N><N>
id=createOverlay(address, size)<N>setOverlayColor(id, color)<N><N>render()<N>  Render the graphics bitmap<N>  Then render the overlays<N><N>setUpdateInterval()<N><N><N>expose: onKeyPress<N><N><N>When the user scrolls left and right the limits will be the  pitch<N>When the user scrolls up or down, it will send an onData event when the new line on is outside of it's current region<N>If onData returns false, the scroll will not succeed and be put back to the max allowed<N><N>
<N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, ExtCtrls, Controls, LMessages, Graphics, GL, glu,<N>  math, dialogs, GLext, betterControls;<N><N>
<N>type TCurrentOverlay=record<N>  x,y,width,height: integer;<N>  data: pointer;<N>end;<N>  PCurrentOverlay=^TCurrentOverlay;<N><N><N>type<N>  TOnDataEvent=function(newAddress: ptruint; PreferedMinimumSize: integer; var newbase: pointer; var newsize: integer): boolean of object;<N>  //This event will be called when the displayed size is changed, or when the position is moved, and it won't fit in the current block anymore<N><N>
  TOnRequestTextEvent=function (Address: ptruint): string of object;<N><N>type<N>  TMemDisplay=class(Tcustompanel)<N>  private<N><N>    oldWndProc: TWndMethod;<N><N>    {$ifdef windows}<N>    hglrc: HGLRC;<N>    {$endif}<N>    updater: TIdleTimer;<N><N>    fType: integer;<N>    fPixelFormat: integer;<N><N>
<N>    fMaxCharCount: integer; //defines how big the font will be<N><N>    fOnRequestText: TOnRequestTextEvent;<N><N>    hasFont: boolean;<N><N>    procedure wndproc_mem(var TheMessage: TLMessage);<N>    procedure Resize; override;<N>    procedure updaterevent(sender: TObject);<N>    procedure SetZoom(z:single);<N>    procedure RecenterDrag;<N>  protected<N>    mapr, mapg, mapb: array of single;<N>    procedure SetParent(NewParent: TWinControl); override;<N><N>
unit LuaPanel;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib, ExtCtrls, betterControls;<N><N>procedure initializeLuaPanel;<N>procedure panel_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N><N>
implementation<N><N>uses luaclass, LuaCustomControl, pluginexports, luahandler;<N><N>function createPanel(L: Plua_State): integer; cdecl;<N>var parameters: integer;<N>  f,p: pointer;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters=1 then<N>  begin<N>    f:=lua_toceuserdata(L, -1);<N>    p:=ce_createPanel(f);<N>    luaclass_newClass(L, p);<N>    result:=1;<N>  end;<N>end;<N><N>
function panel_getAlignment(L: PLua_State): integer; cdecl;<N>var<N>  panel: Tcustompanel;<N>begin<N>  panel:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, integer(panel.Alignment));<N>  result:=1;<N>end;<N><N>function panel_setAlignment(L: PLua_State): integer; cdecl;<N>var<N>  panel: Tcustompanel;<N>begin<N>  result:=0;<N>  panel:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    panel.Alignment:=TAlignment(lua_tointeger(L,-1));<N>end;<N><N>
function panel_getBevelInner(L: PLua_State): integer; cdecl;<N>var<N>  panel: Tcustompanel;<N>begin<N>  panel:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, integer(panel.BevelInner));<N>  result:=1;<N>end;<N><N>function panel_setBevelInner(L: PLua_State): integer; cdecl;<N>var<N>  panel: Tcustompanel;<N>begin<N>  result:=0;<N>  panel:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    panel.BevelInner:=TPanelBevel(lua_tointeger(L,-1));<N>end;<N><N>
function panel_getBevelOuter(L: PLua_State): integer; cdecl;<N>var<N>  panel: Tcustompanel;<N>begin<N>  panel:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, integer(panel.BevelOuter));<N>  result:=1;<N>end;<N><N>function panel_setBevelOuter(L: PLua_State): integer; cdecl;<N>var<N>  panel: Tcustompanel;<N>begin<N>  result:=0;<N>  panel:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    panel.BevelOuter:=TPanelBevel(lua_tointeger(L,-1));<N>end;<N><N>
function panel_getBevelWidth(L: PLua_State): integer; cdecl;<N>var<N>  panel: Tcustompanel;<N>begin<N>  panel:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, integer(panel.BevelWidth));<N>  result:=1;<N>end;<N><N>function panel_setBevelWidth(L: PLua_State): integer; cdecl;<N>var<N>  panel: Tcustompanel;<N>begin<N>  result:=0;<N>  panel:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    panel.BevelWidth:=TBevelWidth(lua_tointeger(L,-1));<N>end;<N><N>
function panel_getFullRepaint(L: PLua_State): integer; cdecl;<N>var<N>  panel: Tcustompanel;<N>begin<N>  panel:=luaclass_getClassObject(L);<N>  lua_pushboolean(L, panel.FullRepaint);<N>  result:=1;<N>end;<N><N>function panel_setFullRepaint(L: PLua_State): integer; cdecl;<N>var<N>  panel: Tcustompanel;<N>begin<N>  result:=0;<N>  panel:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    panel.FullRepaint:=lua_toboolean(L,-1);<N>end;<N><N>
// Copyright Cheat Engine. All Rights Reserved.<N><N>unit disassembler;<N><N>{$MODE Delphi}<N><N>interface<N><N>{$ifdef jni}<N>uses unixporthelper, sysutils, byteinterpreter, symbolhandler, NewKernelHandler,<N> ProcessHandlerUnit, LastDisassembleData, DisassemblerArm, commonTypeDefs;<N>{$endif}<N><N>
{$ifdef windows}<N>uses windows, classes, imagehlp,sysutils,LCLIntf,byteinterpreter, symbolhandler, symbolhandlerstructs,<N>  CEFuncProc, NewKernelHandler, ProcessHandlerUnit, LastDisassembleData, disassemblerarm,<N>  commonTypeDefs, maps, math,vextypedef, betterControls, syncobjs;<N>{$endif}<N><N>
{$ifdef darwin}<N>uses LCLIntf, LCLType, macport, macportdefines, classes,sysutils,byteinterpreter, symbolhandler, symbolhandlerstructs,<N>  CEFuncProc, ProcessHandlerUnit, LastDisassembleData, disassemblerarm,<N>  commonTypeDefs, maps, math,vextypedef, syncobjs, NewKernelHandler;<N>{$endif}<N><N>
//translation: There is no fucking way I change the descriptions to resource strings<N>//if you're bored, go do this<N><N>type Tprefix = set of byte;<N>type TMemory = array [0..64] of byte;<N>type TIntToHexS=function(address:ptrUInt;chars: integer; signed: boolean=false; signedsize: integer=0):string of object;<N><N>
unit CustomBase85;<N><N><N>// uses 85 ascii characters which are better to use in XML ( no &'<"\> chars and no space char = more efficient )<N>//<N>// Base85ToBin doesn't support white spaces and line breaks (HexToBin doesn't support it too)<N><N>// implementation by mgr.inz.Player http://forum.cheatengine.org/viewtopic.php?t=560886 and http://pastebin.com/EUfGFpZ9<N><N>
{$mode delphi}<N><N>interface<N><N>uses<N>  Classes;<N><N>procedure BinToBase85(BinValue, outputStringBase85: PChar; BinBufSize: integer);<N>//<N>//  example:<N>//    getmem(outputstring, (BinarySize div 4) * 5 + 5 );<N>//    BinToBase85(b,outputstring,BinarySize);<N>//<N>//  it adds a 0 terminator to outputstring<N><N>
unit frmMemviewPreferencesUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, LResources, Forms, Controls, Graphics, Dialogs,<N>  StdCtrls, Menus, ExtCtrls, disassemblerviewunit, disassemblerviewlinesunit,<N>  LCLIntf, LCLType,<N>  {$ifdef darwin}<N>  macport, math<N>  {$endif}<N>  {$ifdef windows}<N>  windows, betterControls<N>  {$endif};<N><N>
unit PointerscanConnector;<N><N>//thread that will constantly check if it has a connection queue and if so try to connect it and initiate a connection<N>//it also sets up the basic connection type<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, sockets, resolve, syncobjs, math, {$ifdef windows}winsock2,{$endif} CELazySocket,<N>  PointerscanNetworkCommands, NewKernelHandler{$ifdef darwin},macport{$endif};<N><N>
<N>type<N>  TConnectEntry=record<N>                 id: integer;<N>                 deleted: boolean; //when set this entry should get deleted<N>                 ip: pchar;<N>                 port: word;<N>	         password: pchar;<N>	         becomeparent: boolean;<N>                 trusted: boolean;<N>               end;<N>  PConnectentry=^TConnectentry;<N><N>
  TConnectEntryArray=array of TConnectentry;<N><N>  TPointerscanConnectEvent=procedure(sender: TObject; sockethandle: TSocket; IBecameAParent: boolean; entry: PConnectEntry) of object;<N>  TPointerScanConnectorLogEvent=procedure(sender: TObject; message: string) of object;<N><N>
  TPointerscanConnector=class(TThread)<N>  private<N>    fOnConnected: TPointerscanConnectEvent;<N>    fOnLog: TPointerScanConnectorLogEvent;<N><N>    nextid: integer; //id to pass on to the next added entry<N>    lastlog: string;       //debug only<N>    list: TList;<N>    listcs: TCriticalSection;<N><N>
    hr: THostResolver;<N>    procedure Log(msg: string);<N>    procedure FreeEntry(entry: PConnectEntry);<N>    procedure RemoveDeletedEntries; //only called by the thread.<N>  public<N>    function AddConnection(ip: string; port: word; password: string; becomeparent: boolean; trusted: boolean=false): integer;<N>    procedure MarkEntryForDeletion(id: integer); //marks for deletion<N>    procedure GetList(var l: TConnectEntryArray);<N><N>
    procedure execute; override;<N>    constructor create(onconnect: TPointerscanConnectEvent=nil);<N>    destructor destroy; override;<N><N>    property OnConnected: TPointerscanConnectEvent read fOnConnected write fOnConnected;<N>  end;<N><N>implementation<N><N>
resourcestring<N>  rsHost = 'host:';<N>  rsCouldNotBeResolved = ' could not be resolved';<N>  rsFailureCreatingSocket = 'Failure creating socket';<N>  rsInvalidResponseFrom = 'invalid response from ';<N>  rsSomeoneForgotToGiveThisConnector = 'Someone forgot to give this connector an OnConnected event...';<N>  rsErrorWhileConnecting = 'Error while connecting: ';<N><N>
procedure TPointerscanConnector.GetList(var l: TConnectEntryArray);<N>{<N>Passes a copy of the list of entries to the caller<N>}<N>var i: integer;<N>begin<N>  listcs.enter;<N>  try<N>    setlength(l, list.count);<N>    for i:=0 to list.count-1 do<N>      l[i]:=PConnectEntry(list[i])^;<N>  finally<N>    listcs.leave;<N>  end;<N>end;<N><N>
unit cvconst;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N><N><N>type<N>  TBasicType=(<N>     btNoType = 0,<N>     btVoid = 1,<N>     btChar = 2,<N>     btWChar = 3,<N>     btInt = 6,<N>     btUInt = 7,<N>     btFloat = 8,<N>     btBCD = 9,<N>     btBool = 10,<N>     btLong = 13,<N>     btULong = 14,<N>     btInt2=16,<N>     btCurrency = 25,<N>     btDate = 26,<N>     btVariant = 27,<N>     btComplex = 28,<N>     btBit = 29,<N>     btBSTR = 30,<N>     btHresult = 31);<N><N>
unit unixporthelper;<N><N>//<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils{$ifdef android},log{$endif}, BaseUnix;<N><N>//just fill in some basic info. Most of it won't be used for jni. It's mostly for some structures and function declaration/pointers<N>type<N>  TColor = DWord;<N><N>
  PByteArray = ^TByteArray;<N>  TByteArray = Array[0..{$ifdef CPU16}32766{$else}32767{$endif}] of Byte;<N><N>  PWordarray = ^TWordArray;<N>  TWordArray = array[0..{$ifdef CPU16}16382{$else}16383{$endif}] of Word;<N><N>  TLargeInteger=QWORD;<N>  PUINT64=^UInt64;<N>  ULONG_PTR=ptruint;<N>  ULONG64=qword;<N>  ULONG32=dword;<N>  LONG=integer;<N>  ULONG=DWORD;<N><N>
  pint=^integer;<N><N>  dword64=UInt64;<N>  PDWORD64=^dword64;<N>  LONG64=UInt64;<N><N>  PVOID=pointer;<N>  LPBYTE=^BYTE;<N>  LPVOID=pointer;<N>  SIZE_T=integer;<N>  LPLPVOID=^pointer;<N>  WINBOOL=boolean;<N>  BOOL=boolean;<N>  PBOOL=^BOOL;<N>  PSTR=pchar;<N>  LPSTR=pchar;<N>  LPTSTR=pwidechar;<N>  TCHAR=WCHAR;<N>  PWCHAR=^WCHAR;<N>  HANDLE=integer;<N>  HDC=HANDLE;<N>  HWND=HANDLE;<N>  HICON=HANDLE;<N>  HMODULE=HANDLE;<N>  PHMODULE=^HMODULE;<N><N>
unit CEListviewItemEditor;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ComCtrls, ExtCtrls, propedits, math, betterControls;<N><N>type<N><N>  { TfrmCEListviewItemEditor }<N><N>
unit frmAnchorEditor;<N><N>{$mode ObjFPC}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, LResources, Forms, Controls, Graphics, Dialogs, ExtCtrls,<N>  StdCtrls, Buttons, Spin, DPIHelper, propedits, betterControls;<N><N>type<N><N>  { TAnchorEditor }<N><N>
unit LuaMemoryRecordHotkey;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib, CEFuncProc;<N><N>procedure initializeMemoryRecordHotkey;<N><N>implementation<N><N>uses luaclass, luahandler, luacaller, luaobject, MemoryRecordUnit;<N><N>
<N><N>function memoryrecordhotkey_getDescription(L: PLua_State): integer; cdecl;<N>var<N>  memoryrecordhotkey: TMemoryRecordHotkey;<N>begin<N>  memoryrecordhotkey:=luaclass_getClassObject(L);<N>  lua_pushstring(L, memoryrecordhotkey.description);<N>  result:=1;<N>end;<N><N>
function memoryrecordhotkey_getHotkeyString(L: PLua_State): integer; cdecl;<N>var<N>  memoryrecordhotkey: TMemoryRecordHotkey;<N>begin<N>  memoryrecordhotkey:=luaclass_getClassObject(L);<N>  lua_pushstring(L, ConvertKeyComboToString(memoryrecordhotkey.keys));<N>  result:=1;<N>end;<N><N>
function memoryrecordhotkey_getKeys(L: PLua_State): integer; cdecl;<N>var<N>  memoryrecordhotkey: TMemoryRecordHotkey;<N>  t, i: integer;<N>begin<N>  memoryrecordhotkey:=luaclass_getClassObject(L);<N>  lua_newtable(L);<N>  result:=1;<N><N>  t:=lua_gettop(L); //1<N><N>
  for i:=0 to 4 do<N>  begin<N>    if memoryrecordhotkey.keys[i]=0 then break;<N>    lua_pushinteger(L, i+1);<N>    lua_pushinteger(L, memoryrecordhotkey.keys[i]);<N>    lua_settable(L, t);<N>  end;<N>end;<N><N>function memoryrecordhotkey_setKeys(L: PLua_State): integer; cdecl;<N>var<N>  memoryrecordhotkey: TMemoryRecordHotkey;<N>  i: integer;<N>begin<N>  result:=0;<N>  memoryrecordhotkey:=luaclass_getClassObject(L);<N><N>
  if lua_istable(L,1) then<N>  begin<N>    i:=0;<N>    for i:=0 to 4 do<N>    begin<N>      lua_pushinteger(L, i+1);<N>      lua_gettable(L, 1);<N>      memoryrecordhotkey.keys[i]:=lua_tointeger(L, -1);<N>      if memoryrecordhotkey.keys[i]=0 then exit;<N>    end;<N><N>
  end;<N>end;<N><N>function memoryrecordhotkey_getID(L: PLua_State): integer; cdecl;<N>var<N>  memoryrecordhotkey: TMemoryRecordHotkey;<N>begin<N>  memoryrecordhotkey:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, memoryrecordhotkey.id);<N>  result:=1;<N>end;<N><N>
function memoryrecordhotkey_setOnHotkey(L: PLua_State): integer; cdecl;<N>var<N>  c: Tmemoryrecordhotkey;<N>  m: tmethod;<N>begin<N>  if lua_gettop(L)>=1 then<N>  begin<N>    c:=luaclass_getClassObject(L);<N>    m:=tmethod(c.OnHotkey);<N>    LuaCaller_setMethodProperty(L, m, 'TNotifyEvent', lua_gettop(L));<N>    c.OnHotkey:=tnotifyevent(m);<N>  end;<N>  result:=0;<N>end;<N><N>
function memoryrecordhotkey_setOnPostHotkey(L: PLua_State): integer; cdecl;<N>var<N>  c: Tmemoryrecordhotkey;<N>  m: tmethod;<N>begin<N>  if lua_gettop(L)>=1 then<N>  begin<N>    c:=luaclass_getClassObject(L);<N>    m:=tmethod(c.OnPostHotkey);<N>    LuaCaller_setMethodProperty(L, m, 'TNotifyEvent', lua_gettop(L));<N>    c.OnPostHotkey:=tnotifyevent(m);<N>  end;<N>  result:=0;<N>end;<N><N>
function memoryrecordhotkey_getOwner(L: PLua_State): integer; cdecl;<N>var<N>  memoryrecordhotkey: TMemoryRecordHotkey;<N>begin<N>  memoryrecordhotkey:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, memoryrecordhotkey.owner);<N>  result:=1;<N>end;<N><N>
//Copyright Cheat Engine<N><N>unit dotnethost;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type EDotNetException=class(Exception);<N><N>function DotNetExecuteClassMethod(assemblypath: string; namespace: string; classname: string; methodname: string; parameters: string): integer; //MUST be a "public static int methodname(string str)"  but it's enough to get the initialization done anyhow<N><N>
unit frmRescanPointerUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  StdCtrls, ExtCtrls, LResources, EditBtn, contnrs, cefuncproc, symbolhandler,<N>  multilineinputqueryunit, lua, lualib, lauxlib, registry, resolve, betterControls;<N><N>
unit LuaFont;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Graphics,lua, lualib, lauxlib, LuaHandler;<N><N>procedure initializeLuaFont;<N><N>implementation<N><N>uses mainunit, LuaClass, LuaObject;<N><N>function createFont(L: Plua_State): integer; cdecl;<N>var f: TFont;<N>begin<N>  result:=0;<N>  lua_pop(L, lua_gettop(L));<N>  f:=TFont.Create;<N>  f.assign(mainform.font); //initialize it with the best font there is...<N>  luaclass_newClass(L, f);<N>  result:=1;<N>end;<N><N>
function Font_getColor(L: PLua_State): integer; cdecl;<N>var<N>  Font: TFont;<N>begin<N>  Font:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, Font.Color);<N>  result:=1;<N>end;<N><N>function Font_setColor(L: PLua_State): integer; cdecl;<N>var<N>  Font: TFont;<N>begin<N>  Font:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    Font.color:=lua_tointeger(L, -1);<N>  result:=0;<N>end;<N><N>
function Font_getSize(L: PLua_State): integer; cdecl;<N>var<N>  Font: TFont;<N>begin<N>  Font:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, Font.Size);<N>  result:=1;<N>end;<N><N>function Font_setSize(L: PLua_State): integer; cdecl;<N>var<N>  Font: TFont;<N>begin<N>  Font:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    Font.Size:=lua_tointeger(L, -1);<N>  result:=0;<N>end;<N><N>
function Font_getName(L: PLua_State): integer; cdecl;<N>var<N>  Font: TFont;<N>begin<N>  Font:=luaclass_getClassObject(L);<N>  lua_pushstring(L, Font.Name);<N>  result:=1;<N>end;<N><N>function Font_setName(L: PLua_State): integer; cdecl;<N>var<N>  Font: TFont;<N>begin<N>  Font:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    Font.Name:=Lua_ToString(L, -1);<N>  result:=0;<N>end;<N><N>
unit frmTracerConfigUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, LResources, Forms, Controls, Graphics, Dialogs,<N>  StdCtrls, ExtCtrls, debuggertypedefinitions, betterControls;<N><N>type<N><N>  { TfrmTracerConfig }<N><N>
unit pointeraddresslist;<N><N>{$mode delphi}<N><N>{<N>the pointeraddresslist will hold a map of all addresses that contain an pointer<N>and the value they hold.<N>It's similar to the reversepointerlist, with the exception that I expect this to<N>eat a TON more RAM since there are more addresses with a pointer then there are<N>unique pointer values (multiple addresses point to the same address)<N><N>
Also, this first implementation will make use of the default available maps object<N>}<N><N>interface<N><N>uses<N>  Classes, SysUtils, maps, ComCtrls, bigmemallochandler, CEFuncProc;<N><N>resourcestring<N>  rsPALInvalidScandataFile = 'Invalid scandata file';<N>  rsPALInvalidScandataVersion = 'Invalid scandata version';<N><N>
unit disassemblerviewunit;<N><N>{$MODE Delphi}<N><N>{<N>Disassemblerview is a component that displays the memory using the disassembler routines<N><N>requirements:<N>display disassembled lines split up into sections, resizable with a section bar<N>selecting one or more lines<N>keyboard navigation<N>show function names before each function<N><N>
extra classes:<N>Lines<N><N>Lines contain he disassembled address and the description of that line<N><N>}<N><N>interface<N><N>uses {$ifdef darwin}macport,messages,lcltype,{$endif}<N>     {$ifdef windows}jwawindows, windows,commctrl,{$endif}<N>     sysutils, LCLIntf, forms, classes, controls, comctrls, stdctrls, extctrls, symbolhandler,<N>     cefuncproc, NewKernelHandler, graphics, disassemblerviewlinesunit, disassembler,<N>     math, lmessages, menus, DissectCodeThread, tcclib<N><N>
     {$ifdef USELAZFREETYPE}<N>     ,cefreetype,FPCanvas, EasyLazFreeType, LazFreeTypeFontCollection, LazFreeTypeIntfDrawer,<N>     LazFreeTypeFPImageDrawer, IntfGraphics, fpimage, graphtype<N>     {$endif}<N>     , betterControls, Contnrs;<N><N><N><N>type TShowjumplineState=(jlsAll, jlsOnlyWithinRange);     <N><N>
type TDisassemblerSelectionChangeEvent=procedure (sender: TObject; address, address2: ptruint) of object;<N>type TDisassemblerExtraLineRender=function(sender: TObject; Address: ptruint; AboveInstruction: boolean; selected: boolean; var x: integer; var y: integer): TRasterImage of object;<N>type TDisassemblerViewOverrideCallback=procedure(address: ptruint; var addressstring: string; var bytestring: string; var opcodestring: string; var parameterstring: string; var specialstring: string) of object;<N><N>
<N>type TDisassemblerview=class(TPanel)<N>  private<N>    statusinfo: TPanel;<N>    statusinfolabel: TLabel;<N>    header: THeaderControl;<N>    previousCommentsTabWidth: integer;<N><N>    scrollbox: TScrollbox; //for the header<N>    verticalscrollbar: TScrollbar;<N>    disassembleDescription: TPanel;<N><N>
    disCanvas: TPaintbox;<N>    isUpdating: boolean;<N><N>    fTotalvisibledisassemblerlines: integer;<N>    disassemblerlines: tlist;<N><N>    offscreenbitmap: TBitmap;<N><N>    lastselected1, lastselected2: ptruint; //reminder for the update on what the previous address was<N><N>
    fSelectedAddress: ptrUint; //normal selected address<N>    fSelectedAddress2: ptrUint; //secondary selected address (when using shift selecting)<N>    fTopAddress: ptrUint; //address to start disassembling from<N><N>    fTopSubline: integer; //in case of multiline lines<N><N>
    fShowJumplines: boolean; //defines if it should draw jumplines or not<N>    fShowjumplineState: TShowjumplineState;<N><N>    fCenterOnAddressChangeOutsideView: boolean;<N><N><N>   // fdissectCode: TDissectCodeThread;<N><N>    lastupdate: dword;<N>    destroyed: boolean;<N><N>
    fOnSelectionChange: TDisassemblerSelectionChangeEvent;<N>    fOnExtraLineRender: TDisassemblerExtraLineRender;<N><N>    fspaceAboveLines: integer;<N>    fspaceBelowLines: integer;<N>    fjlThickness: integer;<N>    fjlSpacing: integer;<N><N>    fhidefocusrect: boolean;<N><N>
    scrolltimer: ttimer;<N><N>    fOnDisassemblerViewOverride: TDisassemblerViewOverrideCallback;<N><N><N>    fCR3: qword;<N>    fCurrentDisassembler: TDisassembler;<N><N>    fUseRelativeBase: boolean;<N>    fRelativeBase: ptruint;<N><N><N><N>    procedure updateScrollbox;<N>    procedure scrollboxResize(Sender: TObject);<N><N>
    //-scrollbar-<N>    procedure scrollUp(sender: TObject);<N>    procedure scrollDown(sender: TObject);<N>    procedure updateScroller(speed: integer);<N>    procedure scrollbarChange(Sender: TObject);<N>    procedure scrollbarKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);<N>    procedure scrollBarScroll(Sender: TObject; ScrollCode: TScrollCode; var ScrollPos: Integer);<N><N>
unit LuaGroupbox;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib, stdctrls, controls, betterControls;<N><N>  procedure initializeLuaGroupbox;<N>  procedure groupbox_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N><N>
implementation<N><N>uses luaclass, luahandler, pluginexports, LuaWinControl;<N><N>function createGroupBox(L: Plua_State): integer; cdecl;<N>var parameters: integer;<N>  f: TWinControl;<N>  p: TGroupBox;<N>begin<N>  result:=0;<N>  if lua_gettop(L)>=1 then<N>  begin<N>    f:=lua_toceuserdata(L, 1);<N>    p:=tgroupbox.Create(f);<N>    p.parent:=f;<N><N>
    lua_pop(L, lua_gettop(L));<N><N>    luaclass_newClass(L, p);<N>    result:=1;<N>  end;<N>end;<N><N>procedure groupbox_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>begin<N>  wincontrol_addMetaData(L, metatable, userdata);<N>end;<N><N>
unit LuaPipeServer;<N><N>//pipe server class specifically made for lua. Only 1 client and 1 server connection at a time<N><N>{$mode delphi}<N><N>interface<N><N>{$ifdef windows}<N>uses<N>  jwawindows, windows, Classes, SysUtils, lua, luaclass, luapipe;<N><N>
<N>procedure initializeLuaPipeServer;<N>{$endif}<N><N>implementation<N><N>{$ifdef windows}<N>uses LuaHandler;<N><N>type<N>  TLuaPipeServer=class(TPipeConnection)<N>  private<N>    function isValidPipe: boolean;<N>  public<N>    function WaitForClientConnection: boolean;<N>    constructor create(pipename: string; inputsize, outputsize: integer);<N>  published<N>    property valid: boolean read isValidPipe;<N>  end;<N><N>
function TLuaPipeServer.isValidPipe;<N>begin<N>  result:=pipe<>INVALID_HANDLE_VALUE;<N>end;<N><N>function TLuaPipeServer.WaitForClientConnection;<N>begin<N>  fconnected:=ConnectNamedPipe(pipe, nil);<N><N>  if not fconnected then<N>    fconnected:=getlasterror()=ERROR_PIPE_CONNECTED;<N><N>
  result:=fConnected;<N>end;<N><N>constructor TLuaPipeServer.create(pipename: string; inputsize, outputsize: integer);<N>var<N>  a: SECURITY_ATTRIBUTES;<N>begin<N>  inherited create;<N><N>  a.nLength:=sizeof(a);<N>  a.bInheritHandle:=TRUE;<N>  ConvertStringSecurityDescriptorToSecurityDescriptor('D:(D;;FA;;;NU)(A;;0x12019f;;;WD)(A;;0x12019f;;;CO)', SDDL_REVISION_1, a.lpSecurityDescriptor, nil);<N><N>
  //AllocateAndInitializeSid();<N>  {<N>  LPCWSTR LOW_INTEGRITY_SDDL_SACL_W = L"S:(ML;;NW;;;LW)"<N>  ;<N>  PSECURITY_DESCRIPTOR securitydescriptor;<N>  ConvertStringSecurityDescriptorToSecurityDescriptorW(LOW_INTEGRITY_SDDL_SACL_W,SDDL_REVISION_1,&securitydescriptor,NULL);<N>  sa.nLength = sizeof<N>  (SECURITY_ATTRIBUTES);<N>  sa.lpSecurityDescriptor = securitydescriptor;<N>  sa.bInheritHandle = TRUE;<N>  }<N><N>
unit inputboxtopunit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, LResources, ExtCtrls{$ifdef darwin},macport{$endif}, betterControls;<N><N>type<N><N>  { TInputboxTop }<N><N>
  TInputboxTop = class(TForm)<N>    Button1: TButton;<N>    Button2: TButton;<N>    Edit1: TEdit;<N>    Label1: TLabel;<N>    Panel1: TPanel;<N>    Timer1: TTimer;<N>    procedure FormShow(Sender: TObject);<N>    procedure Label1Click(Sender: TObject);<N>    procedure Timer1Timer(Sender: TObject);<N>  private<N>    { Private declarations }<N>    selecttext: boolean;<N>    combobox: tcombobox;<N>  public<N>    { Public declarations }<N>  end;<N><N>
function InputBoxTop(const ACaption, APrompt, ADefault: string): string; overload;<N>function InputBoxTop(const ACaption, APrompt, ADefault: string; Aselecttext: boolean): string; overload;<N>function InputBoxTop(const ACaption, APrompt, ADefault: string; Aselecttext: boolean; var canceled: boolean): string; overload;<N>function InputBoxTop(const ACaption, APrompt, ADefault: string; Aselecttext: boolean; var canceled: boolean; history: tstrings): string; overload;<N><N>
implementation<N><N><N>{$ifndef tester}<N>uses MemoryBrowserFormUnit;<N>{$else}<N>uses unit1;<N>{$endif}<N><N><N>  <N>function InputBoxTop(const ACaption, APrompt, ADefault: string): string;<N>var canceled: boolean;<N>begin<N>  result:=InputBoxTop(ACaption,APrompt,Adefault,false,canceled);<N>end;<N><N>
unit LuaRasterImage;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Graphics, lua, lualib, lauxlib;<N><N>procedure initializeLuaRasterImage;<N><N>implementation<N><N>uses LuaHandler, luaclass, LuaGraphic;<N><N>function rasterImage_getCanvas(L: PLua_State): integer; cdecl;<N>var<N>  c: TrasterImage;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, c.Canvas);<N>  result:=1;<N>end;<N><N>
function rasterimage_getPixelFormat(L: PLua_State): integer; cdecl;<N>var<N>  c: TrasterImage;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, integer(c.PixelFormat));<N>  result:=1;<N>end;<N><N><N>function rasterimage_setPixelFormat(L: PLua_State): integer; cdecl;<N>var<N>  c: TrasterImage;<N>  a: integer;<N>begin<N>  result:=0;<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    c.PixelFormat:=TPixelFormat(lua_tointeger(L,-1));<N>end;<N><N>
function rasterimage_getTransparent(L: PLua_State): integer; cdecl; //obsolete<N>var<N>  rasterimage: Trasterimage;<N>begin<N>  rasterimage:=luaclass_getClassObject(L);<N>  lua_pushboolean(L, rasterimage.Transparent);<N>  result:=1;<N>end;<N><N>function rasterimage_setTransparent(L: PLua_State): integer; cdecl;<N>var<N>  rasterimage: Trasterimage;<N>begin<N>  result:=0;<N>  rasterimage:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=1 then<N>    rasterimage.Transparent:=lua_toboolean(L, -1);<N>end;<N><N>
<N>function rasterimage_gettransparentColor(L: PLua_State): integer; cdecl;<N>var<N>  c: TrasterImage;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, c.transparentColor);<N>  result:=1;<N>end;<N><N><N>function rasterimage_settransparentColor(L: PLua_State): integer; cdecl;<N>var<N>  c: TrasterImage;<N>  a: integer;<N>begin<N>  result:=0;<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    c.transparentColor:=lua_tointeger(L,-1);<N>end;<N><N>
function rasterimage_loadFromStream(L: PLua_State): integer; cdecl;<N>var<N>  c: TrasterImage;<N>begin<N>  result:=0;<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    c.LoadFromStream(lua_ToCEUserData(L,1));<N>end;<N><N>function rasterimage_saveToStream(L: PLua_State): integer; cdecl;<N>var<N>  c: TrasterImage;<N>begin<N>  result:=0;<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    c.SaveToStream(lua_ToCEUserData(L,1));<N>end;<N><N>
unit LuaMemo;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Lua, Lualib, lauxlib, StdCtrls, controls, betterControls;<N><N>procedure initializeLuaMemo;<N><N>implementation<N><N>uses luaclass, luahandler, LuaWinControl, LuaEdit;<N><N>function createMemo(L: Plua_State): integer; cdecl;<N>var<N>  m: tmemo;<N>  o: twincontrol;<N>begin<N>  result:=0;<N>  if lua_gettop(L)=1 then<N>  begin<N>    o:=lua_toceuserdata(L, -1);<N>    m:=tmemo.create(o);<N>    m.parent:=o;<N><N>
    luaclass_newClass(L, m);<N>    result:=1;<N>  end;<N>end;<N><N>function memo_append(L: PLua_State): integer; cdecl;<N>var<N>  memo: TCustomMemo;<N>begin<N>  memo:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=1 then<N>    memo.Append(Lua_ToString(L,-1));<N><N>
  result:=0;<N>end;<N><N>function memo_getLines(L: PLua_State): integer; cdecl;<N>var<N>  memo: TCustomMemo;<N>begin<N>  memo:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, memo.Lines);<N>  result:=1;<N>end;<N><N>function memo_setLines(L: PLua_State): integer; cdecl;<N>var<N>  memo: TCustomMemo;<N>begin<N>  memo:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=1 then<N>    memo.lines:=tstrings(lua_ToCEUserData(L, 1));<N><N>
  result:=0;<N>end;<N><N>function memo_getWordWrap(L: PLua_State): integer; cdecl;<N>var<N>  memo: TCustomMemo;<N>begin<N>  memo:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, memo.WordWrap);<N>  result:=1;<N>end;<N><N>function memo_setWordWrap(L: PLua_State): integer; cdecl;<N>var<N>  memo: TCustomMemo;<N>begin<N>  memo:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    memo.WordWrap:=lua_tovariant(L, -1);<N>  result:=0;<N>end;<N><N>
function memo_getWantTabs(L: PLua_State): integer; cdecl;<N>var<N>  memo: TCustomMemo;<N>begin<N>  memo:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, memo.WantTabs);<N>  result:=1;<N>end;<N><N>function memo_setWantTabs(L: PLua_State): integer; cdecl;<N>var<N>  memo: TCustomMemo;<N>begin<N>  memo:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    memo.WantTabs:=lua_tovariant(L, -1);<N>  result:=0;<N>end;<N><N>
function memo_getWantReturns(L: PLua_State): integer; cdecl;<N>var<N>  memo: TCustomMemo;<N>begin<N>  memo:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, memo.WantReturns);<N>  result:=1;<N>end;<N><N>function memo_setWantReturns(L: PLua_State): integer; cdecl;<N>var<N>  memo: TCustomMemo;<N>begin<N>  memo:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    memo.WantReturns:=lua_tovariant(L, -1);<N>  result:=0;<N>end;<N><N>
function memo_getScrollBars(L: PLua_State): integer; cdecl;<N>var<N>  memo: TCustomMemo;<N>begin<N>  memo:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, integer(memo.ScrollBars));<N>  result:=1;<N>end;<N><N>function memo_setScrollBars(L: PLua_State): integer; cdecl;<N>var<N>  memo: TCustomMemo;<N>begin<N>  memo:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    memo.ScrollBars:=TScrollStyle(lua_tointeger(L, -1));<N>  result:=0;<N>end;<N><N>
unit frmReferencedFunctionsUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  LCLProc, Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, ComCtrls,<N>  StdCtrls, ExtCtrls, Menus, symbolhandler, Clipbrd, betterControls;<N><N>type<N><N>  { TfrmReferencedFunctions }<N><N>
unit LuaClassArray;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib;<N><N>function luaclassarray_createMetaTable(L: Plua_State; userdata: integer; getArrayFunction: lua_CFunction; setArrayFunction:lua_CFunction=nil ): integer;<N><N>
implementation<N><N>function luaclassarray_newindex(L: PLua_State): integer; cdecl; //set<N>//parameters: (self, key, value)<N>var<N>  s: string;<N>  cf: lua_CFunction;<N>begin<N>  s:=lua_tostring(L, 2);<N>  if s='__set' then<N>  begin<N>    lua_pushvalue(L, 1);<N>    exit(1);<N>  end;<N><N>
  cf:=lua_tocfunction(L, lua_upvalueindex(2));<N>  lua_pushvalue(L, lua_upvalueindex(1)); //push the object<N>  lua_pushcclosure(L, cf, 1); //create a cclosure function on the stack<N>  lua_pushvalue(L, 2); //push the key<N>  lua_pushvalue(L, 3); //push the value<N>  lua_call(L,2,0); //call setArrayFunction(key, value) : object<N>  result:=1;<N><N>
end;<N><N>function luaclassarray_index(L: PLua_State): integer; cdecl; //get<N>//parameters: (self, key)<N>//called when an array object in a class is being indexed<N>var s: string;<N><N>  cf: lua_CFunction;<N>begin<N>  s:=lua_tostring(L, 2);<N>  if s='__get' then<N>  begin<N>    //just return the table itself<N>    lua_pushvalue(L, 1);<N>    exit(1);<N>  end;<N><N>
<N>  //not __get, so get the value at key<N>  cf:=lua_tocfunction(L, lua_upvalueindex(2));<N>  lua_pushvalue(L, lua_upvalueindex(1)); //push the object<N>  lua_pushcclosure(L, cf, 1); //create a cclosure function on the stack<N>  lua_pushvalue(L, 2); //push the key<N>  lua_call(L,1,1); //call getArrayFunction(key) : object<N>  result:=1;<N>end;<N><N>
function luaclassarray_createMetaTable(L: Plua_State; userdata: integer; getArrayFunction: lua_CFunction; setArrayFunction:lua_CFunction=nil ): integer;<N>begin<N>  lua_newtable(L);<N>  result:=lua_gettop(L);<N><N>  //set the index method<N>  lua_pushstring(L, '__index');<N>  lua_pushvalue(L, userdata);<N>  lua_pushcfunction(L, getArrayFunction);<N>  lua_pushcclosure(L, luaclassarray_index, 2);<N>  lua_settable(L, result);<N><N>
  if assigned(setArrayFunction) then<N>  begin<N>    lua_pushstring(L, '__newindex');<N>    lua_pushvalue(L, userdata);<N>    lua_pushcfunction(L, setArrayFunction);<N>    lua_pushcclosure(L, luaclassarray_newindex, 2);<N>    lua_settable(L, result);<N>  end;<N>end;<N><N>
unit formProcessInfo;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, CEFuncProc, NewKernelHandler, LResources, ExtCtrls,<N>  memorybrowserformunit, betterControls;<N><N>
unit ManualModuleLoader;<N><N>{$MODE Delphi}<N><N>{<N>This routine will examine a module and then load it into memory, taking care of the sections and IAT addresses<N>}<N><N>interface<N><N>{$ifdef windows}<N><N>uses windows, LCLIntf, classes, sysutils, imagehlp, dialogs, PEInfoFunctions,CEFuncProc,<N>     NewKernelHandler, symbolhandler, dbk32functions, vmxfunctions, commonTypeDefs,<N>     SymbolListHandler, symbolhandlerstructs, StringHashList;<N><N>
resourcestring<N>  rsMMLNotAValidFile = 'not a valid file';<N>  rsMMLNotAValidHeader = 'Not a valid header';<N>  rsMMLTriedLoadingA64BitModuleOnA32BitSystem = 'Tried loading a 64-bit module on a 32-bit system';<N>  rsMMLAllocationError = 'Allocation error';<N>  rsMMLFailedFindingAddressOf = 'failed finding address of ';<N><N>
type TModuleLoader=class<N>  private<N>    filename: string;<N>    FLoaded: boolean;<N>    FEntrypoint: ptruint;<N>    fSymbolList: TSymbolListHandler;<N><N>    destinationBase: ptruint;<N>    modulesize: integer;<N>    is64bit: boolean;<N>    isdriver: boolean;<N><N>
unit LuaCombobox;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, lua, lualib, lauxlib, controls, StdCtrls, ExtCtrls, LuaWinControl, betterControls;<N><N>procedure initializeLuaCombobox;<N><N>
implementation<N><N>uses luahandler, luaclass;<N>//combobox<N>function createComboBox(L: Plua_State): integer; cdecl;<N>var<N>  ComboBox: TComboBox;<N>  parameters: integer;<N>  owner: TWincontrol;<N>begin<N>  result:=0;<N><N>  parameters:=lua_gettop(L);<N>  if parameters>=1 then<N>    owner:=lua_toceuserdata(L, -parameters)<N>  else<N>    owner:=nil;<N><N>
  lua_pop(L, lua_gettop(L));<N><N><N>  ComboBox:=TComboBox.Create(owner);<N>  if owner<>nil then<N>    ComboBox.Parent:=owner;<N><N>  luaclass_newClass(L, ComboBox);<N>  result:=1;<N>end;<N><N>function combobox_clear(L: Plua_State): integer; cdecl;<N>var<N>  combobox: tcustomcombobox;<N>begin<N>  combobox:=luaclass_getClassObject(L);<N>  combobox.clear;<N>  result:=0;<N>end;<N><N>
<N>function combobox_getItems(L: PLua_State): integer; cdecl;<N>var<N>  combobox: TCustomcombobox;<N>begin<N>  combobox:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, combobox.items);<N>  result:=1;<N>end;<N><N>function combobox_setItems(L: PLua_State): integer; cdecl;<N>var<N>  combobox: TCustomcombobox;<N>begin<N>  result:=0;<N>  combobox:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=1 then<N>    combobox.Items:=tstrings(lua_ToCEUserData(L, 1));<N>end;<N><N>
unit LuaOldD3DHook;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, graphics, lua, lualib, lauxlib;<N><N>procedure initializeLuaOldD3DHook;<N><N>implementation<N><N>{$ifdef windows}<N><N>uses d3dhookUnit, LuaCaller, LuaHandler, LuaClass;<N><N>
function d3dhook_getWidth(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  d: TD3DHook;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters=1 then<N>  begin<N>    d:=lua_toceuserdata(L,-parameters);<N>    lua_pop(L, parameters);<N><N>
    d:=safed3dhook;<N>    if d<>nil then<N>    begin<N>      lua_pushinteger(L, d.getWidth);<N>      result:=1;<N>    end;<N><N>  end else lua_pop(L, parameters);<N>end;<N><N>function d3dhook_getHeight(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  d: TD3DHook;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters=1 then<N>  begin<N>    d:=lua_toceuserdata(L,-parameters);<N>    lua_pop(L, parameters);<N><N>
    d:=safed3dhook;<N>    if d<>nil then<N>    begin<N>      lua_pushinteger(L, d.getHeight);<N>      result:=1;<N>    end;<N><N>  end else lua_pop(L, parameters);<N>end;<N><N>function d3dhook_initializeHook(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  size: integer;<N>  hookwindow: boolean;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters>=1 then<N>    size:=lua_tointeger(L, -parameters)<N>  else<N>    size:=16*1024*1024;<N><N>
  if parameters>=2 then<N>    hookwindow:=lua_toboolean(L, -parameters+1)<N>  else<N>    hookwindow:=true;<N><N><N>  lua_pop(L, parameters);<N><N>  lua_pushboolean(L, safed3dhook(size, hookwindow)<>nil);<N>  result:=1;<N>end;<N><N>function d3dhook_onKey(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  f: integer;<N>  routine: string;<N><N>
  lc: TLuaCaller;<N>  m: TD3DKeyDownEvent;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters=1 then<N>  begin<N>    if D3DHook<>nil then<N>    begin<N><N>      CleanupLuaCall(TMethod(d3dhook.onKeyDown));<N>      d3dhook.onKeyDown:=nil;<N><N>
      if lua_isfunction(L,1) then<N>      begin<N>        f:=luaL_ref(L,LUA_REGISTRYINDEX);<N><N>        lc:=TLuaCaller.create;<N>        lc.luaroutineIndex:=f;<N>        d3dhook.onKeyDown:=lc.D3DKeyDownEvent;<N>      end<N>      else<N>      if lua_isstring(L,1) then<N>      begin<N>        routine:=lua_tostring(L,1);<N>        lc:=TLuaCaller.create;<N>        lc.luaroutine:=routine;<N>        d3dhook.onKeyDown:=lc.D3DKeyDownEvent;<N>      end;<N><N>
    end;<N>  end;<N><N>  lua_pop(L, lua_gettop(L));<N>end;<N><N>function d3dhook_onClick(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  f: integer;<N>  routine: string;<N><N>  lc: TLuaCaller;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters=1 then<N>  begin<N>    if D3DHook<>nil then<N>    begin<N>      CleanupLuaCall(TMethod(d3dhook.onClick));<N>      d3dhook.onClick:=nil;<N><N>
      if lua_isfunction(L,1) then<N>      begin<N>        f:=luaL_ref(L,LUA_REGISTRYINDEX);<N><N>        lc:=TLuaCaller.create;<N>        lc.luaroutineIndex:=f;<N>        d3dhook.OnClick:=lc.D3DClickEvent;<N>      end<N>      else<N>      if lua_isstring(L,1) then<N>      begin<N>        routine:=lua_tostring(L,1);<N>        lc:=TLuaCaller.create;<N>        lc.luaroutine:=routine;<N>        d3dhook.OnClick:=lc.D3DClickEvent;<N>      end;<N><N>
    end;<N>  end;<N><N>  lua_pop(L, lua_gettop(L));<N>end;<N><N><N>function d3dhook_beginUpdate(L: PLua_State): integer; cdecl;<N>var<N>  d: TD3DHook;<N>begin<N>  result:=0;<N>  lua_pop(L, lua_gettop(L));<N>  d:=safed3dhook;<N>  if d<>nil then<N>  begin<N>    d.beginCommandListUpdate;<N>    d.beginTextureupdate;<N>  end;<N>end;<N><N>
function d3dhook_endUpdate(L: PLua_State): integer; cdecl;<N>var<N>  d: TD3DHook;<N>begin<N>  result:=0;<N>  lua_pop(L, lua_gettop(L));<N>  d:=safed3dhook;<N>  if d<>nil then<N>  begin<N>    d.endTextureupdate;<N>    d.endCommandListUpdate;<N>  end;<N>end;<N><N>
<N>function d3dhook_setDisabledZBuffer(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  d: TD3DHook;<N>  state: boolean;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters=1 then<N>  begin<N>    state:=lua_toboolean(L, -parameters);<N><N>
    lua_pop(L, parameters);<N><N>    d:=safed3dhook;<N>    if d<>nil then<N>      d.setDisabledZBuffer(state);<N><N>  end else lua_pop(L, parameters);<N>end;<N><N>function d3dhook_setWireframeMode(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  d: TD3DHook;<N>  state: boolean;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters=1 then<N>  begin<N>    state:=lua_toboolean(L, -parameters);<N><N>
    lua_pop(L, parameters);<N><N>    d:=safed3dhook;<N>    if d<>nil then<N>      d.setWireframeMode(state);<N><N>  end else lua_pop(L, parameters);<N>end;<N><N><N>function d3dhook_setMouseClip(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  d: TD3DHook;<N>  state: boolean;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters=1 then<N>  begin<N>    state:=lua_toboolean(L, -parameters);<N><N>
    lua_pop(L, parameters);<N><N>    d:=safed3dhook;<N>    if d<>nil then<N>      d.setMouseClip(state);<N><N>  end else lua_pop(L, parameters);<N>end;<N><N>function d3dhook_enableConsole(L: PLua_State): integer; cdecl;<N>var<N>  d: TD3DHook;<N>  parameters: integer;<N>  key: dword;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters=1 then<N>  begin<N>    key:=lua_tointeger(L, 1);<N><N>
    lua_pop(L, parameters);<N><N>    d:=safed3dhook;<N>    if d<>nil then<N>      d.enableConsole(key);<N><N>  end else lua_pop(L, parameters);<N>end;<N><N>function d3dhook_createTexture(L: PLua_State): integer; cdecl;<N>var parameters: integer;<N>  o: TObject;<N>  s: string;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N><N>
unit LuaListview;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, controls, comctrls, lua, lualib, lauxlib, betterControls;<N><N>procedure initializeLuaListview;<N><N>implementation<N><N>uses luaclass, luahandler, LuaWinControl, ceguicomponents;<N><N>
function createListView(L: Plua_State): integer; cdecl;<N>var<N>  ListView: TCEListView;<N>  owner: TWincontrol;<N>begin<N>  if lua_gettop(L)=1 then<N>    owner:=lua_toceuserdata(L, 1)<N>  else<N>    owner:=nil;<N><N>  ListView:=TCEListView.Create(owner);<N>  if owner<>nil then<N>    ListView.Parent:=owner;<N>  ListView.ViewStyle:=vsReport;<N><N>
<N>  luaclass_newClass(L, ListView);<N>  result:=1;<N>end;<N><N>function listview_clear(L: Plua_State): integer; cdecl;<N>var<N>  listview: TcustomListView;<N>begin<N>  result:=0;<N>  listview:=luaclass_getClassObject(L);<N>  listview.clear;<N>end;<N><N>function listview_beginupdate(L: Plua_State): integer; cdecl;<N>var<N>  listview: TcustomListView;<N>begin<N>  result:=0;<N>  listview:=luaclass_getClassObject(L);<N>  listview.BeginUpdate;<N>end;<N><N>
unit ceregistry;<N><N>{<N>Wrapper to replace the creating and destroying of default level registry objects with a uniform method<N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macPort,<N>  {$endif}<N>  Classes, SysUtils, registry;<N><N>
unit debugeventhandler;<N><N>//handles the debug events<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N><N>  {$ifdef windows}<N>  jwawindows, Windows, win32proc,<N>  {$endif}<N>  Classes, SysUtils, syncobjs, GuiSafeCriticalSection,<N>  disassembler, CEFuncProc, newkernelhandler,debuggertypedefinitions, frmTracerUnit,<N>  DebuggerInterfaceAPIWrapper, lua, lauxlib, lualib,<N>  tracerIgnore, BreakpointTypeDef, LCLProc, contexthandler {$ifdef darwin}<N>  ,macport, macportdefines<N>  {$endif}  ;<N><N>
type<N>  TContextFields=(cfAll,cfDebug, cfRegisters, cfFloat);<N><N>  TDebugThreadHandler=class;<N>  THandleBreakEvent=function(sender: TDebugThreadHandler; bp: PBreakpoint): boolean of object;<N><N>  TDebugEventHandler = class;<N><N>  TDebugThreadHandler = class<N>  private<N>    debuggerthread: TObject;<N>    debuggerCS: TGuiSafeCriticalSection;<N><N>
    onAttachEvent: TEvent;<N>    onContinueEvent: TEvent;<N>    realcontextpointer: pointer;<N>    threadlist: TList;<N>    breakpointList: TList;<N>    continueOption: TContinueOption;<N>    continueHandled: boolean;<N><N>    setInt3Back: boolean;<N>    Int3setbackAddress: ptrUint;<N>    Int3SetBackBP: PBreakpoint;<N><N>
<N>    expectedUndefinedBreakpoint: ptruint; //ARM: When a breakpoint happens with this address handle it instead of ignoring it<N>    setInt1Back: boolean;<N>    Int1SetBackBP: PBreakpoint;<N><N>    singlestepping: boolean;<N><N>    isBranchMapping: boolean;<N>    branchMappingDisabled: qword;<N><N>
unit DriverList;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef windows}<N>  jwaWindows, windows, imagehlp,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, Dialogs, StdCtrls, Menus, CEFuncProc,<N>  NewKernelHandler, LREsources, ComCtrls, registry, betterControls;<N><N>
unit LuaCustomControl;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Controls, lua, lualib, lauxlib;<N><N>procedure customcontrol_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>procedure initializeLuaCustomControl;<N><N>
implementation<N><N>uses luahandler, luaclass, LuaWinControl, LuaCaller;<N><N><N>function customControl_getCanvas(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  c: TCustomControl;<N>  i: integer;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  if c.Canvas.handle=0 then<N>    i:=c.Canvas.Pixels[0,0];<N><N>
  luaclass_newClass(L, c.Canvas);<N>  result:=1;<N>end;<N><N>function customControl_getOnPaint(L: PLua_State): integer; cdecl;<N>var<N>  c: TCustomControl;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  LuaCaller_pushMethodProperty(L, TMethod(c.OnPaint), 'TNotifyEvent');<N>  result:=1;<N>end;<N><N>
function customControl_setOnPaint(L: PLua_State): integer; cdecl;<N>var<N>  c: TCustomControl;<N>  m: tmethod;<N>begin<N>  if lua_gettop(L)>=1 then<N>  begin<N>    c:=luaclass_getClassObject(L);<N>    m:=tmethod(c.OnPaint);<N>    LuaCaller_setMethodProperty(L, m, 'TNotifyEvent', lua_gettop(L));<N>    c.OnPaint:=tnotifyevent(m);<N>  end;<N>  result:=0;<N>end;<N><N>
<N>procedure customcontrol_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>begin<N>  wincontrol_addMetaData(L, metatable, userdata);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'getCanvas', customControl_getCanvas);<N>  luaclass_addPropertyToTable(L, metatable, userdata, 'Canvas', customControl_getCanvas, nil);<N>  luaclass_addPropertyToTable(L, metatable, userdata, 'OnPaint', customControl_getOnPaint, customControl_setOnPaint);<N>end;<N><N>
procedure initializeLuaCustomControl;<N>begin<N>  lua_register(LuaVM, 'customControl_getCanvas', customControl_getCanvas);<N>  lua_register(LuaVM, 'customcontrol_getCanvas', customControl_getCanvas);<N>end;<N><N><N>initialization<N>  luaclass_register(TCustomControl, customcontrol_addMetaData);<N><N>
unit VEHDebugger;<N><N>{$mode delphi}<N><N>interface<N><N>{$ifdef windows}<N>uses<N><N>  jwaNtStatus, Windows,<N>  Classes, SysUtils,symbolhandler, symbolhandlerstructs,<N>  VEHDebugSharedMem,cefuncproc, autoassembler,newkernelhandler,DebuggerInterface,<N>  Clipbrd,maps;<N><N>
type<N><N>  TVEHDebugInterface=class(TDebuggerInterface)<N>  private<N>    guid: TGUID; //to indentify this specific debugger<N>    guidstring: string;<N><N>    HasDebugEvent: THandle;<N>    HasHandledDebugEvent: THandle;<N><N>    ConfigFileMapping: THandle;<N>    VEHDebugView: PVEHDebugSharedMem;<N><N>
    active: boolean;<N>    is64bit: boolean; //stored local so it doesn't have to evaluate the property (saves some time)<N>    hasPausedProcess: boolean;<N><N>    fisInjectedEvent: boolean; //obsolete(ish)<N>    wasInjectedEvent: boolean;<N>    injectedEvents: TList;<N><N>
unit diagramlink;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, graphics, DiagramTypes, Diagramblock{$ifdef windows}, gl, glu, GLext{$endif}, betterControls;<N><N>
type<N><N>  TDiagramLink=class<N>  private<N>    config: TDiagramConfig;<N>    origin: TDiagramBlockSideDescriptor;<N>    destination: TDiagramBlockSideDescriptor;<N>    points: array of tpoint; //list of coordinates where to go first before going to the toblock<N><N>
    useCustomColor: boolean;<N>    fCustomColor: TColor;<N><N>    useCustomLineThickness: boolean;<N>    fCustomLineThickness: integer;<N><N>    useCustomArrowStyles: boolean;<N>    fCustomArrowStyles: TArrowStyles;<N><N>    useCustomArrowSize: boolean;<N>    fCustomArrowSize: integer;<N><N>
    fName: string;<N><N>    fmaxx: integer; //set after render<N>    fmaxy: integer;<N><N>    fOnDblClick: TNotifyEvent;<N>    fOnDestroy: TNotifyEvent;<N>    ftag: qword;<N><N><N><N>    function getYPosFromX(x: single; linestart: tpoint; lineend: tpoint): double;<N>    function getXPosFromY(y: single; linestart: tpoint; lineend: tpoint): double;<N><N>
    function getCenterPoint(linestart: tpoint; lineend: tpoint): tpoint;<N><N>    function ptInLine(pt: tpoint; linestart: tpoint; lineend: tpoint): boolean;<N>    function getLineColor: TColor;<N>    procedure setLineColor(c: TColor);<N>    function getLineThickness: integer;<N>    procedure setLineThickness(i: integer);<N>    function getArrowStyles: TArrowStyles;<N>    procedure setArrowStyles(s: TArrowStyles);<N><N>
    function getArrowSize: integer;<N>    procedure setArrowSize(i: integer);<N><N><N>    function getAngle(originpoint: TPoint; destinationpoint: TPoint): single;<N>    procedure DrawPlotPoint(point: TPoint);<N>    procedure DrawArrow(originpoint: TPoint; rot: single; centeradjust: tpoint);<N><N>
    procedure drawArrowInCenter;<N>    function zoompoint(p: tpoint): TPoint;<N>  public<N>    procedure render;<N><N>    procedure createPoint(p: tpoint; insertAt: integer=-1);<N>    function isOverLine(x,y: integer): boolean;<N>    function isAtAttachPoint(x,y: integer; out bsd: TDiagramBlockSideDescriptor): boolean;<N>    function getPointIndexAt(x,y: integer): integer;<N>    function getPoint(index: integer): TPoint;<N>    function getPointCount: integer;<N><N>
    function hasLinkToBlock(b: TDiagramBlock):boolean;<N>    procedure updatePointPosition(index: integer; newpos: TPoint);<N><N>    procedure updateSide(descriptor: TDiagramBlockSideDescriptor);<N><N>    procedure RemoveAllPlotPoints;<N>    procedure ResetToDefault;<N><N>
    function getOriginDescriptor: TDiagramBlockSideDescriptor;<N>    function getDestinationDescriptor: TDiagramBlockSideDescriptor;<N><N>    procedure setOriginDescriptor(d: TDiagramBlockSideDescriptor);<N>    procedure setDestinationDescriptor(d: TDiagramBlockSideDescriptor);<N><N>
unit LuaRIPRelativeScanner;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, RipRelativeScanner;<N><N>procedure initializeLuaRipRelativeScanner;<N><N>implementation<N><N>uses lua, LuaClass, LuaObject, LuaHandler, symbolhandler;<N><N>function CreateRipRelativeScanner(L:PLua_State): integer; cdecl;<N>var<N>  modulename: string;<N><N>
  startaddress, stopaddress: ptruint;<N>  includelongjumps: boolean;<N>begin<N>  result:=0;<N>  includelongjumps:=false;<N>  startaddress:=0;<N>  stopaddress:=0;<N><N>  if lua_gettop(L)=1 then<N>  begin<N>    modulename:=Lua_ToString(L, 1);<N>    luaclass_newClass(L, TRIPRelativeScanner.create(modulename, false));<N>    result:=1;<N>    exit;<N>  end;<N><N>
unit frmProcesswatcherExtraUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, LResources, betterControls;<N><N>type<N>  TfrmProcessWatcherExtra = class(TForm)<N>    data: TMemo;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  frmProcessWatcherExtra: TfrmProcessWatcherExtra;<N><N>implementation<N><N><N>initialization<N>  {$i frmProcesswatcherExtraUnit.lrs}<N><N>end.<N>
unit Changeoffsetunit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, Messages, SysUtils, classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ComCtrls, LResources, ExtCtrls,symbolhandler, math, betterControls;<N><N>type<N><N>  { TChangeOffset }<N><N>
unit frmEnumerateDLLsUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, lclproc,<N>  {$endif}<N>  {$ifdef windows}<N>  windows, imagehlp,<N>  {$endif}<N><N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs,CEFuncProc, StdCtrls, ComCtrls, ExtCtrls, ActnList,<N>  Menus, LResources,symbolhandler, symbolhandlerstructs, FindDialogFix,<N>  commonTypeDefs, strutils, ProcessHandlerUnit, Clipbrd, betterControls;<N><N>
type tenumthread=class(tthread)<N>  public<N>    symbolcount: integer;<N>    moduletext: string;<N>    symbolname: array [1..25] of string;<N>    x: TTreenode;<N>    procedure AddModule;<N>    procedure AddSymbol;<N>    procedure Done;<N>    procedure execute; override;<N>end;<N><N>
unit frmHeapsUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ExtCtrls, ComCtrls,{tlhelp32,}CEFuncProc, frmMemoryAllocHandlerUnit, LResources, betterControls;<N><N>
type TFillHeapList=class(tthread)<N>  private<N>    c: integer;<N>    list: array [0..63] of record<N>      address: dword;<N>      size: integer;<N>    end;<N>    expanded: boolean;<N>    procedure enumerateHeapList(const memreclist: PMemRecTableArray; level: integer);<N>    procedure updatelist;<N>  public<N>    node: ttreenode;<N>    procedure execute; override;<N>end;<N><N>
type<N>  TfrmHeaps = class(TForm)<N>    Panel1: TPanel;<N>    Button1: TButton;<N>    ListView1: TListView;<N>    procedure FormClose(Sender: TObject; var Action: TCloseAction);<N>    procedure FormCreate(Sender: TObject);<N>    procedure Button1Click(Sender: TObject);<N>    procedure ListView1DblClick(Sender: TObject);<N>  private<N>    { Private declarations }<N>    fillthread: TFillHeapList;<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit frmWatchlistUnit;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, ValEdit,<N>  ExtCtrls, ComCtrls, Menus, Clipbrd, NewKernelHandler, commonTypeDefs,strutils,<N>  ProcessHandlerUnit, byteinterpreter{$ifdef darwin},macport, mactypes{$endif},<N>  betterControls;<N><N>
unit LuaTreeNodes;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, ComCtrls, lua, lualib, lauxlib;<N><N>implementation<N><N>uses luaclass, luahandler, LuaObject;<N><N><N>function treenodes_clear(L: Plua_State): integer; cdecl;<N>var<N>  treenodes: TTreeNodes;<N>  i: integer;<N>begin<N>  result:=0;<N>  treenodes:=luaclass_getClassObject(L);<N><N>
{$ifdef cpu32}<N>  //free the allocated memory if there was any<N>  for i:=0 to treenodes.count-1 do<N>  begin<N>    if treenodes[i].Data<>nil then<N>      freemem(treenodes[i].data)<N>  end;<N>{$endif}<N>  treenodes.Clear;<N>end;<N><N>function treenodes_getItem(L: PLua_State): integer; cdecl;<N>var<N>  treenodes: Ttreenodes;<N>  index: integer;<N>begin<N>  result:=0;<N>  treenodes:=luaclass_getClassObject(L);<N><N>
  if lua_gettop(L)>=1 then<N>  begin<N>    index:=lua_tointeger(L,-1);<N>    luaclass_newClass(L, treenodes.Item[index]);<N>    result:=1;<N>  end;<N>end;<N><N><N>function treenodes_getCount(L: PLua_State): integer; cdecl;<N>var<N>  treenodes: Ttreenodes;<N>begin<N>  treenodes:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, treenodes.Count);<N>  result:=1;<N>end;<N><N>
function treenodes_add(L: PLua_State): integer; cdecl;<N>var<N>  treenodes: Ttreenodes;<N>  paramcount: integer;<N>  s: string;<N>begin<N>  treenodes:=luaclass_getClassObject(L);<N><N>  paramcount:=lua_gettop(L);<N>  if paramcount>=1 then<N>    s:=Lua_ToString(L, 1)<N>  else<N>    s:='';<N><N>
<N>  luaclass_newClass(L, treenodes.add(nil, s));<N>  result:=1;<N>end;<N><N>function treenodes_insertBehind(L: PLua_State): integer; cdecl;<N>var<N>  treenodes: Ttreenodes;<N>  treenode: ttreenode;<N>  paramcount: integer;<N>  s: string;<N>begin<N>  treenodes:=luaclass_getClassObject(L);<N><N>
  paramcount:=lua_gettop(L);<N>  if paramcount>=1 then<N>    treenode:=lua_ToCEUserData(L, 1)<N>  else<N>    treenode:=nil;<N><N>  if paramcount>=2 then<N>    s:=Lua_ToString(L, 2)<N>  else<N>    s:='';<N><N><N>  luaclass_newClass(L, treenodes.InsertBehind(treenode, s));<N>  result:=1;<N>end;<N><N>
function treenodes_insert(L: PLua_State): integer; cdecl;<N>var<N>  treenodes: Ttreenodes;<N>  treenode: ttreenode;<N>  paramcount: integer;<N>  s: string;<N>begin<N>  treenodes:=luaclass_getClassObject(L);<N><N>  paramcount:=lua_gettop(L);<N>  if paramcount>=1 then<N>    treenode:=lua_ToCEUserData(L, 1)<N>  else<N>    treenode:=nil;<N><N>
unit debuggertypedefinitions;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  Windows,<N>  {$endif}<N>  Classes, SysUtils,<N>  cefuncproc, NewKernelHandler, commonTypeDefs;<N><N>type<N>  TNewProcedureData = record<N>    processid: dword;<N>    processhandle: dword;<N>    filehandle: dword;<N>    EntryPoint: dword;<N>    OriginalEntryByte: byte;<N>    DotNet: boolean;<N>    FirstBreak: boolean;<N>  end;<N><N>
<N><N>type<N>  TDebugRegisterType = (drtAny, drtExecute, drtWatch);<N><N>type<N>  TContinueOption = (co_run=0, co_stepinto=1, co_stepover=2, co_runtill=3);<N><N>type<N>  TBreakpointMethod = (bpmInt3=0, bpmDebugRegister=1, bpmException=2, bpmDBVM=3, bpmDBVMNative=4);<N><N>
type<N>  TBreakOption = (bo_Break = 0, bo_ChangeRegister = 1, bo_FindCode = 2, bo_FindWhatCodeAccesses = 3, bo_BreakAndTrace=4, bo_OnBreakpoint=5, bo_ChangeRegisterEx = 6);<N>  TBreakPointAction = TBreakOption;<N><N>type<N>  TBreakpointTrigger = (bptExecute=0, bptAccess=1, bptWrite=2);<N><N>
  {$ifdef cpu32}<N>  M128A= record<N>    low,high: qword;<N>  end;<N>  {$endif}<N><N>  TXMMFIELDS=array [0..3] of DWORD;<N>  PXMMFIELDS=^TXMMFIELDS;<N><N> TRegisterModificationFloatList=bitpacked record<N>   change_fp0: 0..1;<N>   change_fp1: 0..1;<N>   change_fp2: 0..1;<N>   change_fp3: 0..1;<N>   change_fp4: 0..1;<N>   change_fp5: 0..1;<N>   change_fp6: 0..1;<N>   change_fp7: 0..1;<N> end;<N> PRegisterModificationFloatList=^TRegisterModificationFloatList;<N><N>
 TRegisterModificationXMMListSingleEntry=bitpacked record<N>   change_part1: 0..1;<N>   change_part2: 0..1;<N>   change_part3: 0..1;<N>   change_part4: 0..1;<N> end;<N> PRegisterModificationXMMListSingleEntry=^TRegisterModificationXMMListSingleEntry;<N><N>
unit NullStream;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type TNullStream=class(TStream)<N>  private<N>  public<N>    function Write(const Buffer; Count: Longint): Longint; override;<N>end;<N><N><N>implementation<N><N>function TNullStream.Write(const Buffer; Count: Longint): Longint;<N>begin<N>  result:=count;<N>end;<N><N><N>end.<N><N>
unit frmDebugSymbolStructureListUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, LResources, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ComCtrls, symbolhandlerstructs, betterControls;<N><N>type<N><N>  { TfrmDebugSymbolStructureList }<N><N>
unit vartypestrings;<N>{<N>This unit is to help with translations for the vartype strings used throughout CE.<N>The vartype stringnames are used in the cheat table so they may not be translated, but the visual representation of the screen can<N>}<N><N>{$mode delphi}<N><N>
unit rttihelper;<N><N>{helper for rtti structures}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}macport,{$endif}<N>  Classes, SysUtils;<N><N>function getRTTIClassName(StructureBaseAddress: ptruint; var classname: string): boolean;<N><N>implementation<N><N>
uses newkernelhandler, ProcessHandlerUnit, symbolhandler, symbolhandlerstructs;<N><N>function isvalidstring(s: string): boolean;<N>var i: integer;<N>begin<N>  result:=length(s)>0;<N>  for i:=1 to length(s) do<N>    if (ord(s[i])<32) or (ord(s[i])>126) then exit(false);<N>end;<N><N>
function getRTTIClassNamePascal(StructureBaseAddress: ptruint; var classname: string): boolean;<N>{<N><N>vInstanceSize: SizeInt;<N>vInstanceSize2: SizeInt;<N>vParentRef: pointer<N>vClassName: PShortString;<N>}<N>var<N>  vtable: ptruint;<N>  classnameaddress: ptruint;<N>  cname: array [0..255] of byte;<N>  x: ptruint;<N>  i: integer;<N>  count: integer;<N>begin<N>  result:=false;<N>  vtable:=0;<N><N>
unit LuaControl;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib, Controls, Menus, Graphics;<N><N>procedure initializeLuaControl;<N>procedure control_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N><N>
implementation<N><N>uses luahandler, pluginexports, LuaCaller, LuaComponent, LuaClass, LuaObject;<N><N>function control_repaint(L: PLua_State): integer; cdecl;<N>begin<N>  TControl(luaclass_getClassObject(L)).Repaint;<N>  result:=0;<N>end;<N><N>function control_update(L: PLua_State): integer; cdecl;<N>begin<N>  TControl(luaclass_getClassObject(L)).Update;<N>  result:=0;<N>end;<N><N>
function control_getFont(L: PLua_State): integer; cdecl;<N>var<N>  c: TControl;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, c.font);<N>  result:=1;<N>end;<N><N>function control_setFont(L: Plua_State): integer; cdecl;<N>var<N>  c: tcontrol;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=1 then<N>    c.Font:=lua_ToCEUserData(L, -1);<N><N>
  result:=0;<N>end;<N><N>function control_setCaption(L: Plua_State): integer; cdecl;<N>var<N>  c: tcontrol;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    c.Caption:=lua_tostring(L, -1);<N><N>  result:=0;<N>end;<N><N>function control_getCaption(L: PLua_State): integer; cdecl;<N>var<N>  c: TControl;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushstring(L, c.caption);<N>  result:=1;<N>end;<N><N>
<N>function control_setLeft(L: Plua_State): integer; cdecl;<N>var<N>  c: tcontrol;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=1 then //6.3+, class only so no need for >= and negative indexes<N>    c.left:=lua_tointeger(L, 1);<N><N>  result:=0;<N>end;<N><N>
function control_getLeft(L: Plua_State): integer; cdecl;<N>var<N>  c: tcontrol;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, c.left);<N>  result:=1;<N>end;<N><N>function control_setTop(L: Plua_State): integer; cdecl;<N>var<N>  c: tcontrol;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=1 then<N>    c.top:=lua_tointeger(L, 1);<N><N>
  result:=0;<N>end;<N><N>function control_getTop(L: Plua_State): integer; cdecl;<N>var<N>  c: tcontrol;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, c.top);<N>  result:=1;<N>end;<N><N>function control_setPosition(L: Plua_State): integer; cdecl;<N>var<N>  c: TControl;<N>begin<N>  result:=0;<N>  c:=luaclass_getClassObject(L);<N><N>
  if lua_gettop(L)>=2 then<N>  begin<N>    c.Left:=lua_tointeger(L, -2);<N>    c.Top:=lua_tointeger(L, -1);<N>  end;<N>end;<N><N><N>function control_getPosition(L: PLua_State): integer; cdecl;<N>var<N>  c: TControl;<N>  x,y: integer;<N>begin<N>  result:=0;<N>  c:=luaclass_getClassObject(L);<N><N>
  lua_pushinteger(L, c.left);<N>  lua_pushinteger(L, c.top);<N>  result:=2;<N>end;<N><N>function control_setWidth(L: Plua_State): integer; cdecl;<N>var<N>  c: tcontrol;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=1 then<N>    c.Width:=lua_tointeger(L, 1);<N><N>
  result:=0;<N>end;<N><N>function control_getWidth(L: Plua_State): integer; cdecl;<N>var<N>  c: tcontrol;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, c.Width);<N>  result:=1;<N>end;<N><N><N>function control_setHeight(L: Plua_State): integer; cdecl;<N>var<N>  c: tcontrol;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=1 then<N>    c.Height:=lua_tointeger(L, 1);<N><N>
  result:=0;<N>end;<N><N>function control_getHeight(L: Plua_State): integer; cdecl;<N>var<N>  c: tcontrol;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, c.Height);<N>  result:=1;<N>end;<N><N><N>function control_setClientWidth(L: Plua_State): integer; cdecl;<N>var<N>  c: tcontrol;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=1 then<N>    c.ClientWidth:=lua_tointeger(L, 1);<N><N>
  result:=0;<N>end;<N><N>function control_getClientWidth(L: Plua_State): integer; cdecl;<N>var<N>  c: tcontrol;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, c.ClientWidth);<N>  result:=1;<N>end;<N><N><N>function control_setClientHeight(L: Plua_State): integer; cdecl;<N>var<N>  c: tcontrol;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=1 then<N>    c.ClientHeight:=lua_tointeger(L, 1);<N><N>
  result:=0;<N>end;<N><N>function control_getClientHeight(L: Plua_State): integer; cdecl;<N>var<N>  c: tcontrol;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, c.ClientHeight);<N>  result:=1;<N>end;<N><N>function control_setSize(L: Plua_State): integer; cdecl;<N>var<N>  c: TControl;<N>begin<N>  c:=luaclass_getClassObject(L);<N><N>
<N>  if lua_gettop(L)>=2 then<N>  begin<N>    c.Width:=lua_tointeger(L, -2);<N>    c.height:=lua_tointeger(L, -1);<N>  end;<N>  result:=0;<N>end;<N><N>function control_getSize(L: PLua_State): integer; cdecl;<N>var<N>  c: TControl;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, c.width);<N>  lua_pushinteger(L, c.height);<N>  result:=2;<N>end;<N><N>
<N>function control_setAlign(L: PLua_State): integer; cdecl;<N>var<N>  c: TControl;<N>  a: integer;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    c.Align:=Talign(lua_tointeger(L,-1));<N><N>  result:=0;<N>end;<N><N>function control_getAlign(L: PLua_State): integer; cdecl;<N>var<N>  c: TControl;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, integer(c.Align));<N>  result:=1;<N>end;<N><N>
function control_setEnabled(L: PLua_State): integer; cdecl;<N>var<N>  c: TControl;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    c.Enabled:=lua_toboolean(L,-1);<N><N>  result:=0;<N>end;<N><N>function control_getEnabled(L: PLua_State): integer; cdecl;<N>var<N>  c: TControl;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushboolean(L, c.Enabled);<N>  result:=1;<N>end;<N><N>
<N>function control_setVisible(L: PLua_State): integer; cdecl;<N>var<N>  c: TControl;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    c.Visible:=lua_toboolean(L,-1);<N><N>  result:=0;<N>end;<N><N>function control_getVisible(L: PLua_State): integer; cdecl;<N>var<N>  c: TControl;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushboolean(L, c.Visible);<N>  result:=1;<N>end;<N><N>
function control_setColor(L: PLua_State): integer; cdecl;<N>var<N>  c: TControl;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    c.Color:=Tcolor(lua_tointeger(L,-1));<N><N>  result:=0;<N>end;<N><N>function control_getColor(L: PLua_State): integer; cdecl;<N>var<N>  c: TControl;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, integer(c.color));<N>  result:=1;<N>end;<N><N>
function control_getRGBColor(L: PLua_State): integer; cdecl;<N>var<N>  c: TControl;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, integer(c.GetRGBColorResolvingParent));<N>  result:=1;<N>end;<N><N><N>function control_setParent(L: PLua_State): integer; cdecl;<N>var<N>  c: TControl;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    c.Parent:=lua_ToCEUserData(L, -1);<N><N>
  result:=0;<N>end;<N><N>function control_getParent(L: PLua_State): integer; cdecl;<N>var<N>  c: TControl;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, c.parent);<N>  result:=1;<N>end;<N><N>function control_setPopupMenu(L: PLua_State): integer; cdecl;<N>var<N>  c: TControl;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    c.PopupMenu:=lua_ToCEUserData(L, -1);<N><N>
  result:=0;<N>end;<N><N>function control_getPopupMenu(L: PLua_State): integer; cdecl;<N>var<N>  c: TControl;<N>  i: integer;<N>begin<N>  c:=luaclass_getClassObject(L);<N><N>  luaclass_newClass(L,c);<N>  lua_pushstring(L,'PopupMenu');<N>  lua_getProperty(L);<N><N>
  if lua_isnil(L,-1) then<N>    luaclass_newClass(L, c.PopupMenu);<N><N>  result:=1;<N>end;<N><N>function control_doClick(L: PLua_State): integer; cdecl;<N>var<N>  c: TControl;<N>begin<N>  result:=0;<N>  c:=luaclass_getClassObject(L);<N>  if assigned(c.OnClick) then<N>    c.OnClick(c);<N>end;<N><N>
function control_getOnClick(L: PLua_State): integer; cdecl;<N>var<N>  c: tcontrol;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  LuaCaller_pushMethodProperty(L, TMethod(c.onclick), 'TNotifyEvent');<N>  result:=1;<N>end;<N><N>function control_setOnClick(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  c: TControl;<N>  f: integer;<N>  routine: string;<N><N>
  lc: TLuaCaller;<N><N>//  clickroutine: integer;<N>begin<N>  result:=0;<N>  c:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=1 then<N>  begin<N>    CleanupLuaCall(tmethod(c.onClick));<N>    c.onClick:=nil;<N><N>    if lua_isfunction(L,-1) then<N>    begin<N>      f:=luaL_ref(L,LUA_REGISTRYINDEX);<N><N>
      lc:=TLuaCaller.create;<N>      lc.luaroutineIndex:=f;<N>      c.OnClick:=lc.NotifyEvent;<N>    end<N>    else<N>    if lua_isstring(L,-1) then<N>    begin<N>      routine:=lua_tostring(L,-1);<N>      lc:=TLuaCaller.create;<N>      lc.luaroutine:=routine;<N>      c.OnClick:=lc.NotifyEvent;<N>    end;<N><N>
  end;<N>end;<N><N>function control_bringToFront(L: PLua_State): integer; cdecl;<N>var<N>  control: TControl;<N>begin<N>  control:=luaclass_getClassObject(L);<N>  control.BringToFront;<N>  result:=0<N>end;<N><N>function control_sendToBack(L: PLua_State): integer; cdecl;<N>var<N>  control: TControl;<N>begin<N>  control:=luaclass_getClassObject(L);<N>  control.SendToBack;<N>  result:=0<N>end;<N><N>
function control_screenToClient(L: PLua_State): integer; cdecl;<N>var<N>  control: TControl;<N>  p: tpoint;<N>begin<N>  result:=0;<N>  control:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=2 then<N>  begin<N>    p.x:=lua_tointeger(L,1);<N>    p.y:=lua_tointeger(L,2);<N><N>
    p:=control.ScreenToClient(p);<N>    lua_pushinteger(L,p.x);<N>    lua_pushinteger(L,p.y);<N>    result:=2;<N>  end;<N>end;<N><N>function control_clientToScreen(L: PLua_State): integer; cdecl;<N>var<N>  control: TControl;<N>  p: tpoint;<N>begin<N>  result:=0;<N>  control:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=2 then<N>  begin<N>    p.x:=lua_tointeger(L,1);<N>    p.y:=lua_tointeger(L,2);<N><N>
    p:=control.ClientToScreen(p);<N>    lua_pushinteger(L,p.x);<N>    lua_pushinteger(L,p.y);<N>    result:=2;<N>  end;<N>end;<N><N>function control_refresh(L: PLua_State): integer; cdecl;<N>var<N>  control: TControl;<N>begin<N>  control:=luaclass_getClassObject(L);<N>  control.Refresh;<N>  result:=0;<N>end;<N><N>
unit fileaccess;<N><N>{$mode delphi}<N><N>interface<N><N>{$IFDEF windows}<N>uses<N>  jwaWindows, windows,Classes, SysUtils;<N><N>procedure MakePathAccessible(path: widestring);<N>{$ENDIF}<N><N>implementation<N><N>{$IFDEF windows}<N>resourcestring<N>  rsNoGetNamedSecurityInfo = 'no GetNamedSecurityInfo';<N>  rsNoGetSecurityInfo = 'no GetSecurityInfo';<N>  rsNoSetEntriesInAcl = 'no SetEntriesInAcl';<N>  rsNoSetNamedSecurityInfo = 'no SetNamedSecurityInfo';<N><N>
const  SECURITY_WORLD_SID_AUTHORITY: TSidIdentifierAuthority = (Value: (0, 0, 0, 0, 0, 1));<N><N>type<N>  PTRUSTEE_W=^TRUSTEE_W;<N>  TRUSTEE_W = record<N>    pMultipleTrustee: PTRUSTEE_W;<N>    MultipleTrusteeOperation: MULTIPLE_TRUSTEE_OPERATION;<N>    TrusteeForm: TRUSTEE_FORM;<N>    TrusteeType: TRUSTEE_TYPE;<N>    ptstrName: LPWCH;<N>  end;<N><N>
unit PointerscanNetworkStructures;<N><N>{<N>unit containing some structures used to pass information between functions and child/parents<N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>  TPublicParentData=record<N>    connected: boolean;<N>    name: string;<N>    ip: string;<N>    port: word;<N>    lastupdatesent: qword;<N>    waitingforreconnect: boolean;<N>  end;<N><N>
  TPublicConnectionEntry=record //information publicly available about children<N>    parentconnectedto: boolean; //true if the parent connected to the child<N>    ip: string;<N>    childid: integer;<N>    port: word;<N>    queued: boolean;<N>    queuesize: integer;<N>    queuepos: integer;<N><N>
    isidle: boolean;<N>    disconnected: boolean;<N>    lasterror: string;<N>    pathsevaluated: qword;<N>    trustedconnection: boolean;<N>    potentialthreadcount: integer;<N>    actualthreadcount: integer;<N>    pathquesize: integer;<N>    totalpathqueuesize: integer;<N>    resultsfound: qword;<N><N>
    uploadingscandata:boolean;<N>    ScanDataSent: qword;<N>    ScanDataTotalSize: qword;<N>    ScanDataStartTime: qword;<N>    downloadingResuls: boolean;<N><N>    lastUpdateReceived: qword;<N>  end;<N><N>  TConnectionEntryArray=array of TPublicConnectionEntry;<N><N>
<N>type<N>  TPSHelloMsg=record<N>    publicname: string;<N>    currentscanid: uint32;<N>    scannerid: uint32;<N>  end;<N><N>type<N>  TPSUpdateStatusMsg=record<N>    currentscanid: uint32;<N>    isidle: byte;<N>    potentialthreadcount: integer;<N>    actualthreadcount: integer;<N>    pathsevaluated: qword;<N>    localpathqueuecount: uint32;<N>    totalpathQueueCount: uint32;<N>    queuesize: uint32;<N>  end;<N><N>
unit formmemoryregionsunit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls,CEFuncProc, ComCtrls, Menus,OpenSave,NewKernelHandler, LResources, betterControls;<N><N>
unit frmLoadMemoryunit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, CEFuncProc, StdCtrls, NewKernelHandler, LResources, ExtCtrls, betterControls;<N><N>type tbarray=array of byte;<N><N>
unit Structuresfrm;<N><N><N>{      O<N>      OB<N>     OBS<N>    OBSO<N>   OBSOL<N>  OBSOLE<N> OBSOLET<N>OBSOLETE<N>BSOLETE<N>SOLETE<N>OLETE<N>LETE<N>ETE<N>TE<N>E<N><N>}<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, LMessages, Messages, Classes;<N><N>
unit DebuggerInterface;<N>{<N>This unit contains the base class description for the debugger interface.<N>The other debugger interfaces are inherited from this<N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils{$ifdef windows},windows{$endif},NewKernelHandler, debuggertypedefinitions{$ifdef darwin}, macport, macportdefines{$endif};<N><N>
unit mikmod;<N><N>{$mode objfpc}{$H+}<N><N>{<N>MikMod sound library<N>half port of the MikMod header file to pascal<N>}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  mactypes, dynlibs, macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}Classes, SysUtils, syncobjs;<N><N>
<N>type<N>  PSAMPLE=pointer;<N>  PMODULE=pointer;<N>  PREADER=^MREADER;<N><N>  MREADER_SEEK=function(self:PREADER; offset:longint; whence:integer):longint;cdecl;<N>  MREADER_TELL=function(self:PREADER):longint;cdecl;<N>  MREADER_READ=function(self:PREADER; dest: pointer; l: size_t): BOOL; cdecl;<N>  MREADER_GET=function(self:PREADER):integer; cdecl;<N>  MREADER_EOF=function(self:PREADER):BOOL; cdecl;<N><N>
  MREADER=record<N>    Seek: MREADER_SEEK;<N>    Tell: MREADER_TELL;<N>    Read: MREADER_READ;<N>    Get:  MREADER_GET;<N>    EOF:  MREADER_EOF;<N>    memory: PBYTE;<N>    size: integer;<N>    position: integer;<N>  end;<N><N>  TMikModSFX=class<N>  private<N>    s: PSAMPLE;<N>  public<N>    procedure play;<N>    constructor create(sample: PSAMPLE);<N>    destructor destroy; override;<N>  end;<N><N>
function LoadMikMod: boolean;<N><N>const<N>  {These ones take effect only after MikMod_Init or MikMod_Reset}<N>  DMODE_16BITS       =$0001;<N>  DMODE_STEREO       =$0002;<N>  DMODE_SOFT_SNDFX   =$0004;<N>  DMODE_SOFT_MUSIC   =$0008;<N>  DMODE_HQMIXER      =$0010;<N><N>
  {These take effect immediately}<N>  DMODE_SURROUND     =$0100;<N>  DMODE_INTERP       =$0200;<N>  DMODE_REVERSE      =$0400;<N><N><N>  SFX_CRITICAL= 1;<N><N>  //Sample format [loading and in-memory] flags:<N>  SF_16BITS       =$0001;<N>  SF_STEREO       =$0002;<N>  SF_SIGNED       =$0004;<N>  SF_BIG_ENDIAN   =$0008;<N>  SF_DELTA        =$0010;<N>  SF_ITPACKED     =$0020;<N><N>
  SF_FORMATMASK   =$003F;<N><N>  // General Playback flags<N><N>  SF_LOOP         =$0100;<N>  SF_BIDI         =$0200;<N>  SF_REVERSE      =$0400;<N>  SF_SUSTAIN      =$0800;<N><N>  SF_PLAYBACKMASK =$0C00;<N><N>  // Module-only Playback Flags<N><N>  SF_OWNPAN       =$1000;<N>  SF_UST_LOOP     =$2000;<N><N>
unit ValueFinder;<N><N>{$MODE Delphi}<N><N>{<N>Designed fro use with the pointerscan.<N>With some fiddling it might be used for some other stuff as well<N>}<N><N>interface<N><N>{$ifdef windows}<N>uses windows, LCLIntf, classes, sysutils, symbolhandler, math, cefuncproc,newkernelhandler, commonTypeDefs;<N>{$endif}<N><N>
unit first;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>{$ifdef windows}<N>uses<N>  betterDLLSearchPath, Classes, SysUtils;<N>{$endif}<N><N>implementation<N><N>{$ifdef windows}<N>uses windows, registry, Win32Int;<N><N><N>procedure setDPIAware;   //won't work in windows 10 anymore<N>type<N>  PROCESS_DPI_AWARENESS=(PROCESS_DPI_UNAWARE=0, PROCESS_SYSTEM_DPI_AWARE=1, PROCESS_PER_MONITOR_DPI_AWARE=2);<N><N>
var<N>  SetProcessDpiAwareness:function(value: PROCESS_DPI_AWARENESS):HRESULT; stdcall;<N>  SetProcessDPIAware:function: BOOL; stdcall;<N>  l: HModule;<N>begin<N> // OutputDebugString('setDPIAware');<N>  l:=LoadLibrary('Shcore.dll');<N>  if l<>0 then<N>  begin<N>    farproc(SetProcessDpiAwareness):=GetProcAddress(l,'SetProcessDpiAwareness');<N><N>
    if assigned(SetProcessDpiAwareness) then<N>    begin<N>     // OutputDebugString('p1');<N>      SetProcessDpiAwareness(PROCESS_SYSTEM_DPI_AWARE);<N>      exit;<N>    end;<N>  end;<N><N><N>  //still here, probably win8.0 or 7<N>  l:=LoadLibrary('user32.dll');<N>  if l<>0 then<N>  begin<N>   // OutputDebugString('p2');<N>    farproc(SetProcessDPIAware):=GetProcAddress(l,'SetProcessDPIAware');<N>    if assigned(SetProcessDPIAware) then<N>      SetProcessDPIAware;<N>  end;<N><N>
  OutputDebugString('p3');<N>end;<N><N>var<N>  i: integer;<N>  //istrainer: boolean;<N>  r: TRegistry;<N>  hassetdpiaware: boolean;<N>initialization<N>  //todo, check registry if not a trainer<N><N>  //istrainer:=false;<N>  hassetdpiaware:=false;<N><N>  for i:=1 to Paramcount do<N>  begin<N>    if ParamStr(i)='DPIAWARE' then<N>    begin<N>      setDPIAware;<N>      hassetdpiaware:=true;<N>    end;<N><N>
unit frmCapturedTimersUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ComCtrls, LResources, ExtCtrls, betterControls;<N><N>
unit LuaStream;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lauxlib, lualib, math;<N><N>procedure stream_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N><N>implementation<N><N>uses LuaClass, LuaHandler, LuaObject{$ifdef darwin},mactypes{$endif};<N><N>
unit SaveFirstScan;<N><N>{$MODE Delphi}<N><N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, LCLType,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  sysutils, fileutil, LCLIntf, classes, CEFuncProc, commonTypeDefs;<N><N>type TSaveFirstScanThread=class(tthread)<N>  private<N><N>
  public<N>    folder: string;<N>    newscanmethod: boolean;<N>    memRegion: PMemoryRegions;<N>    pmemRegionPos: pinteger;<N>    buffer: pointer;  <N>    procedure execute; override;<N>    constructor create(folder: string; suspended: boolean; memRegion: PMemoryRegions; pmemRegionPos: pinteger; buffer: pointer); overload;<N>end;<N><N>
implementation<N><N>procedure TSaveFirstScanThread.execute;<N>var //addressfile,memoryfile,newaddressfile,newmermoryfile: file;<N>    datatype: string[6];<N>    i: integer;<N><N>    p: ^byte;<N>    regioncount: integer;<N><N>    oldAddressFile,oldMemoryFile, newAddressFile, newMemoryFile: Tfilestream;<N>begin<N>  if terminated then exit;<N><N>
<N>  regioncount:=pmemregionPos^;<N><N>  if newscanmethod then<N>    dec(regioncount);<N><N>  //open the files<N>  oldAddressFile:=nil;<N>  oldMemoryFile:=nil;<N>  newAddressFile:=nil;<N>  newMemoryFile:=nil;<N><N><N>  try<N>    oldAddressFile:=TFileStream.Create(folder+'ADDRESSES.TMP', fmopenread or fmShareDenyNone);<N>    oldMemoryFile:=TFileStream.Create(folder+'MEMORY.TMP', fmopenread or fmShareDenyNone);<N><N>
    if terminated then exit;<N><N>    oldaddressfile.ReadBuffer(datatype, sizeof(datatype));<N><N>    if datatype='REGION' then<N>    begin<N>      //the scan was a unknown initial value scan, so the memory is stored in memory and not on the disk<N>      //save the memoryregions and memory to disk<N>      NewAddressFile:=TFileStream.Create(folder+'ADDRESSES.FIRST', fmCreate);<N>      NewMemoryFile:=TFileStream.Create(folder+'MEMORY.FIRST', fmCreate);<N><N>
      newAddressfile.WriteBuffer(datatype,sizeof(datatype));<N><N>      p:=buffer;<N>      for i:=0 to regioncount do  //no, not a bug<N>      begin<N>        newaddressfile.WriteBuffer(memregion^[i], sizeof(memregion^[i]));<N>        newmemoryfile.WriteBuffer(p^, memregion^[i].MemorySize);<N>        inc(p,memregion^[i].MemorySize);<N><N>
        if terminated then exit;<N>      end;<N>    end<N>    else<N>    begin<N>      //exact value scan or other scan that gives addresses<N>      //copy the results to addressesfirst.tmp and memoryfirst.tmp<N><N>      copyfile(pchar(folder+'ADDRESSES.TMP'),pchar(folder+'ADDRESSES.FIRST'),false);<N>      if terminated then exit;<N>      copyfile(pchar(folder+'MEMORY.TMP'),pchar(folder+'MEMORY.FIRST'),false);<N>    end;<N><N>
  finally<N>    if oldAddressFile<>nil then<N>      oldAddressFile.free;<N><N>    if oldmemoryfile<>nil then<N>      oldmemoryfile.free;<N><N>    if newaddressfile<>nil then<N>      newaddressfile.free;<N><N>    if newmemoryfile<>nil then<N>      newmemoryfile.free;<N>  end;<N>end;<N><N>
<N>constructor TSaveFirstScanThread.create(folder: string; suspended: boolean; memRegion: PMemoryRegions; pmemRegionPos: pinteger; buffer: pointer);<N>begin<N>  self.folder:=folder;<N>  newscanmethod:=true;<N>  self.memRegion:=memRegion;<N>  self.pmemRegionPos:=pmemRegionPos;<N>  self.buffer:=buffer;<N>  inherited create(suspended);<N>end;<N><N>
unit symbolhandlerstructs;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, cvconst, commonTypeDefs;<N><N><N>type TUDSEnum=record<N>  address: ptrUint;<N>  allocsize: dword;<N>  addressstring: pchar; //points to the string<N>  doNotSave: boolean;<N>end;<N><N>
type symexception=class(Exception);<N><N>type<N>  TDBStructInfo=class(TObject)<N>    moduleid: integer;<N>    typeid: integer;<N>    length: integer;<N>    callbackid: integer;<N>  end;<N><N>  TDBElementInfo=class (TObject)<N>    offset: dword;<N>    basetype: integer;<N>    typeid: integer;<N>    tag: TSymTagEnum;<N>    vartype: TVariableType;<N>  end;<N><N>
<N>  TUserdefinedsymbol=record<N>    symbolname: string;<N>    address: ptrUint;<N>    addressstring: string;<N><N>    allocsize: dword; //if it is a global alloc, allocsize>0<N>    processid: dword; //the processid this memory was allocated to (in case of processswitches)<N>    doNotSave: boolean; //if true this will cause this entry to not be saved when the user saves the table<N>  end;<N><N>
unit LuaDisassembler;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, disassembler, lua, lauxlib, lualib, symbolhandler, LastDisassembleData;<N><N>procedure initializeLuaDisassembler(L: PLua_state);<N><N>procedure LastDisassemblerDataToTable(L: PLua_State; t: integer; const ldd: TLastDisassembleData);<N>procedure LastDisassemblerDataFromTable(L: PLua_State; t: integer; var ldd: TLastDisassembleData);<N><N>
implementation<N><N>uses LuaHandler, LuaClass, LuaObject;<N><N>function disassembler_disassemble(L: PLua_State): integer; cdecl;<N>var d: TDisassembler;<N>  s,desc: string;<N>  address: ptruint;<N>begin<N>  result:=0;<N>  d:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=1 then<N>  begin<N>    if lua_type(L,1)=LUA_TSTRING then<N>      address:=symhandler.getAddressFromNameL(Lua_ToString(L, 1))<N>    else<N>      address:=lua_tointeger(L, 1);<N><N>
    s:=d.disassemble(address, desc);<N>    lua_pushstring(L, s);<N><N>    result:=1;<N>  end;<N><N>end;<N><N>function disassembler_decodeLastParametersToString(L: PLua_State): integer; cdecl;<N>var d: TDisassembler;<N>begin<N>  d:=luaclass_getClassObject(L);<N>  lua_pushstring(L, d.DecodeLastParametersToString);<N>  result:=1;<N>end;<N><N>
procedure LastDisassemblerDataFromTable(L: PLua_State; t: integer; var ldd: TLastDisassembleData);<N>var bytestable: integer;<N>  i, size: integer;<N>begin<N>  lua_pushstring(L,'address');<N>  lua_gettable(L, t);<N>  ldd.address:=lua_tointeger(L, -1);<N>  lua_pop(L, 1);<N><N>
  lua_pushstring(L,'opcode');<N>  lua_gettable(L, t);<N>  ldd.opcode:=Lua_ToString(L, -1);<N>  lua_pop(L, 1);<N><N>  lua_pushstring(L,'parameters');<N>  lua_gettable(L, t);<N>  ldd.parameters:=Lua_ToString(L, -1);<N>  lua_pop(L, 1);<N><N>  lua_pushstring(L,'description');<N>  lua_gettable(L, t);<N>  ldd.description:=Lua_ToString(L, -1);<N>  lua_pop(L, 1);<N><N>
  lua_pushstring(L,'commentsoverride');<N>  lua_gettable(L, t);<N>  ldd.commentsoverride:=Lua_ToString(L, -1);<N>  lua_pop(L, 1);<N><N>  lua_pushstring(L,'bytes');<N>  lua_gettable(L, t);<N>  bytestable:=lua_gettop(L);<N><N>  size:=lua_objlen(L, bytestable);<N>  setlength(ldd.Bytes, size);<N><N>
  for i:=1 to size do<N>  begin<N>    lua_pushinteger(L, i);<N>    lua_gettable(L, bytestable);<N>    ldd.bytes[i-1]:=lua_tointeger(L, -1);<N>    lua_pop(L, 1);<N>  end;<N><N>  lua_pop(L, 1);<N><N>  lua_pushstring(L,'modrmValueType');<N>  lua_gettable(L, t);<N>  ldd.modrmValueType:=TDisAssemblerValueType(lua_tointeger(L, -1));<N>  lua_pop(L, 1);<N><N>
  lua_pushstring(L,'modrmValue');<N>  lua_gettable(L, t);<N>  ldd.modrmValue:=lua_tointeger(L, -1);<N>  lua_pop(L, 1);<N><N>  lua_pushstring(L,'parameterValueType');<N>  lua_gettable(L, t);<N>  ldd.parameterValueType:=TDisAssemblerValueType(lua_tointeger(L, -1));<N>  lua_pop(L, 1);<N><N>
  lua_pushstring(L,'parameterValue');<N>  lua_gettable(L, t);<N>  ldd.parameterValue:=lua_tointeger(L, -1);<N>  lua_pop(L, 1);<N><N>  lua_pushstring(L,'isJump');<N>  lua_gettable(L, t);<N>  ldd.isjump:=lua_toboolean(L, -1);<N>  lua_pop(L, 1);<N><N>  lua_pushstring(L,'isCall');<N>  lua_gettable(L, t);<N>  ldd.isCall:=lua_toboolean(L, -1);<N>  lua_pop(L, 1);<N><N>
  lua_pushstring(L,'isRet');<N>  lua_gettable(L, t);<N>  ldd.isRet:=lua_toboolean(L, -1);<N>  lua_pop(L, 1);<N><N>  lua_pushstring(L,'isConditionalJump');<N>  lua_gettable(L, t);<N>  ldd.isconditionaljump:=lua_toboolean(L, -1);<N>  lua_pop(L, 1);<N><N>end;<N><N>
procedure LastDisassemblerDataToTable(L: PLua_State; t: integer; const ldd: TLastDisassembleData);<N>var temptable: integer;<N>  i: integer;<N>begin<N><N>  lua_pushstring(L,'address');<N>  lua_pushinteger(L, ldd.address);<N>  lua_settable(L, t);<N><N>  lua_pushstring(L,'opcode');<N>  lua_pushstring(L, ldd.opcode);<N>  lua_settable(L, t);<N><N>
  lua_pushstring(L,'parameters');<N>  lua_pushstring(L, ldd.parameters);<N>  lua_settable(L, t);<N><N>  lua_pushstring(L,'description');<N>  lua_pushstring(L, ldd.description);<N>  lua_settable(L, t);<N><N>  lua_pushstring(L,'commentsoverride');<N>  lua_pushstring(L, ldd.commentsoverride);<N>  lua_settable(L, t);<N><N>
  lua_pushstring(L, 'bytes');<N>  lua_newtable(L);<N>  temptable:=lua_gettop(L);<N>  for i:=0 to length(ldd.Bytes)-1 do<N>  begin<N>    lua_pushinteger(L, i+1);<N>    lua_pushinteger(L, ldd.Bytes[i]);<N>    lua_settable(L, temptable);<N>  end;<N>  lua_settable(L, t);<N><N>
  lua_pushstring(L, 'modrmValueType');<N>  lua_pushinteger(L, integer(ldd.modrmValueType));<N>  lua_settable(L, t);<N><N>  lua_pushstring(L,'modrmValue');<N>  lua_pushinteger(L, ldd.modrmValue);<N>  lua_settable(L, t);<N><N>  lua_pushstring(L, 'parameterValueType');<N>  lua_pushinteger(L, integer(ldd.parameterValueType));<N>  lua_settable(L, t);<N><N>
  lua_pushstring(L,'parameterValue');<N>  lua_pushinteger(L, ldd.parameterValue);<N>  lua_settable(L, t);<N><N>  lua_pushstring(L,'isJump');<N>  lua_pushboolean(L, ldd.isJump);<N>  lua_settable(L, t);<N><N>  lua_pushstring(L,'isCall');<N>  lua_pushboolean(L, ldd.isCall);<N>  lua_settable(L, t);<N><N>
  lua_pushstring(L,'isRet');<N>  lua_pushboolean(L, ldd.isret);<N>  lua_settable(L, t);<N><N>  lua_pushstring(L,'isRep');<N>  lua_pushboolean(L, ldd.isrep);<N>  lua_settable(L, t);<N><N>  lua_pushstring(L,'isConditionalJump');<N>  lua_pushboolean(L, ldd.isConditionalJump);<N>  lua_settable(L, t);<N>end;<N><N>
function disassembler_getLastDisassembleData(L: PLua_State): integer; cdecl;<N>var d: TDisassembler;<N>  t: integer;<N><N><N>  i: integer;<N>begin<N>  result:=1;<N>  d:=luaclass_getClassObject(L);<N><N>  lua_newtable(L);<N>  t:=lua_gettop(L);<N>  LastDisassemblerDataToTable(L, t, d.LastDisassembleData);<N>end;<N><N>
function createDisassembler(L: PLua_State): integer; cdecl;<N>begin<N>  luaclass_newClass(L, TDisassembler.Create);<N>  result:=1;<N>end;<N><N>function createCR3Disassembler(L: PLua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  {$ifdef windows}<N>  luaclass_newClass(L, TCR3Disassembler.Create);<N>  result:=1;<N>  {$endif}<N>end;<N><N>
<N>function getDefaultDisassembler(L: PLua_State): integer; cdecl;<N>begin<N>  luaclass_newClass(L, defaultDisassembler);<N>  result:=1;<N>end;<N><N>function getVisibleDisassembler(L: PLua_State): integer; cdecl;<N>begin<N>  luaclass_newClass(L, visibleDisassembler);<N>  result:=1;<N>end;<N><N>
unit LuaDiagramLink;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib,LuaHandler, diagram, diagramblock,<N>  diagramlink, diagramtypes, typinfo;<N><N>implementation<N><N>uses controls, luaclass, LuaCustomControl, LuaObject, LuaDiagram;<N><N>
unit LuaSynedit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>procedure initializeLuaSynEdit;<N><N>implementation<N><N>uses lua, lauxlib, lualib, luahandler, luaclass, controls, SynEdit, LuaCustomControl,<N>  LuaSyntax, SynHighlighterAA, betterControls, SynHighlighterCpp;<N><N>
function createSynEdit(L: PLua_State): integer; cdecl;<N>var<N>  s: TSynEdit;<N>  o: twincontrol;<N><N>  mode: integer;<N>begin<N>  result:=0;<N>  if lua_gettop(L)>=1 then<N>  begin<N>    o:=lua_toceuserdata(L, 1);<N>    s:=TSynEdit.Create(o);<N>    s.parent:=o;<N><N>
    if lua_gettop(L)>=2 then<N>    begin<N>      mode:=lua_tointeger(L,2);<N><N>      case mode of<N>        0: s.Highlighter:=TSynLuaSyn.Create(s);<N>        1: s.Highlighter:=TSynAASyn.Create(s);<N>        2: s.Highlighter:=TSynCppSyn.Create(s);<N>      end;<N>    end;<N><N>
    luaclass_newClass(L, s);<N>    result:=1;<N><N><N>  end;<N>end;<N><N><N>function syn_getSelStart(L: PLua_State): integer; cdecl;<N>var<N>  s: TCustomSynEdit;<N>begin<N>  s:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, s.SelStart);<N>  result:=1;<N>end;<N><N>
function syn_setSelStart(L: PLua_State): integer; cdecl;<N>var<N>  s: TCustomSynEdit;<N>begin<N>  s:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>0 then<N>    s.SelStart:=lua_tointeger(L,1);<N><N>  result:=0;<N>end;<N><N>function syn_getSelEnd(L: PLua_State): integer; cdecl;<N>var<N>  s: TCustomSynEdit;<N>begin<N>  s:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, s.SelEnd);<N>  result:=1;<N>end;<N><N>
function syn_setSelEnd(L: PLua_State): integer; cdecl;<N>var<N>  s: TCustomSynEdit;<N>begin<N>  s:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>0 then<N>    s.SelEnd:=lua_tointeger(L,1);<N>  result:=0;<N><N><N>end;<N><N>function syn_getSelText(L: PLua_State): integer; cdecl;<N>var<N>  s: TCustomSynEdit;<N>begin<N>  s:=luaclass_getClassObject(L);<N>  lua_pushstring(L, s.SelText);<N>  result:=1;<N>end;<N><N>
function syn_setSelText(L: PLua_State): integer; cdecl;<N>var<N>  s: TCustomSynEdit;<N>begin<N>  s:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>0 then<N>    s.SelText:=lua_tostring(L, 1);<N><N><N>  result:=0;<N>end;<N><N>function syn_getCanPaste(L: PLua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, TCustomSynEdit(luaclass_getClassObject(L)).CanPaste);<N>  result:=1;<N>end;<N><N>
function syn_getCanRedo(L: PLua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, TCustomSynEdit(luaclass_getClassObject(L)).CanRedo);<N>  result:=1;<N>end;<N><N>function syn_getCanUndo(L: PLua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, TCustomSynEdit(luaclass_getClassObject(L)).CanUndo);<N>  result:=1;<N>end;<N><N>
function syn_CopyToClipboard(L: PLua_State): integer; cdecl;<N>begin<N>  TCustomSynEdit(luaclass_getClassObject(L)).CopyToClipboard;<N>  result:=0;<N>end;<N><N>function syn_CutToClipboard(L: PLua_State): integer; cdecl;<N>begin<N>  TCustomSynEdit(luaclass_getClassObject(L)).CutToClipboard;<N>  result:=0;<N>end;<N><N>
function syn_PasteFromClipboard(L: PLua_State): integer; cdecl;<N>begin<N>  TCustomSynEdit(luaclass_getClassObject(L)).PasteFromClipboard;<N>  result:=0;<N>end;<N><N>function syn_ClearUndo(L: PLua_State): integer; cdecl;<N>begin<N>  TCustomSynEdit(luaclass_getClassObject(L)).ClearUndo;<N>  result:=0;<N>end;<N><N>
function syn_Redo(L: PLua_State): integer; cdecl;<N>begin<N>  TCustomSynEdit(luaclass_getClassObject(L)).Redo;<N>  result:=0;<N>end;<N><N>function syn_Undo(L: PLua_State): integer; cdecl;<N>begin<N>  TCustomSynEdit(luaclass_getClassObject(L)).Undo;<N>  result:=0;<N>end;<N><N>
function syn_MarkTextAsSaved(L: PLua_State): integer; cdecl;<N>begin<N>  TCustomSynEdit(luaclass_getClassObject(L)).MarkTextAsSaved;<N>  result:=0;<N>end;<N><N>function syn_ClearSelection(L: PLua_State): integer; cdecl;<N>begin<N>  TCustomSynEdit(luaclass_getClassObject(L)).ClearSelection;<N>  result:=0;<N>end;<N><N>
function syn_SelectAll(L: PLua_State): integer; cdecl;<N>begin<N>  TCustomSynEdit(luaclass_getClassObject(L)).SelectAll;<N>  result:=0;<N>end;<N><N>function syn_getCharWidth(L: PLua_State): integer; cdecl;<N>begin<N>  lua_pushinteger(L, TCustomSynEdit(luaclass_getClassObject(L)).CharWidth);<N>  result:=1;<N>end;<N><N>
function syn_getLineHeight(L: PLua_State): integer; cdecl;<N>begin<N>  lua_pushinteger(L, TCustomSynEdit(luaclass_getClassObject(L)).LineHeight);<N>  result:=1;<N>end;<N><N>procedure luasynedit_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>begin<N>  customcontrol_addMetaData(L, metatable, userdata);<N><N>
unit PointerscanWorker;<N><N>//class responsible for receiving paths and working them out<N><N>{$mode delphi}<N><N>interface<N><N>{$ifdef darwin}<N>uses<N>  macport, Classes, SysUtils, syncobjs, PointerscanStructures, ProcessHandlerUnit, pointervaluelist,<N>  pointeraddresslist, NewKernelHandler, zstream, zstreamext, macportdefines, SyncObjs2, math;<N>{$endif}<N><N>
{$ifdef windows}<N>uses<N>  windows, Classes, SysUtils, syncobjs, PointerscanStructures, ProcessHandlerUnit, pointervaluelist,<N>  pointeraddresslist, NewKernelHandler, zstream, zstreamext;<N>{$endif}<N><N>type<N>  TPointerscanWorker = class (tthread)<N>  private<N><N>
unit frmStructuresNewStructureUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  Registry, LCLType, ExtCtrls, betterControls;<N><N>type<N><N>  { TfrmStructuresNewStructure }<N><N>
  TfrmStructuresNewStructure = class(TForm)<N>    btnCancel: TButton;<N>    btnOk: TButton;<N>    cbUseAutoTypes: TCheckBox;<N>    cbGuessFieldTypes: TCheckBox;<N>    edtGuessSize: TEdit;<N>    edtStructName: TEdit;<N>    labelStructureSize: TLabel;<N>    labelStructureName: TLabel;<N>    Panel1: TPanel;<N>    procedure btnOkClick(Sender: TObject);<N>    procedure FormCreate(Sender: TObject);<N>    procedure FormShow(Sender: TObject);<N><N>
unit AsyncTimer;<N>{<N>Timer like thread that will call a specific notifyevent routiner every specified interval<N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, syncobjs;<N><N>type<N>  TAsyncTimer=class(tthread)<N>  private<N>    fInterval: integer;<N>    fOnTimer: TNotifyEvent;<N>    fOnTimerCS: TCriticalSection;<N>    fEnabled: boolean;<N>    eenabled: TEvent;<N>    timerevent: TEvent;<N><N>
    triggeronce: boolean;<N>    procedure setOnTimer(f: TNotifyEvent);<N>    procedure setEnabled(state: boolean);<N>    procedure setInterval(interval: integer);<N>  public<N>    procedure Terminate;<N>    procedure execute; override;<N>    procedure TriggerNow; //triggers the event<N>    constructor create(suspended: boolean);<N>    destructor destroy; override;<N><N>
    property OnTimer: TnotifyEvent read fOnTimer write setOnTimer;<N>    property Interval: integer read fInterval write setInterval;<N>    property Enabled: boolean read fEnabled write setEnabled;<N>  end;<N><N>implementation<N><N>procedure TAsyncTimer.setEnabled(state: boolean);<N>begin<N>  if state then<N>    eenabled.SetEvent<N>  else<N>    eenabled.ResetEvent;<N><N>
  fEnabled:=state;<N>end;<N><N>procedure TAsyncTimer.setInterval(interval: integer);<N>begin<N>  finterval:=interval;<N>  timerevent.SetEvent; //if the timer was sleeping<N>end;<N><N>procedure TAsyncTimer.setOnTimer(f: TNotifyEvent);<N>begin<N>  fOnTimerCS.Enter;<N>  fOnTimer:=f;<N>  fOnTimerCS.Leave;<N>end;<N><N>
procedure TAsyncTimer.Terminate;<N>begin<N>  setOnTimer(nil);<N>  inherited Terminate;<N><N>  timerevent.SetEvent;<N>  Enabled:=true;<N>end;<N><N>procedure TAsyncTimer.TriggerNow; //triggers the event as soon as possible<N>begin<N>  triggeronce:=true;<N>  timerevent.SetEvent;<N>end;<N><N>
procedure TAsyncTimer.execute;<N>var f: TNotifyEvent;<N>begin<N>  while not terminated do<N>  begin<N>    while (not terminated) and (eenabled.WaitFor(INFINITE)=wrTimeout) do ;<N><N>    while (not terminated) and (timerevent.WaitFor(fInterval)=wrSignaled) and (not triggeronce) do //each time the interval changes this will get signaled. When that happens, wait again<N>      timerevent.ResetEvent;<N><N>
    triggeronce:=false;<N><N>    if not terminated then<N>    begin<N>      try<N>        fOnTimerCS.enter;<N>        try<N>          f:=fOnTimer;<N>        finally<N>          fOnTimerCS.leave;<N>        end;<N><N><N>        if enabled and assigned(f) then<N>          f(self);<N>      except<N>        //on unexpected exceptions don't destroy the timer<N>      end;<N>    end;<N><N>
<N>  end;<N>end;<N><N>constructor TAsyncTimer.create(suspended: boolean);<N>begin<N>  timerevent:=TEvent.create(nil, true, false,'');<N>  eenabled:=TEvent.Create(nil, true, false,'');<N>  fOnTimercs:=TCriticalSection.create;<N><N>  fEnabled:=false;<N>  finterval:=1000;<N><N>
unit LuaHandler;<N><N><N><N>{todo: Split up into smaller units. 9255 lines is becomming too big}<N>{todo2: dll injecting lua into a target process}<N><N><N>{Note:<N>Assume all strings passed between lua are in UTF8 format<N>}<N><N>{$mode delphi}<N><N>interface<N><N>
unit textrender;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, graphics, math, LazUTF8;<N><N>function renderFormattedText(canvas: TCanvas; rect: Trect; x,y: integer; const formattedtext: string): trect;<N><N>implementation<N><N>{$ifdef windows}<N>uses windows;<N>{$endif}<N><N>
{$ifdef DARWIN}<N>uses macport,CocoaAll;<N>{$endif}<N><N>const altfonts: array [0..8] of string=('Consolas','Courier','Courier New','Fixedsys','Terminal','Arial','MS Sans Serif','Comic Sans MS','Wingdings');<N><N>var _8bitcolors:array[0..255] of dword;<N><N>
type TTextState=record<N>  bgcolor: tcolor;<N>  font: tfont;<N>end;<N><N>type<N>  TParsedValueInformation=record<N>    defined: boolean;<N>    value:integer;<N>  end;<N><N>  PParsedValueInformation=^TParsedValueInformation;<N><N><N><N><N>procedure restoreOriginalState(canvas: TCanvas; originalState: TTextState);<N>begin<N>  canvas.font.Assign(originalState.font);<N>  canvas.brush.color:=originalState.bgcolor;<N>end;<N><N>
function readIntegerString(const formattedtext: string; var index: integer): string;<N>begin<N>  result:='';<N>  while index<length(formattedtext) do<N>  begin<N>    if formattedtext[index] in ['0'..'9'] then<N>    begin<N>      result:=result+formattedtext[index];<N>      inc(index);<N>    end<N>    else<N>      exit;<N>  end;<N>end;<N><N>
unit savedscanhandler;<N><N>{$MODE Delphi}<N><N>{<N>12 december 2010: Firsthandler should be renamed to "previousscanhandler" as it's being used for saved scans as well now<N>}<N><N>{<N>First scan handler is a class that will help with scanning the results of the<N>first scan.<N>It'll read the results of the first scan and provides an inteface for the<N>scanroutines for quick lookup of the previous value of a specific address<N>}<N><N>
unit frmSortPointerlistUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin} macport, {$endif}<N>  {$IFDEF windows} windows, {$ENDIF} Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ExtCtrls, PointerscanresultReader, maps, ComCtrls, math, betterControls;<N><N>
type<N><N>  { TfrmSortPointerlist }<N><N>  TPointerListSortThread=class(tthread)<N>  private<N>    procedure sortdone;<N>    procedure sorterror;<N>  public<N>    initialtime: dword;<N>    position, maxposition: qword;<N>    pointerscanresults: TPointerscanresultReader;<N>    callback: TNotifyEvent;<N>    callbackOnError: TNotifyEvent;<N>    column: integer;<N>    error: string;<N>    tempname: string;<N><N>
unit LuaAddresslist;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib, LuaHandler, cefuncproc, commonTypeDefs;<N><N>procedure initializeLuaAddresslist;<N><N>implementation<N><N>uses luaclass, memscan, addresslist, MemoryRecordUnit, LuaWinControl;<N><N>
<N>function addresslist_getCount(L: PLua_State): integer; cdecl;<N>var<N>  addresslist: TAddresslist;<N>begin<N>  addresslist:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, addresslist.Count);<N>  result:=1;<N>end;<N><N>function addresslist_getSelectedRecords(L: PLua_State): integer; cdecl;<N>var<N>  addresslist: TAddresslist;<N>  i: integer;<N>begin<N>  result:=0;<N>  addresslist:=luaclass_getClassObject(L);<N>  if addresslist.SelCount>0 then<N>  begin<N>    lua_newtable(L);<N>    result:=1;<N><N>
    for i:=0 to addresslist.Count-1 do<N>    begin<N>      if addresslist[i].isSelected then<N>      begin<N>        lua_pushinteger(L, i+1);<N>        luaclass_newClass(L, addresslist[i]);<N>        lua_settable(L, -3);<N>      end;<N>    end;<N><N>  end;<N><N>
unit LuaGraphicControl;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Controls, lua, lualib, lauxlib;<N><N>procedure graphiccontrol_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>procedure initializeGraphicControl;<N><N>
implementation<N><N>uses luahandler, luaclass, LuaControl;<N><N>function graphicControl_getCanvas(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  c: TGraphicControl;<N>  i: integer;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  if c.Canvas.handle=0 then<N>    i:=c.Canvas.Pixels[0,0];<N><N>
  luaclass_newClass(L, c.Canvas);<N>  result:=1;<N>end;<N><N>procedure graphiccontrol_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>begin<N>  control_addMetaData(L, metatable, userdata);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'getCanvas', graphicControl_getCanvas);<N>  luaclass_addPropertyToTable(L, metatable, userdata, 'Canvas', graphicControl_getCanvas, nil);<N>end;<N><N>
procedure initializeGraphicControl;<N>begin<N>  lua_register(LuaVM, 'graphicControl_getCanvas', graphicControl_getCanvas);<N>  lua_register(LuaVM, 'graphiccontrol_getCanvas', graphicControl_getCanvas);<N>end;<N><N><N>initialization<N>  luaclass_register(TGraphicControl, graphiccontrol_addMetaData );<N><N>
unit frmModifyRegistersUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows, DBK32functions, vmxfunctions,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, CEDebugger, debughelper, KernelDebugger, CEFuncProc,<N>  NewKernelHandler, symbolhandler, LResources, ExtCtrls, ComCtrls,  math,<N>  BreakpointTypeDef, betterControls, contexthandler;<N><N>
type<N><N>  { TfrmModifyRegisters }<N>  TChangeRegFloatPanel=class(TPanel)<N>  private<N>    id: integer;<N>    lbl: tlabel;<N>    edt: Tedit;<N>    freg: PContextElement_register;<N>    procedure init;<N>  public<N>    constructor Create(AOwner: TComponent; id: integer); overload;<N>    constructor Create(Aowner: TComponent; contextreg: PContextElement_register); overload;<N>    property reg: PContextElement_register read freg;<N>  end;<N><N>
  TChangeRegXMMPanelEdit=class(TPanel)<N>  private<N>    lblstart: tlabel;<N>    lblstop: tlabel;<N>    edt: tedit;<N>  public<N>    procedure setrange(start, stop: integer);<N>    constructor Create(AOwner: TComponent; initialid: integer); overload;<N>  end;<N><N>
unit frmResumePointerscanUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ExtCtrls, ComCtrls, Menus, registry, multilineinputqueryunit, CEFuncProc,<N>  math, types, betterControls;<N><N>
resourcestring<N>  rsRPSIpList = 'IP List';<N>  rsRPSEnterTheIpAddressesToNotifyExplicitly = 'Enter the IP addresses to notify explicitly';<N>  rsRPSWasNotFound = ' was not found';<N>  rsNewPointermap = 'New pointermap';<N>  rsEnterTheAddressThisScanShouldLookFor = 'Enter the address this scan should look for';<N><N>
unit KernelDebuggerInterface;<N><N>{$mode delphi}<N><N>interface<N><N>{$ifdef windows}<N>uses<N>  jwawindows, windows, Classes, SysUtils,cefuncproc, newkernelhandler,<N>  DebuggerInterface,contnrs, syncobjs,maps;<N><N>type<N>  TEventType=(etCreateProcess, etCreateThread, etDestroyThread);<N>  TInjectedEvent=record<N>    eventType: TEventType;<N>    processid: dword;<N>    threadid: dword;<N>  end;<N>  PInjectedEvent=^TInjectedEvent;<N><N>
<N>type<N>  TKernelDebugInterface=class;<N>  TThreadPoller=class(tthread)<N>  private<N>    threadlist: TList;<N><N>    procedure UpdateList;<N>    procedure CreateThreadEvent(threadid: dword);<N>    procedure DestroyThreadEvent(threadid: dword);<N><N>  public<N>    pid: dword;<N>    di: TKernelDebugInterface;<N>    procedure GetCurrentList(list: tlist);<N>    procedure execute; override;<N>  end;<N><N>
  TKernelDebugInterface=class(TDebuggerInterface)<N>  private<N>    pid: DWORD;<N>    currentdebuggerstate: TDebuggerstate;<N><N>    injectedEvents: Tqueue;<N>    injectedEventsCS: TcriticalSection;<N>    threadpoller: TThreadPoller;<N>    NeedsToContinue: boolean;<N>    globalDebug: boolean;<N>    fisInjectedEvent: boolean;<N>    currentthread: THandle;<N><N>
unit frmD3DTrainerGeneratorOptionsUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ComCtrls, ExtCtrls, ExtDlgs, cefuncproc, commonTypeDefs, betterControls;<N><N>
unit LuaXMPlayer;<N>//special case, the class methods don't really care if the class is provided<N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, xmplayer_defines, xmplayer_server, lua, lauxlib, lualib, luafile, LuaHandler;<N><N>procedure initializeLuaXMPlayer;<N><N>
implementation<N><N>uses luaclass, LuaObject;<N><N>function xmplayer_playXM(L: Plua_State): integer; cdecl;<N>var parameters: integer;<N>  lf: TLuaFile;<N>  f: string;<N>  i: integer;<N>  o: TObject;<N>  s: TStream;<N>  noloop: boolean;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if (xmplayer<>nil) and (parameters>=1) then<N>  begin<N>    if parameters>=2 then<N>      noloop:=lua_toboolean(L,2)<N>    else<N>      noloop:=false;<N><N>
    if lua_isuserdata(L,1) then //Object, if the given object is a LuaFile, get the stream. If it's a stream, use it as it is<N>    begin<N>      o:=lua_toceuserdata(L,1);<N>      if o is TStream then<N>        s:=TStream(o)<N>      else<N>      if o is TLuafile then<N>        s:=TLuafile(o).stream<N>      else<N>        exit;<N><N>
      xmplayer.playXM(s, noloop)<N>    end<N>    else<N>      xmplayer.playXM(Lua_ToString(L,1), noloop)<N>  end;<N><N>  lua_pop(L, lua_gettop(L));<N>end;<N><N>function xmplayer_pause(L: Plua_State): integer; cdecl;<N>var parameters: integer;<N>begin<N>  if xmplayer=nil then<N>    xmplayer:=TXMPlayer.create;<N><N>
  result:=0;<N>  lua_pop(L, lua_gettop(L));<N><N>  if xmplayer<>nil then<N>     xmplayer.pause;<N>end;<N><N>function xmplayer_resume(L: Plua_State): integer; cdecl;<N>var parameters: integer;<N>begin<N>  if xmplayer=nil then<N>    xmplayer:=TXMPlayer.create;<N><N>
  result:=0;<N>  lua_pop(L, lua_gettop(L));<N><N>  if xmplayer<>nil then<N>     xmplayer.resume;<N>end;<N><N>function xmplayer_stop(L: Plua_State): integer; cdecl;<N>var parameters: integer;<N>begin<N>  if xmplayer=nil then<N>    xmplayer:=TXMPlayer.create;<N><N>
  result:=0;<N>  lua_pop(L, lua_gettop(L));<N><N>  if (xmplayer<>nil) then<N>    xmplayer.stop();<N>end;<N><N>function xmplayer_isPlaying(L: Plua_State): integer; cdecl;<N>var parameters: integer;<N>begin<N>  if xmplayer=nil then<N>    xmplayer:=TXMPlayer.create;<N><N>
  result:=0;<N>  lua_pop(L, lua_gettop(L));<N><N>  if xmplayer<>nil then<N>  begin<N>    result:=1;<N>    lua_pushboolean(L, xmplayer.isPlaying);<N>  end;<N>end;<N><N>function xmplayer_setVolume(L: Plua_State): integer; cdecl;<N>var parameters: integer;<N>  v: integer;<N>begin<N>  if xmplayer=nil then<N>    xmplayer:=TXMPlayer.create;<N><N>
  result:=0;<N>  parameters:=lua_gettop(L);<N>  if (xmplayer<>nil) and (parameters=1) then<N>  begin<N>    v:=lua_tointeger(L,-1);<N>    xmplayer.setVolume(v);<N>  end;<N><N>  lua_pop(L, lua_gettop(L));<N>end;<N><N>procedure xmplayer_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>begin<N>  object_addMetaData(L, metatable, userdata);<N><N>
unit LuaMemoryView;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  forms, Classes, SysUtils, lua;<N><N>procedure initializeLuaMemoryview;<N><N>implementation<N><N>uses luahandler, luaclass, MemoryBrowserFormUnit;<N><N>function createMemoryView(L: PLua_state): integer; cdecl;<N>begin<N>  luaclass_newClass(L, TMemoryBrowser.Create(application));<N>  result:=1;<N>end;<N><N>
function memoryview_getHexadecimalView(L: PLua_state): integer; cdecl;<N>var m: TMemoryBrowser;<N>begin<N>  m:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, m.hexview);<N>  result:=1;<N>end;<N><N>function memoryview_getDisassemblerView(L: PLua_state): integer; cdecl;<N>var m: TMemoryBrowser;<N>begin<N>  m:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, m.disassemblerview);<N>  result:=1;<N>end;<N><N>
<N>procedure initializeLuaMemoryView;<N>begin<N>  lua_register(LuaVM, 'createMemoryView', createMemoryView);<N>  lua_register(LuaVM, 'memoryview_getDisassemblerView', memoryview_getDisassemblerView);<N>  lua_register(LuaVM, 'memoryview_getHexadecimalView', memoryview_getHexadecimalView);<N><N>
unit LuaCalendar;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib, LuaHandler,<N>  pluginexports, controls, ComCtrls, betterControls;<N><N>procedure initializeLuaCalendar;<N><N>implementation<N><N>uses luaclass, LuaWinControl, Calendar;<N><N>
<N>function createCalendar(L: Plua_State): integer; cdecl;<N>var<N>  Calendar: TCalendar;<N>  parameters: integer;<N>  owner: TWincontrol;<N>begin<N>  result:=0;<N><N>  parameters:=lua_gettop(L);<N>  if parameters>=1 then<N>    owner:=lua_toceuserdata(L, -parameters)<N>  else<N>    owner:=nil;<N><N>
  lua_pop(L, lua_gettop(L));<N><N>  Calendar:=TCalendar.Create(owner);<N>  if owner<>nil then<N>    Calendar.Parent:=owner;<N><N>  luaclass_newClass(L, Calendar);<N>  result:=1;<N>end;<N><N>function setFormat(s:string): string;<N>begin<N>    if (uppercase(s)='LOCALSHORT') or (s='') then<N>      result:=FormatSettings.ShortDateFormat<N>    else if (uppercase(s)='LOCALLONG') then<N>      result:=FormatSettings.LongDateFormat<N>    else<N>      result:=s;<N>end;<N><N>
function StrToDateGuessSep(s,f :string): TDateTime;<N>var date: TDateTime;<N>begin<N>  try<N>    date:=StrToDate(s,f,'-');<N>  except<N>      try<N>        date:=StrToDate(s,f,'/');<N>      except<N>        date:=StrToDate(s,f,'.');<N>      end;<N>  end;<N>  result:=date;<N>end;<N><N>
function calendar_getDateLocalFormat(L: PLua_State): integer; cdecl;<N>var<N>  cal: TCalendar;<N>begin<N>  cal:=luaclass_getClassObject(L);<N>  lua_pushstring(L, AnsiToUtf8(cal.Date) );<N>  result:=1;<N>end;<N><N>function calendar_getDate(L: PLua_State): integer; cdecl;<N>var<N>  cal: TCalendar;<N>  s: string;<N>begin<N>  cal:=luaclass_getClassObject(L);<N>  DateTimeToString(s,'yyyy-mm-dd',cal.DateTime);<N>  lua_pushstring(L, AnsiToUtf8(s) );<N>  result:=1;<N>end;<N><N>
function calendar_setDate(L: PLua_State): integer; cdecl;<N>var<N>  cal: TCalendar;<N>  s: string;<N>begin<N>  result:=0;<N>  cal:=luaclass_getClassObject(L);<N>  if lua_gettop(l)>=1 then<N>  begin<N>    s:=Lua_ToString(L, -1);<N>    cal.DateTime:=StrToDate(s,'yyyy-mm-dd','-');<N>  end;<N>end;<N><N>
function calendarDiffDays(L: PLua_state): integer; cdecl;<N>var s, format: string;<N>    parameters: integer;<N>    number: integer;<N>begin<N>  result:=1;<N>  parameters:=lua_gettop(L);<N><N>  if parameters>=2 then<N>  begin<N>    if parameters=3 then format:=setFormat( Lua_ToString(L,3) )<N>    else                 format:='yyyy-mm-dd';<N><N>
    s:=Lua_ToString(L, 1);<N>    number:=trunc( StrToDateGuessSep(s,format) );<N>    s:=Lua_ToString(L, 2);<N>    number:=number - trunc( StrToDateGuessSep(s,format) );<N>    lua_pushinteger(L, number);<N>  end<N>  else<N>    raise exception.create(rsIncorrectNumberOfParameters);<N>end;<N><N>
function calendarDateToNumber(L: PLua_state): integer; cdecl;<N>var s, format: string;<N>    parameters: integer;<N>begin<N>  result:=1;<N>  parameters:=lua_gettop(L);<N><N>  if parameters>=1 then<N>  begin<N>    if parameters=2 then format:=setFormat( Lua_ToString(L,2) )<N>    else                 format:='yyyy-mm-dd';<N><N>
    s:=Lua_ToString(L, 1);<N>    lua_pushinteger(L, trunc( StrToDateGuessSep(s,format)) );<N>  end<N>  else<N>    raise exception.create(rsIncorrectNumberOfParameters);<N>end;<N><N>function calendarNumberToDate(L: PLua_state): integer; cdecl;<N>var s, format: string;<N>    parameters: integer;<N>begin<N>  result:=1;<N>  parameters:=lua_gettop(L);<N><N>
  if parameters>=1 then<N>  begin<N>    if parameters=2 then format:=setFormat( Lua_ToString(L,2) )<N>    else                 format:='yyyy-mm-dd';<N><N>    DateTimeToString(s, format, Lua_ToInteger(L, 1));<N>    lua_pushstring(L, AnsiToUtf8(s) );<N>  end<N>  else<N>    raise exception.create(rsIncorrectNumberOfParameters);<N>end;<N><N>
procedure Calendar_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>begin<N>  wincontrol_addMetaData(L, metatable, userdata);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'getDateLocalFormat', calendar_getDateLocalFormat);<N>  luaclass_addPropertyToTable(L, metatable, userdata, 'Date', calendar_getDate, calendar_setDate);<N>end;<N><N>
procedure initializeLuaCalendar;<N>begin<N>  lua_register(LuaVM, 'createCalendar', createCalendar);<N>  lua_register(LuaVM, 'calendarDiffDays', calendarDiffDays);<N>  lua_register(LuaVM, 'calendarDateToNumber', calendarDateToNumber);<N>  lua_register(LuaVM, 'calendarNumberToDate', calendarNumberToDate);<N>end;<N><N>
unit frmProcessWatcherUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N><N>  {$ifdef windows}<N>  jwawindows, windows, kerneldebugger, CEDebugger, CEFuncProc, symbolhandler, debugHelper, NewKernelHandler, syncobjs,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, ExtCtrls, ComCtrls, StdCtrls, Menus, LResources, betterControls;<N><N>
unit Globals;<N><N>{<N>This unit will hold some global variables (previously cefuncproc.pas)<N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, commonTypeDefs, syncobjs, Graphics, betterControls;<N><N>//type TUnexpectedExceptionAction=(ueaIgnore, ueaBreak, ueaBreakIfInRegion);<N><N>
var<N>//  AllIncludesCustomType: boolean;<N><N>  mtid: TThreadID;<N><N>  overridefont: TFont;<N>  aprilfools: boolean;<N><N>  ScanAllTypes: TVariableTypes=[vtDword, vtSingle, vtDouble];<N><N>  buffersize: dword=512*1024;<N><N>  Skip_PAGE_NOCACHE: boolean=false;<N>  Skip_PAGE_WRITECOMBINE: boolean=true;<N>  Scan_MEM_PRIVATE: boolean=true;<N>  Scan_MEM_IMAGE: boolean=true;<N>  Scan_MEM_MAPPED: boolean=false;<N><N>
  repeatDelay: integer=0;<N>  delayAfterDebuggerAttach: dword=0;<N><N>  scan_dirtyonly: boolean=true;<N>  scan_pagedonly: boolean=true;<N>  fetchSymbols: boolean=true;   //set to false if you don't want the symbols to get enumerated<N><N>  networkRPMCacheTimeout: single=1.0;<N><N>
  systemtype: integer;<N>  {$if defined(CPU386) or defined(CPUX86_64)}<N>  old8087CW: word;  //you never know...<N>  {$endif}<N>  ProcessSelected: Boolean;<N>  //ProcessID: Dword; //deperecated<N>  //ProcessHandle: Thandle;<N><N><N><N><N><N>  TablesDir: string;<N>  CheatEngineDir: String;<N>  WindowsDir: string;<N><N>
  username: string;<N><N>//scanhelpers<N>  nrofbits: integer;<N>  Bitscan: array of byte;<N>  tempbits: array of byte;<N><N>  bitoffsetchange: integer;<N><N><N>  foundaddressB: array of TBitAddress;<N>  foundaddressBswitch: array of TBitAddress;<N><N><N>  tempbytearray: array of byte;<N>  tempwordarray: array of word;<N>  tempdwordarray: array of dword;<N>  tempsinglearray: array of single;<N>  tempdoublearray: array of double;<N>  tempint64array: array of int64;<N><N>
unit frmAAEditPrefsUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ExtCtrls, LResources, SynEdit, synedittypes, betterControls;<N><N>type<N><N>  { TfrmAAEditPrefs }<N><N>
unit LuaTreeview;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, ComCtrls, lua, luaclass, Controls, LuaWinControl, betterControls;<N><N>procedure initializeLuaTreeview;<N><N>implementation<N><N>uses LuaHandler, lauxlib, ceguicomponents;<N><N>
function createTreeView(L: Plua_State): integer; cdecl;<N>var<N>  Treeview: TCETreeview;<N>  owner: TWincontrol;<N>begin<N>  if lua_gettop(L)=1 then<N>    owner:=lua_toceuserdata(L, 1)<N>  else<N>    owner:=nil;<N><N>  Treeview:=TCETreeview.Create(owner);<N><N>
  if owner<>nil then<N>    Treeview.Parent:=owner;<N><N>  luaclass_newClass(L, Treeview);<N>  result:=1;<N><N>end;<N><N>function treeview_getItems(L: PLua_State): integer; cdecl;<N>var<N>  Treeview: TCETreeview;<N>begin<N>  Treeview:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, Treeview.Items);<N>  result:=1;<N>end;<N><N>
function treeview_getSelected(L: PLua_State): integer; cdecl;<N>var<N>  Treeview: TCETreeview;<N>begin<N>  Treeview:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, Treeview.Selected);<N>  result:=1;<N>end;<N><N>function treeview_setSelected(L: PLua_State): integer; cdecl;<N>var<N>  Treeview: TCETreeview;<N>begin<N>  Treeview:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=1 then<N>    Treeview.Selected:=lua_ToCEUserData(L, 1);<N><N>
  result:=0;<N>end;<N><N>function treeview_fullCollapse(L: PLua_State): integer; cdecl;<N>begin<N>  TCETreeview(luaclass_getClassObject(L)).FullCollapse;<N>  result:=0;<N>end;<N><N>function treeview_fullExpand(L: PLua_State): integer; cdecl;<N>begin<N>  TCETreeview(luaclass_getClassObject(L)).FullExpand;<N>  result:=0;<N>end;<N><N>
function treeview_beginUpdate(L: PLua_State): integer; cdecl;<N>begin<N>  TCETreeview(luaclass_getClassObject(L)).BeginUpdate;<N>  result:=0;<N>end;<N><N>function treeview_endUpdate(L: PLua_State): integer; cdecl;<N>begin<N>  TCETreeview(luaclass_getClassObject(L)).EndUpdate;<N>  result:=0;<N>end;<N><N>
unit DotNetPipe;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>{$ifdef jni}<N>//mainly for some defines for easy compilation<N>uses unixporthelper, Unix, Classes, SysUtils, syncobjs, NewKernelHandler, Globals;<N><N>{$else}<N>uses<N>  {$ifdef darwin}<N>  macport, mactypes,<N>  {$endif}<N>  {$ifdef windows}<N>  jwawindows, windows,<N>  {$endif}<N>  Classes, SysUtils, CEFuncProc, syncobjs, guisafecriticalsection, NewKernelHandler, Globals, maps;<N>{$endif}<N><N>
<N><N><N><N><N><N>type<N>  TDotNetDomain=record<N>    hDomain: uint64;<N>    name: widestring;<N>  end;<N>  TDotNetDomainArray=array of TDotNetDomain;<N><N>  TDotNetModule=record<N>    hModule: uint64;<N>    baseaddress: uint64;<N>    name: widestring;<N>  end;<N>  TDotNetModuleArray=array of TDotNetModule;<N><N>
  TDotNetTypeDef=record<N>    token: dword;<N>    name: widestring;<N>    flags: dword;<N>    extends: dword;<N>  end;<N>  TDotNetTypeDefArray=array of TDotNetTypeDef;<N><N>  TNativeCode=record<N>    address: uint64;<N>    size: dword;<N>  end;<N><N>  TDotNetMethod=record<N>    token: dword;<N>    name: widestring;<N><N>
    attributes: dword;<N>    implflags: dword;<N><N>    ILCOde: uint64;<N>    NativeCode: uint64;<N>    SecondaryNativeCode: array of TNativeCode;<N>  end;<N><N>  TDotNetMethodArray=array of TDotNetMethod;<N><N>  TDotNetMethodParameter=record<N>    name: widestring;<N>    ctype: dword;<N>    sequencenr: dword;<N>  end;<N><N>
  TDotNetMethodParameters=array of TDotNetMethodParameter;<N><N>  TTypeDefInfo=record<N>    token: dword;<N>    module: uint64;<N>  end;<N><N>  TFieldInfo=record<N>    token: dword;<N>    offset: dword;<N>    fieldtype: dword;<N>    name: widestring;<N>    fieldTypeClassName: widestring;<N>    attribs: dword;<N>    isStatic: boolean;<N>  end;<N><N>
  TTypeData=record<N>    objecttype: dword;<N>    elementtype: dword; //the data type of elements if this is an array<N>    countoffset, elementsize, firstelementoffset: ulong32; //misc data for objecttype = array or szarray<N><N>    classname: widestring;<N>    fields: array of TFieldInfo;<N>  end;<N>  PTypeData=^TTypeData;<N><N>
<N>  TAddressData=record<N>    startaddress: ptruint;<N>    typedata: TTypeData;<N>  end;<N><N>  type COR_TYPEID=record<N>    token1: QWORD;<N>    token2: QWORD;<N>  end;<N><N>  TDotNetObject=record<N>    startaddress: qword;<N>    size: dword;<N>    typeid: COR_TYPEID;<N>    classname: pwidechar;<N>  end;<N>  PDotNetObject=^TDotNetObject;<N><N>
  TDOTNETObjectList=tmap;<N><N>  TDotNetPipe=class<N>  private<N>    pipe: THandle;<N>    fConnected: boolean;<N>    fAttached: boolean;<N>    fSupportsDotNet4_5: boolean;<N><N>    pHandle: THandle;<N>    pipecs: TGuiSafeCriticalSection;  //guisafecriticalsection?<N>    procedure Read(var o; size: integer);<N>    procedure Write(const o; size: integer);<N>    procedure ReadTypeData(var typedata: TTypeData);<N>  public<N>    constructor create;<N>    destructor destroy; override;<N><N>
// Copyright Cheat Engine. All Rights Reserved.<N><N><N>unit Assemblerunit;<N><N>//todo: case<N><N>{$MODE Delphi}<N><N><N><N>interface<N><N>{$ifdef jni}<N>uses  sysutils, ProcessHandlerUnit;<N>{$else}<N>uses<N>  dialogs,LCLIntf,sysutils{$ifdef windows},imagehlp{$endif}, ProcessHandlerUnit,vextypedef;<N>{$endif}<N><N>
unit frmTracerUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, macportdefines,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  NewKernelHandler, LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ExtCtrls, Buttons, LResources, commonTypeDefs, frmFindDialogUnit,<N>  Menus, ComCtrls, frmStackviewunit, frmFloatingPointPanelUnit, disassembler,<N>  debuggertypedefinitions, betterControls, LastDisassembleData;<N><N>
type<N>  TTraceDebugInfo=class<N>  private<N>  public<N>    cr3:qword;<N>    instruction: string;<N>    instructionsize: integer;<N>    referencedAddress: ptrUint;<N>    c: _CONTEXT;<N>    bytes: pbytearray;<N>    bytesize: PtrUInt;<N>    isfloat: boolean;<N><N>
    stack: record<N>      savedsize: PtrUInt;<N>      stack: pbyte;<N>    end;<N><N>    compareindex: integer;<N><N><N><N>    function datatype: TVariableType;<N>    procedure fillbytes(datasize: integer);<N>    procedure savestack;<N>    procedure saveToStream(s: tstream);<N>    constructor createFromStream(s: tstream);<N>    destructor destroy; override;<N>  end;<N><N>
  TDBVMStatusUpdater=class(TPanel)<N>  private<N>    found: TLabel;<N>    progressbar: TProgressbar;<N>    cancelButton: TButton;<N>    timer: TTimer;<N>    procedure CancelAndGetResultClick(sender: TObject);<N>    procedure checkDBVMTracerStatus(sender: TObject);<N>  public<N>    OnTraceDone: TNotifyEvent;<N>    constructor Create(TheOwner: TComponent); override;<N>  end;<N><N>
unit CELazySocket;<N>{<N>Just some functions to make sockets easier<N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef windows}<N>  windows, Classes, SysUtils, Sockets, winsock, ssockets, NewKernelHandler, syncobjs2;<N>  {$endif}<N>  {$ifdef darwin}<N>  Classes, SysUtils, Sockets, ssockets, NewKernelHandler, ctypes, baseunix, macport;<N>  {$endif}<N><N>
unit StructuresAddElementfrm;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, LResources, betterControls;<N><N>resourcestring<N>  rsSAE4Bytes = '4 Bytes';<N>  rsSAE2Bytes = '2 Bytes';<N><N>
unit HotkeyHandler;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, machotkeys,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N><N>  LCLType,LCLIntf,classes,sysutils, SyncObjs,CEFuncProc,messages,genericHotkey, math,<N>  commonTypeDefs;<N><N>
type thotkeyitem=record<N>  {$ifdef darwin}<N>  machk: pointer; //needed for unregister<N>  {$endif}<N>  keys: TKeyCombo;<N>  windowtonotify: thandle;<N>  id: integer;<N>  memrechotkey: pointer; //if set this gets passed down to the hotkey handler in the message<N>  genericHotkey: TGenericHotkey;<N><N>
  //extra<N>  fuModifiers: word;<N>  uVirtKey:word;<N>  handler2:boolean;<N>  lastactivate: dword; //determines when the last time this hotkey was activated<N>  delayBetweenActivate: integer; //If not 0 this is a userdefined delay for a hotkey, so you have have fast responding and slow responding hotkeys at the same time<N>end;<N><N>
type<N>  PHotkeyItem=^THotkeyItem;<N><N>  THotkeyThreadState=(htsActive=0, htsMemrecOnly=1, htsNoMemrec=2, htsDisabled=3);<N><N><N>  Thotkeythread=class(tthread)<N>  private<N>    memrechk: pointer;<N>    generichk: TGenericHotkey;<N>    fstate: THotkeyThreadState;<N><N>
    mainformhotkey2command: integer;<N><N>    procedure memrechotkey;<N>    procedure memrechotkeydisable;<N>    procedure handleGenericHotkey;<N>    procedure mainformhotkey2;<N>  public<N>    suspended: boolean;<N>    hotkeylist: array of thotkeyitem;<N>    procedure execute; override;<N>    constructor create(suspended: boolean);<N>  published<N>    property state: THotkeyThreadState read fState write fState;<N>end;<N><N>
unit LuaRadioGroup;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, Controls, ExtCtrls, SysUtils;<N><N>procedure initializeLuaRadioGroup;<N><N>implementation<N><N>uses lua, lualib, lauxlib, LuaHandler, ceguicomponents, LuaCaller, LuaGroupbox, LuaClass, betterControls;<N><N>
function createRadioGroup(L: Plua_State): integer; cdecl;<N>var<N>  RadioGroup: TCERadioGroup;<N>  parameters: integer;<N>  owner: TWincontrol;<N>begin<N>  result:=0;<N><N>  parameters:=lua_gettop(L);<N>  if parameters>=1 then<N>    owner:=lua_toceuserdata(L, -parameters)<N>  else<N>    owner:=nil;<N><N>
  lua_pop(L, lua_gettop(L));<N><N><N>  RadioGroup:=TCERadioGroup.Create(owner);<N>  if owner<>nil then<N>    RadioGroup.Parent:=owner;<N><N>  luaclass_newClass(L, RadioGroup);<N>  result:=1;<N>end;<N><N>function radiogroup_getRows(L: PLua_State): integer; cdecl;<N>var<N>  radiogroup: TCustomRadioGroup;<N>begin<N>  radiogroup:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, radiogroup.Rows);<N>  result:=1;<N>end;<N><N>
function radiogroup_getItems(L: PLua_State): integer; cdecl;<N>var<N>  radiogroup: TCustomRadioGroup;<N>begin<N>  radiogroup:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, radiogroup.items);<N>  result:=1;<N>end;<N><N>function radiogroup_getColumns(L: PLua_State): integer; cdecl;<N>var<N>  radiogroup: TCustomRadioGroup;<N>begin<N>  radiogroup:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, radiogroup.Columns);<N>  result:=1;<N>end;<N><N>
function radiogroup_setColumns(L: PLua_State): integer; cdecl;<N>var<N>  radiogroup: Tcustomradiogroup;<N>begin<N>  result:=0;<N>  radiogroup:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=1 then<N>    radiogroup.Columns:=lua_tointeger(L,-1);<N>end;<N><N>
<N>function radiogroup_getItemIndex(L: PLua_State): integer; cdecl;<N>var<N>  radiogroup: TCustomRadioGroup;<N>begin<N>  radiogroup:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, radiogroup.ItemIndex);<N>  result:=1;<N>end;<N><N>function radiogroup_setItemIndex(L: PLua_State): integer; cdecl;<N>var<N>  radiogroup: Tcustomradiogroup;<N>begin<N>  result:=0;<N>  radiogroup:=luaclass_getClassObject(L);<N><N>
  if lua_gettop(L)>=1 then<N>    radiogroup.ItemIndex:=lua_tointeger(L,-1);<N>end;<N><N>function radiogroup_getonclick(L: PLua_State): integer; cdecl;<N>var<N>  c: TCustomRadioGroup;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  LuaCaller_pushMethodProperty(L, TMethod(c.OnClick), 'TNotifyEvent');<N>  result:=1;<N>end;<N><N>
function radiogroup_setonClick(L: PLua_State): integer; cdecl; //for some reason the radiogroup has it's own fonclick variable<N>var<N>  control: TCustomRadioGroup;<N>  f: integer;<N>  routine: string;<N><N>  lc: TLuaCaller;<N>begin<N>  result:=0;<N>  control:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>  begin<N>    CleanupLuaCall(tmethod(control.onClick));<N>    control.onClick:=nil;<N><N>
    if lua_isfunction(L,-1) then<N>    begin<N>      routine:=Lua_ToString(L,-1);<N>      f:=luaL_ref(L,LUA_REGISTRYINDEX);<N><N>      lc:=TLuaCaller.create;<N>      lc.luaroutineIndex:=f;<N>      control.OnClick:=lc.NotifyEvent;<N>    end<N>    else<N>    if lua_isstring(L,-1) then<N>    begin<N>      routine:=lua_tostring(L,-1);<N>      lc:=TLuaCaller.create;<N>      lc.luaroutine:=routine;<N>      control.OnClick:=lc.NotifyEvent;<N>    end;<N><N>
unit frmThreadlistunit;<N><N>{$MODE Delphi}<N>{$warn 4056 off}<N>{$warn 4082 off}<N><N>interface<N><N>uses<N>  {$ifdef windows}<N>  jwawindows, windows,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, ComCtrls, Menus, StdCtrls, LResources,cefuncproc, CEDebugger, debugHelper,<N>  newkernelhandler, networkInterface, NetworkDebuggerInterface, networkInterfaceApi, betterControls  {$ifdef darwin}<N>  ,macport, macportdefines<N>  {$endif}  ;<N><N>
unit assemblerArm;<N><N>{$mode objfpc}{$H+}<N>{$warn 2005 off}<N><N>interface<N><N><N>{$ifdef jni}<N>uses classes, SysUtils, StrUtils, assemblerunit, symbolhandler;<N>{$else}<N>uses<N>  Classes, SysUtils, strutils{$ifndef ARMDEV}, assemblerunit{$endif}, dialogs,<N>  symbolhandler;<N>{$endif}<N><N>
// Copyright Cheat Engine. All Rights Reserved.<N><N>unit memscan;<N><N>{$MODE Delphi}<N><N>{<N>This unit will hold the class object used to control scanning<N>The old scanning routines will be moved out of cefuncproc and made object oriented into this class<N>Special care should be taken to add multithreaded scanning routines<N>}<N><N>
unit diagramblock;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Controls, types, DiagramTypes, Graphics, textrender,<N>  ComCtrls{$ifdef windows}, gl, glext{$endif}, betterControls;<N><N>type<N><N>  TDiagramBlock=class;<N>  TDiagramBlockSideDescriptor=record<N>    block: TDiagramBlock;<N>    side: TDiagramBlockSide;<N>    sideposition: integer; //0 is center, -1 is one pixel to the left, 1 is one pixel to the rigth<N>  end;<N><N>
  TDBCustomDrawEvent=procedure(Sender: TDiagramBlock; const ARect: TRect; beforePaint: boolean; var DefaultDraw: Boolean) of object;<N><N>  TDiagramBlock=class<N>  private<N>    fx,fy: integer;<N>    fwidth: integer;<N>    fheight: integer;<N><N>    fname: string;<N>    fcaption: string;<N><N>
    fOnDoubleClickHeader: TNotifyEvent;<N>    fOnDoubleClickBody: TNotifyEvent;<N>    fOnRenderHeader: TDBCustomDrawEvent;<N>    fOnRenderBody: TDBCustomDrawEvent;<N><N>    data: TStringList;<N><N>    captionheight: integer;<N>    config: TDiagramConfig;<N>    fOnDestroy: TNotifyEvent;<N><N>
    useCustomBackgroundColor: boolean;<N>    customBackgroundColor: tcolor;<N><N>    useCustomTextColor: boolean;<N>    CustomTextColor: Tcolor;<N><N>    fAutoSide: boolean;<N>    fAutoSideDistance: integer;<N><N>    fAutoSize: boolean;<N>    preferedWidth, preferedHeight: integer;<N><N>
    hasChanged: boolean;<N>    cachedBlock: TBitmap; //Cache the block image and only update when changes happen<N>    {$ifdef windows}<N>    ftexture: glint;<N>    {$endif}<N><N><N>    fBlockId: integer;<N>    fShowHeader: boolean;<N>    fDragbody: boolean;<N>    fOnDrag: TNotifyEvent;<N>    fOnDragStart: TNotifyEvent;<N>    fOnDragEnd: TNotifyEvent;<N><N>
<N>    fTag: qword;<N><N>    function getBackgroundColor: TColor;<N>    procedure setBackgroundColor(c: TColor);<N>    function getTextColor: TColor;<N>    procedure setTextColor(c: TColor);<N>    function getCanvas: TCanvas;<N>    function getOwner: TCustomControl;<N>    procedure setCaption(c: string);<N><N>
    procedure setWidth(w: integer);<N>    procedure setHeight(h: integer);<N><N>    procedure DataChange(sender: TObject);<N><N>    procedure setx(newx: integer);<N>    procedure sety(newy: integer);<N>    function getRect: trect;<N>    procedure setRect(r: trect);<N><N>
unit NetworkDebuggerInterface;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N><N>  {$ifdef windows}<N>  jwawindows, windows,<N>  {$endif}<N>  Classes, SysUtils,cefuncproc, newkernelhandler,<N>  DebuggerInterface, networkInterface, networkInterfaceApi, contnrs{$ifdef darwin},macport, macportdefines{$endif};<N><N>
unit KernelDebugger;<N><N>{obsolete}<N><N>{$MODE Delphi}<N><N>interface<N><N>uses classes, sysutils;<N><N><N>implementation<N><N>end.<N>
unit frmExeTrainerGeneratorUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, math, LCLIntf,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, FileUtil, LResources, Forms, Controls, Graphics,<N>  ExtCtrls, dialogs, StdCtrls, ComCtrls, Menus, CEFuncProc, IconStuff, zstream,<N>  registry, MainUnit2, symbolhandler, lua, lualib, lauxlib, betterControls;<N><N>
unit frmDebugEventsUnit; <N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, LResources, Forms, Controls, Graphics, Dialogs,<N>  StdCtrls, ExtCtrls, Menus, newkernelhandler{$ifdef darwin},macport{$endif}, betterControls;<N><N><N>type<N>  TDebugEventData=record<N>    context: TContext;<N>  end;<N>  PDebugEventData=^TDebugEventData;<N><N>
unit formhotkeyunit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, LResources, ExtCtrls, LCLType, betterControls;<N><N>
unit libipt;<N><N>{$mode DELPHI}<N><N>interface<N><N>uses<N>  {$ifdef windows}<N>  Windows,<N>  {$endif}<N>  {$ifdef darwin}<N>  macport, dynlibs, mactypes,<N>  {$endif}<N>  Classes, SysUtils;<N><N>const<N>  pt_asid_no_cr3  = QWORD($ffffffffffffffff);<N>  pt_asid_no_vmcs = QWORD($ffffffffffffffff);<N>  pt_max_insn_size= 15;<N><N>
type<N>  pt_error_code = (pte_ok,pte_internal,pte_invalid,pte_nosync,<N>        pte_bad_opc,pte_bad_packet,pte_bad_context,<N>        pte_eos,pte_bad_query,pte_nomem,pte_bad_config,<N>        pte_noip,pte_ip_suppressed,pte_nomap,<N>        pte_bad_insn,pte_no_time,pte_no_cbr,<N>        pte_bad_image,pte_bad_lock,pte_not_supported,<N>        pte_retstack_empty,pte_bad_retcomp,<N>        pte_bad_status_update,pte_no_enable,<N>        pte_event_ignored);<N><N>
  {$PACKENUM  4}<N>  pt_insn_class = (ptic_error,ptic_other,ptic_call,ptic_return,<N>          ptic_jump,ptic_cond_jump,ptic_far_call,<N>          ptic_far_return,ptic_far_jump);<N>  {$PACKENUM DEFAULT}<N><N>  pt_exec_mode = (ptem_unknown,ptem_16bit,ptem_32bit,ptem_64bit);<N><N>
  PPT_Image=pointer;<N>  Ppt_encoder = pointer;<N>  Ppt_packet_decoder = pointer;<N><N>  Ppt_query_decoder = pointer;<N><N>  Ppt_insn_decoder = pointer;<N><N>  Ppt_packet_unknown = pointer;<N><N><N>  TPT_ASID=record<N>    size: SIZE_T;<N>    cr3:  uint64;<N>    vmcs: uint64;<N>  end;<N>  PPT_ASID=^TPT_ASID;<N><N>
unit frmFindstaticsUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  jwawindows, windows,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ExtCtrls, ComCtrls,disassembler,CEFuncProc,NewKernelHandler,<N>  {tlhelp32,}symbolhandler, LResources, commonTypeDefs, betterControls;<N><N>
type TStaticlist=record<N>  s: ptrUint;<N>  isstruct: boolean;<N>  referencecount: dword;<N>  //referals: array of dword;<N>end;<N><N>type TUpdateType= (AddEntry,UpdateEntry);<N><N>type TStaticscanner = class (TThread)<N>  private<N>    updatetype: TUpdateType;<N>    updateline: integer; //not used for addentry<N><N>
    memoryregion: array of tmemoryregion;<N>    procedure UpdateList;<N>    procedure done;<N>  public<N>    filterstart:ptrUint;<N>    filterstop:ptrUint;<N>    startaddress: ptrUint;<N>    stopaddress: ptrUint;<N>    onlyexecutable: boolean;<N>    progressbar: TProgressbar;<N>    procedure execute; override;<N>  end;<N><N>
unit HotKeys;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, LCLType, math, machotkeys,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, Buttons, registry, CEFuncProc, ExtCtrls, LResources,<N>  comCtrls, menus, hotkeyhandler, MemoryRecordUnit, commonTypeDefs, strutils, betterControls, LMessages;<N><N>
unit frmPointerscanConnectDialogUnit;<N>{OBSOLETE}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ExtCtrls, Sockets, resolve, CEFuncProc;<N><N>type<N><N>  { TfrmPointerscanConnectDialog }<N><N>
unit vextypedef;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>  TVEX3Byte=bitpacked record<N>    mmmmm: 0..31;<N>    B: 0..1;<N>    X: 0..1;<N>    R: 0..1;<N>    pp: 0..3;<N>    L: 0..1;<N>    vvvv: 0..15;<N>    W: 0..1;<N>  end;<N>  PVEX3Byte=^TVEX3Byte;<N><N>  TVEX2Byte=bitpacked record<N>    pp: 0..3;<N>    L: 0..1;<N>    vvvv: 0..15;<N>    R: 0..1;<N>  end;<N>  PVex2Byte=^TVex2Byte;<N><N>implementation<N><N>end.<N><N>
unit frmHotkeyExUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs,<N>  StdCtrls, ExtCtrls, cefuncproc, commonTypeDefs, betterControls;<N><N>
type<N><N>  { TfrmHotkeyEx }<N><N>  TfrmHotkeyEx = class(TForm)<N>    Button1: TButton;<N>    Button2: TButton;<N>    Button3: TButton;<N>    edtHotkey: TEdit;<N>    Label1: TLabel;<N>    Panel1: TPanel;<N>    procedure Button3Click(Sender: TObject);<N>    procedure edtHotkeyKeyDown(Sender: TObject; var Key: Word;<N>      Shift: TShiftState);<N>  private<N>    { private declarations }<N>  public<N>    { public declarations }<N>    newhotkey: tkeycombo;<N>  end; <N><N>
<N><N>implementation<N><N>{$R *.lfm}<N><N>{ TfrmHotkeyEx }<N><N>procedure TfrmHotkeyEx.edtHotkeyKeyDown(Sender: TObject; var Key: Word;<N>  Shift: TShiftState);<N>var i: integer;<N>begin<N>  if newhotkey[4]=0 then<N>  begin<N>    for i:=0 to 4 do<N>      if newhotkey[i]=0 then<N>      begin<N>        newhotkey[i]:=key;<N>        break;<N>      end else<N>      if newhotkey[i]=key then break;<N>  end;<N><N>
  edtHotkey.Text:=ConvertKeyComboToString(newhotkey);<N>end;<N><N>procedure TfrmHotkeyEx.Button3Click(Sender: TObject);<N>begin<N>  ZeroMemory(@newhotkey, sizeof(newhotkey));<N>  edtHotkey.Text:=ConvertKeyComboToString(newhotkey);<N>end;<N><N>end.<N><N><N><N>
unit DisassemblerThumb;<N><N>{$mode objfpc}{$H+}<N><N>{<N>This disassembler is build based on the information in chapter F of the ARM DDI 0487A.e ID121714 Documentation<N><N>it's main purpose is to give an basic overview of what is going on.<N>And yes, this can require a bit of refactoring<N>}<N><N>
unit DebuggerInterfaceAPIWrapper;<N>{<N>This unit hold the DebuggerInterface currently used, and overrides the default windows debug api's so they make use of the DebuggerInterface's version<N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, {$ifdef windows}windows,{$endif} debuggerinterface, newkernelhandler{$ifdef darwin}, macport, macportdefines{$endif};<N><N>
unit WindowsDebugger;<N>{<N>Debugger interface for the default windows api.<N>It's basically just a forward for everything<N>}<N><N>{$mode delphi}<N><N>interface<N><N>{$ifdef windows}<N><N>uses<N>  Classes, SysUtils, DebuggerInterface, windows, cefuncproc,newkernelhandler,<N>  symbolhandler, dialogs;<N><N>
unit frmStackViewUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  cefuncproc, newkernelhandler, Classes, SysUtils, FileUtil, LResources,<N>  Forms, Controls, Graphics, Dialogs, StdCtrls, Menus, stacktrace2, Clipbrd, ComCtrls,<N>  strutils, frmSelectionlistunit, maps, betterControls;<N><N>
unit DBK64SecondaryLoader;<N><N>{$mode delphi}<N><N>interface<N><N>{$IFDEF windows}<N>uses<N>  jwawindows, windows, Classes, SysUtils, cefuncproc, NewKernelHandler, dialogs;<N><N>function SecondaryDriverLoad: THandle;<N>function SecondaryDeviceIoControl(dwIoControlCode: DWORD; lpInBuffer: Pointer; nInBufferSize: DWORD; lpOutBuffer: Pointer; nOutBufferSize: DWORD; var lpBytesReturned: DWORD; lpOverlapped: POverlapped): BOOL; stdcall;<N>{$ENDIF}<N><N>
unit networkInterfaceApi;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  {$ifdef windows}<N>  jwawindows, windows,<N>  {$endif}<N>  Classes, SysUtils, networkInterface, NewKernelHandler, CEFuncProc<N>  {$ifdef JNI}<N>  ,unixporthelper, newkernelhandler;<N>  {$else}<N>  {$ifdef darwin}<N>  ,mactypes, macport, macportdefines, dialogs;<N>  {$endif}<N>  {$ifdef windows}<N>  ,dialogs;<N>  {$endif}<N><N>
unit LuaRemoteThread;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils,lua, lualib, lauxlib,LuaHandler, LCLType;<N><N><N>  procedure initializeLuaRemoteThread;<N><N>implementation<N><N>uses<N>  {$ifdef darwin}macport,pthreads, macCreateRemoteThread, {$endif}<N>  {$ifdef windows}windows,{$endif}<N>  ProcessHandlerUnit, LuaClass, LuaObject, NewKernelHandler;<N><N>
type<N>  TRemoteThread=class<N>  private<N>    h: THandle;<N>    tid: dword;<N>  public<N>    function getResult: integer;<N>    function waitForThread(timeout: integer): integer;<N>    constructor create(address: ptruint; parameter: ptruint);<N>  published<N>    property Result: integer read getResult;<N>  end;<N><N>
function TRemoteThread.getResult: integer;<N>var r: dword;<N>begin<N><N>  if GetExitCodeThread(h, r) then<N>    result:=r<N>  else<N>    result:=-1;<N>end;<N><N><N>function TRemoteThread.waitForThread(timeout: integer): integer;<N>begin<N>  result:=-1; //not yet implemented<N>  {$ifdef windows}<N>  result:=WaitForSingleObject(h,timeout);<N>  {$endif}<N><N>
  {$ifdef darwin}<N>  if macWaitForRemoteThread(h, timeout) then<N>    result:=WAIT_OBJECT_0<N>  else<N>    result:=WAIT_TIMEOUT;<N><N>  {$endif}<N><N><N><N>end;<N><N>constructor TRemoteThread.create(address: ptruint; parameter: ptruint);<N>begin<N>  h:=CreateRemoteThread(processhandle, nil, 0, pointer(address), pointer(parameter), 0, tid);<N>end;<N><N>
function remotethread_waitForThread(L: PLua_State): integer; cdecl;<N>var<N>  timeout: dword;<N>  r: integer;<N>  rt: TRemoteThread;<N>begin<N>  result:=0;<N>  if lua_Gettop(L)>=1 then<N>    timeout:=lua_tointeger(L,1)<N>  else<N>    timeout:=INFINITE;<N><N>
  rt:=TRemoteThread(luaclass_getClassObject(L));<N>  r:=rt.waitForThread(timeout);<N>  if r=WAIT_OBJECT_0 then<N>  begin<N>    result:=2;<N>    lua_pushboolean(L, true);<N>    lua_pushinteger(L, rt.Result);<N>  end<N>  else<N>  if r=WAIT_TIMEOUT then<N>  begin<N>    result:=2;<N>    lua_pushboolean(L, false);<N>    lua_pushinteger(L, lua_integer(-2));<N>  end<N>  else<N>  begin<N>    result:=2;<N>    lua_pushboolean(L, false);<N>    lua_pushinteger(L, lua_integer(-3));<N>  end;<N>end;<N><N>
function lua_createRemoteThread(L: PLua_State): integer; cdecl;<N>var<N>  rt: TRemoteThread;<N>  address, parameter: ptruint;<N>begin<N>  result:=0;<N>  if lua_gettop(L)>=1 then<N>  begin<N>    if lua_isnil(L,1) then exit;<N><N>    address:=lua_toaddress(L,1);<N><N>
    if lua_gettop(L)>=2 then<N>      parameter:=lua_toaddress(L,2)<N>    else<N>      parameter:=0;<N><N>    rt:=TRemoteThread.create(address, parameter);<N><N>    if rt.h=0 then<N>    begin<N>      rt.free;<N>      exit;<N>    end<N>    else<N>    begin<N>      luaclass_newClass(L,rt);<N>      result:=1;<N>    end;<N>  end;<N>end;<N><N>
procedure remotethread_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>begin<N>  object_addMetaData(L, metatable, userdata);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'waitForThread', remotethread_waitForThread);<N>end;<N><N>
unit LuaButton;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib, forms, controls, StdCtrls, betterControls;<N><N>procedure InitializeLuaButton;<N>procedure button_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N><N>
implementation<N><N>uses LuaHandler, LuaClass, LuaWinControl;<N><N>function createButton(L: Plua_State): integer; cdecl;<N>var c: TWincontrol;<N>  b: Tbutton;<N>begin<N>  result:=0;<N>  if lua_gettop(L)=1 then<N>  begin<N>    c:=lua_toceuserdata(L, 1);<N>    b:=TButton.create(c);<N>    b.Parent:=c;<N>    luaclass_newClass(L, b);<N>    result:=1;<N>  end;<N>end;<N><N>
function button_getModalResult(L: PLua_State): integer; cdecl;<N>var<N>  button: Tcustombutton;<N>begin<N>  button:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, integer(button.ModalResult));<N>  result:=1;<N>end;<N><N>function button_setModalResult(L: PLua_State): integer; cdecl;<N>var<N>  button: Tcustombutton;<N>begin<N>  result:=0;<N>  button:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    button.ModalResult:=TModalResult(lua_tointeger(L,-1));<N>end;<N><N>
procedure button_addMetaData(L: PLua_state; metatable: integer; userdata: integer);<N>begin<N>  wincontrol_addMetaData(L, metatable, userdata);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'getModalResult', button_getModalResult);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'setModalResult', button_setModalResult);<N>  luaclass_addPropertyToTable(L, metatable, userdata, 'ModalResult', button_getModalResult, button_setModalResult);<N><N>
end;<N><N>procedure InitializeLuaButton;<N>begin<N>  lua_register(LuaVM, 'createButton', createButton);<N>  lua_register(LuaVM, 'button_getModalResult', button_getModalResult);<N>  lua_register(LuaVM, 'button_setModalResult', button_setModalResult);<N>end;<N><N>
unit binutils;<N><N>//responsible for launching and retrieving data from the binutil tools<N><N>{$mode objfpc}{$H+}<N>{$warn 2005 off}<N><N>interface<N><N>uses<N>  {$ifdef darwin}macport,{$endif}<N>  {$ifdef windows}windows, {$endif}<N>  newkernelhandler, forms, Classes, SysUtils, process, LastDisassembleData, strutils, maps;<N><N>
type<N>  TSection=record<N>    name: string;<N>    size: dword;<N>  end;<N>  TSectionArray=array of TSection;<N><N>  TImportListEntry=record<N>    name: string;<N>    address: ptruint;<N>  end;<N><N>  TImportList=array of TImportListEntry;<N><N><N>  TBinarySection=record<N>    sectionname: string;<N>    data: array of byte;<N>  end;<N>  TBinarySections=array of TBinarySection;<N><N>
type<N>  TBinUtils=class<N>  private<N>    disassemblercache: TMap;<N>    fpath: string;<N>    procedure setPath(path: string);<N>    procedure cleanEntry(_entry: Pointer);<N>  public<N>    name: string;<N>    description: string;<N>    prefix: string;<N>    lasterror: string;<N>    arch: string;<N>    OnDisassemble: integer; //lua function reference<N><N>
    ASParam: string;<N>    LDParam: string;<N>    OBJDUMPParam: string;<N>    DisassemblerCommentChar: string;<N><N>    constructor create;<N>    destructor destroy; override;<N><N>    procedure clearDisassemblerCache;<N>    procedure clearLongRangeDisassemblerCache(address: ptruint);<N><N>
<N>    function compile(script: tstringlist): boolean;<N>    function compileproject(filelist: tstringlist): boolean;<N><N>    procedure LinkObjectFiles(objectfiles: tstringlist; const imports: TImportList; targetfilename: string; targetaddress:ptruint=0);<N>    procedure ObjectToBinary(objectfile: string; binfile: string);<N>    procedure stripSection(objectfile: string; section: string);<N><N>
unit LuaSQL;<N><N>{<N>routines for SQL access<N>example script:<N>c=createSQLite3Connection()<N>c.DatabaseName='e:\\something.sqlite3'<N>c.Connected=true<N><N>t=createSQLTransaction()<N>t.SQLConnection=c<N>t.Active=true<N><N>tn=c.getTableNames()<N>if #tn==0 then<N>  print("empty")<N><N>
  c.ExecuteDirect([[<N>    CREATE TABLE something (<N>    'id' INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,<N>    'processname' char(256) NOT NULL,<N>    'rating' INTEGER);<N>  ]])<N>  tn=c.getTableNames()<N>  if #tn==0 then error('no table created') end<N><N>
end<N><N>print("tables:")<N>local hassomething=false<N>local i<N>for i=1,#tn do<N>  print(tn[i])<N>  if tn[i]=='something' then hassomething=true end<N>end<N><N>if hassomething then<N>  pn=process<N>  if (pn==nil) or (p=='nil') then pn='no process'  end<N><N>
  --check if pn is in the table, if so, increment rating, else add it<N>  q=createSQLQuery()<N>  q.SQLConnection=c<N>  q.SQLTransaction=t<N><N>  q.SQL.Text=string.format([[ Select * from something where processname='%s' ]],pn) --not secure, I know, just an example<N>  q.Active=true<N><N>
  if q.RecordCount>0 then<N>    print("In the list")<N>    fields=q.Fields<N>    print("fieldcount="..fields.Count)<N><N>    local id=q.FieldByName('id').asInteger<N>    print("id="..id)<N><N>    local rating=q.FieldByName('rating')<N>    print("rating="..rating.asInteger)<N><N>
    q.Active=false<N>    q.StatementType='stUpdate'<N>    q.SQL.Text=string.format([[update something set rating=rating+1 where id=%d]], id)<N>    q.ExecSQL()<N>                                   09<N>  else<N>    print("Not yet in the list")<N>    c.ExecuteDirect(string.format([[insert into something(processname,rating) values('%s',1)]],pn))<N>  end<N><N>
  q.Active=false<N><N>  q.StatementType='stSelect'<N>  q.SQL.Text=[[select * from something]]<N>  q.Active=true<N><N>  count=1<N>  print(string.format("RecordCount=%d", q.RecordCount))<N>  while not q.EOF do<N>    print("line "..count)<N>    local i<N>    for i=0, q.Fields.Count-1 do<N>      print(string.format("  %s = %s", q.Fields[i].FieldName, q.Fields[i].Value))<N>    end<N><N>
    q.next()<N>    count=count+1<N>  end<N><N>  q.Active=false<N>  q.destroy()<N><N>else<N>  error("something doesn't exist")<N>end<N><N>t.Commit()<N>t.Active=false<N>c.Connected=false<N><N>t.destroy()<N>c.destroy()<N><N>}<N><N>{$mode delphi}<N><N>interface<N><N>
uses<N>  Classes, SysUtils, db, sqldb, sqlite3, sqlite3conn, odbcconn, BufDataset,<N>  LuaComponent, LuaClass, luaobject, lua, lualib, lauxlib, typinfo;<N><N>procedure initializeLuaSQL;<N><N>implementation<N><N>uses LuaHandler, LuaCollection, LuaCollectionItem, LuaByteTable;<N><N>
function createSQLQuery(L: Plua_State): integer; cdecl;<N>var owner: TComponent;<N>begin<N>  if lua_gettop(L)=1 then<N>    owner:=lua_toceuserdata(L, 1)<N>  else<N>    owner:=nil;<N><N>  luaclass_newClass(L, TSQLQuery.Create(owner));<N>  result:=1;<N><N>end;<N><N>
<N>function createSQLTransaction(L: Plua_State): integer; cdecl;<N>var owner: TComponent;<N>begin<N>  if lua_gettop(L)=1 then<N>    owner:=lua_toceuserdata(L, 1)<N>  else<N>    owner:=nil;<N><N>  luaclass_newClass(L, TSQLTransaction.Create(owner));<N>  result:=1;<N>end;<N><N>
function createSQLite3Connection(L: Plua_State): integer; cdecl;<N>var owner: TComponent;<N>begin<N>  if lua_gettop(L)=1 then<N>    owner:=lua_toceuserdata(L, 1)<N>  else<N>    owner:=nil;<N><N>  luaclass_newClass(L, TSQLite3Connection.Create(owner));<N>  result:=1;<N>end;<N><N>
function setSQLiteLibraryName(L: Plua_State): integer; cdecl;<N>begin<N>  if lua_gettop(L)=1 then<N>    SQLiteLibraryName:=Lua_ToString(L,1);<N><N>  result:=0;<N>end;<N><N>function sqlite3connection_createDB(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  try<N>    TSQLite3Connection(luaclass_getClassObject(L)).CreateDB;<N>  except<N>    on e:exception do<N>    begin<N>      lua_pushstring(L, e.message);<N>      lua_error(L);<N>    end;<N>  end;<N>end;<N><N>
function sqlite3connection_dropDB(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  try<N>    TSQLite3Connection(luaclass_getClassObject(L)).DropDB;<N>  except<N>    on e:exception do<N>    begin<N>      lua_pushstring(L, e.message);<N>      lua_error(L);<N>    end;<N>  end;<N>end;<N><N>
function sqlite3connection_getInsertID(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushinteger(L, TSQLite3Connection(luaclass_getClassObject(L)).GetInsertID);<N>  result:=1;<N>end;<N><N>function createODBCConnection(L: Plua_State): integer; cdecl;<N>var owner: TComponent;<N>begin<N>  if lua_gettop(L)=1 then<N>    owner:=lua_toceuserdata(L, 1)<N>  else<N>    owner:=nil;<N><N>
  luaclass_newClass(L, TODBCConnection.Create(owner));<N>  result:=1;<N>end;<N><N><N>function sqlconnection_startTransaction(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  try<N>    TSQLConnection(luaclass_getClassObject(L)).StartTransaction;<N>  except<N>    on e:exception do<N>    begin<N>      lua_pushstring(L, e.message);<N>      lua_error(L);<N>    end;<N>  end;<N>end;<N><N>
function sqlconnection_endTransaction(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  try<N>    TSQLConnection(luaclass_getClassObject(L)).EndTransaction;<N>  except<N>    on e:exception do<N>    begin<N>      lua_pushstring(L, e.message);<N>      lua_error(L);<N>    end;<N>  end;<N>end;<N><N>
function sqlconnection_executeDirect(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  if lua_gettop(L)>=1 then<N>  begin<N>    try<N>      TSQLConnection(luaclass_getClassObject(L)).ExecuteDirect(Lua_ToString(L,1));<N>    except<N>      on e:exception do<N>      begin<N>        lua_pushstring(L, e.message);<N>        lua_error(L);<N>      end;<N>    end;<N>  end;<N>end;<N><N>
//procedure GetFieldNames(const TableName : string; List : TStrings); virtual;<N>function sqlconnection_getFieldNames(L: Plua_State): integer; cdecl;<N>var<N>  tablename: string;<N>  s: tstringlist;<N>  i: integer;<N>begin<N>  result:=0;<N>  if lua_gettop(L)>=1 then<N>  begin<N>    tablename:=Lua_ToString(L,1);<N>    try<N>      s:=tstringlist.create;<N>      try<N>        TSQLConnection(luaclass_getClassObject(L)).GetFieldNames(tablename,s);<N><N>
        result:=1;<N>        lua_newtable(L);<N>        for i:=0 to s.Count-1 do<N>        begin<N>          lua_pushinteger(L,i+1);<N>          lua_pushstring(L,s[i]);<N>          lua_settable(L,-3);<N>        end;<N>      finally<N>        s.free;<N>      end;<N>    except<N>      on e:exception do<N>      begin<N>        lua_pushstring(L, e.message);<N>        lua_error(L);<N>      end;<N>    end;<N>  end;<N>end;<N><N>
<N>function sqlconnection_getTableNames(L: Plua_State): integer; cdecl;<N>var<N>  s: tstringlist;<N>  i: integer;<N>begin<N>  result:=0;<N><N>  try<N>    s:=tstringlist.create;<N>    try<N>      TSQLConnection(luaclass_getClassObject(L)).GetTableNames(s);<N><N>
      result:=1;<N>      lua_newtable(L);<N>      for i:=0 to s.Count-1 do<N>      begin<N>        lua_pushinteger(L,i+1);<N>        lua_pushstring(L,s[i]);<N>        lua_settable(L,-3);<N>      end;<N>    finally<N>      s.free;<N>    end;<N>  except<N>    on e:exception do<N>    begin<N>      lua_pushstring(L, e.message);<N>      lua_error(L);<N>    end;<N>  end;<N><N>
end;<N><N>function database_getTransactionCount(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushinteger(L, TDatabase(luaclass_getClassObject(L)).TransactionCount);<N>  result:=1;<N>end;<N><N>function customconnection_open(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  try<N>    TCustomConnection(luaclass_getClassObject(L)).Open;<N>  except<N>    on e:exception do<N>    begin<N>      lua_pushstring(L, e.message);<N>      lua_error(L);<N>    end;<N>  end;<N>end;<N><N>
function customconnection_close(L: Plua_State): integer; cdecl;<N>var force: boolean;<N>begin<N>  result:=0;<N>  if lua_gettop(L)>=1 then<N>    force:=lua_toboolean(L,1)<N>  else<N>    force:=false;<N><N>  try<N>    TCustomConnection(luaclass_getClassObject(L)).Close(force);<N>  except<N>    on e:exception do<N>    begin<N>      lua_pushstring(L, e.message);<N>      lua_error(L);<N>    end;<N>  end;<N>end;<N><N>
function dbtransaction_getDataBase(L: Plua_State): integer; cdecl;<N>begin<N>  luaclass_newClass(L,TDBTransaction(luaclass_getClassObject(L)).DataBase);<N>  result:=1;<N>end;<N><N>function dbtransaction_setDataBase(L: Plua_State): integer; cdecl;<N>begin<N>  try<N>    TDBTransaction(luaclass_getClassObject(L)).DataBase:=lua_ToCEUserData(L,1);<N>  except<N>    on e:exception do<N>    begin<N>      lua_pushstring(L, e.message);<N>      lua_error(L);<N>    end;<N>  end;<N><N>
  result:=0;<N>end;<N><N>function dbtransaction_closeDataSets(L: Plua_State): integer; cdecl;<N>begin<N>  TDBTransaction(luaclass_getClassObject(L)).CloseDataSets;<N>  result:=0;<N>end;<N><N>function sqltransaction_commit(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  try<N>    TSQLTransaction(luaclass_getClassObject(L)).Commit;<N>  except<N>    on e:exception do<N>    begin<N>      lua_pushstring(L, e.message);<N>      lua_error(L);<N>    end;<N>  end;<N>end;<N><N>
function sqltransaction_commitRetaining(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  try<N>    TSQLTransaction(luaclass_getClassObject(L)).CommitRetaining;<N>  except<N>    on e:exception do<N>    begin<N>      lua_pushstring(L, e.message);<N>      lua_error(L);<N>    end;<N>  end;<N>end;<N><N>
function sqltransaction_rollback(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  try<N>    TSQLTransaction(luaclass_getClassObject(L)).rollback;<N>  except<N>    on e:exception do<N>    begin<N>      lua_pushstring(L, e.message);<N>      lua_error(L);<N>    end;<N>  end;<N>end;<N><N>
function sqltransaction_rollbackRetaining(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  try<N>    TSQLTransaction(luaclass_getClassObject(L)).rollbackRetaining;<N>  except<N>    on e:exception do<N>    begin<N>      lua_pushstring(L, e.message);<N>      lua_error(L);<N>    end;<N>  end;<N>end;<N><N>
function sqltransaction_startTransaction(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  try<N>    TSQLTransaction(luaclass_getClassObject(L)).StartTransaction;<N>  except<N>    on e:exception do<N>    begin<N>      lua_pushstring(L, e.message);<N>      lua_error(L);<N>    end;<N>  end;<N>end;<N><N>
function sqltransaction_endTransaction(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  try<N>    TSQLTransaction(luaclass_getClassObject(L)).EndTransaction;<N>  except<N>    on e:exception do<N>    begin<N>      lua_pushstring(L, e.message);<N>      lua_error(L);<N>    end;<N>  end;<N>end;<N><N>
//-----------------------<N><N>function dataset_getBlockReadSize(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushinteger(L, tdataset(luaclass_getClassObject(L)).BlockReadSize);<N>  result:=1;<N>end;<N><N>function dataset_setBlockReadSize(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  tdataset(luaclass_getClassObject(L)).BlockReadSize:=lua_tointeger(L,1);<N>end;<N><N>
function dataset_getBOF(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, tdataset(luaclass_getClassObject(L)).BOF);<N>  result:=1;<N>end;<N><N>function dataset_getCanModify(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, tdataset(luaclass_getClassObject(L)).CanModify);<N>  result:=1;<N>end;<N><N>
function dataset_getDefaultFields(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, tdataset(luaclass_getClassObject(L)).DefaultFields);<N>  result:=1;<N>end;<N><N>function dataset_getEOF(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, tdataset(luaclass_getClassObject(L)).EOF);<N>  result:=1;<N>end;<N><N>
function dataset_getFieldCount(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushinteger(L, tdataset(luaclass_getClassObject(L)).FieldCount);<N>  result:=1;<N>end;<N><N>function dataset_getFields(L: Plua_State): integer; cdecl;<N>begin<N>  luaclass_newClass(L, tdataset(luaclass_getClassObject(L)).Fields);<N>  result:=1;<N>end;<N><N>
function dataset_getFound(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, tdataset(luaclass_getClassObject(L)).Found);<N>  result:=1;<N>end;<N><N>function dataset_getModified(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, tdataset(luaclass_getClassObject(L)).Modified);<N>  result:=1;<N>end;<N><N>
function dataset_getIsUniDirectional(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, tdataset(luaclass_getClassObject(L)).IsUniDirectional);<N>  result:=1;<N>end;<N><N>function dataset_getRecordCount(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushinteger(L, tdataset(luaclass_getClassObject(L)).RecordCount);<N>  result:=1;<N>end;<N><N>
function dataset_getRecNo(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushinteger(L, tdataset(luaclass_getClassObject(L)).RecNo);<N>  result:=1;<N>end;<N><N>function dataset_setRecNo(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  tdataset(luaclass_getClassObject(L)).RecNo:=lua_tointeger(L,1);<N>end;<N><N>
function dataset_getFieldValues(L: PLua_State): integer; cdecl;<N>var<N>  dataset: TDataSet;<N>  v: string;<N>begin<N>  result:=0;<N>  dataset:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>  begin<N>    v:=Lua_ToString(L,1);<N><N>    lua_pushvariant(L, dataset.FieldValues[v]);<N>    result:=1;<N>  end;<N>end;<N><N>
function dataset_getFilter(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushstring(L, tdataset(luaclass_getClassObject(L)).Filter);<N>  result:=1;<N>end;<N><N>function dataset_setFilter(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  tdataset(luaclass_getClassObject(L)).Filter:=Lua_ToString(L,1);<N>end;<N><N>
function dataset_getFiltered(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, tdataset(luaclass_getClassObject(L)).Filtered);<N>  result:=1;<N>end;<N><N>function dataset_setFiltered(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  tdataset(luaclass_getClassObject(L)).Filtered:=lua_toboolean(L,1);<N>end;<N><N>
<N>function dataset_setFieldValues(L: PLua_State): integer; cdecl;<N>var<N>  dataset: TDataSet;<N>  v: string;<N>begin<N>  result:=0;<N>  dataset:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=2 then<N>  begin<N>    v:=Lua_ToString(L,1);<N>    dataset.FieldValues[v]:=lua_tovariant(L,2);<N>  end;<N>end;<N><N>
function dataset_getFilterOptions(L: Plua_State): integer; cdecl;<N>var ti: PTypeInfo;<N>begin<N>  ti:=typeinfo(TFilterOptions);<N><N>  lua_pushstring(L, SetToString(ti, integer(tdataset(luaclass_getClassObject(L)).FilterOptions),true));<N>  result:=1;<N>end;<N><N>
function dataset_setFilterOptions(L: Plua_State): integer; cdecl;<N>var ti: PTypeInfo;<N>begin<N>  ti:=typeinfo(TFilterOptions);<N><N>  tdataset(luaclass_getClassObject(L)).FilterOptions:=TFilterOptions(StringToSet(ti,Lua_ToString(L,1)));<N>  result:=0;<N>end;<N><N>
function dataset_getActive(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, tdataset(luaclass_getClassObject(L)).Active);<N>  result:=1;<N>end;<N><N>function dataset_setActive(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  tdataset(luaclass_getClassObject(L)).Active:=lua_toboolean(L,1);<N>end;<N><N>
function dataset_getAutoCalcFields(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, tdataset(luaclass_getClassObject(L)).AutoCalcFields);<N>  result:=1;<N>end;<N><N>function dataset_setAutoCalcFields(L: Plua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  tdataset(luaclass_getClassObject(L)).AutoCalcFields:=lua_toboolean(L,1);<N>end;<N><N>
function dataset_append(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).Append;<N>  result:=0;<N>end;<N><N>function dataset_cancel(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).cancel;<N>  result:=0;<N>end;<N><N>
function dataset_checkBrowseMode(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).CheckBrowseMode;<N>  result:=0;<N>end;<N><N>function dataset_clearFields(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).ClearFields;<N>  result:=0;<N>end;<N><N>
function dataset_close(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).Close;<N>  result:=0;<N>end;<N><N>function dataset_controlsDisabled(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, tdataset(luaclass_getClassObject(L)).ControlsDisabled);<N>  result:=1;<N>end;<N><N>
function dataset_cursorPosChanged(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).CursorPosChanged;<N>  result:=0;<N>end;<N><N>function dataset_delete(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).Delete;<N>  result:=0;<N>end;<N><N>
function dataset_disableControls(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).DisableControls;<N>  result:=0;<N>end;<N><N>function dataset_edit(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).Edit;<N>  result:=0;<N>end;<N><N>
function dataset_enableControls(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).EnableControls;<N>  result:=0;<N>end;<N><N>function dataset_fieldByName(L: Plua_State): integer; cdecl;<N>begin<N>  luaclass_newClass(L, tdataset(luaclass_getClassObject(L)).FieldByName(lua_tostring(L,1)));<N>  result:=1;<N>end;<N><N>
function dataset_findField(L: Plua_State): integer; cdecl;<N>begin<N>  luaclass_newClass(L, tdataset(luaclass_getClassObject(L)).FindField(lua_tostring(L,1)));<N>  result:=1;<N>end;<N><N>function dataset_findFirst(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, tdataset(luaclass_getClassObject(L)).FindFirst);<N>  result:=1;<N>end;<N><N>
function dataset_findLast(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, tdataset(luaclass_getClassObject(L)).FindLast);<N>  result:=1;<N>end;<N><N>function dataset_findNext(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, tdataset(luaclass_getClassObject(L)).FindNext);<N>  result:=1;<N>end;<N><N>
function dataset_findPrior(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, tdataset(luaclass_getClassObject(L)).FindPrior);<N>  result:=1;<N>end;<N><N>function dataset_first(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).First;<N>  result:=0;<N>end;<N><N>
function dataset_insert(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).Insert;<N>  result:=0;<N>end;<N><N>function dataset_isEmpty(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, tdataset(luaclass_getClassObject(L)).IsEmpty);<N>  result:=1;<N>end;<N><N>
function dataset_last(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).last;<N>  result:=0;<N>end;<N><N>function dataset_locate(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushboolean(L, tdataset(luaclass_getClassObject(L)).Locate(Lua_ToString(L,1), lua_tovariant(L,2), TLocateOptions(StringToSet(PTypeInfo(typeinfo(TLocateOptions)),lua_tovariant(L,3)))));<N>  result:=1;<N>end;<N><N>
function dataset_lookup(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushvariant(L, tdataset(luaclass_getClassObject(L)).Lookup(Lua_ToString(L,1), lua_tovariant(L,2), lua_tostring(L,3)));<N>  result:=1;<N>end;<N><N>function dataset_moveBy(L: Plua_State): integer; cdecl;<N>begin<N>  lua_pushinteger(L, tdataset(luaclass_getClassObject(L)).MoveBy(lua_tointeger(L,1)));<N>  result:=1;<N>end;<N><N>
function dataset_next(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).next;<N>  result:=0;<N>end;<N><N>function dataset_open(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).open;<N>  result:=0;<N>end;<N><N>
function dataset_post(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).post;<N>  result:=0;<N>end;<N><N>function dataset_prior(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).prior;<N>  result:=0;<N>end;<N><N>
function dataset_refresh(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).refresh;<N>  result:=0;<N>end;<N><N>function dataset_updateCursorPos(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).UpdateCursorPos;<N>  result:=0;<N>end;<N><N>
function dataset_updateRecord(L: Plua_State): integer; cdecl;<N>begin<N>  tdataset(luaclass_getClassObject(L)).UpdateRecord;<N>  result:=0;<N>end;<N><N>procedure dataset_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>begin<N>  component_addMetaData(L, metatable, userdata);<N><N>
  luaclass_addPropertyToTable(L, metatable, userdata, 'BlockReadSize', dataset_getBlockReadSize, dataset_setBlockReadSize);<N>  luaclass_addPropertyToTable(L, metatable, userdata, 'BOF', dataset_getBOF, nil);<N>  luaclass_addPropertyToTable(L, metatable, userdata, 'CanModify', dataset_getCanModify, nil);<N>  luaclass_addPropertyToTable(L, metatable, userdata, 'DefaultFields', dataset_getDefaultFields, nil);<N>  luaclass_addPropertyToTable(L, metatable, userdata, 'EOF', dataset_getEOF, nil);<N><N>
unit LuaBinary;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua;<N><N>procedure initializeLuaBinary;<N><N>implementation<N><N>uses luahandler;<N><N>function bOr(L: PLua_state): integer; cdecl;<N>begin<N>  result:=1;<N>  if lua_gettop(L)=2 then<N>    lua_pushinteger(L, lua_tointeger(L, 1) or lua_tointeger(L,2))<N>  else<N>    raise exception.create(rsIncorrectNumberOfParameters);<N>end;<N><N>
function bXor(L: PLua_state): integer; cdecl;<N>begin<N>  result:=1;<N>  if lua_gettop(L)=2 then<N>    lua_pushinteger(L, lua_tointeger(L, 1) xor lua_tointeger(L,2))<N>  else<N>    raise exception.create(rsIncorrectNumberOfParameters);<N>end;<N><N>function bAnd(L: PLua_state): integer; cdecl;<N>begin<N>  result:=1;<N>  if lua_gettop(L)=2 then<N>    lua_pushinteger(L, lua_tointeger(L, 1) and lua_tointeger(L,2))<N>  else<N>    raise exception.create(rsIncorrectNumberOfParameters);<N>end;<N><N>
function bShl(L: PLua_state): integer; cdecl;<N>begin<N>  result:=1;<N>  if lua_gettop(L)=2 then<N>    lua_pushinteger(L, lua_tointeger(L, 1) shl lua_tointeger(L,2))<N>  else<N>    raise exception.create(rsIncorrectNumberOfParameters);<N>end;<N><N>function bShr(L: PLua_state): integer; cdecl;<N>begin<N>  result:=1;<N>  if lua_gettop(L)=2 then<N>    lua_pushinteger(L, lua_tointeger(L, 1) shr lua_tointeger(L,2))<N>  else<N>    raise exception.create(rsIncorrectNumberOfParameters);<N>end;<N><N>
function bNot(L: PLua_state): integer; cdecl;<N>begin<N>  result:=1;<N>  if lua_gettop(L)=1 then<N>    lua_pushinteger(L, not lua_tointeger(L, 1))<N>  else<N>    raise exception.create(rsIncorrectNumberOfParameters);<N>end;<N><N>procedure initializeLuaBinary;<N>begin<N>  lua_register(LuaVM, 'bOr', bOr);<N>  lua_register(LuaVM, 'bXor', bXor);<N>  lua_register(LuaVM, 'bAnd', bAnd);<N>  lua_register(LuaVM, 'bShl', bShl);<N>  lua_register(LuaVM, 'bShr', bShr);<N>  lua_register(LuaVM, 'bNot', bNot);<N>end;<N><N>
unit changelist;<N><N>{<N>changelist is a helper class for the hexview<N>it keeps a list of entries containing lastvalue and timestamp of the last time it changed<N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>{$IFNDEF STANDALONEHV}<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>{$ENDIF}<N>  Classes, SysUtils;<N><N>
unit frmDissectwindowUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, ComCtrls,StdCtrls,CEFuncProc, ExtCtrls, LResources, Menus, betterControls;<N><N>
unit frmBreakpointlistunit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, Messages, LMessages, LCLType, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  StdCtrls, CEDebugger, KernelDebugger, ExtCtrls, LResources, ComCtrls, Menus,<N>  debuggertypedefinitions, BreakpointTypeDef, betterControls;<N><N>
unit frmSyntaxHighlighterEditor;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, LResources, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ColorBox, ExtCtrls, ComCtrls, SynEditHighlighter, Types, betterControls;<N><N>type<N><N>  { TfrmHighlighterEditor }<N><N>
unit LuaProgressBar;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib, LuaHandler, ceguicomponents,<N>  pluginexports, controls, ComCtrls, betterControls;<N><N>procedure initializeLuaProgressBar;<N><N>implementation<N><N>
uses luaclass, LuaWinControl;<N><N><N>function createProgressBar(L: Plua_State): integer; cdecl;<N>var<N>  ProgressBar: TProgressBar;<N>  parameters: integer;<N>  owner: TWincontrol;<N>begin<N>  result:=0;<N><N>  parameters:=lua_gettop(L);<N>  if parameters>=1 then<N>    owner:=lua_toceuserdata(L, -parameters)<N>  else<N>    owner:=nil;<N><N>
  lua_pop(L, lua_gettop(L));<N><N><N>  ProgressBar:=TProgressBar.Create(owner);<N>  if owner<>nil then<N>    ProgressBar.Parent:=owner;<N><N>  luaclass_newClass(L, ProgressBar);<N>  result:=1;<N>end;<N><N>function progressbar_stepIt(L: Plua_State): integer; cdecl;<N>var progressbar: TCustomProgressBar;<N>begin<N>  result:=0;<N>  progressbar:=luaclass_getClassObject(L);<N>  progressbar.StepIt;<N>end;<N><N>
function progressbar_stepBy(L: Plua_State): integer; cdecl;<N>var<N>  progressbar: TCustomProgressBar;<N>begin<N>  result:=0;<N>  progressbar:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    progressbar.StepBy(lua_tointeger(L, -1));<N>end;<N><N>
<N>function progressbar_getMax(L: PLua_State): integer; cdecl;<N>var<N>  progressbar: Tcustomprogressbar;<N>begin<N>  progressbar:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, progressbar.Max);<N>  result:=1;<N>end;<N><N>function progressbar_setMax(L: PLua_State): integer; cdecl;<N>var<N>  progressbar: Tcustomprogressbar;<N>begin<N>  result:=0;<N>  progressbar:=luaclass_getClassObject(L);<N>  if lua_gettop(l)>=1 then<N>    progressbar.max:=lua_tointeger(L, -1);<N>end;<N><N>
function progressbar_getMin(L: PLua_State): integer; cdecl;<N>var<N>  progressbar: Tcustomprogressbar;<N>begin<N>  progressbar:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, progressbar.Min);<N>  result:=1;<N>end;<N><N>function progressbar_setMin(L: PLua_State): integer; cdecl;<N>var<N>  progressbar: Tcustomprogressbar;<N>begin<N>  result:=0;<N>  progressbar:=luaclass_getClassObject(L);<N>  if lua_gettop(l)>=1 then<N>    progressbar.Min:=lua_tointeger(L, -1);<N>end;<N><N>
function progressbar_getPosition(L: PLua_State): integer; cdecl;<N>var<N>  progressbar: Tcustomprogressbar;<N>begin<N>  progressbar:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, progressbar.Position);<N>  result:=1;<N>end;<N><N>function progressbar_setPosition(L: PLua_State): integer; cdecl;<N>var<N>  progressbar: Tcustomprogressbar;<N>begin<N>  result:=0;<N>  progressbar:=luaclass_getClassObject(L);<N>  if lua_gettop(l)>=1 then<N>    progressbar.Position:=lua_tointeger(L, -1);<N>end;<N><N>
unit LuaComponent;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib;<N><N>procedure InitializeLuaComponent;<N>function component_findComponentByName(L: PLua_state): integer; cdecl; //used by luaclass when a entry can't be resolved<N>procedure component_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N><N>
implementation<N><N>uses LuaHandler, LuaObject, LuaClass;<N><N>function component_getComponentCount(L: PLua_state): integer; cdecl;<N>var c: TComponent;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, c.ComponentCount);<N>  result:=1;<N>end;<N><N>
function component_findComponentByName(L: PLua_state): integer; cdecl;<N>var c: TComponent;<N>  n: string;<N>begin<N>  result:=0;<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>  begin<N>    n:=Lua_ToString(L, -1);<N>    luaclass_newClass(L, c.FindComponent(n));<N>    result:=1;<N>  end;<N>end;<N><N>
function component_getComponent(L: PLua_state): integer; cdecl;<N>var c: TComponent;<N>  i: integer;<N>begin<N>  result:=0;<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>  begin<N>    i:=lua_tointeger(L,-1);<N>    luaclass_newClass(L, c.Components[i]);<N>    result:=1;<N>  end;<N>end;<N><N>
function component_getName(L: PLua_state): integer; cdecl;<N>var c: TComponent;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushstring(L, c.Name);<N>  result:=1;<N>end;<N><N>function component_setName(L: PLua_state): integer; cdecl;<N>var c: TComponent;<N>begin<N>  result:=0;<N>  c:=luaclass_getClassObject(L);<N><N>
  if lua_gettop(L)>=1 then<N>    c.Name:=lua_tostring(L,-1);<N>end;<N><N>function component_getTag(L: PLua_state): integer; cdecl;<N>var c: TComponent;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, c.Tag);<N>  result:=1;<N>end;<N><N>function component_setTag(L: PLua_state): integer; cdecl;<N>var c: TComponent;<N>begin<N>  result:=0;<N>  c:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    c.Tag:=lua_tointeger(L, -1);<N>end;<N><N>
<N>function component_getOwner(L: PLua_state): integer; cdecl;<N>var c: TComponent;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, c.owner);<N>  result:=1;<N>end;<N><N>procedure component_addMetaData(L: PLua_state; metatable: integer; userdata: integer);<N>begin<N>  object_addMetaData(L, metatable, userdata);<N><N>
unit frmMemoryViewExUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, LCLType, LCLIntf,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs,<N>  ExtCtrls, StdCtrls, ComCtrls, Menus, memdisplay, newkernelhandler, cefuncproc,<N>  syncobjs, math, savedscanhandler, foundlisthelper, CustomTypeHandler,<N>  symbolhandler, inputboxtopunit, commonTypeDefs, GL, GLext, Types, DPIHelper, betterControls;<N><N>
<N>type TMVCompareMethod=(cmOr, cmXor, cmAnd);<N><N>type<N>  TMemoryDataSource=class(TThread)<N>  private<N>    cs: TCriticalSection;<N>    address: ptruint;<N>    buf: pbytearray;<N>    bufsize: integer;<N>    faddresslistonly: boolean;<N>    fcompareagainstsavedscan: boolean;<N>    fvartype: TVariableType;<N>    fvarsize: integer;<N><N>
unit memrecDataStructures;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, autoassembler;<N><N>type<N>  TMemrecStringData=record<N>    unicode: boolean;<N>    codepage: boolean;<N>    length: integer;<N>    ZeroTerminate: boolean;<N>  end;<N><N>
  TMemRecBitData=record<N>    Bit     : Byte;<N>    bitlength: integer;<N>    showasbinary: boolean;<N>  end;<N><N>  TMemRecByteData=record<N>    bytelength: integer;<N>  end;<N><N>  TMemRecAutoAssemblerData=record<N>    script: tstringlist;<N>    disableinfo: TDisableInfo;<N>    lastExecutionFailed: boolean;<N>    lastExecutionFailedReason: string;<N>  end;<N><N>
  TMemRecExtraData=record<N>    case integer of<N>      1: (stringData: TMemrecStringData); //if this is the last level (maxlevel) this is an PPointerList<N>      2: (bitData: TMemRecBitData);   //else it's a PReversePointerListArray<N>      3: (byteData: TMemRecByteData);<N>  end;<N><N>
unit frmgroupscanalgoritmgeneratorunit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ExtCtrls, CustomTypeHandler, math, strutils, cefuncproc, groupscancommandparser,<N>  vartypestrings, commonTypeDefs, betterControls;<N><N>
unit pointerparser;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>function getPointerAddress(address: ptruint; const offsets: array of integer; var hasError: boolean): ptruint;<N><N>implementation<N><N>{$ifdef windows}<N>uses newkernelhandler, ProcessHandlerUnit;<N>{$endif}<N><N>
unit LuaListcolumn;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lauxlib, lualib, ComCtrls;<N><N>procedure initializeLuaListcolumn;<N><N>implementation<N><N>uses luahandler, LuaClass, LuaCollectionItem;<N><N>function listcolumn_getAutosize(L: PLua_State): integer; cdecl;<N>var<N>  listcolumn: TListColumn;<N>begin<N>  listcolumn:=luaclass_getClassObject(L);<N>  lua_pushboolean(L, listcolumn.AutoSize);<N>  result:=1;<N>end;<N><N>
function listcolumn_setAutosize(L: PLua_State): integer; cdecl;<N>var<N>  listcolumn: TListColumn;<N>begin<N>  result:=0;<N>  listcolumn:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=1 then<N>    listcolumn.AutoSize:=lua_toboolean(L,-1);<N>end;<N><N>
<N>function listcolumn_getCaption(L: PLua_State): integer; cdecl;<N>var<N>  listcolumn: Tlistcolumn;<N>begin<N>  listcolumn:=luaclass_getClassObject(L);<N>  lua_pushstring(L, listcolumn.caption);<N>  result:=1;<N>end;<N><N>function listcolumn_setCaption(L: PLua_State): integer; cdecl;<N>var<N>  listcolumn: Tlistcolumn;<N>begin<N>  result:=0;<N>  listcolumn:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    listcolumn.caption:=Lua_ToString(L,-1);<N>end;<N><N>
function listcolumn_getMaxWidth(L: PLua_State): integer; cdecl;<N>var<N>  listcolumn: Tlistcolumn;<N>begin<N>  listcolumn:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, listcolumn.MaxWidth);<N>  result:=1;<N>end;<N><N>function listcolumn_setMaxWidth(L: PLua_State): integer; cdecl;<N>var<N>  listcolumn: Tlistcolumn;<N>begin<N>  result:=0;<N>  listcolumn:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    listcolumn.MaxWidth:=lua_tointeger(L,-1);<N>end;<N><N>
<N>function listcolumn_getMinWidth(L: PLua_State): integer; cdecl;<N>var<N>  listcolumn: Tlistcolumn;<N>begin<N>  listcolumn:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, listcolumn.MinWidth);<N>  result:=1;<N>end;<N><N>function listcolumn_setMinWidth(L: PLua_State): integer; cdecl;<N>var<N>  listcolumn: Tlistcolumn;<N>begin<N>  result:=0;<N>  listcolumn:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    listcolumn.MinWidth:=lua_tointeger(L,-1);<N>end;<N><N>
function listcolumn_getWidth(L: PLua_State): integer; cdecl;<N>var<N>  listcolumn: Tlistcolumn;<N>begin<N>  listcolumn:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, listcolumn.Width);<N>  result:=1;<N>end;<N><N>function listcolumn_setWidth(L: PLua_State): integer; cdecl;<N>var<N>  listcolumn: Tlistcolumn;<N>begin<N>  result:=0;<N>  listcolumn:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    listcolumn.Width:=lua_tointeger(L,-1);<N>end;<N><N>
unit DPIHelper;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, math,<N>  {$endif}<N>  {$ifdef windows}<N>  Windows,<N>  {$endif}Classes, controls, comctrls, SysUtils, Buttons, Graphics, forms, StdCtrls, betterControls;<N><N>
procedure AdjustSpeedButtonSize(sb: TCustomSpeedButton);<N>procedure AdjustToolbar(tb: TToolbar);<N>procedure AdjustImageList(il: TImageList);<N>procedure AdjustComboboxSize(cb: TComboBox; canvas: TCanvas);<N>procedure AdjustEditBoxSize(editbox: TCustomEdit; mintextwidth: integer);<N>function GetEditBoxMargins(editbox: TCustomEdit): integer;<N><N>
function getDPIScaleFactor: single;<N><N>implementation<N><N>uses globals{$ifdef windows}, win32proc{$endif};<N><N>const<N>  designtimedpi=96;<N><N>function getDPIScaleFactor: single;<N>begin<N>  result:=screen.PixelsPerInch/designtimedpi;<N>end;<N><N>function GetEditBoxMargins(editbox: TCustomEdit): integer;<N>var m: dword;<N>begin<N>  {$ifdef windows}<N>  if WindowsVersion>=wvVista then<N>    m:=sendmessage(editbox.Handle, EM_GETMARGINS, 0,0)<N>  else<N>  {$endif}<N>    m:=10;<N><N>
  result:=(m shr 16)+(m and $ffff);<N>end;<N><N>procedure AdjustEditBoxSize(editbox: TCustomEdit; mintextwidth: integer);<N>var marginsize: integer;<N>begin<N>  marginsize:=GetEditBoxMargins(editbox);<N>  editbox.clientwidth:=mintextwidth+marginsize;<N>end;<N><N>
procedure AdjustComboboxSize(cb: TComboBox; canvas: TCanvas);<N>var<N>  {$ifdef windows}<N>  cbi: TComboboxInfo;<N>  {$endif}<N>  i: integer;<N>  s: string;<N>  maxwidth: integer;<N><N>  w: integer;<N>begin<N>  maxwidth:=0;<N>  for i:=0 to cb.Items.Count-1 do<N>  begin<N>    s:=cb.Items[i];<N>    maxwidth:=max(maxwidth, Canvas.TextWidth(s));<N>  end;<N><N>
  {$ifdef windows}<N>  cbi.cbSize:=sizeof(cbi);<N>  if GetComboBoxInfo(cb.Handle, @cbi) then<N>  begin<N>    i:=maxwidth-(cbi.rcItem.Right-cbi.rcItem.Left)+4;<N><N>    w:=cb.width+i;<N>  end<N>  else<N>  {$endif}<N>    w:=maxwidth+16;<N><N>  cb.width:=w;<N>  cb.Constraints.MinWidth:=w;<N>end;<N><N>
unit iptlogdisplay;<N><N>//todo: virtualtreeview this<N><N>{$mode ObjFPC}{$H+}<N><N>interface<N><N>uses<N>  {$ifdef windows}windows,{$endif} ProcessHandlerUnit, Classes, SysUtils, LResources, Forms, Controls,<N>  Graphics, Dialogs, StdCtrls, ComCtrls, ExtCtrls, Menus, betterControls,<N>  libipt, pagemap, Contnrs, syncobjs,maps;<N><N>
type<N><N>  { TfrmIPTLogDisplay }<N><N>{$ifdef windows}<N><N>  TIPList=record<N>    list: pqword;   //max 64MB(8388608 entries) / block<N>    listpos: dword;<N>    listsize: integer;<N>  end;<N>  PIPList=^TIPList;<N>  PPIPList=^PIPList;<N><N><N>  TIPTLogLoaderCommand=(illGetCurrentRange, illGetPreviousRange, illGetNextRange, illGetAll);<N>  TIPTLogLoaderCommandData=record<N>    command: TIPTLogLoaderCommand;<N>  end;<N>  PIPTLogLoaderCommandData=^TIPTLogLoaderCommandData;<N><N>
  TIPTLogDataReadyEvent=procedure(sender: TObject; log: PPIPList; count: integer) of object;<N><N>  TIPTLogLoader=class(TThread)<N>  private<N>    hascommand: TEvent;<N>    commandscs: TCriticalSection;<N>    commands: TQueue;<N>    fOnDataReady: TIPTLogDataReadyEvent;<N>    pagemap: TPageMap;<N><N>
    rangelist: TFPList; //contains offsets of syncpoints<N>    currentrange: integer;<N><N>    data: PPIPList;<N>    datapos: integer;<N>    datasize: integer;<N><N>    logname: string;<N>    iptlog: pointer;<N>    logsize: qword;<N><N>    progress:qword;<N><N>
    iptConfig: pt_config;<N>    decoder: ppt_insn_decoder;<N>    callbackImage: PPT_Image;<N><N>    procedure cleardata;<N>    procedure doDataReady;<N><N><N>    procedure getCurrentRangeInternal(skipdonenotification: boolean=false);<N>    procedure getPreviousRangeInternal;<N>    procedure getNextRangeInternal;<N>    procedure getAllInternal;<N><N>
unit LuaStructure;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib, LuaHandler, LuaCaller, symbolhandler,<N>  cefuncproc, newkernelhandler, Dialogs, LuaClass, LuaClassArray, commonTypeDefs;<N><N>procedure initializeLuaStructure;<N><N>
procedure structure_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>procedure structureElement_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N><N>implementation<N><N>uses StructuresFrm2, LuaObject, DotNetPipe, symbolhandlerstructs;<N><N>
<N><N>function getStructureCount(L: PLua_State): integer; cdecl;<N>begin<N>  result:=1;<N>  lua_pushinteger(L, DissectedStructs.Count);<N>end;<N><N>function getStructure(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  i: integer;<N>  userdata, metatable: integer;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters=1 then<N>  begin<N>    i:=lua_tointeger(L,-parameters);<N>    lua_pop(L, parameters);<N><N>
    luaclass_newClass(L, DissectedStructs[i]);<N><N>    result:=1;<N>  end else lua_pop(L, parameters);<N>end;<N><N><N><N>function structure_getName(L: PLua_State): integer; cdecl;<N>var<N>  struct: TDissectedStruct;<N>begin<N>  struct:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, struct.name);<N>  result:=1;<N>end;<N><N>
function structure_setName(L: PLua_State): integer; cdecl;<N>var<N>  struct: TDissectedStruct;<N>begin<N>  result:=0;<N><N>  struct:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    struct.name:=lua_tovariant(L, -1)  //Lua_ToString(L, -1); //last parameter<N>end;<N><N>
function structure_getSize(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  struct: TDissectedStruct;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N><N>  struct:=luaclass_getClassObject(L);<N><N>  lua_pushinteger(L, struct.structuresize);<N>end;<N><N>
function structure_getElementCount(L: PLua_State): integer; cdecl;<N>var<N>  struct: TDissectedStruct;<N>begin<N>  result:=0;<N>  struct:=luaclass_getClassObject(L);<N><N>  lua_pushinteger(L, struct.count);<N>  result:=1;<N>end;<N><N>function structure_getElement(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  struct: TDissectedStruct;<N>  index: integer;<N>begin<N>  result:=0;<N>  struct:=luaclass_getClassObject(L);<N><N>
  parameters:=lua_gettop(L);<N>  if parameters>=1 then<N>  begin<N>    index:=lua_tointeger(L,-1);<N>    if index<struct.count then<N>    begin<N>      luaclass_newclass(L, struct.element[index]);<N>      result:=1;<N>    end;<N>  end;<N>end;<N><N><N>function structure_getElementByOffset(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  struct: TDissectedStruct;<N>  offset: integer;<N>begin<N>  result:=0;<N>  struct:=luaclass_getClassObject(L);<N><N>
  parameters:=lua_gettop(L);<N>  if parameters>=1 then<N>  begin<N>    offset:=lua_tointeger(L,-1);<N>    luaclass_newclass(L, struct.element[struct.getIndexOfOffset(offset)]);<N>    result:=1;<N>  end else lua_pop(L, parameters);<N>end;<N><N>function structure_addElement(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  struct: TDissectedStruct;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N><N>
  struct:=luaclass_getClassObject(L);<N><N>  luaclass_newclass(L, struct.addElement);<N>  result:=1;<N>end;<N><N>function structure_fillFromDotNetAddress(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  struct: TDissectedStruct;<N>  address: ptruint;<N>  changename: boolean;<N><N>
  al: TAddressData;<N>begin<N>  struct:=luaclass_getClassObject(L);<N>  result:=0;<N>  parameters:=lua_gettop(L);<N><N>  changename:=false;<N>  if parameters>=1 then<N>  begin<N>    if lua_isnumber(L, 1) then<N>      address:=lua_tointeger(L,1)<N>    else<N>      address:=symhandler.getAddressFromNameL(lua_tostring(L,1));<N><N>
<N>    if (parameters>=2) then<N>      changename:=lua_toboolean(L, 2);<N><N><N>    if symhandler.GetLayoutFromAddress(address, al) then<N>    begin<N><N>      struct.fillFromDotNetAddressData(al);<N><N>      if changename then<N>        struct.setName(al.typedata.classname);<N>    end;<N><N>
<N>  end;<N>end;<N><N>function structure_autoGuess(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  struct: TDissectedStruct;<N>  base: ptruint;<N>  offset: integer;<N>  size: integer;<N>begin<N>  // structure_autoGuess(structure, baseaddresstoguessfrom, offset, size)<N><N>
  struct:=luaclass_getClassObject(L);<N><N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters>=3 then<N>  begin<N>    if lua_isstring(L, -3) then<N>      base:=symhandler.getAddressFromNameL(lua_tostring(L,-3))<N>    else<N>      base:=lua_tointeger(L,-3);<N><N>
<N>    offset:=lua_tointeger(L,-2);<N>    size:=lua_tointeger(L,-1);<N>    struct.autoGuessStruct(base, offset, size);<N>    result:=0;<N>  end;<N>end;<N><N>function structure_beginUpdate(L: PLua_State): integer; cdecl;<N>var<N>  struct: TDissectedStruct;<N>begin<N>  result:=0;<N>  struct:=luaclass_getClassObject(L);<N><N>
  struct.beginUpdate;<N>end;<N><N>function structure_endUpdate(L: PLua_State): integer; cdecl;<N>var<N>  struct: TDissectedStruct;<N>begin<N>  result:=0;<N>  struct:=luaclass_getClassObject(L);<N><N>  struct.endUpdate;<N>end;<N><N>function structure_addToGlobalStructureList(L: PLua_State): integer; cdecl;<N>var<N>  struct: TDissectedStruct;<N>begin<N>  result:=0;<N>  struct:=luaclass_getClassObject(L);<N><N>
  struct.addToGlobalStructList;<N>end;<N><N>function structure_removeFromGlobalStructureList(L: PLua_State): integer; cdecl;<N>var<N>  struct: TDissectedStruct;<N>begin<N>  result:=0;<N>  struct:=luaclass_getClassObject(L);<N><N>  struct.removeFromGlobalStructList;<N>end;<N><N>
<N><N><N>procedure structure_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>var i: integer;<N>begin<N>  object_addMetaData(L, metatable, userdata);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'setName', structure_setName);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'getName', structure_getName);<N><N>
  luaclass_addPropertyToTable(L, metatable, userdata, 'Name', structure_getName, structure_setName);<N><N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'getSize', structure_getSize);<N>  luaclass_addPropertyToTable(L, metatable, userdata, 'Size', structure_getSize, nil);<N><N>
  luaclass_addClassFunctionToTable(L, metatable, userdata, 'getElementCount', structure_getElementCount);<N>  luaclass_addPropertyToTable(L, metatable, userdata, 'Count', structure_getElementCount, nil);<N><N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'getElement', structure_getElement);<N><N>
unit frmRearrangeStructureListUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, ExtCtrls,<N>  Buttons, StdCtrls, Menus, betterControls;<N><N>type<N><N>  { TfrmRearrangeStructureList }<N><N>
unit LuaCustomType;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>procedure initializeLuaCustomType;<N><N>implementation<N><N>uses CustomTypeHandler, lua, LuaClass, LuaObject, luahandler, LuaByteTable;<N><N>function getCustomType(L: Plua_State): integer; cdecl;<N>var<N>  s: string;<N>  ct: TCustomType;<N>begin<N>  result:=0;<N>  if lua_gettop(L)=0 then exit;<N><N>
  ct:=GetCustomTypeFromName(Lua_ToString(L,1));<N>  if ct<>nil then<N>  begin<N>    luaclass_newClass(L, ct);<N>    result:=1;<N>  end;<N>end;<N><N>function customtype_byteTableToValue(L: Plua_State): integer; cdecl;<N>var<N>  ct: TCustomType;<N>  a: ptruint;<N>  o: pointer;<N>begin<N>  result:=0;<N>  if (lua_gettop(L)=0) or (not lua_istable(L,1)) then exit;<N><N>
unit FormDebugStringsUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ExtCtrls, LResources, betterControls;<N><N>type<N>  TFormDebugStrings = class(TForm)<N>    ListBox1: TListBox;<N>    Panel1: TPanel;<N>    Button1: TButton;<N>    procedure Button1Click(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
{-------------------------------------------------------------------------------<N>The contents of this file are subject to the Mozilla Public License<N>Version 1.1 (the "License"); you may not use this file except in compliance<N>with the License. You may obtain a copy of the License at<N>http://www.mozilla.org/MPL/<N><N>
Software distributed under the License is distributed on an "AS IS" basis,<N>WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for<N>the specific language governing rights and limitations under the License.<N><N>Code template generated with SynGen.<N>The original code is: Lua.pas, released 2004-10-27.<N>Description: Lua Syntax Parser/Highlighter<N>The initial author of this file is Jean-Franois Goulet.<N>Copyright (c) 2004, all rights reserved.<N><N>
unit LuaPageControl;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, controls, comctrls, lua, lualib, lauxlib, betterControls;<N><N>procedure initializeLuaPageControl;<N><N>implementation<N><N>uses luahandler, LuaWinControl, luaclass;<N><N>
function createPageControl(L: Plua_State): integer; cdecl;<N>var<N>  PageControl: TPageControl;<N>  owner: TWincontrol;<N>begin<N>  if lua_gettop(L)=1 then<N>    owner:=lua_toceuserdata(L, 1)<N>  else<N>    owner:=nil;<N><N>  PageControl:=TPageControl.Create(owner);<N>  PageControl.Parent:=owner;<N><N>
  luaclass_newClass(L, PageControl);<N>  result:=1;<N>end;<N><N>function pagecontrol_addTab(L: Plua_State): integer; cdecl;<N>var<N>  pc: TPageControl;<N>  ts: TTabSheet;<N>begin<N>  pc:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, pc.AddTabSheet);<N>  result:=1;<N>end;<N><N>
function pagecontrol_tabRect(L: Plua_State): integer; cdecl;<N>var<N>  pc: TPageControl;<N>  index: integer;<N>begin<N>  if lua_gettop(L)>=1 then<N>  begin<N>    index:=lua_tointeger(L,1);<N>    lua_pushrect(L, TPageControl(luaclass_getClassObject(L)).TabRect(index));<N>    result:=1;<N>  end<N>  else<N>    result:=0;<N>end;<N><N>
unit plugin;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses lclproc,<N>     {$ifdef darwin}<N>     macport, dynlibs,<N>     {$endif}<N>     {$ifdef windows}<N>     windows,<N>     {$endif}<N>     classes, sysutils,LCLIntf,checklst,menus,dialogs,CEFuncProc,<N>     NewKernelHandler, graphics, syncobjs, commonTypeDefs, betterControls;<N><N>
const CurrentPluginVersion=6;<N><N>//todo: Move the type definitions to a different unit<N><N>//structures<N>type TPluginVersion = record<N>  version: dword; //version number of ce plugin it is developed for (compatibility for the future)<N>  pluginname: pchar; //pointer to a 0-terminated string in the dll<N>end;<N>type PPluginVersion=^TPluginVersion;<N><N>
unit frmSymbolEventTakingLongUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, LResources, Forms, Controls, Graphics, Dialogs,<N>  StdCtrls, ExtCtrls, syncobjs, symbolhandler, betterControls;<N><N>type<N><N>  { TfrmSymbolEventTakingLong }<N><N>
unit LuaNetworkInterface;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib;<N><N>procedure initializeLuaNetworkInterface(L: Plua_State);<N><N>implementation<N><N>uses LuaClass, luahandler, networkInterface, networkInterfaceApi, LuaObject;<N><N>
function ceconnection_getOption(L: PLua_State): integer; cdecl;<N>var<N>  c: TCEConnection;<N>  optname: string;<N>begin<N>  result:=0;<N>  c:=getconnection;<N>  if c=nil then exit;<N><N>  if lua_gettop(L)=1 then<N>  begin<N>    optname:=lua_tostring(L,1);<N>    lua_pushstring(L, c.getOption(optname));<N>    result:=1;<N>  end;<N>end;<N><N>
function ceconnection_setOption(L: PLua_State): integer; cdecl;<N>var<N>  c: TCEConnection;<N>  optname: string;<N>  v: string;<N>begin<N>  result:=0;<N>  c:=getconnection;<N>  if c=nil then exit;<N><N>  if lua_gettop(L)=2 then<N>  begin<N>    optname:=lua_tostring(L,1);<N>    v:=Lua_ToString(L,2);<N>    c.setOption(optname,v);<N>  end;<N>end;<N><N>
function ceconnection_getOptionList(L: PLua_State): integer; cdecl;<N>var c: TCEConnection;<N>  o: TCEServerOptions;<N>  i: integer;<N>begin<N>  result:=0;<N>  o:=[];<N>  c:=getconnection;<N>  if c=nil then exit;<N><N>  if c.connected then<N>  begin<N>    lua_createtable(L,length(o),0);<N>    result:=1;<N><N>
    c.getOptions(o);<N>    for i:=0 to length(o)-1 do<N>    begin<N>      lua_pushinteger(L,i+1);<N>      lua_createtable(L,0,6);<N><N>      //optname, parentoptname, optdescription, acceptablevalue, currentvalue, optiontype(0=not an option, just a label, 1=bool, 2=int, 3=float, 4=double, 5=text)<N>      lua_pushstring(L,'optname');<N>      lua_pushstring(L,o[i].optname);<N>      lua_settable(L,-3);<N><N>
      lua_pushstring(L,'parentoptname');<N>      lua_pushstring(L,o[i].parentoptname);<N>      lua_settable(L,-3);<N><N>      lua_pushstring(L,'optdescription');<N>      lua_pushstring(L,o[i].optdescription);<N>      lua_settable(L,-3);<N><N>      lua_pushstring(L,'acceptablevalues');<N>      lua_pushstring(L,o[i].acceptablevalues);<N>      lua_settable(L,-3);<N><N>
      lua_pushstring(L,'currentvalue');<N>      lua_pushstring(L,o[i].currentvalue);<N>      lua_settable(L,-3);<N><N>      lua_pushstring(L,'optiontype');<N>      lua_pushinteger(L,ord(o[i].optiontype));<N>      lua_settable(L,-3);<N><N>      lua_settable(L,-3);<N>    end;<N><N>
  end;<N><N>end;<N><N><N><N>function ceconnection_setCurrentPath(L: PLua_State): integer; cdecl;<N>var c: TCEConnection;<N>begin<N>  c:=getconnection;<N>  if c=nil then exit(0);<N><N>  if lua_gettop(L)=1 then<N>  begin<N>    lua_pushboolean(L, c.setCurrentPath(Lua_ToString(L,1)));<N>    exit(1);<N>  end;<N>end;<N><N>
function ceconnection_getCurrentPath(L: PLua_State): integer; cdecl;<N>var c: TCEConnection;<N>begin<N>  c:=getconnection;<N>  if c=nil then exit(0);<N><N>  lua_pushstring(L, c.getCurrentPath);<N>  exit(1);<N>end;<N><N>function ceconnection_enumFiles(L: PLua_State): integer; cdecl;<N>var<N>  path: string;<N>  c: TCEConnection;<N>  filelist: tstringlist;<N>  i: integer;<N>begin<N>  c:=getconnection;<N>  if c=nil then exit(0);<N><N>
  if lua_gettop(L)>=1 then<N>    path:=Lua_ToString(L,1)<N>  else<N>    path:=c.getCurrentPath;<N><N>  filelist:=tstringlist.create;<N>  c.enumfiles(path, filelist);<N><N>  lua_createtable(L,filelist.count,0);<N><N>  for i:=0 to filelist.count-1 do<N>  begin<N>    lua_pushinteger(L,i+1);<N>    lua_newtable(L);<N>    lua_pushstring(L,'name');<N>    lua_pushstring(L,filelist[i]);<N>    lua_settable(L,-3);<N><N>
    lua_pushstring(L,'type');<N>    lua_pushinteger(L,ptruint(filelist.Objects[i]));<N>    lua_settable(L,-3);<N><N>    lua_settable(L,-3);<N>  end;<N><N>  result:=1;<N>end;<N><N>function ceconnection_createDir(L: PLua_State): integer; cdecl;<N>var path: string;<N>  c: TCEConnection;<N>begin<N>  result:=0;<N>  c:=getconnection;<N>  if c=nil then exit(0);<N><N>
  if lua_gettop(L)>=1 then<N>  begin<N>    path:=Lua_ToString(L,1);<N>    lua_pushboolean(L, c.createdir(path));<N>    result:=1;<N>  end;<N>end;<N><N>function ceconnection_deleteFile(L: PLua_State): integer; cdecl;<N>var path: string;<N>  c: TCEConnection;<N>begin<N>  result:=0;<N>  c:=getconnection;<N>  if c=nil then exit(0);<N><N>
  if lua_gettop(L)>=1 then<N>  begin<N>    path:=Lua_ToString(L,1);<N>    lua_pushboolean(L, c.deletefile(path));<N>    result:=1;<N>  end;<N>end;<N><N>function ceconnection_getFilePermission(L: PLua_State): integer; cdecl;<N>var<N>  path: string;<N>  c: TCEConnection;<N>  perm: UINT32;<N>begin<N>  result:=0;<N>  c:=getconnection;<N>  if c=nil then exit(0);<N><N>
  if lua_gettop(L)>=1 then<N>  begin<N>    path:=Lua_ToString(L,1);<N>    if c.getFilePermissions(path,perm) then<N>    begin<N>      lua_pushinteger(L,perm);<N>      result:=1;<N>    end;<N>  end;<N>end;<N><N>function ceconnection_setFilePermission(L: PLua_State): integer; cdecl;<N>var<N>  path: string;<N>  c: TCEConnection;<N>  perm: UINT32;<N>begin<N>  result:=0;<N>  c:=getconnection;<N>  if c=nil then exit(0);<N><N>
  if lua_gettop(L)>=2 then<N>  begin<N>    path:=Lua_ToString(L,1);<N>    perm:=lua_tointeger(L,2);<N>    result:=1;<N><N>    lua_pushboolean(L, c.setfilepermissions(path,perm));<N>  end;<N>end;<N><N>function ceconnection_getFile(L: PLua_State): integer; cdecl;<N>var<N>  c: TCEConnection;<N>  path: string;<N>  s: tstream;<N>begin<N>  result:=0;<N>  c:=getconnection;<N>  if c=nil then exit(0);<N>  if lua_gettop(L)>=2 then<N>  begin<N>    path:=Lua_ToString(L,1);<N>    s:=lua_ToCEUserData(L,2);<N><N>
    lua_pushboolean(L, c.getfile(path,s));<N>  end;<N>end;<N><N>function ceconnection_putFile(L: PLua_State): integer; cdecl;<N>var<N>  c: TCEConnection;<N>  path: string;<N>  s: tstream;<N>begin<N>  result:=0;<N>  c:=getconnection;<N>  if c=nil then exit(0);<N>  if lua_gettop(L)>=2 then<N>  begin<N>    path:=Lua_ToString(L,1);<N>    s:=lua_ToCEUserData(L,2);<N><N>
    lua_pushboolean(L, c.putfile(path,s));<N>  end;<N>end;<N><N>function getCEServerInterface(L: PLua_State): integer; cdecl;<N>var c: TCEConnection;<N>begin<N>  result:=0;<N>  c:=getconnection;<N>  if c<>nil then<N>  begin<N>    luaclass_newClass(L, c);<N>    exit(1);<N>  end;<N>end;<N><N>
unit LuaMenu;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils,lua, lualib, lauxlib, LuaHandler,menus, LCLProc;<N><N>procedure initializeLuaMenu;<N><N>implementation<N><N>uses LuaCaller, LuaClass, LuaComponent, betterControls;<N><N>function menu_getItems(L: PLua_State): integer; cdecl;<N>var<N>  menu: TMenu;<N>begin<N>  menu:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, menu.Items);<N>  result:=1;<N>end;<N><N>
<N><N><N>function createMainMenu(L: Plua_State): integer; cdecl;<N>var parameters: integer;<N>  f: TComponent;<N>  m: TMainMenu;<N>begin<N>  result:=0;<N><N>  parameters:=lua_gettop(L);<N>  if parameters=1 then<N>  begin<N>    f:=lua_ToCEUserData(L, 1);<N>    m:=TMainMenu.Create(f);<N>    luaclass_newClass(L, m);<N>    result:=1;<N>  end else lua_pop(L, lua_gettop(L));<N>end;<N><N>
function createPopupMenu(L: Plua_State): integer; cdecl;<N>var parameters: integer;<N>  f: TComponent;<N>  m: TPopupMenu;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters=1 then<N>  begin<N>    f:=lua_ToCEUserData(L, -1);<N>    lua_pop(L, lua_gettop(L));<N><N>
    m:=TPopupMenu.Create(f);<N>    luaclass_newClass(L, m);<N>    result:=1;<N>  end else lua_pop(L, lua_gettop(L));<N>end;<N><N>function createMenuItem(L: Plua_State): integer; cdecl;<N>var parameters: integer;<N>  o: TMenu;<N>  mi: TMenuitem;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters=1 then<N>  begin<N>    o:=lua_ToCEUserData(L, -1);<N>    lua_pop(L, lua_gettop(L));<N><N>
    mi:=TMenuItem.Create(o);<N>    luaclass_newClass(L, mi);<N>    result:=1;<N>  end else lua_pop(L, lua_gettop(L));<N>end;<N><N>function menuItem_getMenuIndex(L: PLua_State): integer; cdecl;<N>var<N>  menuItem: TmenuItem;<N>begin<N>  menuitem:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, menuItem.MenuIndex);<N>  result:=1;<N>end;<N><N>
function menuItem_setMenuIndex(L: PLua_State): integer; cdecl;<N>var<N>  menuItem: TmenuItem;<N>  i: integer;<N>begin<N>  menuitem:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>  begin<N>    i:=lua_tointeger(L, -1);<N>    menuItem.MenuIndex:=i;<N>  end;<N>  result:=0;<N>end;<N><N>
unit formAddToCodeList;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, LResources, ExtCtrls, cefuncproc, newkernelhandler, betterControls;<N><N>type<N><N>  { TfrmAddToCodeList }<N><N>
unit CETranslator;<N><N>{ Copyright (C) 2004-2010 V.I.Volchenko and Lazarus Developers Team<N><N>  This library is free software; you can redistribute it and/or modify it<N>  under the terms of the GNU Library General Public License as published by<N>  the Free Software Foundation; either version 2 of the License, or (at your<N>  option) any later version.<N><N>
  This program is distributed in the hope that it will be useful, but WITHOUT<N>  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or<N>  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Library General Public License<N>  for more details.<N><N>
unit cefreetype;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>{$ifdef USELAZFREETYPE}<N>function loadCEFreeTypeFonts: boolean;<N>{$endif}<N><N>implementation<N><N>{$ifdef USELAZFREETYPE}<N>uses forms, FPCanvas, EasyLazFreeType, LazFreeTypeFontCollection, LazFreeTypeIntfDrawer,<N>  LazFreeTypeFPImageDrawer, IntfGraphics, fpimage, graphtype;<N><N>
unit LuaPen;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Graphics,lua, lualib, lauxlib,LuaHandler;<N><N>procedure initializeLuaPen;<N><N>implementation<N><N>uses luaclass, LuaObject;<N><N>function pen_getColor(L: PLua_State): integer; cdecl;<N>var<N>  pen: TPen;<N>begin<N>  pen:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, pen.Color);<N>  result:=1;<N>end;<N><N>
function pen_setColor(L: PLua_State): integer; cdecl;<N>var<N>  pen: TPen;<N>begin<N>  pen:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    pen.color:=lua_tointeger(L, -1);<N>  result:=1;<N>end;<N><N>function pen_getWidth(L: PLua_State): integer; cdecl;<N>var<N>  pen: TPen;<N>begin<N>  pen:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, pen.Width);<N>  result:=1;<N>end;<N><N>
unit frmStructureLinkerUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  Grids, ExtCtrls, symbolhandler, StructuresFrm2, cefuncproc, newkernelhandler, betterControls;<N><N>
unit VirtualMemory;<N><N>{$MODE Delphi}<N><N>{obsolete}<N><N>interface<N><N>{$ifdef darwin}<N>uses macport, SysUtils,LCLIntf,NewKernelHandler,CEFuncProc,ComCtrls, symbolhandler, commonTypeDefs;<N>{$endif}<N><N>{$ifdef windows}<N>uses windows, SysUtils,LCLIntf,NewKernelHandler,CEFuncProc,ComCtrls, symbolhandler, commonTypeDefs;<N>{$endif}<N><N>
unit tablist;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils,controls,ExtCtrls,graphics, math;<N><N>type<N>  TTabChangeEvent=procedure(sender: TObject; oldselection: integer) of object;<N>  TTabCreateDestroyEvent=procedure(sender: TObject; tabIndex: integer) of object;<N><N>
  TTablist=class;<N><N>  TControlWithArrows=class(TCustomControl)<N>  private<N>    tablist: TTablist;<N>  protected<N>    procedure MouseDown(Button: TMouseButton; Shift:TShiftState; X,Y:Integer); override;<N>  public<N>    leftArrowActive: boolean;<N>    rightArrowActive: boolean;<N>    arrowWidth: integer;<N>    procedure Paint; override;<N>  end;<N><N>
  TTablist=class(TCustomControl)<N>  private<N>    fTabs: tstringlist;<N>    fmintabWidth: integer;<N>    fselectedTab: integer;<N>    fOnTabChange: TTabChangeEvent;<N>    fOnTabCreate: TTabCreateDestroyEvent;<N>    fOnTabDestroy: TTabCreateDestroyEvent;<N><N>
    offset: integer; //defines how many tabs must be shifted to the left<N>    controlWithArrows: TControlWithArrows;<N><N>    function getTabWidth(i: integer): integer;<N>    function getTabXPos(i: integer): integer;<N><N>    procedure setSelectedTab(i: integer);<N>    function getTabData(i: integer):pointer;<N>    procedure setTabData(i: integer; p: pointer);<N>    function getCount: integer;<N>    function getTabText(i: integer): string;<N>    procedure setTabText(i: integer; s: string);<N><N>
unit LuaStructureFrm;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib, LuaHandler, LuaCaller, symbolhandler,<N>  cefuncproc, newkernelhandler, Dialogs, LuaClass, LuaClassArray, commonTypeDefs,<N>  Forms, StructuresFrm2, LuaStructure, betterControls;<N>  <N>  <N><N>
procedure initializeLuaStructureFrm;<N>procedure structureFrm_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>procedure structGroup_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>procedure structColumn_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N><N>
implementation<N><N>uses LuaForm, LuaObject, DotNetPipe, ComCtrls;<N><N>resourcestring<N>  rsGroup1 = 'Group 1';<N>  rsGroupD = 'Group %d';<N><N>function enumStructureForms(L: PLua_State): integer; cdecl;<N>var i: integer;<N>begin<N>  lua_newtable(L);<N><N>
  for i:=0 to frmStructures2.Count-1 do<N>  begin<N>    lua_pushinteger(L,i+1);<N>    luaclass_newClass(L, frmStructures2[i]);<N>    lua_settable(L,-3);<N>  end;<N><N>  result:=1;<N>end;<N><N>function createStructureForm(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  address: string;<N>  form: TfrmStructures2;<N>  column: TStructColumn;<N><N>
  metatable: integer;<N>  m: tmethod;<N>  i: integer;<N>  userdata: integer;<N>  structname: string;<N>  groupname: string;<N>  struct: TDissectedStruct;<N>  group: TStructGroup;<N><N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N><N>  structname:='';<N>  address:='';<N>  groupname:=rsGroup1;<N><N>
  if parameters>=3 then structname:=lua_tostring(L,3);<N>  if parameters>=2 then groupname:=lua_tostring(L,2);<N>  if parameters>=1 then address:=lua_tostring(L,1);<N>  lua_pop(L, parameters);<N><N>  form:=TfrmStructures2.create(application);<N>  luaclass_newclass(L, form);<N><N>
unit Filehandler;<N><N>{$MODE Delphi}<N><N>{<N>implement replaced handlers for ReadProcessMemory and WriteProcessMemory so it<N>reads/writes to the file instead<N>}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  jwawindows, windows,<N>  {$endif}<N>  LCLIntf, syncobjs, sysutils, Classes;<N><N>
unit ProcessHandlerUnit;<N><N>{$MODE Delphi}<N><N>{<N>Will handle all process specific stuff like openening and closing a process<N>The ProcessHandler variable will be in cefuncproc, but a tabswitch to another<N>process will set it to the different tab's process<N>}<N><N>
interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  {$ifndef jni}LCLIntf, {$endif}<N>  newkernelhandler, classes, sysutils;<N><N>type<N>  TSystemArchitecture=(archX86=0, archArm=1);<N>  TOperatingsystemABI=(abiWindows=0, abiSystemV=1);<N><N>
type TProcessHandler=class<N>  private<N>    fis64bit: boolean;<N>    fprocesshandle: THandle;<N>    fpointersize: integer;<N>    fSystemArchitecture: TSystemArchitecture;<N>    fOSABI: TOperatingsystemABI;  //for c-code<N>    fHexDigitPreference: integer;<N>    procedure setIs64bit(state: boolean);<N>    procedure setProcessHandle(processhandle: THandle);<N>  public<N>    processid: dword;<N><N>
unit APIhooktemplatesettingsfrm;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, Lmessages, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, LResources, ExtCtrls, betterControls;<N><N>type<N><N>  { TfrmAPIhookTemplateSettings }<N><N>
  TfrmAPIhookTemplateSettings = class(TForm)<N>    Edit1: TEdit;<N>    Edit2: TEdit;<N>    Edit3: TEdit;<N>    Label1: TLabel;<N>    Label2: TLabel;<N>    Label3: TLabel;<N>    Label4: TLabel;<N>    Label6: TLabel;<N>    Button1: TButton;<N>    Button2: TButton;<N>    Label5: TLabel;<N>    Panel1: TPanel;<N>    procedure FormCreate(Sender: TObject);<N>    procedure FormShow(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
implementation<N><N><N>{ TfrmAPIhookTemplateSettings }<N><N>procedure TfrmAPIhookTemplateSettings.FormCreate(Sender: TObject);<N>begin<N><N>end;<N><N>procedure TfrmAPIhookTemplateSettings.FormShow(Sender: TObject);<N>begin<N>  button1.autosize:=false;<N>  button2.autosize:=false;<N>  if button1.width<button2.width then<N>    button1.width:=button2.width else button2.width:=button1.width;<N>end;<N><N>
unit LuaBrush;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Graphics,lua, lualib, lauxlib, LuaHandler;<N><N>procedure initializeLuaBrush;<N><N>implementation<N><N>uses LuaClass, LuaObject;<N><N>function Brush_getColor(L: PLua_State): integer; cdecl;<N>var<N>  Brush: TBrush;<N>begin<N>  Brush:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, Brush.Color);<N>  result:=1;<N>end;<N><N>
unit MemFuncs;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, cefuncproc, newkernelhandler, commonTypeDefs;<N><N>procedure getexecutablememoryregionsfromregion(start: ptrUint; stop:ptrUint; var memoryregions: TMemoryRegions);<N>function getallmemoryregions(var memoryregions: tmemoryregions): qword;<N><N>
implementation<N><N>uses ProcessHandlerUnit;<N><N><N>function getallmemoryregions(var memoryregions: tmemoryregions): qword;<N>var address: ptrUint;<N>    mbi: memory_basic_information;<N>    stop: ptruint;<N>begin<N>  result:=0;<N><N>  setlength(memoryregions,0);<N>  address:=0;<N>  if processhandler.is64Bit then<N>    stop:=$7fffffffffffffff<N>  else<N>    stop:=$7fffffff;<N><N>
unit MenuItemExtra;<N><N>{$MODE Delphi}<N><N>{<N>V1.0: TMenuItemExtra is just a TMenuItem with an extra data pointer, so menu<N>items can be created on the fly and assigned extra data in the form of records<N>or other objects useful for an onclick handler<N>}<N><N>interface<N><N>uses menus, betterControls;<N><N>type TMenuItemExtra=class(TMenuItem)<N>  public<N>    data: pointer;<N>end;<N><N>implementation<N><N>end.<N>
// Copyright Cheat Engine. All Rights Reserved.<N><N>unit frmSourceDisplayUnit;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, LResources, Forms, Controls, Graphics, Dialogs, ComCtrls,<N>  ExtCtrls, Menus, SynEdit, SynEditMarks, SynHighlighterCpp, disassembler,<N>  MemoryBrowserFormUnit, tcclib, betterControls, SynGutterBase, debugeventhandler,<N>  BreakpointTypeDef;<N><N>
unit symbolconfigunit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, Messages, LMessages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls,symbolhandler, symbolhandlerstructs, ComCtrls, ExtCtrls,<N>  Menus, LResources, betterControls;<N><N>
unit frmStructures2ElementInfoUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef windows}windows,{$endif}Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ExtCtrls, cefuncproc, StructuresFrm2, vartypestrings, math, CustomTypeHandler, commonTypeDefs, betterControls;<N><N>
resourcestring<N>  rsS2EILocalStruct = 'Local struct:';<N>  rsS2EIIfYouContinueTheOldLocallyDefinedType = 'If you continue the old locally defined type %s will be deleted. Continue? (Tip: You can make this type into a global type so it can be re-used over again)';<N>  rsUndefined = 'Undefined';<N>  rsMustSelectStructure = 'For a nested structure you must select a predefined'<N>    +' structure';<N>type<N><N>
unit contexthandler;<N><N>//helper for dealing with different context types<N><N>//{$mode ObjFPC}{$H+}<N>{$mode ObjFPC}{$H+}<N>{$MODESWITCH ADVANCEDRECORDS}<N><N>interface<N><N>uses<N>  {$ifdef darwin}macport,{$endif}{$ifdef windows}windows, {$endif}Classes, SysUtils,StringHashList, newkernelhandler,math;<N><N>
unit ProcessList;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef windows}jwawindows, windows, {$endif}<N>  {$ifdef darwin}macport,{$endif}<N>  cefuncproc, LazUTF8, Classes, SysUtils{$ifndef JNI}, StdCtrls{$endif},<N>  ProcessHandlerUnit {$ifdef JNI},unixporthelper{$endif},newkernelhandler;<N><N>
{$ifndef jni}<N>procedure GetProcessList(ProcessList: TListBox; NoPID: boolean=false); overload;<N>{$endif}<N>procedure GetProcessList(ProcessList: TStrings; NoPID: boolean=false; noProcessInfo: boolean=false); overload;<N>procedure sanitizeProcessList(processlist: TStrings);<N>procedure cleanProcessList(processlist: TStrings);<N><N>
<N>function GetFirstModuleName(processid: dword): string;<N><N><N>//global vars refering to the processlist<N>var<N>  GetProcessIcons: Boolean;<N>  ProcessesCurrentUserOnly: boolean;<N><N>implementation<N><N>uses Globals, commonTypeDefs, networkInterfaceApi<N>  {$ifdef darwin}<N>  , macportdefines //must be at the end<N>  {$endif}<N>  ;<N><N>
unit windows7taskbar;<N><N>{$MODE Delphi}<N>{$WARN 5044 off : Symbol "$1" is not portable}   //Windows 7 taskbar, says enough<N>interface<N><N>{$IFDEF windows}<N>//credits to http://alex.ciobanu.org/?p=215<N><N>uses Forms,win32int, win32proc;<N><N>type<N>  TTaskBarProgressState = (tbpsNone, tbpsIndeterminate, tbpsNormal, tbpsError, tbpsPaused);<N><N>
  procedure SetProgressState(const AState: TTaskBarProgressState);<N>  procedure SetProgressValue(const ACurrent, AMax: UInt64);<N>{$ENDIF}<N><N>implementation<N>{$IFDEF windows}<N>uses<N>  ComObj, Types, cefuncproc;<N><N>const<N>  TASKBAR_CID: TGUID = '{56FDF344-FD6D-11d0-958A-006097C9A090}';<N><N>
const<N>  TBPF_NOPROGRESS = 0;<N>  TBPF_INDETERMINATE = 1;<N>  TBPF_NORMAL = 2;<N>  TBPF_ERROR = 4;<N>  TBPF_PAUSED = 8;<N><N>type<N>  { Definition for Windows 7 ITaskBarList3 }<N>  ITaskBarList3 = interface(IUnknown)<N>  ['{EA1AFB91-9E28-4B86-90E9-9E9F8A5EEFAF}']<N>    procedure HrInit(); stdcall;<N>    procedure AddTab(hwnd: THandle); stdcall;<N>    procedure DeleteTab(hwnd: THandle); stdcall;<N>    procedure ActivateTab(hwnd: THandle); stdcall;<N>    procedure SetActiveAlt(hwnd: THandle); stdcall;<N><N>
    procedure MarkFullscreenWindow(hwnd: THandle; fFullscreen: Boolean); stdcall;<N><N>    procedure SetProgressValue(hwnd: THandle; ullCompleted: UInt64; ullTotal: UInt64); stdcall;<N>    procedure SetProgressState(hwnd: THandle; tbpFlags: Cardinal); stdcall;<N><N>
unit PointerscanresultReader;<N><N>{$MODE Delphi}<N><N>{<N>The TPointerscanresultReader will read the results from the pointerfile and present them to the pointerscanner as if it is just one file<N>}<N>interface<N><N>{$ifdef darwin}<N>uses macport, MacTypes, LCLIntf, sysutils, classes, CEFuncProc, NewKernelHandler,<N>  symbolhandler, math, dialogs, LazUTF8,macportdefines;<N>{$endif}<N><N>
<N>{$ifdef windows}<N>uses windows, LCLIntf, sysutils, classes, CEFuncProc, NewKernelHandler,<N>  symbolhandler, math, dialogs, LazUTF8;<N>{$endif}<N><N>resourcestring<N>  rsPSRCorruptedPointerscanFile = 'Corrupted pointerscan file';<N>  rsPSRInvalidPointerscanFileVersion = 'Invalid pointerscan file version';<N>  rsBuggedList = 'BuggedList';<N><N>
  {$ifdef windows}<N>function GetFileSizeEx(hFile:HANDLE; FileSize:PQWord):BOOL; stdcall; external 'kernel32.dll' name 'GetFileSizeEx';<N>{$endif}<N><N><N>type TPointerscanResult=packed record<N>  modulenr: integer;<N>  moduleoffset: int64;<N>  offsetcount: integer;<N>  offsets: array [0..1000] of integer;<N>end;<N>type PPointerscanResult= ^TPointerscanResult;<N><N>
type<N>  TPointerscanresultReader=class;<N>  TPointerscanresultReader=class<N>  private<N>    Fcount: qword;<N><N>    sizeOfEntry: integer;<N>    maxlevel: integer;<N>    modulelist: tstringlist;<N><N>    FFileName: widestring;<N>    files: array of record<N>      startindex: qword;<N>      lastindex: qword;<N>      filename: widestring;<N>      filesize: qword;<N>      f,fm: Thandle;<N>    end;<N><N>
    cacheStart: integer;<N>    cacheSize: size_t;<N>    cache: pointer;<N><N>    cacheStart2: integer;<N>    cacheSize2: integer;<N>    cache2: pointer;<N><N>    fExternalScanners: integer;<N>    fGeneratedByWorkerID: integer;<N>    fCompressedPtr: boolean;<N>    fAligned: boolean;<N><N>
    MaskModuleIndex: dword;<N>    MaskLevel: dword;<N>    MaskOffset: dword;<N><N>    fMaxBitCountModuleIndex: dword;<N>    fMaxBitCountModuleOffset: dword;<N>    fMaxBitCountLevel: dword;<N>    fMaxBitCountOffset: dword;<N><N>    fEndsWithOffsetList: array of dword;<N><N>
    fCanResume: boolean;<N>    fdidBaseRangeScan: boolean;<N>    foriginalBaseScanRange: qword;<N><N><N>    CompressedPointerScanResult: PPointerscanResult;<N>    compressedTempBuffer: PByteArray;<N><N>    fLastRawPointer: pointer;<N><N><N>    fmergedresults: array of integer;<N>    function InitializeCache(i: qword): boolean;<N>    function getModuleListCount: integer;<N><N>
unit LuaTimer;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, ExtCtrls, lua, lualib, lauxlib, CustomTimer;<N><N>procedure initializeLuaTimer;<N><N>implementation<N><N>uses luaclass, luahandler, luacaller, LuaComponent, Clipbrd, luasyntax;<N><N>
type<N>  TRunOnceTimer=class(TTimer)<N>  private<N>    procedure DoOnTimer; override;<N>  public<N>  end;<N><N>procedure TRunOnceTimer.DoOnTimer;<N>begin<N>  inherited DoOnTimer;<N><N>  Enabled:=false;<N>  free;<N>end;<N><N>function createTimerInternal(L: Plua_State): integer; cdecl;<N>var parameters: integer;<N>  f: pointer;<N><N>
  t: TTimer;<N>  interval: integer;<N>  m: tmethod;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  f:=nil;<N><N>  if parameters>=1 then<N>  begin<N>    if lua_isinteger(L,1) then<N>    begin<N>      if lua_isfunction(L,2) then  //run once timer<N>      begin<N>        interval:=lua_tointeger(L,1);<N><N>
unit MemoryStreamReader;<N><N>{<N>Implements the TMemoryStreamReader object.<N>It's basically a memorystream that can not write. It's main purpose is to provide a seperate read pointer for a memorystream object<N><N>One requirement is that the memorystream object does not get written to while this object exists<N>}<N>{$mode delphi}<N><N>
interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>  TMemoryStreamReader=class(TCustomMemoryStream)<N>  private<N>  protected<N>  public<N>    constructor create(ms: TCustomMemoryStream);<N>  end;<N><N>implementation<N><N><N>constructor TMemoryStreamReader.create(ms: TCustomMemoryStream);<N>begin<N>  inherited create;<N>  SetPointer(ms.Memory, ms.size);<N>end;<N><N>
unit LuaCheckListBox;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, controls, CheckLst, betterControls;<N><N>procedure initializeLuaCheckListbox;<N><N>implementation<N><N>uses LuaListbox, luahandler, luaclass, lua;<N><N>function createCheckListBox(L: Plua_State): integer; cdecl;<N>var<N>  CheckListBox: TCheckListBox;<N>  parameters: integer;<N>  owner: TWincontrol;<N>begin<N>  result:=0;<N><N>
  parameters:=lua_gettop(L);<N>  if parameters>=1 then<N>    owner:=lua_toceuserdata(L, -parameters)<N>  else<N>    owner:=nil;<N><N>  lua_pop(L, lua_gettop(L));<N><N><N>  CheckListBox:=TCheckListBox.Create(owner);<N>  if owner<>nil then<N>    CheckListBox.Parent:=owner;<N><N>
  luaclass_newClass(L, CheckListBox);<N>  result:=1;<N>end;<N><N>function checklistbox_getChecked(L: PLua_State): integer; cdecl;<N>var<N>  checklistbox: TCustomCheckListBox;<N>  index: integer;<N>begin<N>  result:=0;<N>  checklistbox:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=1 then<N>  begin<N>    index:=lua_toInteger(L, 1);<N>    lua_pushboolean(L, checklistbox.Checked[index]);<N>    result:=1;<N>  end;<N>end;<N><N>
function checklistbox_setChecked(L: PLua_State): integer; cdecl;<N>var<N>  checklistbox: TCustomCheckListBox;<N>  index: integer;<N>begin<N>  result:=0;<N>  checklistbox:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=2 then<N>  begin<N>    index:=lua_toInteger(L, 1);<N>    checklistbox.Checked[index]:=lua_toboolean(L, 2);<N>  end;<N>end;<N><N>
procedure checklistbox_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>begin<N>  listbox_addMetaData(L, metatable, userdata);<N>  luaclass_addArrayPropertyToTable(L, metatable, userdata, 'Checked', checklistbox_getChecked, checklistbox_setChecked);<N>end;<N><N>
unit cpuidUnit;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>  TCPUIDResult=record<N>    eax: dword;<N>    ebx: dword;<N>    ecx: dword;<N>    edx: dword;<N>  end;<N><N>function CPUID(index: dword; index2: dword=0): TCPUIDResult;<N><N>
implementation<N><N><N><N>{$ifndef CPUAARCH64}<N><N>{$ifdef cpu32}<N>procedure _cpuid(p: pointer); assembler;<N>asm<N>  push edi<N>  mov edi,p<N><N>  push eax<N>  push ebx<N>  push ecx<N>  push edx<N><N>  mov eax,[edi]<N>  mov ebx,[edi+4]<N>  mov ecx,[edi+8]<N>  mov edx,[edi+12]<N><N>
  cpuid<N>  mov [edi],eax<N>  mov [edi+4],ebx<N>  mov [edi+8],ecx<N>  mov [edi+12],edx<N><N>  pop edx<N>  pop ecx<N>  pop ebx<N>  pop eax<N><N>  pop edi<N>end;<N>{$endif}<N><N><N>{$ifdef cpu64}<N>procedure _cpuid(p: pointer); stdcall; assembler;<N>asm<N>  mov r8,p<N>  mov r9,rbx //save rbx<N>  mov eax,[r8]<N>  mov ebx,[r8+4]<N>  mov ecx,[r8+8]<N>  mov edx,[r8+12]<N>  cpuid<N><N>
  mov [r8],eax<N>  mov [r8+4],ebx<N>  mov [r8+8],ecx<N>  mov [r8+12],edx<N><N>  mov rbx,r9 //restore rbx<N>end;<N>{$endif}<N>{$endif} //cpuaarch64<N><N>function CPUID(index: dword; index2: dword=0): TCPUIDResult;<N>var<N>  r: TCPUIDResult;<N>begin<N>  r.eax:=index;<N>  r.ebx:=0;<N>  r.ecx:=index2;<N>  r.edx:=0;<N><N>
unit LuaSymbolListHandler;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, LuaClass, SymbolListHandler;<N><N>procedure initializeLuaSymbolListHandler;<N><N>procedure pushSymbol(L: PLua_state; si: PCESymbolInfo);<N><N>implementation<N><N>
uses LuaHandler, LuaObject, symbolhandler, ProcessHandlerUnit, NewKernelHandler;<N><N>function getMainSymbolList(L: Plua_State): integer; cdecl;<N>begin<N>  result:=1;<N>  luaclass_newClass(L, symhandler.GetMainSymbolList);<N>end;<N><N><N>function enumRegisteredSymbolLists(L: Plua_State): integer; cdecl;<N>var<N>  list: tlist;<N>  i: integer;<N>begin<N>  result:=1;<N>  list:=tlist.create;<N>  symhandler.GetSymbolLists(list);<N>  lua_createtable(L,list.count,0);<N><N>
  for i:=0 to list.count-1 do<N>  begin<N>    lua_pushinteger(L,i+1);<N>    luaclass_newClass(L,list[i]);<N>    lua_settable(L,-3);<N>  end;<N>  exit(1);<N>end;<N><N>function createSymbolList(L: Plua_State): integer; cdecl;<N>begin<N>  result:=1;<N>  luaclass_newClass(L, TSymbolListHandler.create);<N>end;<N><N>
function SymbolList_clear(L: Plua_State): integer; cdecl;<N>var<N>  sl: TSymbolListHandler;<N>begin<N>  sl:=luaclass_getClassObject(L);<N>  sl.clear;<N>  result:=0;<N>end;<N><N>function SymbolList_register(L: Plua_State): integer; cdecl;<N>var<N>  sl: TSymbolListHandler;<N>begin<N>  sl:=luaclass_getClassObject(L);<N>  symhandler.AddSymbolList(sl);<N>  result:=0;<N>end;<N><N>
function SymbolList_unregister(L: Plua_State): integer; cdecl;<N>var<N>  sl: TSymbolListHandler;<N>begin<N>  sl:=luaclass_getClassObject(L);<N>  symhandler.RemoveSymbolList(sl);<N>  result:=0;<N>end;<N><N>function SymbolList_getModuleList(L: Plua_State): integer; cdecl;<N>var<N>  sl: TSymbolListHandler;<N>  list: TExtraModuleInfoList;<N>  i: integer;<N>begin<N>  sl:=luaclass_getClassObject(L);<N>  sl.GetModuleList(list);<N><N>
  lua_createtable(L, length(list),0);<N>  for i:=0 to length(list)-1 do<N>  begin<N>    lua_pushinteger(L,i+1);<N>    lua_createtable(L,0,5);<N><N>    lua_pushstring(L,'modulename');<N>    lua_pushstring(L,pchar(list[i].modulename));<N>    lua_settable(L,-3);<N><N>
    lua_pushstring(L,'modulepath');<N>    lua_pushstring(L,pchar(list[i].modulepath));<N>    lua_settable(L,-3);<N><N>    lua_pushstring(L,'baseaddress');<N>    lua_pushinteger(L,list[i].baseaddress);<N>    lua_settable(L,-3);<N><N>    lua_pushstring(L,'modulesize');<N>    lua_pushinteger(L,list[i].modulesize);<N>    lua_settable(L,-3);<N><N>
    lua_pushstring(L,'is64bitmodule');<N>    lua_pushboolean(L,list[i].is64bitmodule);<N>    lua_settable(L,-3);<N><N>    lua_settable(L,-3);<N>  end;<N><N>  result:=1;<N>end;<N><N>function SymbolList_getSymbolList(L: Plua_State): integer; cdecl;<N>var<N>  sl: TSymbolListHandler;<N>  list: tstringlist;<N>  i: integer;<N>begin<N>  sl:=luaclass_getClassObject(L);<N><N>
  list:=tstringlist.create;<N>  sl.GetSymbolList(list);<N><N>  lua_createtable(L, 0,list.count);<N>  for i:=0 to list.count-1 do<N>  begin<N>    lua_pushstring(L, pchar(list[i]));<N>    lua_pushinteger(L, ptruint(list.Objects[i]));<N>    lua_settable(L,-3);<N>  end;<N><N>
  result:=1;<N><N>  list.free;<N>end;<N><N>procedure pushSymbol(L: PLua_state; si: PCESymbolInfo);<N>var tableindex: integer;<N>begin<N>  lua_newtable(L);<N>  tableindex:=lua_gettop(L);<N><N>  lua_pushstring(L,'modulename');<N>  lua_pushstring(L,si.module);<N>  lua_settable(L, tableindex);<N><N>
  lua_pushstring(L,'searchkey');<N>  lua_pushstring(L,si.originalstring);<N>  lua_settable(L, tableindex);<N><N>  lua_pushstring(L,'address');<N>  lua_pushinteger(L,si.address);<N>  lua_settable(L, tableindex);<N><N>  lua_pushstring(L,'symbolsize');<N>  lua_pushinteger(L,si.size);<N>  lua_settable(L, tableindex);<N>end;<N><N>
function SymbolList_GetSymbolFromAddress(L: Plua_State): integer; cdecl;<N>var<N>  sl: TSymbolListHandler;<N>  si: PCESymbolInfo;<N>begin<N>  result:=0;<N>  sl:=luaclass_getClassObject(L);<N><N>  si:=sl.FindAddress(lua_tointeger(L, 1));<N>  if si<>nil then<N>  begin<N>    pushSymbol(L, si);<N>    result:=1;<N>  end;<N>end;<N><N>
function SymbolList_getSymbolFromString(L: Plua_State): integer; cdecl;<N>var<N>  sl: TSymbolListHandler;<N>  si: PCESymbolInfo;<N>begin<N>  result:=0;<N>  sl:=luaclass_getClassObject(L);<N><N>  si:=sl.FindSymbol(lua_tostring(L, 1));<N>  if si<>nil then<N>  begin<N>    pushSymbol(L, si);<N>    result:=1;<N>  end;<N>end;<N><N>
function SymbolList_deleteModule(L: Plua_State): integer; cdecl;<N>var<N>  sl: TSymbolListHandler;<N>  s: string;<N>begin<N>  result:=0;<N>  sl:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=1 then<N>  begin<N>    if lua_isnumber(L,1) then<N>      sl.DeleteModule(qword(lua_tointeger(L,1)))<N>    else<N>    begin<N>      s:=Lua_ToString(L,1);<N>      sl.DeleteModule(s);<N>    end;<N>  end;<N>end;<N><N>
function SymbolList_addModule(L: Plua_State): integer; cdecl;<N>var<N>  sl: TSymbolListHandler;<N>  modulename: string;<N>  modulepath: string;<N>  base: ptruint;<N>  size: integer;<N>  is64bit: boolean;<N>begin<N>  result:=0;<N>  sl:=luaclass_getClassObject(L);<N><N>
  if lua_gettop(L)>=4 then<N>  begin<N>    modulename:=Lua_ToString(L,1);<N>    modulepath:=Lua_ToString(L,2);<N>    base:=lua_tointeger(L,3);<N>    size:=lua_tointeger(L,4);<N>    if lua_gettop(L)>=5 then<N>      is64bit:=lua_toboolean(L,5)<N>    else<N>      is64bit:=processhandler.is64bit;<N><N>
    sl.AddModule(modulename, modulepath, base, size, is64bit);<N>  end;<N>end;<N><N>function SymbolList_addSymbol(L: Plua_State): integer; cdecl;<N>var<N>  sl: TSymbolListHandler;<N>  si: PCESymbolInfo;<N><N>  modulename: string;<N>  searchkey: string;<N>  address: qword;<N>  size: integer;<N>  skipAddressToSymbol: boolean;<N><N>
  esd: TExtraSymbolData;<N>  returntype: string;<N>  parameters: string;<N>begin<N>  result:=0;<N>  sl:=luaclass_getClassObject(L);<N>  esd:=nil;<N><N>  if lua_gettop(L)>=4 then //modulename, searchkey, address, symbolsize, skipAddressToSymbol<N>  begin<N>    modulename:=lua_tostring(L, 1);<N>    searchkey:=lua_tostring(L, 2);<N>    address:=lua_tointeger(L, 3);<N>    size:=lua_tointeger(L, 4);<N><N>
    if lua_gettop(L)>=5 then<N>      skipAddressToSymbol:=lua_toboolean(L, 5)<N>    else<N>      skipAddressToSymbol:=false;<N><N>    if lua_gettop(L)>=6 then<N>    begin<N>      if lua_istable(L, 6) then<N>      begin<N>        lua_pushstring(L, 'returntype');<N>        lua_gettable(L, 6);<N><N>
        returntype:=Lua_ToString(L, -1);<N>        lua_pop(L,1);<N><N>        lua_pushstring(L, 'parameters');<N>        lua_gettable(L, 6);<N><N>        parameters:=Lua_ToString(L, -1);<N>        lua_pop(L,1);<N><N>        if (returntype<>'') or (parameters<>'') then<N>        begin<N>          esd:=TExtraSymbolData.create;<N>          esd.return:=returntype;<N>          esd.simpleparameters:=parameters;<N><N>
          esd.filledin:=true;<N><N>          sl.AddExtraSymbolData(esd);<N>        end;<N><N>      end;<N><N>    end<N>    else<N>      parameters:='';<N><N><N>    si:=sl.AddSymbol(modulename, searchkey, address, size, skipAddressToSymbol, esd,true);<N><N>
<N>    if esd<>nil then<N>      esd.free;<N><N>    if si=nil then<N>    begin<N>      //outputdebugstring('sl.AddSymbol returned nil');<N>      exit(0);<N>    end;<N><N><N>    pushSymbol(L, si);<N>    result:=1;<N>  end;<N>end;<N><N>function SymbolList_deleteSymbol(L: Plua_State): integer; cdecl;<N>var<N>  sl: TSymbolListHandler;<N>  si: PCESymbolInfo;<N>begin<N>  result:=0;<N>  sl:=luaclass_getClassObject(L);<N><N>
<N>  if lua_type(L,1)=LUA_TNUMBER then<N>  begin<N>    si:=sl.FindAddress(lua_tointeger(L, 1));<N>    if si<>nil then<N>    begin<N>      if si.extra<>nil then<N>      begin<N>        sl.RemoveExtraSymbolData(si.extra);<N>        si.extra.free;<N>      end;<N><N>
      sl.DeleteSymbol(lua_tointeger(L, 1))<N>    end;<N>  end<N>  else<N>  begin<N>    si:=sl.FindSymbol(lua_tostring(L, 1));<N>    if si<>nil then<N>    begin<N>      if si.extra<>nil then<N>      begin<N>        sl.RemoveExtraSymbolData(si.extra);<N>        si.extra.free;<N>      end;<N><N>
unit ServiceDescriptorTables;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef windows}<N>  windows, imagehlp,<N>  {$endif}LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs,CEFuncProc,NewKernelHandler, Menus, ComCtrls,symbolhandler,disassembler,<N>  StdCtrls, LResources, commonTypeDefs;<N><N>
unit LuaGraphic;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Graphics,lua, lualib, lauxlib,LuaHandler;<N><N>procedure initializeLuaGraphic;<N>procedure graphic_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N><N>
implementation<N><N>uses luaclass, LuaObject;<N><N>function graphic_getWidth(L: PLua_State): integer; cdecl;<N>var<N>  graphic: TGraphic;<N>begin<N>  graphic:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, graphic.Width);<N>  result:=1;<N>end;<N><N>function graphic_setWidth(L: PLua_State): integer; cdecl;<N>var<N>  graphic: TGraphic;<N>begin<N>  result:=0;<N>  graphic:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    graphic.Width:=lua_tointeger(L, 1);<N>end;<N><N>
function graphic_getHeight(L: PLua_State): integer; cdecl;<N>var<N>  graphic: TGraphic;<N>begin<N>  graphic:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, graphic.Height);<N>  result:=1;<N>end;<N><N>function graphic_setHeight(L: PLua_State): integer; cdecl;<N>var<N>  graphic: TGraphic;<N>begin<N>  result:=0;<N>  graphic:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    graphic.Height:=lua_tointeger(L, 1);<N>end;<N><N>
function graphic_getTransparent(L: PLua_State): integer; cdecl;<N>var<N>  graphic: TGraphic;<N>begin<N>  graphic:=luaclass_getClassObject(L);<N>  lua_pushboolean(L, graphic.Transparent);<N>  result:=1;<N>end;<N><N>function graphic_setTransparent(L: PLua_State): integer; cdecl;<N>var<N>  graphic: TGraphic;<N>begin<N>  result:=0;<N>  graphic:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=1 then<N>    graphic.Transparent:=lua_toboolean(L, 1);<N>end;<N><N>
function graphic_loadFromFile(L: PLua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  if lua_gettop(L)>=1 then<N>    tgraphic(luaclass_getClassObject(L)).LoadFromFile(Lua_ToString(L,1));<N>end;<N><N>function graphic_saveToFile(L: PLua_State): integer; cdecl;<N>begin<N>  result:=0;<N>  if lua_gettop(L)>=1 then<N>    tgraphic(luaclass_getClassObject(L)).SaveToFile(Lua_ToString(L,1));<N>end;<N><N>
//Copyright Cheat Engine<N><N><N>unit CSharpCompiler;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  {$ifdef windows}<N>  jwawindows, windows, Classes, SysUtils, dotnethost{$ifndef standalonetest}, newkernelhandler{$endif};<N>  {$else}<N>  classes, SysUtils;<N>  //todo: mono?<N>  {$endif}<N><N>
unit groupscancommandparser;<N><N>{<N>This unit contains the class that reads a groupscan command and parses it. The results can be looked at afterwards<N>}<N><N>{$mode delphi}<N><N>interface<N><N><N><N><N>{$ifdef jni}<N>uses Classes, SysUtils, strutils, CustomTypeHandler, commonTypeDefs;<N>{$else}<N>uses Classes, SysUtils, cefuncproc, CustomTypeHandler, strutils, commonTypeDefs;<N>{$endif}<N><N>
resourcestring<N>  rsGSCPCustomTypeNotRecognized = 'Custom type not recognized: ';<N>  rsGSCPInvalidGroupscanCommand = 'Invalid groupscan command';<N>  rsGSCPWildcardsEmptyAreNotAllowedForOutOfOrderScans = 'Wildcards/Empty are not allowed for Out of Order scans';<N>  rsARangeTypeNeedsARangeForValue = 'A range type needs a range for value';<N>  rsARangeCantBeAWildcard = 'A range can''t be a wildcard';<N><N>
type<N>  TGroupscanCommandParser=class<N>  private<N>    calculatedBlocksize: integer;<N>    function parseFloat(const s: string): double;<N>    function splitRange(const s: string): TStringArray;<N>    procedure parseToken(s: string);<N>  public<N>    FloatSettings: TFormatSettings;<N><N>
unit LuaDebug;<N><N>{This unit will hold the debug_ specific lua functions, not related to lua debugging}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, newkernelhandler, debug, DebugHelper,<N>  DebuggerInterfaceAPIWrapper, lua, lualib, lauxlib, LuaHandler{$ifdef darwin},macport{$endif};<N><N>
procedure initializeLuaDebug;<N><N>implementation<N><N>function debug_setLastBranchRecording(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  newstate: boolean;<N>begin<N>  OutputDebugString('debug_setLastBranchRecording');<N>  result:=0;<N><N>
  parameters:=lua_gettop(L);<N>  {$ifdef windows}<N>  if parameters=1 then<N>  begin<N>    newstate:=lua_toboolean(L, -1);<N>    DBKDebug_SetStoreLBR(newstate);<N>  end;<N>  {$endif}<N><N>  lua_pop(L, parameters);<N>end;<N><N>function debug_getMaxLastBranchRecord(L: PLua_State): integer; cdecl;<N>var<N>  max: integer;<N>begin<N>  result:=1;<N><N>
  if CurrentDebuggerInterface<>nil then<N>    max:=CurrentDebuggerInterface.GetLastBranchRecords(nil)<N>  else<N>    max:=-1;<N><N>  lua_pop(L, lua_gettop(L));<N>  lua_pushinteger(L, max);<N>end;<N><N>function debug_getLastBranchRecord(L: PLua_State): integer; cdecl;<N>type TQwordArray=array [0..0] of qword;<N>  PQwordArray=^Tqwordarray;<N>var<N>  parameters: integer;<N>  value: ptruint;<N>  max: integer;<N>  index: integer;<N>  lbrbuf: PQwordArray;<N>begin<N>  result:=0;<N><N>
  parameters:=lua_gettop(L);<N><N>  if parameters=1 then<N>  begin<N>    index:=lua_tointeger(L, -1);<N>    lua_pop(L, parameters);<N><N>    if CurrentDebuggerInterface<>nil then<N>    begin<N>      max:=CurrentDebuggerInterface.GetLastBranchRecords(nil);<N>      getmem(lbrbuf, max*sizeof(qword));<N>      try<N>        max:=CurrentDebuggerInterface.GetLastBranchRecords(lbrbuf);<N>        if index<=max then<N>          lua_pushinteger(L, lbrbuf[index]);<N><N>
        result:=1;<N>      finally<N>        FreeMemAndNil(lbrbuf);<N>      end;<N>    end;<N><N>  end<N>  else<N>    lua_pop(L, parameters);<N>end;<N><N>function debug_getXMMPointer(L: PLua_State): integer; cdecl;<N>var<N>  c: ptruint;<N>  xmmreg: integer;<N>  parameters: integer;<N>begin<N>  result:=1;<N>  c:=0;<N><N>
  parameters:=lua_gettop(L);<N><N>  if parameters=1 then<N>  begin<N>    xmmreg:=lua_tointeger(L, -1);<N>    if (debuggerthread<>nil) and (debuggerthread.CurrentThread<>nil) then<N>      c:=ptruint(@debuggerthread.CurrentThread.context.{$ifdef cpu64}FltSave.{$else}ext.{$endif}XmmRegisters[xmmreg]);<N>  end;<N><N>
  lua_pop(L, lua_gettop(L));<N>  lua_pushinteger(L, c);<N>end;<N><N><N>procedure initializeLuaDebug;<N>begin<N>  lua_register(LuaVM, 'debug_setLastBranchRecording', debug_setLastBranchRecording);<N>  lua_register(LuaVM, 'debug_getMaxLastBranchRecord', debug_getMaxLastBranchRecord);<N>  lua_register(LuaVM, 'debug_getLastBranchRecord', debug_getLastBranchRecord);<N>  lua_register(LuaVM, 'debug_getXMMPointer', debug_getXMMPointer);<N><N>
unit disassemblerviewlinesunit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses math,LCLIntf,sysutils, classes,ComCtrls, graphics, CEFuncProc, disassembler,<N>     CEDebugger, debughelper, KernelDebugger, symbolhandler, plugin,<N>     disassemblerComments, SymbolListHandler, ProcessHandlerUnit, tcclib,SynHighlighterCpp<N>     {$ifdef USELAZFREETYPE}<N>     ,LazFreeTypeIntfDrawer, EasyLazFreeType<N>     {$endif}, betterControls;<N><N>
type<N>  TDisassemblerViewColorsState=(csUndefined=-1, csNormal=0, csHighlighted=1, csSecondaryHighlighted=2, csBreakpoint=3, csHighlightedbreakpoint=4, csSecondaryHighlightedbreakpoint=5, csUltimap=6, csHighlightedUltimap=7, csSecondaryHighlightedUltimap=8);<N>  TDisassemblerViewColors=array [csNormal..csSecondaryHighlightedUltimap] of record<N>    backgroundcolor: TColor;<N>    normalcolor: TColor;<N>    registercolor: TColor;<N>    symbolcolor: TColor;<N>    hexcolor: TColor;<N>  end;<N><N>
  PDisassemblerViewColors=^TDisassemblerViewColors;<N><N>  TDisassemblerLine=class<N>  private<N>    fowner: TObject;<N>    fbitmap: tbitmap;<N>    fCanvas: TCanvas;<N>    fHeaders: THeaderSections;<N>    ftop: integer;<N>    fheight: integer; //height of the line<N>    fDefaultHeight: integer; //the normal height without anything extra<N>    fInstructionCenter: integer; //y position of the center of the disassembled line (so no header)<N><N>
unit zstreamext;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, zstream;<N><N>type<N>  TCompressionstreamWithPositionSupport=class(Tcompressionstream)<N>  private<N>  public<N>    function Seek(const Offset: Int64; Origin: TSeekOrigin): Int64;  override;<N>  end;<N><N>
implementation<N><N>resourcestring<N>  rsASeekWasDoneForAnotherPurpose = 'A seek was done for another purpose than getting the position';<N><N>function TcompressionstreamWithPositionSupport.Seek(const Offset: Int64; Origin: TSeekOrigin): Int64;<N>begin<N>  if (origin=soCurrent) and (offset=0) then<N>    result:=raw_written //fsource.position<N>  else<N>    raise exception.create(rsASeekWasDoneForAnotherPurpose);<N>end;<N><N>
unit frmstacktraceunit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, macportdefines,<N>  {$endif}<N>  {$ifdef windows}<N>  windows, imagehlp,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs,NewKernelHandler, CEFuncProc, ComCtrls,CEDebugger, KernelDebugger,<N>  Menus, LResources, debughelper, symbolhandler, betterControls;<N><N>
unit LuaCustomImageList;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Controls, lua, lualib, lauxlib, ImgList, GraphType;<N><N>procedure initializeLuaCustomImageList;<N><N>implementation<N><N>uses luahandler, luaclass, LuaComponent, LuaCaller, Graphics, Forms, TypInfo;<N><N>
function createImageList(L: Plua_State): integer; cdecl;<N>var il: TImageList;<N>  owner: TComponent;<N>begin<N>  if lua_gettop(L)>=1 then<N>    owner:=lua_ToCEUserData(L,1)<N>  else<N>    owner:=nil;<N><N>  il:=TImageList.Create(owner);<N>  luaclass_newClass(L, il);<N>  result:=1;<N>end;<N><N>
function customimagelist_draw(L: PLua_State): integer; cdecl;<N>var<N>  c: TCustomImageList;<N>  canvas: tcanvas;<N>  x,y: integer;<N>  index: integer;<N>begin<N><N>  result:=0;<N>  c:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=4 then<N>  begin<N>    canvas:=lua_ToCEUserData(L,1);<N>    x:=lua_tointeger(L,2);<N>    y:=lua_tointeger(L,3);<N>    index:=lua_tointeger(L,4);<N><N>
    c.DrawForPPI(canvas,x,y,index,c.width,screen.PixelsPerInch,1);<N>  end;<N>end;<N><N>function customimagelist_getBitmap(L: PLua_State): integer; cdecl;<N>var<N>  c: TCustomImageList;<N>  index: integer;<N>  image: tcustombitmap;<N>  effect: TGraphicsDrawEffect;<N>begin<N><N>
  result:=0;<N>  c:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=2 then<N>  begin<N>    index:=lua_tointeger(L,1);<N>    image:=lua_touserdata(L,2);<N><N>    if lua_gettop(L)>=3 then<N>    begin<N>      if lua_isinteger(L,3) then<N>        effect:=TGraphicsDrawEffect(lua_tointeger(L,3))<N>      else<N>        effect:=TGraphicsDrawEffect(GetEnumValue(typeinfo(TGraphicsDrawEffect),lua_ToString(L,3)));<N>    end<N>    else<N>      effect:=gdeNormal;<N><N>
    c.GetBitmap(index, image, effect);<N>  end;<N>end;<N><N><N><N>function customimagelist_add(L: PLua_State): integer; cdecl;<N>var<N>  c: TCustomImageList;<N>  i: integer;<N>  img, mask: TCustomBitmap;<N>begin<N>  result:=0;<N>  c:=luaclass_getClassObject(L);<N>  if lua_Gettop(L)>=1 then<N>  begin<N>    img:=lua_ToCEUserData(L,1);<N><N>
    if lua_Gettop(L)>=2 then<N>      mask:=lua_ToCEUserData(L,2)<N>    else<N>      mask:=nil;<N><N>    lua_pushinteger(L, c.Add(img,mask));<N>    result:=1;<N>  end;<N>end;<N><N>function customimagelist_getCount(L: PLua_State): integer; cdecl;<N>var<N>  c: TCustomImageList;<N>begin<N>  c:=luaclass_getClassObject(L);<N>  lua_pushinteger(L,c.count);<N>  result:=1;<N>end;<N><N>
<N><N><N>procedure customimagelist_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>begin<N>  component_addMetaData(L, metatable, userdata);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'add', customimagelist_add);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'draw', customimagelist_draw);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'getBitmap', customimagelist_getBitmap);<N><N>
<N><N>  luaclass_addPropertyToTable(L, metatable, userdata,'Count',customimagelist_getCount,nil);<N>end;<N><N>procedure initializeLuaCustomImageList;<N>begin<N>  lua_register(LuaVM, 'createImageList', createImageList);<N>end;<N><N>initialization<N>  luaclass_register(TCustomImageList, customimagelist_addMetaData);<N><N>
unit frmAdConfigUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, LResources, Forms, Controls, Graphics, Dialogs,<N>  StdCtrls, ExtCtrls, ComCtrls, cesupport, betterControls;<N><N>resourcestring<N>  rsPercentageShown = 'Percentage shown';<N><N>
unit bCrypt;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>{$ifdef windows}<N><N>uses<N>  windows, Classes, SysUtils;<N><N>type<N>  NTSTATUS = ULONG;<N>  BCRYPT_ALG_HANDLE = handle;<N>  BCRYPT_KEY_HANDLE = handle;<N>  BCRYPT_HASH_HANDLE = handle;<N>  BCRYPT_HANDLE = handle;<N>  PBCRYPT_KEY_HANDLE = ^BCRYPT_KEY_HANDLE;<N><N>
const<N>  BCRYPT_ALG_HANDLE_HMAC_FLAG = 8;<N>  BCRYPT_PROV_DISPATCH = 1;<N><N>  BCRYPT_RSAFULLPRIVATE_BLOB = 'RSAFULLPRIVATEBLOB';<N>  BCRYPT_RSAPUBLIC_BLOB      = 'RSAPUBLICBLOB';<N>  BCRYPT_RSAPRIVATE_BLOB     = 'RSAPRIVATEBLOB';<N><N>  BCRYPT_DSA_PUBLIC_BLOB     = 'DSAPUBLICBLOB';<N>  BCRYPT_DSA_PRIVATE_BLOB    = 'DSAPRIVATEBLOB';<N><N>
unit frmFloatingPointPanelUnit;<N><N>{$MODE Delphi}<N><N>{<N>This window will be used to display the floating point values of a context structure<N>}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, math,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ExtCtrls, cefuncproc, ComCtrls, LResources, NewKernelHandler,<N>  commonTypeDefs, betterControls, contexthandler;<N><N>
unit LuaPipeClient;<N><N><N>//pipe server class specifically made for lua. Only 1 client and 1 server connection at a time<N><N><N>{$mode delphi}<N><N>interface<N><N><N>uses<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  {$ifdef darwin}<N>  macport, macpipe,<N>  {$endif}<N>  Classes, SysUtils, LuaPipe, lua, LuaClass;<N><N>
procedure initializeLuaPipeClient;<N><N>type<N>  TLuaPipeClient=class(TPipeConnection)<N>  private<N>  public<N>    constructor create(pipename: string; timeout: integer=0);<N>  end;<N><N><N>implementation<N><N>uses LuaHandler, networkInterface, networkInterfaceApi;<N><N>
unit winsapi;<N><N>{<N>partial sapi.h conversion for the syntesized voice functions<N><N>https://www.w3.org/TR/speech-synthesis/<N><N>works:<N><?xml version="1.0"?><N><speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis"<N>       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<N>       xsi:schemaLocation="http://www.w3.org/2001/10/synthesis<N>                 http://www.w3.org/TR/speech-synthesis/synthesis.xsd"<N>       xml:lang="en-US"><N><N>
hello<N></speak><N><N>this wil freeze it(for a too long time)<N><?xml version="1.0"?><N><!DOCTYPE speak PUBLIC "-//W3C//DTD SYNTHESIS 1.0//EN"<N>                  "http://www.w3.org/TR/speech-synthesis/synthesis.dtd"><N><speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis"<N>         xml:lang="en-US"><N><N>
hello<N></speak><N><N>}<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>{$ifdef windows}<N><N>uses<N>  windows, Classes, SysUtils, ole2, variants, ActiveX, comobj;<N><N>function speak(s: widestring; waittilldone: boolean=false): HRESULT; overload;<N>function speak(s: widestring; flags: dword): HRESULT; overload;<N><N>
unit frmSetupPSNNodeUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, lclintf,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs,<N>  StdCtrls, ExtCtrls, math, registry, betterControls;<N><N>
unit frmstructurecompareunit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$else}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, FileUtil, LResources, Forms, Controls, Graphics, Dialogs, StdCtrls, ExtCtrls, ComCtrls,<N>  cefuncproc, newkernelhandler, frmStringMapUnit, MemFuncs, AvgLvlTree, Menus,<N>  bigmemallochandler, math, maps, oldRegExpr, symbolhandler, commonTypeDefs,<N>  pagemap, syncobjs2, syncobjs, Clipbrd, betterControls;<N><N>
const compareversion=1;<N><N>type<N><N>  { TfrmStructureCompare }<N>  TPointerpath=array of dword;<N>  TDiffkind=(dkDontCare, dkMustBeDifferent, dkMustBeSame);<N><N><N><N>type<N><N>  PMappedRegion=^TMappedRegion;<N>  TMappedRegion=record<N>    baseaddress: ptruint; //if a new section overlaps, append to this<N>    size: ptruint; //if a new section ovrlaps increase this<N>    previous: PMappedRegion;<N>    next: PMappedRegion;<N>  end;<N><N>
  PPointerListEntry=^TPointerListEntry;<N>  TPointerListEntry=record<N>    address: ptruint;<N>    pointsto: ptruint;<N>    previous: PPointerListEntry;<N>    next: PPointerListEntry;<N>  end;<N><N><N>  type TPointerRecord=packed record<N>    level: integer;<N>    offset: TDwordArray;<N>  end;<N>  PPointerRecord=^TPointerRecord;<N><N>
<N><N>  TPointerfileReader=class<N>  private<N>    files: array of record<N>      f: Tfilestream;<N>      startindex: qword;<N>      lastindex: qword;<N>    end;<N>    entrysize: integer;<N>    fcount: qword;<N>    pointerfileLevelwidth: integer;<N><N>    bufferindex: integer;<N>    buffersize: integer;<N>    pointerrecords: PPointerRecord;    //actually an array...<N><N>
unit AccessedMemory;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  windows, Classes, SysUtils, FileUtil, laz.VirtualTrees, Forms, Controls, Graphics,<N>  Dialogs, StdCtrls, ExtCtrls, Menus, ComCtrls, genericHotkey, DBK32functions,<N>  commonTypeDefs, newkernelhandler, betterControls,AvgLvlTree, Laz_AVL_Tree;<N><N>
unit RegionEx;<N>{<N>Extends the TRegion class by adding the AddPolygon method<N>}<N>{$mode DELPHI}<N><N>interface<N><N>uses<N>  LCLIntf, StdCtrls, Classes, controls, SysUtils, dialogs, Graphics, LCLType;<N><N>type<N> TRegionEx = class(TRegion)<N> private<N> public<N>   procedure AddPolygon(polygon: array of TPoint);<N> published<N> end;<N><N>
<N>implementation<N><N>procedure TRegionEx.AddPolygon(polygon: array of TPoint);<N>var<N>  lRGN: HRGN;<N>begin<N>  lRGN := CreatePolygonRgn(@polygon[0], length(polygon), WINDING);<N>  CombineRgn(Handle, Handle, lRGN, RGN_OR);<N>  DeleteObject(lRGN);<N>end;<N><N>
unit LuaDiagramBlock;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib,LuaHandler, diagram, diagramblock,<N>  diagramlink, diagramtypes, typinfo;<N><N>implementation<N><N>uses controls, luaclass, LuaCustomControl, LuaObject, LuaDiagram;<N><N>
<N>function diagramBlock_intersectsWithLine(L: PLua_state): integer; cdecl;<N>var<N>  b: TDiagramBlock;<N>  p1: tpoint;<N>  p2: tpoint;<N>  r: tpoint;<N>begin<N>  result:=0;<N>  b:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=2 then<N>  begin<N>    if lua_istable(L,1) and lua_istable(L,2) then<N>    begin<N>      p1:=lua_toPoint(L,1);<N>      p2:=lua_toPoint(L,2);<N><N>
      if b.IntersectsWithLine(p1,p2,r) then<N>      begin<N>        lua_pushboolean(L,true);<N>        lua_pushpoint(L,r);<N>      end<N>      else<N>      begin<N>        lua_pushboolean(L,false);<N>        result:=1;<N>      end;<N>    end;<N>  end;<N>end;<N><N>
function diagramBlock_overlapsWith(L: PLua_state): integer; cdecl;<N>var<N>  b1,b2: TDiagramBlock;<N>  r: boolean;<N>begin<N>  b1:=luaclass_getClassObject(L);<N>  if lua_Gettop(L)>=1 then<N>  begin<N>    b2:=lua_ToCEUserData(L,1);<N>    r:=b1.OverlapsWith(b2);<N>    lua_pushboolean(L, r);<N>    result:=1;<N>  end<N>  else<N>    result:=0;<N>end;<N><N>
function diagramBlock_getLinks(L: PLua_state): integer; cdecl;<N>var<N>  db: TDiagramBlock;<N>  d: TDiagram;<N>  List: TList;<N>  t: integer;<N>  t2: integer;<N>  i: integer;<N>begin<N>  db:=luaclass_getClassObject(L);<N>  d:=TDiagram(db.Owner);<N><N>  lua_newtable(L);<N>  t:=lua_gettop(l);<N><N>
  List:=tlist.create;<N>  d.getConnectionsFromBlock(db,List);<N>  lua_pushstring(L, 'asSource');<N>  lua_newtable(L);<N>  t2:=lua_gettop(L);<N><N>  for i:=0 to list.count-1 do<N>  begin<N>    lua_pushinteger(L,i+1);<N>    luaclass_newClass(L,list[i]);<N>    lua_settable(L,t2);<N>  end;<N>  lua_settable(L,t);<N><N>
  List.Clear;<N>  d.getConnectionsToBlock(db,List);<N>  lua_pushstring(L, 'asDestination');<N>  lua_newtable(L);<N>  t2:=lua_gettop(L);<N><N>  for i:=0 to list.count-1 do<N>  begin<N>    lua_pushinteger(L,i+1);<N>    luaclass_newClass(L,list[i]);<N>    lua_settable(L,t2);<N>  end;<N>  lua_settable(L,t);<N><N>
unit FindWindowUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, Messages, LMessages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls,CEFuncProc,ComCtrls, ExtCtrls, LResources, memscan,<N>  commonTypeDefs, math, {$ifdef windows}win32proc,{$endif} symbolhandler, betterControls;<N><N>
unit LuaEdit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Controls, StdCtrls, Lua, Lualib, lauxlib, betterControls;<N><N>procedure edit_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>procedure initializeLuaEdit;<N><N>
implementation<N><N>uses luahandler, LuaClass, LuaCaller, LuaWinControl;<N><N>function createEdit(L: Plua_State): integer; cdecl;<N>var<N>  e: Tedit;<N>  w: twincontrol;<N>begin<N>  result:=0;<N><N>  if lua_gettop(L)=1 then<N>  begin<N>    w:=lua_toceuserdata(L, -1);<N>    e:=tedit.create(w);<N>    e.parent:=w;<N>    luaclass_newClass(L, e);<N>    result:=1;<N>  end;<N>end;<N><N>
function edit_clear(L: Plua_State): integer; cdecl;<N>var<N>  e: tcustomedit;<N>begin<N>  e:=luaclass_getClassObject(L);<N>  e.clear;<N>  result:=0;<N>end;<N><N>function edit_selectAll(L: Plua_State): integer; cdecl;<N>var<N>  e: tcustomedit;<N>begin<N>  e:=luaclass_getClassObject(L);<N>  e.SelectAll;<N>  result:=0;<N>end;<N><N>
unit BreakpointTypeDef;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N><N>  Classes, SysUtils, {$ifdef windows}windows,{$endif} FoundCodeUnit, formchangedaddresses, frmTracerUnit,<N>  commonTypeDefs, debuggertypedefinitions;<N><N>type<N><N>  PBreakpoint = ^TBreakPoint;<N><N>
unit sharedMemory;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, symbolhandler, autoassembler, frmautoinjectunit,<N>  cefuncproc, NewKernelHandler, Clipbrd, commonTypeDefs;<N><N>const FILE_MAP_EXECUTE = $20;<N><N>
function allocateSharedMemory(name: string; size: integer=4096): pointer;<N>function allocateSharedMemoryIntoTargetProcess(name: string; size: integer=4096): pointer;<N>function createSharedMemory(name: string; size: integer): THandle;<N><N>implementation<N><N>
uses ProcessHandlerUnit;<N><N><N>function createSharedMemory(name: string; size: integer): THandle;<N>begin<N>  {$ifdef windows}<N>  result:=CreateFileMapping(INVALID_HANDLE_VALUE,nil,PAGE_EXECUTE_READWRITE,0,size,pchar(name));<N>  {$else}<N>  result:=-1;<N>  {$endif}<N>end;<N><N>
function allocateSharedMemory(name: string; size: integer=4096): pointer;<N>var<N>  access: dword;<N>  h: thandle;<N>begin<N>  {$ifdef windows}<N>  access:=FILE_MAP_EXECUTE or FILE_MAP_READ or FILE_MAP_WRITE;<N><N><N>  //if name does not exist allocate it first<N>  h:=OpenFileMapping(access, false, pchar(name));<N><N>
  if h=0 then<N>    h:=createSharedMemory(name, size);<N><N>  result:=MapViewOfFile(h,access,0,0,0);<N>  {$else}<N>  result:=nil;<N>  {$endif}<N>end;<N><N>function allocateSharedMemoryIntoTargetProcess(name: string; size: integer=4096): pointer;<N>var s: tstringlist;<N>  disableinfo: TDisableInfo;<N>  i: integer;<N>  starttime: qword;<N>  x: ptruint;<N>  address: ptruint;<N><N>
  access: dword;<N><N>  h: THandle;<N>begin<N>  {$ifdef windows}<N>  access:=FILE_MAP_EXECUTE or FILE_MAP_READ or FILE_MAP_WRITE;<N><N><N>  //if name does not exist allocate it first<N>  h:=OpenFileMapping(access, false, pchar(name));<N><N>  if h=0 then<N>    h:=createSharedMemory(name, size);<N><N>
<N>  result:=nil;<N>  s:=tstringlist.create;<N><N><N>  s.add('alloc(allocator,1024)');<N>  s.add('alloc(sname,128)');<N>  s.add('alloc(address, 4)');<N>  s.add('label(error)');<N>  s.add('sname:');<N>  s.add('db '''+name+''',0');<N>  s.add('');<N>  s.add('address:');<N>  if processhandler.is64Bit then<N>    s.add('dq 0')<N>  else<N>    s.add('dd 0');<N><N>
unit frmAssemblyScanUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ExtCtrls, CEFuncProc, Parsers, symbolhandler, ProcessHandlerUnit, betterControls;<N><N>type<N><N>  { TfrmAssemblyScan }<N><N>
  TfrmAssemblyScan = class(TForm)<N>    btnOk: TButton;<N>    edtFrom: TEdit;<N>    edtTo: TEdit;<N>    lblInputAssemblyCode: TLabel;<N>    lblFrom: TLabel;<N>    lblTo: TLabel;<N>    mAssemblerSearch: TMemo;<N>    Panel1: TPanel;<N>    Panel2: TPanel;<N>    procedure btnOkClick(Sender: TObject);<N>    procedure FormShow(Sender: TObject);<N>  private<N>    { private declarations }<N>  public<N>    { public declarations }<N>    startaddress: ptruint;<N>    stopaddress: ptruint;<N>  end;<N><N>
var frmAssemblyScan: TfrmAssemblyScan;<N><N>implementation<N><N>uses LCLType, LCLIntf;<N><N>{$R *.lfm}<N><N>{ TfrmAssemblyScan }<N><N>procedure TfrmAssemblyScan.btnOkClick(Sender: TObject);<N>begin<N>  try<N>    startaddress:=StrToQWordEx('$'+edtfrom.text);<N>  except<N>    startaddress:=symhandler.getAddressFromName(edtfrom.text);<N>  end;<N><N>
  try<N>    stopaddress:=StrToQWordEx('$'+edtto.text);<N>  except<N>    stopaddress:=symhandler.getAddressFromName(edtto.text);<N>  end;<N><N>  if startaddress>stopaddress then<N>  begin  //xor swap<N>    startaddress:=startaddress xor stopaddress;<N>    stopaddress:=stopaddress xor startaddress;<N>    startaddress:=startaddress xor stopaddress;<N>  end;<N><N>
unit LuaDotNetPipe;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>procedure initializeLuaDotNetPipe;<N><N>implementation<N><N>uses luahandler, lua, lauxlib, lualib, luaclass, LuaObject, symbolhandler, dotnetpipe, Maps;<N><N>function dotnetpipe_enumDomains(L: PLua_state): integer; cdecl;<N>var<N>  dnp: TDotNetPipe;<N>  domains: TDotNetDomainArray;<N>  i: integer;<N>  arraytable: integer;<N>begin<N>  dnp:=luaclass_getClassObject(L);<N><N>
  setlength(domains,0);<N>  dnp.EnumDomains(domains);<N>  lua_createtable(L,length(domains),0);<N><N>  for i:=0 to length(domains)-1 do<N>  begin<N>    lua_pushinteger(L,i+1);<N>    lua_createtable(L,0,2);<N><N>    lua_pushstring(L, 'DomainHandle');<N>    lua_pushinteger(L, domains[i].hDomain);<N>    lua_settable(L,-3); //entry<N><N>
    lua_pushstring(L, 'Name');<N>    lua_pushstring(L, domains[i].Name);<N>    lua_settable(L,-3); //entry<N><N>    lua_settable(L,-3); //array<N>  end;<N><N>  result:=1;<N><N>end;<N><N>function dotnetpipe_enumModuleList(L: PLua_state): integer; cdecl;<N>var<N>  dnp: TDotNetPipe;<N>  domain: uint64;<N>  modules: TDotNetModuleArray;<N>  i: integer;<N>begin<N>  result:=0;<N>  dnp:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>  begin<N>    domain:=lua_tointeger(L,1);<N><N>
    setlength(modules,0);<N>    dnp.EnumModuleList(domain, modules);<N><N>    lua_createtable(L,length(modules),0);<N><N>    for i:=0 to length(modules)-1 do<N>    begin<N>      lua_pushinteger(L,i+1);<N>      lua_createtable(L,0,3);<N><N>      lua_pushstring(L, 'ModuleHandle');<N>      lua_pushinteger(L, modules[i].hModule);<N>      lua_settable(L,-3);<N><N>
      lua_pushstring(L, 'BaseAddress');<N>      lua_pushinteger(L, modules[i].baseaddress);<N>      lua_settable(L,-3);<N><N>      lua_pushstring(L, 'Name');<N>      lua_pushstring(L, modules[i].Name);<N>      lua_settable(L,-3);<N><N>      lua_settable(L,-3);<N>    end;<N><N>
    result:=1;<N>  end;<N>end;<N><N>function dotnetpipe_enumTypeDefs(L: PLua_state): integer; cdecl;<N>var<N>  dnp: TDotNetPipe;<N>  modulehandle: uint64;<N>  typedefs: TDotNetTypeDefArray;<N>  i: integer;<N>begin<N>  result:=0;<N>  dnp:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>  begin<N>    modulehandle:=lua_tointeger(L,1);<N><N>
    setlength(typedefs,0);<N>    dnp.EnumTypeDefs(modulehandle, typedefs);<N><N>    lua_createtable(L,length(typedefs),0);<N><N>    for i:=0 to length(typedefs)-1 do<N>    begin<N>      lua_pushinteger(L,i+1);<N>      lua_createtable(L,0,4);<N><N>      lua_pushstring(L, 'TypeDefToken');<N>      lua_pushinteger(L, typedefs[i].token);<N>      lua_settable(L,-3);<N><N>
      lua_pushstring(L, 'Name');<N>      lua_pushstring(L, typedefs[i].Name);<N>      lua_settable(L,-3);<N><N>      lua_pushstring(L, 'Flags');<N>      lua_pushinteger(L, typedefs[i].flags);<N>      lua_settable(L,-3);<N><N>      lua_pushstring(L, 'Extends');<N>      lua_pushinteger(L, typedefs[i].extends);<N>      lua_settable(L,-3);<N><N>
      lua_settable(L,-3);<N>    end;<N><N>    result:=1;<N>  end;<N>end;<N><N>function dotnetpipe_getTypeDefMethods(L: PLua_state): integer; cdecl;<N>var<N>  dnp: TDotNetPipe;<N>  modulehandle: uint64;<N>  typedeftoken: uint64;<N>  methods: TDotNetMethodArray;<N>  i,j: integer;<N>begin<N>  result:=0;<N>  dnp:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=2 then<N>  begin<N>    modulehandle:=lua_tointeger(L,1);<N>    typedeftoken:=lua_tointeger(L,2);<N><N>
    lua_pop(L,lua_gettop(L));<N><N>    setlength(methods,0);<N><N>    dnp.GetTypeDefMethods(modulehandle, typedeftoken, methods);<N>    lua_createtable(L,length(methods),0);<N><N>    for i:=0 to length(methods)-1 do<N>    begin<N>      //MethodToken, Name, Attributes, ImplementationFlags, ILCode, NativeCode, SecondaryNativeCode[]<N><N>
      lua_pushinteger(L,i+1);<N>      lua_createtable(L,0,7);<N><N><N>      lua_pushstring(L, 'MethodToken');<N>      lua_pushinteger(L, methods[i].token);<N>      lua_settable(L,-3);<N><N>      lua_pushstring(L, 'Name');<N>      lua_pushstring(L, methods[i].Name);<N>      lua_settable(L,-3);<N><N>
      lua_pushstring(L, 'Attributes');<N>      lua_pushinteger(L, methods[i].Attributes);<N>      lua_settable(L,-3);<N><N>      lua_pushstring(L, 'ImplementationFlags');<N>      lua_pushinteger(L, methods[i].implflags);<N>      lua_settable(L,-3);<N><N>      lua_pushstring(L, 'ILCode');<N>      lua_pushinteger(L, methods[i].ILCode);<N>      lua_settable(L,-3);<N><N>
unit LuaVirtualStringTree;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, ComCtrls, lua, luaclass, Controls, LuaWinControl,<N>  laz.VirtualTrees, betterControls;<N><N><N>procedure initializeLuaVirtualStringTree;<N><N><N><N>implementation<N><N>
uses LuaHandler, lauxlib, ceguicomponents, TypInfo, LuaByteTable, LuaCollection,<N>     LuaObject;<N><N><N><N>function createVirtualStringTree(L: Plua_State): integer; cdecl;<N>var<N>  tv: TLazVirtualStringTree;<N>  owner: TWincontrol;<N>begin<N>  if lua_gettop(L)=1 then<N>    owner:=TWincontrol(lua_toceuserdata(L, 1))<N>  else<N>    owner:=nil;<N><N>
  tv:=TLazVirtualStringTree.Create(owner);<N><N>  tv.Header.Options:=tv.Header.Options-[hoDrag]; //too confusing for new users. Add it if you need it<N>  if owner<>nil then<N>    tv.Parent:=owner;<N><N>  luaclass_newClass(L, tv);<N>  result:=1;<N>end;<N><N>
function VirtualStringTree_clear(L: Plua_State): integer; cdecl;<N>var<N>  tv: TLazVirtualStringTree;<N>begin<N>  tv:=TLazVirtualStringTree(luaclass_getClassObject(L));<N>  tv.Clear;<N>  result:=0;<N>end;<N><N><N>function VirtualStringTree_beginUpdate(L: Plua_State): integer; cdecl;<N>var<N>  tv: TLazVirtualStringTree;<N>begin<N>  tv:=TLazVirtualStringTree(luaclass_getClassObject(L));<N>  tv.BeginUpdate;<N>  result:=0;<N>end;<N><N>
function VirtualStringTree_endUpdate(L: Plua_State): integer; cdecl;<N>var<N>  tv: TLazVirtualStringTree;<N>begin<N>  tv:=TLazVirtualStringTree(luaclass_getClassObject(L));<N>  tv.EndUpdate;<N>  result:=0;<N>end;<N><N>function VirtualStringTree_addChild(L: Plua_State): integer; cdecl;<N>var<N>  tv: TLazVirtualStringTree;<N>  parent: PVirtualNode;<N>  r: integer;<N>begin<N>  tv:=TLazVirtualStringTree(luaclass_getClassObject(L));<N>  parent:=nil;<N><N>
  if lua_gettop(L)>=1 then<N>    parent:=lua_topointer(L,1);<N><N>  lua_pushlightuserdata(L, tv.AddChild(parent));<N>  result:=1;<N>end;<N><N><N>function VirtualStringTree_deleteNode(L: Plua_State): integer; cdecl;<N>var<N>  tv: TLazVirtualStringTree;<N>  node: PVirtualNode;<N>  r: integer;<N>begin<N>  result:=0;<N>  tv:=TLazVirtualStringTree(luaclass_getClassObject(L));<N>  if lua_gettop(L)>=1 then<N>  begin<N>    node:=lua_topointer(L,1);<N>    tv.DeleteNode(node);<N>  end;<N>end;<N><N>
unit savedisassemblyfrm;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, LResources, Messages, LMessages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, Dialogs, symbolhandler, symbolhandlerstructs, disassembler,<N>  StdCtrls, ComCtrls, ActnList, Clipbrd, ExtCtrls, strutils, Parsers, betterControls;<N><N>
type<N>  TfrmSavedisassembly = class;<N>  TSaveDisassemblyThread=class(TThread)<N>  private<N>    procedure closeform;<N>  public<N>    progressbar: tprogressbar;<N>    startaddress: ptrUint;<N>    stopaddress: ptrUint;<N>    address: boolean;<N>    bytes: boolean;<N>    opcode: boolean;<N>    comment: boolean;<N>    copymode: boolean;<N>    filename: string;<N>    form: TfrmSavedisassembly;<N><N>
unit frmD3DHookSnapshotConfigUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, EditBtn,<N>  StdCtrls, ExtCtrls, CEFuncProc, registry, commonTypeDefs, betterControls;<N><N>type<N><N>  { TfrmD3DHookSnapshotConfig }<N><N>
unit d3dhookUnit;<N>{<N>This unit will inject the d3d hook dll into the target process and hook the<N>apropriate functions.<N>A shared object will be used for communicating states and data<N>}<N><N>{$mode delphi}<N><N>{$warn 5044 off}<N><N>interface<N><N>{$ifdef windows}<N><N>
uses<N>  windows, Classes, SysUtils, sharedMemory, forms, graphics, cefuncproc,<N>  newkernelhandler, controls, Clipbrd, strutils, LuaHandler, RemoteMemoryManager,<N>  math, syncobjs;<N><N>type<N>  TCEMessage=packed record<N>    uMsg: DWORD;<N>    wParam: UINT64;<N>    lParam: UINT64;<N>    character: DWORD;<N>  end;<N><N>
  TTextureEntry=packed record<N>    AddressOfTexture: UINT64;<N>    AddressOfFontmap: UINT64;<N>    size: integer;<N>    hasBeenUpdated: integer;<N>  end;<N><N>  TTextureEntryArray=Array [0..1000] of TTextureEntry;<N>  PTextureEntryArray=^TTextureEntryArray;<N><N>
  type TRenderCommandEnum=(rcEndOfCommandlist=0, //Stop going through the list<N>  			   rcIgnored=1,          //Ignore (Being updated)<N>  			   rcDrawSprite=2,	 //Render the sprite at the given position<N>  			   rcDrawFont=3);	 //Render some text at the given coordinates. The string is located at  "addressoftext"<N><N>
<N>  TSpriteCommand=packed record<N>    width: integer;<N>    height: integer;<N>    textureid: integer;<N>  end;<N><N>  TFontCommand=packed record<N>    addressoftext: UINT64;<N>    fontid: integer;<N>  end;<N><N>  TRenderCommand=packed record<N>    command: integer;<N>    x: single;<N>    y: single;<N>    alphablend: single;<N><N>
    centerX: single;<N>    centerY: single;<N>    rotation: single;<N><N>    case TRenderCommandEnum of<N>      rcDrawSprite: (Sprite: TSpriteCommand);<N>      rcDrawFont: (Font: TFontCommand);<N>  end;<N>  PRenderCommand=^TRenderCommand;<N><N>  TRenderCommandarray=array [0..100] of TRenderCommand;<N>  PRenderCommandArray=^TRenderCommandArray;<N><N>
<N>  TD3DHookShared=packed record<N>    cheatenginedir: array [0..255] of char;<N>    snapshotdir: array [0..255] of char;<N>    dxgi_present: UINT64;<N>    dxgi_resizebuffers: UINT64;<N>    d3d9_present: UINT64;<N>    d3d9_reset: UINT64;<N><N>    d3d9_drawprimitive: UINT64;<N>    d3d9_drawindexedprimitive: UINT64;<N>    d3d9_drawprimitiveup: UINT64;<N>    d3d9_drawindexedprimitiveup: UINT64;<N>    d3d9_drawrectpatch: UINT64;<N>    d3d9_drawtripatch: UINT64;<N><N>
    d3d10_drawindexed: UINT64;<N>    d3d10_draw: UINT64;<N>    d3d10_drawindexedinstanced: UINT64;<N>    d3d10_drawinstanced: UINT64;<N>    d3d10_drawauto: UINT64;<N><N>    d3d11_drawindexed: UINT64;<N>    d3d11_draw: UINT64;<N>    d3d11_drawindexedinstanced: UINT64;<N>    d3d11_drawinstanced: UINT64;<N>    d3d11_drawauto: UINT64;<N><N>
<N>    dxgi_newpresent: UINT64;<N>    dxgi_newresizebuffers: UINT64;<N>    d3d9_newpresent: UINT64;<N>    d3d9_newreset: UINT64;<N><N>    d3d9_newdrawprimitive: UINT64;<N>    d3d9_newdrawindexedprimitive: UINT64;<N>    d3d9_newdrawprimitiveup: UINT64;<N>    d3d9_newdrawindexedprimitiveup: UINT64;<N>    d3d9_newdrawrectpatch: UINT64;<N>    d3d9_newdrawtripatch: UINT64;<N><N>
    d3d10_newdrawindexed: UINT64;<N>    d3d10_newdraw: UINT64;<N>    d3d10_newdrawindexedinstanced: UINT64;<N>    d3d10_newdrawinstanced: UINT64;<N>    d3d10_newdrawauto: UINT64;<N><N>    d3d11_newdrawindexed: UINT64;<N>    d3d11_newdraw: UINT64;<N>    d3d11_newdrawindexedinstanced: UINT64;<N>    d3d11_newdrawinstanced: UINT64;<N>    d3d11_newdrawauto: UINT64;<N><N>
<N>    dxgi_originalpresent: UINT64;<N>    dxgi_originalresizebuffers: UINT64;<N>    d3d9_originalpresent: UINT64;<N>    d3d9_originalreset: UINT64;<N><N>    d3d9_originaldrawprimitive: UINT64;<N>    d3d9_originaldrawindexedprimitive: UINT64;<N>    d3d9_originaldrawprimitiveup: UINT64;<N>    d3d9_originaldrawindexedprimitiveup: UINT64;<N>    d3d9_originaldrawrectpatch: UINT64;<N>    d3d9_originaldrawtripatch: UINT64;<N><N>
    d3d10_originaldrawindexed: UINT64;<N>    d3d10_originaldraw: UINT64;<N>    d3d10_originaldrawindexedinstanced: UINT64;<N>    d3d10_originaldrawinstanced: UINT64;<N>    d3d10_originaldrawauto: UINT64;<N><N>    d3d11_originaldrawindexed: UINT64;<N>    d3d11_originaldraw: UINT64;<N>    d3d11_originaldrawindexedinstanced: UINT64;<N>    d3d11_originaldrawinstanced: UINT64;<N>    d3d11_originaldrawauto: UINT64;<N><N>
<N>    wireframe: integer;<N>    disabledzbuffer: integer;<N><N>    hookwnd: integer;<N>    clipmouseinwindow: integer;<N><N>    clickedoverlay: integer;<N>    clickedx: integer;<N>    clickedy: integer;<N><N>    console: packed record<N>      hasconsole: integer;<N>      consolevisible: integer;<N>      consolekey: dword;<N>      overlayid: integer;<N>      cursorid: integer;<N>      lastmessage: TCEMessage;<N><N>
unit LuaStringlist;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib;<N><N>procedure initializeLuaStringlist;<N>procedure stringlist_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N><N>implementation<N><N>
uses luahandler, luaclass, luastrings;<N><N>function createStringlist(L: Plua_State): integer; cdecl;<N>begin<N>  luaclass_newClass(L, TStringList.Create);<N>  result:=1;<N>end;<N><N>function stringlist_getDuplicates(L: PLua_State): integer; cdecl;<N>var<N>  stringlist: TStringlist;<N>begin<N>  stringlist:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, integer(stringlist.Duplicates));<N>  result:=1;<N>end;<N><N>
function stringlist_setDuplicates(L: PLua_State): integer; cdecl;<N>var<N>  stringlist: TStringlist;<N>  a: integer;<N>begin<N>  result:=0;<N>  stringlist:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    stringlist.Duplicates:=TDuplicates(lua_tointeger(L,-1));<N>end;<N><N>
<N>function stringlist_getSorted(L: PLua_State): integer; cdecl;<N>var<N>  stringlist: TStringlist;<N>begin<N>  stringlist:=luaclass_getClassObject(L);<N>  lua_pushboolean(L, stringlist.Sorted);<N>  result:=1;<N>end;<N><N>function stringlist_setSorted(L: PLua_State): integer; cdecl;<N>var<N>  stringlist: TStringlist;<N>  a: integer;<N>begin<N>  result:=0;<N>  stringlist:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    stringlist.sorted:=lua_toboolean(L,-1);<N>end;<N><N>
unit LuaD3DHook;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, Graphics;<N><N>procedure initializeLuaD3dHook;<N><N>implementation<N><N>{$ifdef windows}<N>uses luaclass, luahandler, d3dhookUnit, LuaObject;<N><N>function createD3DHook(L: PLua_State): integer; cdecl;<N>var<N>  size: integer;<N>  hookwindow: boolean;<N>begin<N><N>
  size:=16*1024*1024;<N>  hookwindow:=true;<N><N>  if lua_gettop(L)=1 then<N>    size:=lua_tointeger(L, 1);<N><N>  if lua_gettop(L)=2 then<N>    hookwindow:=lua_toboolean(L, 2);<N><N>  luaclass_newClass(L, safed3dhook(size, hookwindow));<N>  result:=1;<N>end;<N><N>
function d3dhook_beginupdate(L: PLua_State): integer; cdecl;<N>var d: TD3DHook;<N>begin<N>  d:=luaclass_getClassObject(L);<N>  d.beginCommandListUpdate;<N>  d.beginTextureUpdate;<N>  result:=0;<N>end;<N><N>function d3dhook_endUpdate(L: PLua_State): integer; cdecl;<N>var d: TD3DHook;<N>begin<N>  d:=luaclass_getClassObject(L);<N>  d.endTextureUpdate;<N>  d.endCommandListUpdate;<N><N>
  result:=0;<N>end;<N><N><N>function d3dhook_enableConsole(L: PLua_State): integer; cdecl;<N>var d: TD3DHook;<N>    k: dword;<N>begin<N>  d:=luaclass_getClassObject(L);<N>  if lua_gettop(L)=1 then<N>    k:=lua_tointeger(L, 1)<N>  else<N>    k:=$c0; //~<N><N>
  d.enableConsole(k);<N><N>  result:=0;<N>end;<N><N>function d3dhook_createTexture(L: PLua_State): integer; cdecl;<N>var<N>  d: TD3DHook;<N>  o: TObject;<N>  s: string;<N><N>  p: TPicture;<N>begin<N>  d:=luaclass_getClassObject(L);<N>  result:=0;<N>  if lua_gettop(L)>=1 then<N>  begin<N><N>
unit cheatecoins;<N><N>{<N>Cheat-E coin handler and simple anti debug code<N><N>WARNING: If you read this you will lose all bragging rights on how you bypassed the cheat-e-coin system<N>You can of course say you didn't read this, but you'll know...<N><N>Now if you didn't read this to bypass the cheat-e-coin system but just want to see how it works, have fun<N><N>
(May crash on some people's systems, due to security)<N>}<N><N>{$mode delphi}<N><N>interface<N><N>{$IFDEF windows}<N>uses<N>  jwawindows, windows, newkernelhandler, Classes, SysUtils, dialogs, betterControls;<N><N>procedure EnableCheatEcoinSystem;<N><N>procedure decreaseCheatECoinCount; stdcall;<N>function getCheatECoinCount: integer;<N><N>
function checkCoinStatus: integer;<N>{$ENDIF}<N><N>implementation<N><N>{$IFDEF windows}<N>uses forms, frmMicrotransactionsUnit, ceregistry, luahandler, mainunit2;<N><N>var<N>  _DecreaseCount: integer;<N>  something: integer;<N>  _GetCount: integer;<N>  c2: pinteger;<N>  c3: pinteger; //last decrease value<N><N>
  mainthreadhandle: THandle;<N>  context: PCONTEXT;<N>  contextmem: pointer;<N><N>threadvar<N>  actualcount: pinteger;<N><N>function antidebug1: integer; stdcall; //always returns 0xcececece<N>begin<N>  result:=GetTickCount64;<N>end;<N><N>function antidebug2(x: dword): dword; stdcall; //jumps to antidebug3 when executed (so returns x+0x100)<N>begin<N>  if x>5 then<N>    raise exception.create('It''s not that easy')<N>  else<N>    result:=10;<N>end;<N><N>
function antidebug3(x: dword): dword; stdcall;<N>begin<N>  result:=x+$100;<N>end;<N><N>procedure setupContext;<N>begin<N>  context^.ContextFlags:=CONTEXT_DEBUG_REGISTERS;<N>  if GetThreadContext(mainthreadhandle,context^) then<N>  begin<N><N>    context.Dr0:=ptruint(@_DecreaseCount);<N>    context.dr1:=ptruint(@_GetCount);<N>    context.dr2:=ptruint(@antidebug1);<N>    context.dr3:=ptruint(@antidebug2);<N>    context.dr7:=$fd0055; //dr0: write - dr1: readwrite, dr2=execute dr3=execute<N><N>
    SetThreadContext(mainthreadhandle,context^);<N>  end;<N>end;<N><N>procedure clearDRContext;<N>begin<N>  context^.ContextFlags:=CONTEXT_DEBUG_REGISTERS;<N>  if GetThreadContext(mainthreadhandle,context^) then<N>  begin<N>    context.dr7:=0; //dr0: write - dr1: readwrite<N>    SetThreadContext(mainthreadhandle,context^);<N>  end;<N>end;<N><N>
function CECExceptionHandler(ExceptionInfo: windows.PEXCEPTION_POINTERS): LONG; stdcall;<N>var<N>  v,v2: dword;<N>  c: PContext;<N>  s: string;<N>  i: integer;<N><N>  newv: pinteger;<N>begin<N>  result:=EXCEPTION_CONTINUE_SEARCH;<N><N>  //MEssageBoxA(0,'e 1','exeption',0);<N><N>
  asm<N>    push dword $202 //just to piss of a newbie stepper (set a software bp after)<N>    {$ifdef cpu64}<N>    popfq<N>    {$else}<N>    popfd<N>    {$endif}<N>  end;<N>  setupContext; //clears breakpoints  (software bp's help, I won't do integrity checks yet)<N><N>
  //MEssageBoxA(0,'e 2','exeption',0);<N><N>  c:=PContext(ExceptionInfo^.ContextRecord);<N><N> // MessageBoxA(0,pchar('Exception', 'exceptionHandler',0);<N><N>  case ExceptionInfo^.ExceptionRecord.ExceptionCode of<N>    EXCEPTION_SINGLE_STEP, STATUS_WX86_SINGLE_STEP:<N>    begin<N>      //MessageBoxA(0,pchar(format('CECExceptionHandler 2 %.8x',[c^.dr6])),'CECExceptionHandler 2',0);<N>      //MEssageBoxA(0,'e 3','exeption',0);<N><N>
      if (c^.Dr6 and 1=1) then  //decrease coin<N>      begin<N>        //MessageBoxA(0,'DR0','CECExceptionHandler 2',0);<N><N><N><N>        if (c3<>nil) and (c3^=actualcount^) then //frozen value or continued editing (two times 0)<N>        begin<N>          //MessageBoxA(0,'BYE','CECExceptionHandler 2',0);<N><N>
          exitProcess(1);<N>          asm<N>            {$ifdef cpu64}<N>            mov rsp,0<N>            mov rbp,0<N>            {$else}<N>            mov esp,0<N>            mov ebp,0<N>            {$endif}<N>          end;<N>          exit;<N>        end;<N><N>
        getmem(newv,4+random(64));<N>        if c3<>nil then<N>          freemem(c3);<N><N>        c3:=newv;<N>        c3^:=actualcount^;<N><N>        v:=(dword(actualcount^) xor dword(antidebug1)) shr dword(13);<N><N><N>        asm<N>          push dword $202 //just to piss of a newbie stepper (set a software bp after)<N>          {$ifdef cpu64}<N>          popfq<N>          {$else}<N>          popfd<N>          {$endif}<N>        end;<N>        v2:=dword(c2^ xor (antidebug2($deadf023)));<N><N>
<N><N><N>        asm<N>          push dword $202 //just to piss of a newbie stepper (set a software bp after)<N>          {$ifdef cpu64}<N>          popfq<N>          {$else}<N>          popfd<N>          {$endif}<N>        end;<N><N>        if v2<>v then   //someone tried to tamper<N>        begin<N>          //MessageBoxA(0,pchar(format('Coin tamper detected %d <> %d (actualcount=%x)',[v2, v, actualcount])),'CECExceptionHandler 2',0);<N><N>
          v:=0 //goodbye coins<N>        end<N>        else<N>          dec(v);<N><N>        freemem(c2);<N>        getmem(c2,4+random(64));<N><N>        c2^:=integer(dword(v) xor antidebug2($deadf023)); //just to keep people of track<N><N>        freemem(actualcount);<N>        getmem(actualcount,4+random(64));<N><N>
        actualcount^:=integer(dword((dword(v) shl 13) xor antidebug1));<N><N>        //      c^.dr6:=0;  MEssageBoxA(0,'test done','exeption',0); exit(EXCEPTION_CONTINUE_EXECUTION);<N><N><N>        v2:=dword(v) xor dword($deadf123);<N>        if dword(v2)<>dword(c2^) then<N>        begin<N>         // MessageBoxA(0,pchar(format('antidebug tamper detected %x<>%x',[v2,c2])),'CECExceptionHandler 2',0);<N><N>
          ExitProcess(2);<N>          asm<N>            {$ifdef cpu64}<N>            mov rsp,0<N>            mov rbp,0<N>            {$else}<N>            mov esp,0<N>            mov ebp,0<N>            {$endif}<N>          end;<N>          exit;<N>        end;<N><N>
<N><N>        c^.dr6:=0;<N><N><N>       // MEssageBoxA(0,'e 4','exeption',0);<N><N>        exit(EXCEPTION_CONTINUE_EXECUTION);<N>      end;<N><N>      if (ExceptionInfo^.ContextRecord^.Dr6 and 2=2) then<N>      begin<N>        //MessageBoxA(0,'DR1','CECExceptionHandler 2',0);<N><N>
        c^.{$ifdef cpu64}Rax{$else}eax{$endif}:=qword(dword(c2^) xor antidebug2($deadf023));<N>        c^.dr6:=0;<N><N>        //MessageBoxA(0,'CECExceptionHandler 2.2','CECExceptionHandler 2.2',0);<N><N>        exit(EXCEPTION_CONTINUE_EXECUTION);<N>      end;<N><N>
      if (ExceptionInfo^.ContextRecord^.Dr6 and 4=4) then<N>      begin<N>        //MessageBoxa(0,'dr2','cec',0);<N><N><N>        {$ifdef cpu64}<N>        c^.rax:=$cececece;<N>        c^.rip:=pqword(c^.Rsp)^; //change rip back to the caller<N>        c^.rsp:=c^.rsp+8; //pop the return of the stack<N>        {$else}<N>        c^.eax:=$cececece;<N>        c^.eip:=pdword(c^.esp)^; //change rip back to the caller<N>        c^.esp:=c^.esp+4; //pop the return address of the stack<N><N>
        {$endif}<N>        c^.dr6:=0;<N>        exit(EXCEPTION_CONTINUE_EXECUTION);<N>      end;<N><N>      if (ExceptionInfo^.ContextRecord^.Dr6 and 8=8) then<N>      begin<N>        //MessageBoxa(0,'dr3','cec',0);<N>        c^.{$ifdef cpu64}rip{$else}eip{$endif}:=ptruint(@antidebug3);<N>        c^.dr6:=0;<N>        exit(EXCEPTION_CONTINUE_EXECUTION);<N>      end;<N><N>
    end;<N><N>    EXCEPTION_ACCESS_VIOLATION:<N>    begin<N>      //s:=format('Address = %.8x rip=%.8x rax=%.8x r8=%.8x', [ptruint(ExceptionInfo^.ExceptionRecord.ExceptionAddress), c^.rip, c^.rax, c^.r8]);<N><N><N>      for i:=0 to ExceptionInfo^.ExceptionRecord.NumberParameters do<N>      begin<N>        s:=s+' '+inttostr(i)+':'+inttohex(ExceptionInfo^.ExceptionRecord^.ExceptionInformation[i],1);<N>      end;<N><N>
      //MessageBoxA(0,pchar(s),'CECExceptionHandler 3',0);<N><N>      if ExceptionInfo^.ExceptionRecord.ExceptionInformation[1]=$101 then<N>      begin<N>        //MessageBoxA(0,'bla2','bla2',0);<N>        {$ifdef cpu64}<N>        c^.rip:=c^.r8;<N>        {$else}<N>        c^.eip:=c^.ecx;<N>        {$endif}<N>        exit(EXCEPTION_CONTINUE_EXECUTION);<N>      end;<N>    end;<N>  end;<N><N>
end;<N><N>function Control: integer; assembler;<N>label oka;<N>asm<N>  {$ifdef cpu64}<N><N>  mov rax,$101<N>  push r8<N>  lea r8,oka<N>  mov dword [rax],12<N>oka:<N>  pop r8<N>  nop<N>  {$else}<N>  mov eax,$101<N>  push ecx<N>  lea ecx,oka<N>  mov dword [eax],12<N>oka:<N>  pop ecx<N>  nop<N>  {$endif}<N>end;<N><N>
<N>procedure decreaseCheatECoinCount; stdcall;<N>begin<N>  asm<N>    {$ifdef cpu64}<N>    lea r8,[rip+_DecreaseCount]<N>    xor dword [r8],$deadbeef<N>    {$else}<N>    add [_DecreaseCount],2<N>    {$endif}<N>  end;<N><N>  control;<N>end;<N><N>function getCheatECoinCount: integer; assembler; nostackframe;<N>asm<N>  {$ifdef cpu64}<N>  lea r8,[rip+_GetCount]<N>  mov eax,[r8]<N>  {$else}<N>  lea eax,[_GetCount]<N>  mov eax,[eax]<N>  {$endif}<N>  ret<N>end;<N><N>
function checkCoinStatus: integer;<N>var<N>  c: integer;<N>  d: dword;<N>begin<N>  c:=getCheatECoinCount;<N><N>  try<N>    control;<N>  except<N>    //MessageBoxA(0,'BYE2', 'ccs',0);<N>    ExitProcess(1);<N>    asm<N>      {$ifdef cpu64}<N>      mov rsp,0<N>      mov rbp,0<N>      {$else}<N>      mov esp,0<N>      mov ebp,0<N>      {$endif}<N>    end;<N>  end;<N><N>
  d:=integer((antidebug1 xor dword($cececece))+antidebug2($ce));<N><N>  if (c>20) or (d<>$1ce) then<N>  begin<N>    //MessageBoxA(0,pchar(format('Bye3 c=%d d=%d',[c,d])),'ccs',0);<N>    ExitProcess(1);<N>    asm<N>      {$ifdef cpu64}<N>      mov rsp,0<N>      mov rbp,0<N>      {$else}<N>      mov esp,0<N>      mov ebp,0<N>      {$endif}<N>    end;<N>  end;<N>  result:=c;<N>end;<N><N>
procedure saveCoins;<N>begin<N>  if mainthreadhandle<>0 then //most stupid way to save the coins:<N>    cereg.writeInteger('Used Coins',20-getCheatECoinCount);<N>end;<N><N>procedure EnableCheatECoinSystem;   //simple solution to all this shittery, remove this function<N>var<N>  AddVectoredExceptionHandler: function (FirstHandler: Cardinal; VectoredHandler: PVECTORED_EXCEPTION_HANDLER): pointer; stdcall;<N>  k: HModule;<N><N>
  th: THandle;<N><N>  v: integer;<N><N>  used: integer;<N><N>begin<N>  //MEssageBoxA(0,'0','0',0);<N><N><N>  ShowMessage('New!!! Cheat-e-coins! Now you can buy Cheat-e-coins to be able to use '+strCheatEngine+'. It''s just like a game!!! Yay!');<N><N>  k:=GetModuleHandle('kernel32.dll');<N>  AddVectoredExceptionHandler:=GetProcAddress(k,'AddVectoredExceptionHandler');<N><N>
  AddVectoredExceptionHandler(1, PVECTORED_EXCEPTION_HANDLER(CECExceptionHandler));<N><N>  mainthreadhandle:=OpenThread(THREAD_SET_CONTEXT or THREAD_GET_CONTEXT,false, GetCurrentThreadId);<N><N>  getmem(contextmem,sizeof(TCONTEXT)+4096);<N>  zeromemory(contextmem,sizeof(TCONTEXT)+4096);<N><N>
  context:=Align(contextmem,16);<N><N>  getmem(actualcount, 4+random(64));<N>  actualcount^:=integer(dword((20 shl 13) xor $cececece));<N><N>  getmem(c2,4+random(64));<N>  c2^:=integer(dword(20 xor $deadf123));<N><N>  used:=cereg.readInteger('Used Coins',0);<N><N>
  //MEssageBoxA(0,'1','1',0);<N><N><N>  setupcontext;<N><N>  while used>0 do<N>  begin<N>    decreaseCheatECoinCount;<N>    dec(used);<N>  end;<N><N> // MEssageBoxA(0,'2','2',0);<N><N><N>  frmMicroTransactions:=TfrmMicroTransactions.Create(application);<N>  frmMicroTransactions.show;<N>end;<N><N>
// Copyright Cheat Engine. All Rights Reserved.<N><N>unit autoassembler;<N><N>{$MODE Delphi}<N><N>interface<N><N><N>{$ifdef jni}<N>uses unixporthelper, Assemblerunit, classes, symbolhandler, sysutils,<N>     NewKernelHandler, ProcessHandlerUnit, commonTypeDefs;<N>{$else}<N><N>
<N><N>uses<N>   {$ifdef darwin}<N>   macport, math,<N>   {$endif}<N>   {$ifdef windows}<N>   jwawindows, windows,<N>   {$endif}<N>   Assemblerunit, classes, LCLIntf,symbolhandler, symbolhandlerstructs,<N>   sysutils,dialogs,controls, CEFuncProc, NewKernelHandler ,plugin,<N>   ProcessHandlerUnit, lua, lualib, lauxlib, LuaClass, commonTypeDefs, OpenSave,<N>   SymbolListHandler, tcclib,<N>   betterControls;<N><N>
<N>{$endif}<N><N>type<N>  TDisableInfo=class<N>  private<N>  public<N>    allocs: TCEAllocArray;<N>    exceptions:TCEExceptionListArray;<N>    registeredsymbols: tstringlist;<N>    ccodesymbols: TSymbolListHandler;<N>    sourcecodeinfo: TSourceCodeInfo;<N>    donotfreeccodedata: boolean;<N><N>
    allsymbols: tstringlist; //filled at the end with all known symbols (allocs, labels, kallocs, aobscan results, defines that are addresses, etc...)<N><N>    constructor create;<N>    destructor destroy; override;<N>  end;<N><N>  TMemoryrecord=pointer;<N><N>
<N>function getenableanddisablepos(code:tstrings;var enablepos,disablepos: integer): boolean;<N>procedure getEnableOrDisableScript(code: TStrings; newscript: tstrings; enablescript: boolean);<N>function autoassemble(code: tstrings;popupmessages: boolean):boolean; overload;<N>function autoassemble(code: Tstrings; popupmessages,enable,syntaxcheckonly, targetself: boolean; disableinfo: TDisableInfo=nil; memrec: TMemoryrecord=nil): boolean; overload;<N><N>
type TAutoAssemblerPrologue=procedure(code: TStrings; syntaxcheckonly: boolean) of object;<N>type TAutoAssemblerCallback=function(parameters: string; syntaxcheckonly: boolean): string of object;<N>type TRegisteredAutoAssemblerCommand=class<N>  command: string;<N>  callback: TAutoAssemblerCallback;<N>end;<N><N>
type EAutoAssembler=class(exception);<N><N>procedure RegisterAutoAssemblerCommand(command: string; callback: TAutoAssemblerCallback);<N>procedure UnregisterAutoAssemblerCommand(command: string);<N>function registerAutoAssemblerPrologue(m: TAutoAssemblerPrologue; postAOBSCAN: boolean=false): integer;<N>procedure unregisterAutoAssemblerPrologue(id: integer);<N><N>
var oldaamessage: boolean;<N><N><N>function autoassemble2(code: tstrings;popupmessages: boolean;syntaxcheckonly:boolean; targetself: boolean; disableinfo: TDisableInfo=nil; memrec: TMemoryRecord=nil):boolean;<N><N>implementation<N><N>{$ifdef jni}<N>uses strutils, memscan, disassembler, networkInterface, networkInterfaceApi,<N>     Parsers, Globals, memoryQuery,types;<N>{$else}<N><N>
<N>uses simpleaobscanner, StrUtils, LuaHandler, memscan, disassembler, networkInterface,<N>     networkInterfaceApi, LuaCaller, SynHighlighterAA, Parsers, Globals, memoryQuery,<N>     MemoryBrowserFormUnit, MemoryRecordUnit{$ifdef windows}, vmxfunctions{$endif}, autoassemblerexeptionhandler,<N>     UnexpectedExceptionsHelper, types, autoassemblercode, System.UITypes, frmautoinjectunit;<N>{$endif}<N><N>
unit LuaCECustomButton;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib;<N><N>procedure initializeLuaCECustomButton;<N><N>implementation<N><N>uses LuaCustomControl, CECustomButton, LuaClass, LuaHandler;<N><N><N><N>function cecustombutton_startAnimatorTimer(L: PLua_state): integer; cdecl;<N>begin<N>  TCECustomButton(luaclass_getClassObject(L)).startAnimatorTimer;<N>  result:=0;<N>end;<N><N>
function cecustombutton_stopAnimatorTimer(L: PLua_state): integer; cdecl;<N>begin<N>   TCECustomButton(luaclass_getClassObject(L)).stopAnimatorTimer;<N>   result:=0;<N>end;<N><N>function lua_createCECustomButton(L: PLua_state): integer;  cdecl;<N>begin<N>  if lua_gettop(L)=1 then<N>  begin<N>    luaclass_newClass(L, TCECustomButton.create(lua_toceuserdata(L,1)));<N>    result:=1;<N>  end<N>  else<N>    result:=0;<N>end;<N><N>
procedure cecustombutton_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>begin<N>  customcontrol_addMetaData(L,metatable, userdata);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'startAnimatorTimer', cecustombutton_startAnimatorTimer);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'stopAnimatorTimer', cecustombutton_stopAnimatorTimer);<N>end;<N><N>
unit LuaListColumns;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lualib, lauxlib, comctrls;<N><N>procedure initializeLuaListColumns;<N><N>implementation<N><N>uses luaclass, luahandler, LuaCollection;<N><N>function listcolumns_add(L: PLua_State): integer; cdecl;<N>var<N>  listcolumns: TListColumns;<N>begin<N>  listcolumns:=luaclass_getClassObject(L);<N>  luaclass_newclass(L, listcolumns.add);<N>  result:=1;<N>end;<N><N>
function listcolumns_getColumn(L: PLua_State): integer; cdecl;<N>var<N>  listcolumns: TListcolumns;<N>  index: integer;<N>begin<N>  result:=0;<N>  listcolumns:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=1 then<N>  begin<N>    index:=lua_toInteger(L,-1);<N>    luaclass_newClass(L, listcolumns[index]);<N>    result:=1;<N>  end;<N>end;<N><N>
function listcolumns_setColumn(L: PLua_State): integer; cdecl;<N>var<N>  listcolumns: TListcolumns;<N>  index: integer;<N>  li: TListColumn;<N>begin<N>  result:=0;<N>  listcolumns:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)=2 then<N>  begin<N>    index:=lua_toInteger(L, 1);<N>    li:=lua_ToCEUserData(L, 2);<N>    listcolumns[index]:=li;<N>  end;<N>end;<N><N>
procedure listcolumns_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>begin<N>  collection_addMetaData(L, metatable, userdata);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'add', listcolumns_add);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'getColumn', listcolumns_getColumn);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'setColumn', listcolumns_setColumn);<N><N>
  luaclass_addArrayPropertyToTable(L, metatable, userdata, 'Column', listcolumns_getColumn);<N>  luaclass_setDefaultArrayProperty(L, metatable, userdata, listcolumns_getColumn, listcolumns_setColumn);<N>end;<N><N>procedure initializeLuaListColumns;<N>begin<N>  lua_register(LuaVM, 'listcolumns_add', listcolumns_add);<N>  lua_register(LuaVM, 'listcolumns_getColumn', listcolumns_getColumn);<N>end;<N><N>
unit frmFoundlistPreferencesUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, LResources, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ColorBox, ComCtrls, ExtCtrls, math, betterControls;<N><N>type<N><N>  { TfrmFoundlistPreferences }<N><N>
unit xmplayer_defines;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils; <N><N><N>const XMPLAYER_PLAYXM = 0;<N>const XMPLAYER_PAUSE = 1;<N>const XMPLAYER_RESUME = 2;<N>const XMPLAYER_STOP = 3;<N>const XMPLAYER_SETVOLUME = 4;<N><N><N>implementation<N><N>end.<N><N>
unit FindDialogFix;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, forms, Dialogs;<N><N>type<N>  TFindDialog=class(Dialogs.TFindDialog)<N>  private<N>    FFormLeft: integer;<N>    FFormTop: integer;<N>  protected<N>    function GetLeftFix: integer;<N>    procedure SetLeftFix(l: integer);<N><N>
    function GetTopFix: integer;<N>    procedure SetTopFix(t: integer);<N><N>    function GetPositionFix: TPoint;<N>    procedure SetPositionFix(p: TPoint);<N><N>  public<N>    property Left: Integer read GetLeftFix write SetLeftFix;<N>    property Position: TPoint read GetPositionFix write SetPositionFix;<N>    property Top: Integer read GetTopFix write SetTopFix;<N>  end;<N><N>
implementation<N><N>function TFindDialog.GetLeftFix: integer;<N>begin<N>  if assigned(FFindForm) then<N>    result:=FFindForm.Left<N>  else<N>    Result:=FFormLeft;<N>end;<N><N>procedure TFindDialog.SetLeftFix(l: integer);<N>begin<N>  FFormLeft:=l;<N>  if Assigned(FFindForm) then FFindForm.Left :=FFormLeft;<N>end;<N><N>
function TFindDialog.GetTopFix: integer;<N>begin<N>  if assigned(FFindForm) then<N>    result:=FFindForm.Top<N>  else<N>    Result:=FFormLeft;<N><N>end;<N><N>procedure TFindDialog.SetTopFix(t: integer);<N>begin<N>  FFormTop:=t;<N>  if Assigned(FFindForm) then FFindForm.Top :=FFormTop;<N>end;<N><N>
function TFindDialog.GetPositionFix: TPoint;<N>begin<N>  if assigned(FFindForm) then<N>    Result:=Point(FFindForm.Left, FFindForm.Top)<N>  else<N>    Result:=Point(FFormLeft, FFormTop);<N>end;<N><N>procedure TFindDialog.SetPositionFix(p: TPoint);<N>begin<N>  FFormLeft:=p.x;<N>  FFormTop:=p.y;<N>  if assigned(FFindForm) then<N>  begin<N>    FFindForm.Left:=FFormLeft;<N>    FFindForm.Top:=FFormTop;<N>  end;<N>end;<N><N>
unit FrmMemoryRecordDropdownSettingsUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  LCLType, Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ExtCtrls, MemoryRecordUnit, CEFuncProc, SynEdit, Menus, betterControls, addresslist,<N>  synedittypes;<N><N>
unit networkConfig;<N><N>{$mode DELPHI}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  jwawindows, windows,<N>  {$endif}<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics,<N>  Dialogs, StdCtrls, ExtCtrls, ComCtrls, Menus, resolve, Sockets, ctypes,<N>  registry, betterControls, Types;<N><N>
unit formAddressChange;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs;<N><N>type<N>  TForm2 = class(TForm)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form2: TForm2;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit frmSelectionlistunit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ExtCtrls, LResources, betterControls;<N><N>type<N><N>  { TfrmSelectionList }<N><N>  TSelectionToTextEvent=function(index: integer; listText: string): string of object;<N><N>
{------------------------------------------------------------------------------<N>The contents of this file are subject to the Mozilla Public License<N>Version 1.1 (the "License"); you may not use this file except in compliance<N>with the License. You may obtain a copy of the License at<N>http://www.mozilla.org/MPL/<N><N>
unit cesupport;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef windows}<N>  windows, activex, comobj,<N>  {$endif}<N>  lclintf, Classes, SysUtils,forms, controls, LMessages,<N>  ExtCtrls, Graphics, FileUtil, Dialogs, math;<N><N>type TADWindow=class(TCustomForm)<N>  private<N>    browserisvalid,browserisvalid2: boolean;<N>    browser: Olevariant;<N><N>
unit frmMergePointerscanResultSettingsUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, ExtCtrls,<N>  StdCtrls, betterControls;<N><N>type<N><N>  { TfrmMergePointerscanResultSettings }<N><N>
  TfrmMergePointerscanResultSettings = class(TForm)<N>    Button1: TButton;<N>    Button2: TButton;<N>    GroupBox1: TGroupBox;<N>    lblDescription: TLabel;<N>    Panel1: TPanel;<N>    Panel2: TPanel;<N>    rgGroupMethod: TRadioGroup;<N>    procedure FormCreate(Sender: TObject);<N>    procedure rgGroupMethodSelectionChanged(Sender: TObject);<N>  private<N>    { private declarations }<N>  public<N>    { public declarations }<N>  end;<N><N>
unit LuaCheckbox;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils,lua, lualib, lauxlib, controls, StdCtrls, betterControls;<N><N>procedure initializeLuaCheckbox;<N><N>implementation<N><N>uses luahandler, luacaller, luaclass, LuaWinControl, ceguicomponents;<N><N>
function createCheckBox(L: Plua_State): integer; cdecl;<N>var<N>  CheckBox: TCECheckBox;<N>  parameters: integer;<N>  owner: TWincontrol;<N>begin<N>  result:=0;<N><N>  parameters:=lua_gettop(L);<N>  if parameters>=1 then<N>    owner:=lua_toceuserdata(L, -parameters)<N>  else<N>    owner:=nil;<N><N>
  lua_pop(L, lua_gettop(L));<N><N><N>  CheckBox:=TCECheckBox.Create(owner);<N>  if owner<>nil then<N>    CheckBox.Parent:=owner;<N><N>  luaclass_newClass(L, CheckBox);<N>  result:=1;<N>end;<N><N>function checkbox_getAllowGrayed(L: PLua_State): integer; cdecl;<N>var<N>  checkbox: Tcustomcheckbox;<N>begin<N>  checkbox:=luaclass_getClassObject(L);<N>  lua_pushboolean(L, checkbox.AllowGrayed);<N>  result:=1;<N>end;<N><N>
function checkbox_setAllowGrayed(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  checkbox: Tcustomcheckbox;<N>begin<N>  result:=0;<N>  checkbox:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    checkbox.AllowGrayed:=lua_toboolean(L,-1);<N>end;<N><N>
unit SyncObjs2;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses {$ifdef darwin}<N>  macport, cthreads, unix, unixtype, pthreads, baseunix,<N>  {$else}<N>  windows,<N>  {$endif}SyncObjs, classes, sysutils, LCLIntf;<N><N>type TSemaphore=class<N>  private<N>    {$ifdef windows}<N>    h: THandle;<N>    {$endif}<N><N>
    max: integer;<N>    {$ifdef darwin}<N>    h: psem_t;<N>    semaphorecount: cardinal;<N><N>    semname: string;<N>    {$endif}<N><N><N><N>  public<N>    function TryAcquire(time: integer=0): boolean;<N>    procedure Acquire;<N>    function Release(count:integer=1):integer;<N>    constructor create(maxcount: integer; init0:boolean=false);<N>    destructor destroy;  override;<N>end;<N><N>
<N>type<N>  TThreadHelper=class helper for TThread<N>    function WaitTillDone(timeout: DWORD; granularity: integer=25): boolean;<N>  end;<N><N><N>{$ifdef THREADNAMESUPPORT}<N>function GetThreadName(tid: TThreadID={$ifdef windows}0{$else}nil{$endif}): string;<N>{$endif}<N><N>
<N>implementation<N><N>uses networkInterfaceApi, maps;<N><N>var<N>  tm: TThreadManager;<N>  oldSetThreadDebugNameA: procedure(threadHandle: TThreadID; const ThreadName: AnsiString);<N><N>  threadnames: TMap;<N>  threadnamesCS: TCriticalSection;<N><N>{$ifdef THREADNAMESUPPORT}<N><N>
function GetThreadName(tid: TThreadID={$ifdef windows}0{$else}nil{$endif}): string;<N>var s: pstring;<N>begin<N>  result:='';<N>  if {$ifdef windows}tid=0{$else}tid=nil{$endif} then tid:=GetCurrentThreadId;<N><N>  threadnamesCS.enter;<N>  s:=nil;<N>  if threadnames.GetData(tid, s) then<N>    result:=s^;<N><N>
  threadnamesCS.Leave;<N>end;<N><N>procedure SetThreadDebugNameA(tid: TThreadID; const ThreadName: AnsiString);<N>var s: pstring;<N>  str: string;<N>begin<N>  if assigned(oldSetThreadDebugNameA) then<N>    oldSetThreadDebugNameA(tid, threadname);<N><N>  if tid=TThreadID(-1) then<N>    tid:=GetCurrentThreadId;<N><N>
  threadnamesCS.enter;<N>  if threadnames.GetData(tid, s) then<N>  begin<N>    DisposeStr(s);<N>    threadnames.Delete(tid);<N>  end;<N>  threadnames.Add(tid, NewStr(threadname));<N>  threadnamesCS.Leave;<N><N>  if (tid=GetCurrentThreadId) and (getConnection<>nil) then<N>    Getconnection.setconnectionname(threadname);<N><N>
<N>end;<N><N>procedure EndThread(exitcode: dword);<N>var s: pstring;<N>begin<N>  threadnamesCS.enter;<N>  if threadnames.GetData(GetCurrentThreadId, s) then<N>  begin<N>    DisposeStr(s);<N>    threadnames.Delete(GetCurrentThreadId);<N>  end;<N><N>  threadnamesCS.Leave;<N>end;<N>{$endif}<N><N>
function TThreadHelper.WaitTillDone(timeout: dword; granularity: integer=25): boolean;<N>var<N>  needsynchronize: boolean;<N>  endtime: qword;<N>begin<N>  needsynchronize:=MainThreadID=GetCurrentThreadId;<N><N>  if Finished then exit(true);<N>  if timeout=0 then exit(Finished);<N>  if timeout=$ffffffff then<N>  begin<N>    WaitFor;<N>    exit(true);<N>  end;<N>  endtime:=gettickcount64+timeout;<N><N>
<N>  repeat<N>    if needsynchronize then<N>      CheckSynchronize(granularity)<N>    else<N>    begin<N>{$ifdef windows}<N>      exit(waitforsingleobject(self.handle, timeout)=WAIT_OBJECT_0);<N>{$else}<N>      sleep(granularity);<N>{$endif}<N>    end;<N>  until (gettickcount64>endtime) or Finished;<N><N>
  result:=finished;<N>end;<N><N>{$ifdef darwin}<N>function sem_open(name: pchar; oflags: integer; mode: integer; value: integer):Psem_t;cdecl; external;<N><N>var<N>  count: integer;<N>{$endif}<N><N>constructor TSemaphore.create(maxcount:integer; init0: boolean=false);<N>var<N>  init: integer;<N>  i: integer;<N>begin<N>  max:=maxcount;<N>  if init0 then<N>    init:=0<N>  else<N>    init:=maxcount;<N><N>
<N>  {$ifdef windows}<N>  h:=CreateSemaphore(nil,init,maxcount,nil);<N>  {$endif}<N><N>  {$ifdef unix}<N>  {$ifndef darwin}<N>  i:=sem_init(@h,0,init);<N>  {$else}<N>  inc(count);<N>  semname:='Semaphore'+inttohex(GetCurrentProcessID,8)+'-'+inttostr(count);<N>  h:=sem_open(pchar(semname), O_CREAT, &644{&777},init);<N><N>
  if IntPtr(h)=-1 then<N>  begin<N>    i:=errno;<N>    raise exception.create('sem_open error '+inttostr(i));<N><N>  end;<N>  {$endif}<N>  {$endif}<N>end;<N><N>destructor TSemaphore.destroy;<N>begin<N>  {$ifdef windows}<N>  closehandle(h);<N>  {$endif}<N><N>
  {$ifdef unix}<N>  {$ifndef darwin}<N>  sem_destroy(h);<N>  {$else}<N>  sem_unlink(pchar(semname));<N>  sem_close(@h);<N>  {$endif}<N>  {$endif}<N><N>  inherited destroy;<N>end;<N><N>procedure TSemaphore.Acquire;<N>begin<N>  {$ifdef windows}<N>  waitforsingleobject(h,infinite);<N>  {$else}<N>  if sem_wait(h)=0 then //wait inside a critical section<N>    InterlockedDecrement(semaphorecount);<N>  {$endif}<N>end;<N><N>
function TSemaphore.TryAcquire(time: integer=0):boolean;<N>{$ifndef windows}<N>var<N>  t: TThread;<N>  starttime: qword;<N><N>  abstime: timespec;<N>  tspec: TTimeSpec;<N>{$endif}<N>begin<N>  {$ifdef windows}<N>  result:=waitforsingleobject(h,time)=WAIT_OBJECT_0;<N>  {$else}<N>  starttime:=gettickcount64;<N>  result:=false;<N><N>
unit LuaBitmap;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Graphics, lua, lualib, lauxlib,LuaHandler;   ;<N><N>procedure initializeLuaBitmap;<N><N>implementation<N><N><N><N>{<N>unit LuaPen;<N><N>interface<N><N>uses<N>  Classes, SysUtils, Graphics,lua, lualib, lauxlib,LuaHandler;<N><N>
procedure initializeLuaPen;<N><N>implementation<N><N>function pen_getColor(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  pen: TPen;<N><N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters=1 then<N>  begin<N>    pen:=lua_touserdata(L,-1);<N>    lua_pop(L, parameters);<N><N>
    lua_pushinteger(L, pen.Color);<N>    result:=1;<N>  end else lua_pop(L, parameters);<N>end;<N><N>function pen_setColor(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  pen: TPen;<N>  color: TColor;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters=2 then<N>  begin<N>    pen:=lua_touserdata(L,-parameters);<N>    color:=lua_tointeger(L, -parameters+1);<N>    lua_pop(L, parameters);<N><N>
    pen.Color:=color;<N>  end else lua_pop(L, parameters);<N>end;<N><N>function pen_getWidth(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  pen: TPen;<N><N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters=1 then<N>  begin<N>    pen:=lua_touserdata(L,-1);<N>    lua_pop(L, parameters);<N><N>
    lua_pushinteger(L, pen.Width);<N>    result:=1;<N>  end else lua_pop(L, parameters);<N>end;<N><N>function pen_setWidth(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  pen: TPen;<N>  width: integer;<N>begin<N>  result:=0;<N>  parameters:=lua_gettop(L);<N>  if parameters=2 then<N>  begin<N>    pen:=lua_touserdata(L,-parameters);<N>    width:=lua_tointeger(L, -parameters+1);<N>    lua_pop(L, parameters);<N><N>
    pen.Width:=width;<N>  end else lua_pop(L, parameters);<N>end;<N><N><N><N>}<N><N>procedure initializeLuaBitmap;<N>begin<N>  lua_register(LuaVM, 'pen_getColor', pen_getColor);<N>  lua_register(LuaVM, 'pen_setColor', pen_setColor);<N>  lua_register(LuaVM, 'pen_getWidth', pen_getWidth);<N>  lua_register(LuaVM, 'pen_setWidth', pen_setWidth);<N><N>
unit frmSaveSnapshotsUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ExtCtrls, math, LuaCanvas, FPImage, FPCanvas, FPImgCanv, FPReadPNG, FPWritePNG, betterControls;<N><N>
unit multilineinputqueryunit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, LCLIntf,<N>  {$endif}<N>  {$ifdef windows}<N>  win32proc, windows,<N>  {$endif}<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls, ExtCtrls,<N>  LCLType, math, betterControls;<N><N>
{ TfrmMultilineInputQuery }<N><N><N>function MultilineInputQuery(const ACaption, APrompt : String; Values : TStrings) : Boolean; overload;<N>function MultilineInputQuery(const ACaption, APrompt : String; var Value : String) : Boolean; overload;<N><N>implementation<N><N>
{$R *.lfm}<N><N>type<N>  TfrmMultilineInputQuery = class(TForm)<N>    Panel1: TPanel;<N>    Panel2: TPanel;<N>    Button1: TButton;<N>    Button2: TButton;<N>    lblPrompt: TLabel;<N>    Memo1: TMemo;<N>    procedure Memo1KeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);<N>    procedure FormShow(Sender: TObject);<N>  end;<N><N>
function MultilineInputQuery(const ACaption, APrompt : String; var Value : String) : Boolean;<N>var values: Tstringlist;<N>begin<N>  values:=tstringlist.create;<N>  try<N>    values.Text:=Value;<N>    result:=MultilineInputQuery(ACaption, APrompt, Values);<N>    if result then<N>      value:=values.Text;<N>  finally<N>    values.free;<N>  end;<N>end;<N><N>
function MultilineInputQuery(const ACaption, APrompt : String; Values : TStrings) : Boolean;<N>var f: TfrmMultilineInputQuery;<N>  i: integer;<N>begin<N>  result:=false;<N>  f:=TfrmMultilineInputQuery.Create(application);<N>  f.Caption:=ACaption;<N>  f.lblPrompt.caption:=APrompt;<N>  f.Memo1.Lines.Clear;<N>  f.memo1.Lines.AddStrings(values);<N><N>
<N>  if f.showmodal=mrok then<N>  begin<N>    values.Clear;<N>    values.AddStrings(f.memo1.lines);<N>    result:=true;<N>  end;<N><N>  f.free;<N>end;<N><N>procedure TfrmMultilineInputQuery.Memo1KeyDown(Sender: TObject; var Key: Word;<N>  Shift: TShiftState);<N>begin<N>  if key=VK_ESCAPE then<N>    modalresult:=mrcancel;<N><N>
  if (key=VK_RETURN) and (ssCtrl in shift) then<N>    modalresult:=mrok;<N>end;<N><N>procedure TfrmMultilineInputQuery.FormShow(Sender: TObject);<N>const CCHILDREN_TITLEBAR=5;<N>type<N>  TTitleBarInfoEx=record<N>    cbSize: DWORD;<N>    rcTitleBar: TRECT;<N>    rgstate: array [0..CCHILDREN_TITLEBAR] of DWORD;<N>    rgrect: array [0..CCHILDREN_TITLEBAR] of TRECT;<N>  end;<N><N>
var<N>  tbi: TTITLEBARINFOEX;<N>  i: integer;<N>  widthneeded: integer;<N>begin<N>  widthneeded:=canvas.TextWidth(' '+caption+' ');<N><N>  Memo1.Constraints.MinHeight:=canvas.TextHeight('X')*3;<N>  constraints.MinWidth:=max(button1.Width+button2.width+panel2.width+32, widthneeded+GetSystemMetrics(SM_CXSIZE)*2+GetSystemMetrics(SM_CXMENUSIZE));<N>  constraints.MinHeight:=lblPrompt.height+panel1.height+Memo1.Constraints.MinHeight;<N><N>
unit frmsnapshothandlerUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, ExtCtrls,<N>  StdCtrls, Menus, math, NewKernelHandler, FPImage, FPCanvas, FPImgCanv, FPReadPNG, FPWritePNG, betterControls  ;<N><N>
unit FileMapping;<N><N>{$MODE Delphi}<N><N>{<N>Wrapper class for filemapping<N>version 0.1: Only supports opening of exisiting files and no appending<N>version 0.2: copy on write, you can now write to it without actually messing up the file<N><N>}<N><N>interface<N><N>
unit frmBranchMapperUnit;<N><N>{$mode delphi}<N>{$warn 4056 off}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  CheckLst, maps, ExtCtrls, syncobjs, betterControls;<N><N>type<N><N>  { TfrmBranchMapper }<N><N>
unit lua_server;<N>{<N>This unit will setup a communication to the lua engine<N>It will be responsible for receiving and dispatching messages<N><N>lua server waits for pipe connections and when made spawns a new thread(TLuaServerHandler) which<N>handles the communication while it itself is going back to listen to new connections.<N><N>
}<N><N>{$mode delphi}<N><N>interface<N><N>{$ifdef windows}<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, lua, lauxlib, lualib, LuaHandler;<N><N>type<N>  TLuaServerHandler=class(TThread)<N>  private<N>    pipe: THandle;<N>    exec: tstringlist;<N>    result: qword;<N><N>
    returncount: byte;<N>    results: array of qword;<N>    L: Plua_State;<N>    ExecuteLuaFunctionAsync: boolean; //set to true if async<N>    procedure ExecuteLuaScript(async: boolean=false);<N>    procedure ExecuteLuaScriptVar;<N>    procedure ExecuteLuaFunction_Internal;<N>    procedure ExecuteLuaFunction;<N>    procedure ExecuteScript;<N>    procedure ExecuteScriptAsync;<N><N>
    procedure createLuaStateIfNeeded;<N>  protected<N>    procedure execute; override;<N><N>  public<N>    constructor create(pipe: THandle);<N>    destructor destroy; override;<N>  end;<N><N>  TLuaServer=class(TThread)<N>  private<N>    fname: string;<N>  protected<N>    procedure execute; override;<N>  public<N>    constructor create(name: string);<N>    destructor destroy; override;<N>    property name: string read fname;<N>  end;<N><N>
 // TLuaServers =  TFPGList<TLuaServer>;<N><N>var luaservers: TList;<N><N>function luaserverExists(name: string): boolean;<N><N>{$endif}<N><N>implementation<N><N>{$ifdef windows}<N><N>resourcestring<N>  rsALuaserverWithTheName = 'A luaserver with the name ';<N>  rsAlreadyExists = ' already exists';<N><N>
type EPipeError=class(Exception);<N><N>function luaserverExists(name: string): boolean;<N>var i: integer;<N>begin<N>  result:=true;<N>  for i:=0 to luaservers.count-1 do<N>    if TLuaServer(luaservers[i]).name=name then exit;<N><N>  result:=false;<N>end;<N><N>
<N><N>//--------TLuaServerHandler--------<N><N>constructor TLuaServerHandler.create(pipe: THandle);<N>begin<N>  FreeOnTerminate:=true;<N>  self.pipe:=pipe;<N>  exec:=TStringlist.create;<N>  inherited create(false);<N>end;<N><N>destructor TLuaServerHandler.destroy;<N>begin<N>  exec.free;<N>  inherited destroy;<N>end;<N><N>
procedure TLuaServerHandler.ExecuteScript;<N>var<N>  i,j: integer;<N>  top: integer;<N><N>begin<N>  top:=lua_gettop(Luavm);<N>  i:=luahandler.lua_dostring(luavm, pchar(exec.text));<N>  if i=0 then<N>    result:=lua_tointeger(Luavm, -1)<N>  else<N>    result:=0;<N><N>
  if returncount>0 then<N>  begin<N>    if length(results)<returncount then<N>      setlength(results, returncount);<N><N>    for i:=0 to returncount-1 do<N>      results[(returncount-1)-i]:=lua_tointeger(Luavm, -1-i);<N><N>  end;<N><N>  lua_settop(Luavm, top);<N><N>
end;<N><N>procedure TLuaServerHandler.createLuaStateIfNeeded;<N>var<N>  i: integer;<N>  s: string;<N>begin<N>  if l=nil then<N>    l:=luavm; //this creates the new lua state<N>end;<N><N>procedure TLuaServerHandler.ExecuteScriptAsync;<N>var<N>  i,top: integer;<N>  s: string;<N>begin<N>  createLuaStateIfNeeded;<N><N>
  top:=lua_gettop(L);<N>  i:=luahandler.lua_dostring(L, pchar(exec.text));<N>  if i=0 then<N>    result:=lua_tointeger(L, -1)<N>  else<N>    result:=0;<N><N>  if returncount>0 then<N>  begin<N>    if length(results)<returncount then<N>      setlength(results, returncount);<N><N>
    for i:=0 to returncount-1 do<N>      results[(returncount-1)-i]:=lua_tointeger(L, -1-i);<N><N>  end;<N><N>  lua_settop(L, top);<N>end;<N><N>procedure TLuaServerHandler.ExecuteLuaFunction_Internal;<N>type TParamType=(ptNil=0, ptBoolean=1, ptInt64=2, ptInt32=3, ptNumber=4, ptString=5, ptTable=6, ptUnknown=255);<N>{<N>todo: ExecuteLuaFunction<N>Variable paramcount<N>setup:<N>functionref: byte<N>if functionref=0 then<N>  functionnamelength: byte<N>  functionname[functionnamelength]: char<N>end<N><N>
paramcount: byte<N>params[paramcount]: record<N>    paramtype: byte  - 0=nil, 1=integer64, 2=double, 3=string,  4=table perhaps ?<N>    value:<N>      --if paramtype=2 then<N>      stringlength: word<N>      string[strinbglength]: char<N>      --else<N>      value: 8byte<N>  end<N><N>
returncount: byte<N><N><N>--returns:<N>actualreturncount: byte<N><N>}<N>  procedure error;<N>  begin<N>    OutputDebugString('Read error');<N>    terminate;<N>  end;<N><N>var<N>  functionref: integer;<N>  br: dword;<N>  functionname: pchar;<N>  functionnamelength: word;<N>  paramcount: byte;<N>  returncount: byte;<N><N>
  paramtype: byte;<N><N>  value: qword;<N>  value32: dword absolute value;<N>  doublevalue: double absolute value;<N>  v8: byte absolute value;<N><N>  stringlength: word;<N>  tempstring: pchar;<N>  i,j,t: integer;<N><N>  valid: integer;<N><N>  lvm: Plua_State;<N>  oldtop: integer;<N>begin<N>  if ExecuteLuaFunctionAsync then<N>    lvm:=L<N>  else<N>  begin<N>    lvm:=LuaVM;<N>  end;<N><N>
  try<N>    oldtop:=lua_gettop(lvm);<N><N>    if readfile(pipe, functionref, sizeof(functionref), br, nil)=false then raise EPipeError.Create('');<N><N>    if functionref<>0 then<N>    begin<N>      lua_rawgeti(lvm, LUA_REGISTRYINDEX, functionref);<N>    end<N>    else<N>    begin<N>      if readfile(pipe, functionnamelength, sizeof(functionnamelength), br, nil)=false then raise EPipeError.Create('');<N><N>
      getmem(functionname, functionnamelength+1);<N>      if readfile(pipe, functionname^, functionnamelength, br, nil)=false then raise EPipeError.Create('');<N><N>      functionname[functionnamelength]:=#0;<N><N>      lua_getglobal(lvm, pchar(functionname));<N><N>
      FreeMemAndNil(functionname);<N>    end;<N><N>    //the function is now pushed on the lua stack<N>    if readfile(pipe, paramcount, sizeof(paramcount), br, nil)=false then raise EPipeError.Create('');<N><N>    for i:=0 to paramcount-1 do<N>    begin<N>      if readfile(pipe, paramtype, sizeof(paramtype), br, nil)=false then raise EPipeError.Create('');<N><N>
      case TParamType(paramtype) of<N>        ptNil: lua_pushnil(lvm);<N><N>        ptBoolean: //int<N>        begin<N>          if readfile(pipe, v8, sizeof(v8), br, nil)=false then raise EPipeError.Create('');<N>          lua_pushboolean(lvm, v8<>0);<N>        end;<N><N>
        ptInt32: //int32<N>        begin<N>          if readfile(pipe, value32, sizeof(value32), br, nil)=false then raise EPipeError.Create('');<N>          lua_pushinteger(lvm, value32);<N>        end;<N><N>        ptInt64: //int<N>        begin<N>          if readfile(pipe, value, sizeof(value), br, nil)=false then raise EPipeError.Create('');<N>          lua_pushinteger(lvm, value);<N>        end;<N><N>
        ptNumber: //number<N>        begin<N>          if readfile(pipe, value, sizeof(value), br, nil)=false then raise EPipeError.Create('');<N>          lua_pushnumber(lvm, doublevalue);<N>        end;<N><N>        ptString: //string<N>        begin<N>          if readfile(pipe, stringlength, sizeof(stringlength), br, nil)=false then raise EPipeError.Create('');<N>          getmem(tempstring, stringlength+1);<N><N>
          if readfile(pipe, tempstring[0], stringlength, br, nil)=false then raise EPipeError.Create('');<N><N>          tempstring[stringlength]:=#0;<N>          lua.lua_pushstring(lvm, tempstring);<N><N>          FreeMemAndNil(tempstring);<N>        end;<N><N>
       { 4: //table<N>        begin<N>          lua_newtable(lvm);<N>          t:=lua_gettop(lvm);<N>          LoadLuaTable(t);<N>        end;   }<N>      end;<N><N>    end;<N><N>    if readfile(pipe, returncount, sizeof(returncount), br, nil)=false then raise EPipeError.Create('');<N><N>
<N>    if lua_pcall(lvm, paramcount, returncount, 0)=0 then<N>    begin<N>      writefile(pipe, returncount, sizeof(returncount), br,nil);<N>      for i:=0 to returncount-1 do<N>      begin<N>        j:=-returncount+i;<N><N>        case lua_type(lvm, j) of<N>          LUA_TNIL:<N>          begin<N>            paramtype:=byte(ptNil);<N>            if writefile(pipe, paramtype, sizeof(paramtype), br, nil)=false then raise EPipeError.Create('');<N>          end;<N><N>
          LUA_TBOOLEAN:<N>          begin<N>            paramtype:=byte(ptBoolean);<N>            if writefile(pipe, paramtype, sizeof(paramtype), br, nil)=false then raise EPipeError.Create('');<N><N>            if lua_toboolean(lvm, j) then v8:=1 else v8:=0;<N>            if writefile(pipe, v8, sizeof(v8), br, nil)=false then raise EPipeError.Create('');<N>          end;<N><N>
unit CustomTypeHandler;<N><N>{$mode delphi}<N>{<N>This class is used as a wrapper for different kinds of custom types<N>}<N><N>interface<N><N><N><N><N><N>{$ifdef jni} //not yet implemented, but the interface is available<N>uses<N>  Classes, SysUtils, math;<N><N>
type PLua_state=pointer;<N>{$else}<N>uses<N>  dialogs, Classes, SysUtils,cefuncproc, lua, lauxlib, lualib,<N>  math, commonTypeDefs;<N>{$endif}<N><N>type<N>  TConversionRoutine=function(data: pointer):integer; stdcall;<N>  TReverseConversionRoutine=procedure(i: integer; output: pointer); stdcall;<N><N>
//I should have used cdecl from the start<N>  TConversionRoutine2=function(data: pointer; address: ptruint):integer; cdecl;<N>  TReverseConversionRoutine2=procedure(i: integer; address: ptruint; output: pointer); cdecl;<N><N>  TConversionRoutineString=procedure(data: pointer; address: ptruint; output: pchar); cdecl;<N>  TReverseConversionRoutineString=procedure(s: pchar; address: ptruint; output: pointer); cdecl;<N><N>
<N>  TCustomTypeException=class(Exception);<N><N>  TCustomTypeType=(cttAutoAssembler, cttLuaScript, cttPlugin);<N>  TCustomType=class<N>  private<N>    fname: string;<N>    ffunctiontypename: string; //lua<N><N>    lua_bytestovaluefunctionid: integer;<N>    lua_valuetobytesfunctionid: integer;<N>    lua_bytestovalue: string; //help string that contains the functionname so it doesn't have to build up this string at runtime<N>    lua_valuetobytes: string;<N><N>
<N>    routine: pointer;<N>    reverseroutine: pointer;<N><N>    currentscript: tstringlist;<N>    fCustomTypeType: TCustomTypeType; //plugins set this to cttPlugin<N>    fScriptUsesFloat: boolean;<N>    fScriptUsesCDecl: boolean;<N>    fScriptUsesString: boolean;<N><N>
    disableinfo: tobject;//Tdisableinfo;<N><N><N>    textbuffersize: integer; //size of string to pass to AA script versions<N><N>    procedure unloadscript;<N>    procedure setName(n: string);<N>    procedure setfunctiontypename(n: string);<N>  public<N><N>
    bytesize: integer;<N>    preferedAlignment: integer;<N><N>    //these 4 functions are just to make it easier<N>    procedure ConvertToData(f: single; output: pointer; address: ptruint); overload;<N>    procedure ConvertToData(i: integer; output: pointer; address: ptruint); overload;<N>    procedure ConvertToData(s: pchar; output: pointer; address: ptruint); overload;<N><N>
    function ConvertDataToInteger(data: pointer; address: ptruint): integer;<N>    function ConvertDataToIntegerLua(data: pbytearray; address: ptruint): integer;<N>    procedure ConvertIntegerToData(i: integer; output: pointer; address: ptruint);<N>    procedure ConvertIntegerToDataLua(i: integer; output: pbytearray; address: ptruint);<N><N>
    function ConvertDataToFloat(data: pointer; address: ptruint): single;<N>    function ConvertDataToFloatLua(data: pbytearray; address: ptruint): single;<N>    procedure ConvertFloatToData(f: single; output: pointer; address: ptruint);<N>    procedure ConvertFloatToDataLua(f: single; output: pbytearray; address: ptruint);<N><N>
    function ConvertDataToString(data: pointer; address: ptruint): string;<N>    function ConvertDataToStringLua(data: pbytearray; address: ptruint): string;<N>    procedure ConvertStringToData(s: pchar; output: pointer; address: ptruint);<N>    procedure ConvertStringToDataLua(s: pchar; output: pbytearray; address: ptruint);<N><N>
<N><N><N>    function getScript:string;<N>    procedure setScript(script:string; luascript: boolean=false);<N>    constructor CreateTypeFromAutoAssemblerScript(script: string);<N>    constructor CreateTypeFromLuaScript(script: string);<N>    destructor destroy; override;<N><N>
unit rescanhelper;<N><N>{$MODE Delphi}<N><N>interface<N><N>{$ifdef darwin}<N><N>uses macport, LCLIntf, classes, symbolhandler, CEFuncProc,NewKernelHandler, maps,<N>  sysutils, syncobjs, pagemap, Sockets, (*CELazySocket, PointerscanNetworkCommands, *)<N>  zstream, commonTypeDefs;<N>{$endif}<N><N>
{$ifdef windows}<N><N>uses windows, LCLIntf, classes, symbolhandler, CEFuncProc,NewKernelHandler, maps,<N>  sysutils, syncobjs, pagemap, Sockets, CELazySocket, PointerscanNetworkCommands,<N>  zstream, commonTypeDefs;<N>{$endif}<N><N>type<N><N><N>  TRescanHelper=class<N>  private<N>    pagemap: TPageMap;<N>    pagemapcs: TCriticalsection;<N><N>
    memoryregion: TMemoryRegions;<N><N>    function BinSearchMemRegions(address: ptrUint): integer;<N>    procedure quicksortmemoryregions(lo,hi: integer);<N>  public<N>    function ispointer(address: ptrUint): boolean;<N>    function GetMemoryRegion(Address: ptruint): TMemoryRegion;<N><N>
unit feces;<N>//friends endorsing cheat engine system<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>{$ifdef windows}<N>uses<N>  Classes, SysUtils, System.uitypes, bcrypt, DOM, xmlutils, XmlRead, XMLWrite, dialogs, windows,<N>  graphics, math;<N><N>function canSignTables: boolean;<N>procedure signTable(cheattable: TDOMElement);<N>procedure signTableFile(f: string);<N>function isProperlySigned(cheattable: TDOMElement; out specialstring: string; out imagepos: integer; out image: tpicture): boolean;<N><N>
unit frmFindDialogUnit;<N>{<N>The lazarus finddialog window has too many options I never use, AND when you<N>remove them, the up/down direction disappears as well, and overal shoddy look<N><N>Thus this version instead<N>}<N><N><N>{$mode delphi}<N><N>interface<N><N>
unit LuaCollectionItem;<N><N>//first new object added since the conversion (no initializeLuaCollectionItem because no backwards compatibility and no create)<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, lua, lauxlib, lualib;<N><N>procedure collectionItem_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N><N>
implementation<N><N>uses luahandler, LuaClass, LuaObject;<N><N>function collectionItem_getID(L: PLua_state):integer; cdecl;<N>var ci: TCollectionItem;<N>begin<N>  ci:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, ci.ID);<N>  result:=1;<N>end;<N><N>function collectionItem_getIndex(L: PLua_state):integer; cdecl;<N>var ci: TCollectionItem;<N>begin<N>  ci:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, ci.Index);<N>  result:=1;<N>end;<N><N>
function collectionItem_setIndex(L: PLua_state):integer; cdecl;<N>var ci: TCollectionItem;<N>begin<N>  ci:=luaclass_getClassObject(L);<N>  if lua_gettop(l)=1 then<N>    ci.index:=lua_tointeger(L,1);<N><N>  result:=0;<N>end;<N><N>function collectionItem_getDisplayName(L: PLua_state):integer; cdecl;<N>var ci: TCollectionItem;<N>begin<N>  ci:=luaclass_getClassObject(L);<N>  lua_pushstring(L, ci.DisplayName);<N>  result:=1;<N>end;<N><N>
function collectionItem_setDisplayName(L: PLua_state):integer; cdecl;<N>var ci: TCollectionItem;<N>begin<N>  ci:=luaclass_getClassObject(L);<N>  if lua_gettop(l)=1 then<N>    ci.DisplayName:=Lua_ToString(L,1);<N><N>  result:=0;<N>end;<N><N>procedure collectionItem_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>begin<N>  object_addMetaData(L, metatable, userdata);<N><N>
unit LuaCheatComponent;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils,lua, lualib, lauxlib, LuaHandler, LuaCaller,<N>  ExtCtrls, StdCtrls, ExtraTrainerComponents;<N><N>procedure initializeLuaCheatComponent;<N><N>implementation<N><N>uses LuaClass, LuaWinControl;<N><N>
function cheatcomponent_getActive(L: PLua_State): integer; cdecl;<N>var<N>  cheatcomponent: TCheat;<N>begin<N>  cheatcomponent:=luaclass_getClassObject(L);<N>  lua_pushboolean(L, cheatcomponent.activated);<N>  result:=1;<N>end;<N><N><N>function cheatcomponent_setActive(L: PLua_State): integer; cdecl;<N>var<N>  paramstart, paramcount: integer;<N>  cheatcomponent: TCheat;<N><N>
  deactivatetime: integer;<N>  t: TTimer;<N>begin<N>  result:=0;<N>  cheatcomponent:=luaclass_getClassObject(L, @paramstart, @paramcount);<N><N><N>  if paramcount>=1 then<N>  begin<N>    cheatcomponent.activated:=lua_toboolean(L,paramstart);<N><N>    if paramcount=2 then<N>    begin<N>      deactivatetime:=lua_tointeger(L,paramstart+1);<N>      if cheatcomponent.activated then<N>        cheatcomponent.setDeactivateTimer(deactivatetime);<N><N>
    end;<N>  end;<N>end;<N><N>function cheatcomponent_getDescription(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  cheatcomponent: TCheat;<N>begin<N>  cheatcomponent:=luaclass_getClassObject(L);<N>  lua_pushstring(L, cheatcomponent.Description);<N>  result:=1;<N>end;<N><N>
<N>function cheatcomponent_setDescription(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  cheatcomponent: TCheat;<N><N>  deactivatetime: integer;<N>  t: TTimer;<N>begin<N>  result:=0;<N>  cheatcomponent:=luaclass_getClassObject(L);<N><N>
  if lua_gettop(L)>=1 then<N>    cheatcomponent.Description:=Lua_ToString(L,-1);<N>end;<N><N>function cheatcomponent_getHotkey(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  cheatcomponent: TCheat;<N>begin<N>  result:=0;<N>  cheatcomponent:=luaclass_getClassObject(L);<N>  lua_pushstring(L, cheatcomponent.Hotkey);<N>  result:=1;<N>end;<N><N>
<N>function cheatcomponent_setHotkey(L: PLua_State): integer; cdecl;<N>var<N>  cheatcomponent: TCheat;<N><N>  deactivatetime: integer;<N>  t: TTimer;<N>begin<N>  result:=0;<N>  cheatcomponent:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    cheatcomponent.Hotkey:=Lua_ToString(L,-1);<N>end;<N><N>
function cheatcomponent_getDescriptionLeft(L: PLua_State): integer; cdecl;<N>var<N>  cheatcomponent: TCheat;<N>begin<N>  cheatcomponent:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, cheatcomponent.DescriptionLeft);<N>  result:=1;<N>end;<N><N><N>function cheatcomponent_setDescriptionLeft(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  cheatcomponent: TCheat;<N><N>
  deactivatetime: integer;<N>  t: TTimer;<N>begin<N>  result:=0;<N>  cheatcomponent:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=1 then<N>    cheatcomponent.Descriptionleft:=lua_tointeger(L,-1);<N>end;<N><N><N>function cheatcomponent_getHotkeyLeft(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  cheatcomponent: TCheat;<N>begin<N>  result:=0;<N>  cheatcomponent:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, cheatcomponent.Hotkeyleft);<N>  result:=1;<N>end;<N><N>
<N>function cheatcomponent_setHotkeyLeft(L: PLua_State): integer; cdecl;<N>var<N>  cheatcomponent: TCheat;<N><N>  deactivatetime: integer;<N>  t: TTimer;<N>begin<N>  result:=0;<N>  cheatcomponent:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    cheatcomponent.Hotkeyleft:=lua_tointeger(L,-1);<N>end;<N><N>
function cheatcomponent_getEditValue(L: PLua_State): integer; cdecl;<N>var<N>  cheatcomponent: TCheat;<N>begin<N>  cheatcomponent:=luaclass_getClassObject(L);<N>  lua_pushstring(L, cheatcomponent.EditValue);<N>  result:=1;<N>end;<N><N><N>function cheatcomponent_setEditValue(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  cheatcomponent: TCheat;<N><N>
unit frmSaveMemoryRegionUnit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms, symbolhandler,<N>  Dialogs, StdCtrls, NewKernelHandler, CEFuncProc, ExtCtrls, LResources, Menus, betterControls;<N><N>
unit unrandomizer;<N><N>//Todo, update with new tech<N><N>{$MODE Delphi}<N><N>interface<N><N>uses {$ifdef darwin}macport,{$endif}<N>     {$ifdef windows}windows,{$endif}<N>     CEFuncProc,dialogs,classes,comctrls,LCLIntf,sysutils,formsettingsunit,<N>     NewKernelHandler, commonTypeDefs, MemFuncs, betterControls;<N><N>
unit frmExceptionRegionListUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ExtCtrls, Menus,commonTypeDefs, betterControls;<N><N>type<N><N>  { TfrmExceptionRegionList }<N><N>
unit PEInfoFunctions;<N><N>{$MODE Delphi}<N><N>{<N>This unit will contain all functions used for PE-header inspection<N>}<N><N>{$warn 4056 off}<N><N>interface<N><N>uses<N>  {$ifdef windows}<N>  jwawindows, windows,<N>  {$endif}<N>  LCLIntf,SysUtils,classes, CEFuncProc,NewKernelHandler,FileMapping, commonTypeDefs;<N><N>
<N>const<N>  IMAGE_DOS_SIGNATURE                     = $5A4D;      { MZ }<N>  IMAGE_OS2_SIGNATURE                     = $454E;      { NE }<N>  IMAGE_OS2_SIGNATURE_LE                  = $454C;      { LE }<N>  IMAGE_VXD_SIGNATURE                     = $454C;      { LE }<N>  IMAGE_NT_SIGNATURE                      = $00004550;  { PE00 }<N><N>
unit LuaManualModuleLoader;<N><N>{$mode delphi}<N><N>interface<N><N><N>{$IFDEF windows}<N>uses<N>  windows, Classes, SysUtils;<N><N>procedure initializeLuaModuleLoader;<N>{$ENDIF}<N><N>implementation<N><N>{$IFDEF windows}<N>uses ManualModuleLoader, lua, lauxlib, lualib, LuaClass, LuaHandler, LuaObject;<N><N>
unit DissectCodeunit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  jwawindows, windows,<N>  {$endif}<N>  LCLIntf, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ComCtrls, ExtCtrls, DissectCodeThread, CEFuncProc,<N>  symbolhandler, LResources, Menus, frmReferencedStringsUnit, newkernelhandler,<N>  MemFuncs, commonTypeDefs, ProcessHandlerUnit, betterControls;<N><N>
unit LuaFoundlist;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils,lua, lualib, lauxlib, symbolhandler, LuaHandler, cefuncproc,<N>  memscan, foundlisthelper, betterControls;<N><N><N><N>procedure initializeFoundlist;<N><N>implementation<N><N>
uses luaclass, luaobject;<N><N>resourcestring<N>  rsCreatefoundlistNeedsAMemscanObjectAsParameter = 'createfoundlist needs a memscan object as parameter';<N><N>function createFoundList(L: Plua_State): integer; cdecl;<N>var<N>  foundlist: TFoundlist;<N>  memscan: TMemScan;<N>begin<N>  result:=0;<N>  if lua_gettop(L)=1 then<N>    memscan:=lua_toceuserdata(L, -1)<N>  else<N>    raise exception.create(rsCreatefoundlistNeedsAMemscanObjectAsParameter);<N><N>
  foundlist:=TFoundList.create(nil, memscan);<N><N>  luaclass_newClass(L, foundlist);<N>  result:=1;<N>end;<N><N>function foundlist_initialize(L: Plua_State): integer; cdecl;<N>var<N>  foundlist: Tfoundlist;<N>begin<N>  result:=0;<N>  foundlist:=luaclass_getClassObject(L);<N>  foundlist.Initialize;<N>end;<N><N>
function foundlist_deinitialize(L: Plua_State): integer; cdecl;<N>var<N>  foundlist: Tfoundlist;<N>begin<N>  result:=0;<N>  foundlist:=luaclass_getClassObject(L);<N>  foundlist.Deinitialize;<N>end;<N><N><N>function foundlist_getCount(L: PLua_State): integer; cdecl;<N>var<N>  foundlist: Tfoundlist;<N>begin<N>  foundlist:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, foundlist.count);<N>  result:=1;<N>end;<N><N>
function foundlist_getAddress(L: PLua_State): integer; cdecl;<N>var<N>  foundlist: Tfoundlist;<N>  index: integer;<N>begin<N>  result:=0;<N>  foundlist:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>  begin<N>    index:=lua_tointeger(L,-1);<N>    lua_pushstring(L, inttohex(foundlist.GetAddress(index),8));<N>    result:=1;<N>  end;<N>end;<N><N>
function foundlist_getValue(L: PLua_State): integer; cdecl;<N>var<N>  parameters: integer;<N>  foundlist: Tfoundlist;<N>  b: dword;<N>  value: string;<N>  index: integer;<N>begin<N>  result:=0;<N>  foundlist:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=1 then<N>  begin<N>    index:=lua_tointeger(L,-1);<N>    foundlist.GetAddress(index, b, value);<N>    lua_pushstring(L, value);<N>    result:=1;<N>  end;<N>end;<N><N>
unit aboutunit;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,shellapi,<N>  {$endif}LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ExtCtrls, LResources, vmxfunctions, NewKernelHandler, betterControls;<N><N>
unit disassemblerComments;<N><N>{<N>this unit will contain the interface for the disassembler comments<N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>{$ifdef darwin}<N>  macport,<N>{$endif}<N>{$ifdef windows}<N>  windows,<N>{$endif}<N>  Classes, SysUtils, AvgLvlTree, math, cefuncproc, symbolhandler,<N>  symbolhandlerstructs, dom;<N><N>
unit tracerIgnore;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, symbolhandler, symbolhandlerstructs, cefuncproc, globals;<N><N>type<N>  TTracerIgnore=class<N>  private<N>    ignoredtracerregions: array of record<N>      start: ptruint;<N>      stop: ptruint;<N>    end;<N>  public<N>    function InIgnoredModuleRange(address: ptruint): boolean;<N>    procedure loadIgnoredModules;<N>  end;<N><N>
var IgnoredModuleListHandler: TTracerIgnore;<N><N>implementation<N><N><N>procedure TTracerIgnore.loadIgnoredModules;<N>var<N>  s: string;<N>  i,j: integer;<N>  donottrace: tstringlist;<N>  mi: tmoduleinfo;<N>begin<N>  //parse the donottrace.txt file and find the range<N>  setlength(ignoredtracerregions, 0);<N><N>
  s:=cheatenginedir+'donottrace.txt';<N>  if FileExists(s) then //if the list exists<N>  begin<N>    donottrace:=tstringlist.create;<N><N>    try<N>      donottrace.LoadFromFile(s{$if FPC_FULLVERSION>=030200}, true{$endif});<N><N>      i:=0;<N>      while i<donottrace.Count do<N>      begin<N>        j:=pos('#', donottrace[i]);<N>        if j>0 then<N>          donottrace[i]:=trim(copy(donottrace[i], 1, j-1));<N><N>
unit frmMicrotransactionsUnit;<N><N>//Don't piss your pants, this is just an april fools thing<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, LResources, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ExtCtrls, Buttons, LuaInternet, lua, luahandler, lualib, lauxlib, betterControls;<N><N>
unit RemoteMemoryManager;<N><N>{<N>this unit will contain a class that will be used to control remotely allocated memory blocks.<N>Specifically designed for smaller allocations. allocate at least systeminfo.dwAllocationGranularity on each real alloc  (64kb)<N><N>
Speed is not of essence here. Assumed it that only up to 8KB of memory will be used at MOST<N><N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  syncobjs, Classes, SysUtils, cefuncproc, newkernelhandler;<N><N>
type<N>  TAllocs=record  //record describing each little allocated block of memory<N>    address: ptruint;<N>    size: dword;<N>  end;<N>  PAllocs=^TAllocs;<N><N>type<N>  TAllocatedRegion=record<N>    remotebase: ptruint; //size is not stored, that is systeminfo.dwAllocationGranularity<N>    allocs: Tlist; //sorted list of allocations<N>  end;<N>  PAllocatedRegion=^TAllocatedRegion;<N><N>
type<N>  TRemoteMemoryManager=class(tobject)<N>  private<N>    cs: TCriticalsection;<N>    allocatedRegions: Tlist;<N>    bigAllocs: Tlist;<N>    function findFreeRegion(size: dword): ptruint;<N>    procedure addNewAlloc(address: ptruint; size: integer);<N>  public<N><N>
    function alloc(size: dword):ptruint;<N>    procedure dealloc(address: ptruint);<N>    constructor create;<N>    destructor destroy; override;<N>  end;<N><N>implementation<N><N>uses ProcessHandlerUnit;<N><N>procedure TRemoteMemoryManager.addNewAlloc(address: ptruint; size: integer);<N>var i,j: integer;<N>  a,b: PAllocs;<N>  ar: PAllocatedRegion;<N>begin<N>  getmem(a, sizeof(TAllocs));<N>  a.address:=address;<N>  a.size:=size;<N><N>
unit luafile;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, DOM, zstream, math, custombase85, fgl, xmlutils;<N><N>type TLuafile=class<N>  private<N>    fname: string;<N>    filedata: TMemorystream;<N>  public<N><N>    constructor create(name: string; stream: TStream);<N>    constructor createFromXML(node: TDOMNode);<N>    procedure saveToXML(node: TDOMNode);<N>    destructor destroy; override;<N><N>
<N>  published<N>    property name: string read fname write fname;<N>    property stream: TMemoryStream read filedata;<N>  end;<N><N>  TLuaFileList =  TFPGList<TLuafile>;<N><N>implementation<N><N>constructor TLuafile.createFromXML(node: TDOMNode);<N>var s: string;<N>  b: pchar;<N>  m: TMemorystream;<N>  dc: Tdecompressionstream;<N>  maxsize, size: integer;<N>  read: integer;<N><N>
  useascii85: boolean;<N>  a: TDOMNode;<N>begin<N>  name:=node.NodeName;<N>  filedata:=TMemorystream.create;<N><N>  s:=node.TextContent;<N><N>  useascii85:=false;<N><N>  if node.HasAttributes then<N>  begin<N>    a:=node.Attributes.GetNamedItem('Encoding');<N>    useascii85:=(a<>nil) and (a.TextContent='Ascii85');<N>  end;<N><N>
<N>  if useascii85 then<N>  begin<N>    size:=(length(s) div 5)*4+(length(s) mod 5);<N>    maxsize:=max(65536,size);<N>    getmem(b, maxsize);<N>    size:=Base85ToBin(pchar(s), b);<N>  end<N>  else<N>  begin<N>    size:=length(s) div 2;<N>    maxsize:=max(65536,size); //64KB or the required size if that's bigger<N><N>
unit frmFilePatcherUnit;<N><N>{Not implemented as I currently don't see a real use for it}<N><N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls, EditBtn, PEInfoFunctions, PEInfounit, betterControls;<N><N>
unit AccessCheck;<N>{obsolete, all files are now in the user or temp folder}<N><N>{$MODE Delphi}<N><N>{<N>This unit will contain routines to be used for testing and verifying that ce has<N>the required access needed.<N><N>FileAccessTest is the main routine<N><N>
unit circularBuffer;<N><N>{$MODE Delphi}<N><N>{<N>Circular buffer for only 1 writer and 1 reader thread<N>Do not use with multiple writers or multiple readers (or at least protect the read and write yourself then)<N>}<N><N>interface<N><N>uses<N>  {$ifdef darwin}macport,{$endif}<N>  {$ifdef windows}windows,{$endif}<N>  LCLIntf, syncobjs,classes, sysutils;<N><N>
type TCircularObjectBuffer=class<N>  private<N>    buffer: array of TObject;<N>    ReadIndex: integer;<N>    WriteIndex: integer;<N>    maxTimeout: integer;<N>    hasData: Tevent;<N>    hasSpace: TEvent;<N>    function getCount: integer;<N>  public<N>    function Write(o: TObject): boolean;<N>    function Read: TObject;<N>    constructor create(InitialSize, maxTimeout: integer);<N>    destructor destroy; override;<N>    property count: integer read getCount;<N>end;<N><N>
implementation<N><N>constructor TCircularObjectBuffer.create(InitialSize, maxTimeout: integer);<N>begin<N>  setlength(buffer,initialsize);<N>  ReadIndex:=0;<N>  WriteIndex:=0;<N>  HasData:=Tevent.create(nil,false,false,'');<N>  HasSpace:=Tevent.create(nil,false,true,'');<N>  self.maxTimeout:=MaxTimeout;<N>end;<N><N>
destructor TCircularObjectBuffer.destroy;<N>begin<N>  setlength(buffer,0);<N>  if HasData<>nil then<N>    HasData.Free;<N><N>  if HasSpace<>nil then<N>    HasSpace.Free;<N>end;<N><N>function TCircularObjectBuffer.getCount: integer;<N>begin<N>  if ReadIndex=WriteIndex then<N>    result:=0<N>  else<N>  if ReadIndex<WriteIndex then<N>    result:=WriteIndex-ReadIndex<N>  else<N>    result:=(length(buffer)-ReadIndex)+WriteIndex;<N>end;<N><N>
function TCircularObjectBuffer.Write(o: TObject): boolean;<N>var nextwriteindex: integer;<N>begin<N>  result:=false;<N>  nextwriteindex:=(WriteIndex+1) mod length(buffer);<N>  if (nextwriteindex=ReadIndex) then<N>  begin<N>    //buffer full<N>    sleep(5000);<N>    if (hasspace.WaitFor(maxTimeout)<>wrsignaled) then exit;<N>  end;<N><N>
  buffer[WriteIndex]:=o;<N>  writeindex:=nextwriteindex;<N>  HasData.SetEvent;<N><N>  result:=true;<N>end;<N><N>function TCircularObjectBuffer.Read: TObject;<N>begin<N>  result:=nil;<N>  if (readindex=writeindex) and (hasdata.WaitFor(MaxTimeout)<>wrSignaled) then exit;<N><N>
unit addresslist;<N><N>{$warn 3057 off}<N><N>{$mode DELPHI}<N><N><N><N>interface<N><N>uses<N>  LCLIntf, LCLType, Classes, SysUtils, controls, stdctrls, comctrls, ExtCtrls, graphics,<N>  math, MemoryRecordUnit, FPCanvas, CEFuncProc, NewKernelHandler, menus,dom,<N>  XMLRead,XMLWrite, symbolhandler, AddresslistEditor, inputboxtopunit,<N>  frmMemrecComboboxUnit, commonTypeDefs, multilineinputqueryunit, LazUTF8, StringHashList, betterControls;<N><N>
type<N>  TTreeviewWithScroll=class(TTreeview)<N>  protected<N>    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;<N>  published<N>    property ScrolledTop;<N>  end;<N><N>type<N>  TDropByListviewEvent=procedure(sender: TObject; node: TTreenode; attachmode: TNodeAttachMode) of object;<N>  TCompareRoutine=function(a: tmemoryrecord; b: tmemoryrecord): integer of object;<N>  TMemRecChangeEvent=function(sender: TObject; memrec: TMemoryRecord):boolean of object;<N><N>
unit frmcodefilterunit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ComCtrls, ExtCtrls, maps, Menus, syncobjs, newkernelhandler,<N>  ProcessHandlerUnit, CodeFilterCallOrAllDialog, PEInfoFunctions, PEInfounit,<N>  lua, lualib, lauxlib, LuaForm, LuaClass{$ifdef darwin},macport{$endif}, betterControls;<N><N>
unit LuaCanvas;<N>{<N>This unit will be used to register TCanvas class methods to lua<N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Graphics, GraphType, lua, lualib, lauxlib, LuaHandler, fpcanvas, LCLType, LCLIntf;<N><N>procedure initializeLuaCanvas(L: Plua_State);<N>procedure drawWithMask(DestCanvas:TCanvas; Dx,Dy,Dw,Dh:integer; graph:TRasterImage; Sx,Sy,Sw,Sh:integer);<N><N>
implementation<N><N>uses luaclass, luaobject, textrender;<N><N><N><N>function canvas_clear(L: PLua_State): integer; cdecl;<N>var<N>  canvas: TCanvas;<N>begin<N>  canvas:=luaclass_getClassObject(L);<N>  canvas.clear;<N>  result:=0;<N>end;<N><N>function canvas_getPen(L: PLua_State): integer; cdecl;<N>var<N>  canvas: TCanvas;<N>begin<N>  canvas:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, canvas.pen);<N>  result:=1;<N>end;<N><N>
function canvas_getBrush(L: PLua_State): integer; cdecl;<N>var<N>  canvas: TCanvas;<N>begin<N>  canvas:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, canvas.brush);<N>  result:=1;<N>end;<N><N>function canvas_getFont(L: PLua_State): integer; cdecl;<N>var<N>  canvas: TCanvas;<N>begin<N>  canvas:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, canvas.font);<N>  result:=1;<N>end;<N><N>
function canvas_getWidth(L: PLua_State): integer; cdecl;<N>var<N>  canvas: TCanvas;<N>begin<N>  canvas:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, canvas.width);<N>  result:=1;<N>end;<N><N>function canvas_getHeight(L: PLua_State): integer; cdecl;<N>var<N>  canvas: TCanvas;<N>begin<N>  canvas:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, canvas.height);<N>  result:=1;<N>end;<N><N>
function canvas_getHandle(L: PLua_State): integer; cdecl;<N>var<N>  canvas: TCanvas;<N>begin<N>  canvas:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, canvas.handle);<N>  result:=1;<N>end;<N><N>function canvas_setHandle(L: PLua_State): integer; cdecl;<N>var<N>  canvas: TCanvas;<N>begin<N>  if lua_gettop(L)>=1 then<N>  begin<N>    canvas:=luaclass_getClassObject(L);<N>    canvas.handle:=lua_tointeger(L,1);<N>  end;<N>  result:=0;<N>end;<N><N>
unit LuaTreeNode;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, ComCtrls, lua, lualib, lauxlib;<N><N>implementation<N><N>uses luaclass, luahandler, LuaObject;<N><N><N>function treenode_delete(L: Plua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  result:=0;<N>  treenode:=luaclass_getClassObject(L);<N><N>
  treenode.Delete;<N>end;<N><N><N><N>function treenode_deleteChildren(L: Plua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  result:=0;<N>  treenode:=luaclass_getClassObject(L);<N>  treenode.DeleteChildren;<N>end;<N><N>function treenode_expand(L: Plua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>  recursive: boolean;<N>begin<N>  result:=0;<N>  treenode:=luaclass_getClassObject(L);<N><N>
  if lua_gettop(L)>0 then<N>    recursive:=lua_toboolean(L,1)<N>  else<N>    recursive:=true;<N><N>  treenode.Expand(recursive);<N>end;<N><N>function treenode_collapse(L: Plua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>  recursive: boolean;<N>begin<N>  result:=0;<N>  treenode:=luaclass_getClassObject(L);<N><N>
  if lua_gettop(L)>0 then<N>    recursive:=lua_toboolean(L,1)<N>  else<N>    recursive:=true;<N><N>  treenode.Collapse(recursive);<N>end;<N><N>function treenode_getItems(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>  index: integer;<N>begin<N>  result:=0;<N>  treenode:=luaclass_getClassObject(L);<N><N>
  if lua_gettop(L)>=1 then<N>  begin<N>    index:=lua_tointeger(L,-1);<N>    luaclass_newClass(L, treenode.Items[index]);<N>    result:=1;<N>  end;<N>end;<N><N>function treenode_getCount(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, treenode.Count);<N>  result:=1;<N>end;<N><N>
function treenode_getIndex(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, treenode.Index);<N>  result:=1;<N>end;<N><N>function treenode_getLevel(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, treenode.Level);<N>  result:=1;<N>end;<N><N>
function treenode_getAbsoluteIndex(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, treenode.AbsoluteIndex);<N>  result:=1;<N>end;<N><N>function treenode_getMultiSelected(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N><N>
  treenode:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, treenode.MultiSelected);<N>  result:=1;<N>end;<N><N>function treenode_setMultiSelected(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    treenode.MultiSelected:=lua_tovariant(L, -1);<N><N>
  result:=0;<N>end;<N><N>function treenode_getSelected(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N><N>  treenode:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, treenode.Selected);<N>  result:=1;<N>end;<N><N>function treenode_setSelected(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    treenode.Selected:=lua_tovariant(L, -1);<N><N>
  result:=0;<N>end;<N><N>function treenode_getHasChildren(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N><N>  treenode:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, treenode.HasChildren);<N>  result:=1;<N>end;<N><N>function treenode_setHasChildren(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    treenode.HasChildren:=lua_tovariant(L, -1);<N><N>
  result:=0;<N>end;<N><N>function treenode_getExpanded(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N><N>  treenode:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, treenode.Expanded);<N>  result:=1;<N>end;<N><N>function treenode_setExpanded(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    treenode.Expanded:=lua_toboolean(L, 1);<N><N>
  result:=0;<N>end;<N><N>function treenode_getVisible(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N><N>  treenode:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, treenode.Visible);<N>  result:=1;<N>end;<N><N>function treenode_setVisible(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    treenode.visible:=lua_toboolean(L, 1);<N><N>
  result:=0;<N>end;<N><N>function treenode_getParent(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, treenode.Parent);<N>  result:=1;<N>end;<N><N>function treenode_getText(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  lua_pushvariant(L, treenode.Text);<N>  result:=1;<N>end;<N><N>
function treenode_setText(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    treenode.Text:=Lua_ToString(L, 1);<N><N>  result:=0;<N>end;<N><N>function treenode_getDisplayRect(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>  textonly: boolean=false;<N>  r: trect;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    textonly:=lua_toboolean(L,1);<N><N>
  r:=treenode.DisplayRect(TextOnly);<N>  lua_pushrect(L,r);<N>  result:=1;<N>end;<N><N>function treenode_makeVisible(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>  partialok: boolean=false;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  treenode.MakeVisible;<N><N>
  result:=0;<N>end;<N><N>function treenode_getData(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, UIntPtr(treenode.Data));<N>  result:=1;<N>end;<N><N>function treenode_setData(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    treenode.data:=pointer(lua_tointeger(L, 1));<N><N>
  result:=0;<N>end;<N><N>function treenode_getImageIndex(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  lua_pushinteger(L, treenode.ImageIndex);<N>  result:=1;<N>end;<N><N>function treenode_setImageIndex(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  if lua_gettop(L)>=1 then<N>    treenode.ImageIndex:=lua_tointeger(L, 1);<N><N>
  result:=0;<N>end;<N><N>function treenode_add(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>  treenodes: Ttreenodes;<N>  paramcount: integer;<N>  s: string;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  treenodes:=treenode.Owner;<N><N>
  paramcount:=lua_gettop(L);<N>  if paramcount>=1 then<N>    s:=Lua_ToString(L, 1)<N>  else<N>    s:='';<N><N>  luaclass_newClass(L, treenodes.AddChild(treenode, s));<N>  result:=1;<N>end;<N><N>function treenode_getNextSibling(L: PLua_State): integer; cdecl;<N>var<N>  treenode: Ttreenode;<N>begin<N>  treenode:=luaclass_getClassObject(L);<N>  luaclass_newClass(L, treenode.GetNextSibling);<N>  result:=1;<N>end;<N><N>
procedure treenode_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>begin<N>  object_addMetaData(L, metatable, userdata);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'add', treenode_add);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'getText', treenode_getText);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'setText', treenode_setText);<N><N>
unit formDifferentBitSizeUnit;<N><N>{$MODE Delphi}<N><N>//todo: this is REALLY REALLY OLD<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport, LCLType,<N>  {$endif}<N>  {$ifdef windows}<N>  Windows,<N>  {$endif}<N>  LCLIntf, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls,CEFuncProc, Menus, LResources, betterControls;<N><N>
unit LuaRegion; <N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Graphics,lua, lualib, lauxlib, LuaHandler, RegionEx, LCLIntf, LCLType;<N><N>procedure initializeLuaRegion;<N><N>implementation<N><N>uses luaobject, luaclass;<N><N>function createRegion(L: Plua_State): integer; cdecl;<N>begin<N>  luaclass_newClass(L, TRegionEx.Create);<N>  result:=1;<N>end;<N><N>
function region_addRectangle(L: PLua_State): integer; cdecl;<N>var<N>  r: TRegion;<N>  x1,y1,x2,y2: integer;<N>begin<N>  result:=0;<N>  r:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=4 then<N>  begin<N>    x1:=lua_tointeger(L, -4);<N>    y1:=lua_tointeger(L, -3);<N>    x2:=lua_tointeger(L, -2);<N>    y2:=lua_tointeger(L, -1);<N>    r.AddRectangle(x1,y1,x2,y2);<N>  end;<N>end;<N><N>
function region_addPolygon(L: PLua_State): integer; cdecl;<N>var<N>  paramstart: integer;<N>  r: TRegionEx;<N><N>  coordinatesTable: integer;<N>  coordinateTable: integer;<N><N><N>  c: array of TPoint;<N><N>  tablesize: integer;<N>  coordinate: integer;<N><N>
<N>  x,y: integer;<N><N>  debug: integer;<N>begin<N>  setlength(c,0);<N>  result:=0;<N>  r:=luaclass_getClassObject(L);<N><N>  if lua_gettop(L)>=1 then<N>  begin<N>    coordinatesTable:=lua_gettop(L);<N><N>    if lua_istable(L, coordinatesTable) then<N>    begin<N>      tablesize:=lua_objlen(L, coordinatesTable);<N>      setlength(c, tablesize);<N><N>
<N>      for coordinate:=1 to tablesize do<N>      begin<N>        lua_pushinteger(l,coordinate);<N>        lua_gettable(L, coordinatesTable);<N><N>        coordinateTable:=lua_gettop(L);<N><N><N>        if lua_istable(L, coordinateTable) then<N>        begin<N>          //it's a table<N><N>
          debug:=lua_gettop(L);<N><N><N><N>          //get x<N>          lua_pushinteger(l, 1);<N>          lua_gettable(L, coordinateTable);<N>          x:=lua_tointeger(L, -1);<N>          c[coordinate-1].x:=x;<N>          lua_pop(L, 1);<N><N>          //get y<N>          lua_pushinteger(l, 2);<N>          lua_gettable(L, coordinateTable);<N>          y:=lua_tointeger(L, -1);<N>          c[coordinate-1].y:=y;<N>          lua_pop(L, 1);<N>        end else exit;<N><N>
        lua_pop(L,1);<N>      end;<N><N>      //still here so valid coordinates<N>      r.AddPolygon(c);<N>    end;<N><N><N>  end;<N><N>  lua_settop(L, 0);<N>end;<N><N>procedure region_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N>begin<N>  object_addMetaData(L, metatable, userdata);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'addRectangle', region_addRectangle);<N>  luaclass_addClassFunctionToTable(L, metatable, userdata, 'addPolygon', region_addPolygon);<N><N>
end;<N><N>procedure initializeLuaRegion;<N>begin<N>  lua_register(LuaVM, 'createRegion', createRegion);<N>  lua_register(LuaVM, 'region_addRectangle', region_addRectangle);<N>  lua_register(LuaVM, 'region_addPolygon', region_addPolygon);<N>end;<N><N>initialization<N>  luaclass_register(TRegion, region_addMetaData);<N><N>
unit DBVMDebuggerInterface;<N><N>//limited debugger, but still useful<N><N>{$mode delphi}<N><N>interface<N><N>{$ifdef windows}<N><N>uses<N>  jwawindows, windows, Classes, SysUtils,cefuncproc, newkernelhandler,<N>  DebuggerInterface,contnrs, vmxfunctions;<N>{$else}<N>uses classes, DebuggerInterface;<N>{$endif}<N><N>
<N><N>type<N>  TDBVMResumerThread=class(TThread)<N>  public<N>    {$ifdef windows}<N>    procedure Execute; override; //frequently gets the frozen thread list and checks if it contains the CE process. If so, resume, and check more frequently<N>    {$endif}<N>  end;<N><N>
<N>  TDBVMDebugInterface=class(TDebuggerInterface)<N>  private<N>    {$ifdef windows}<N>    lastfrozenID: integer;<N>    currentFrozenID: integer;<N>    currentFrozenState: TPageEventExtended;<N><N><N>    lastContinueWasAStep: boolean; //if the last continue was a step then wait for lastfrozenID specifically until it gets abandoned (or takes 5 seconds)<N><N>
unit DisassemblerArm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>{$ifdef JNI}<N>uses unixporthelper, classes, sysutils, NewKernelHandler, LastDisassembleData, DisassemblerThumb;<N>{$endif}<N><N>{$ifdef windows}<N>uses<N>  windows, Classes, SysUtils{$ifndef ARMDEV}, newkernelhandler, cefuncproc{$endif},<N>  LastDisassembleData, DisassemblerThumb;<N>{$endif}<N><N>
unit LuaCommonDialog;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, dialogs, lua, lauxlib, lualib;<N><N>procedure commondialog_addMetaData(L: PLua_state; metatable: integer; userdata: integer );<N><N>implementation<N><N>uses LuaClass, LuaHandler, LuaComponent;<N><N>
unit SymbolListHandler;<N>{<N>This unit will keep two trees that link to a list of string to address information records for quick lookup<N>}<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>{$ifdef windows}<N>uses<N>  windows, Classes, SysUtils, AvgLvlTree, laz_avl_Tree, math, fgl, cvconst, syncobjs, symbolhandlerstructs;<N>{$endif}<N><N>
unit frmEditHistoryUnit;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs,<N>  StdCtrls, ComCtrls, ExtCtrls, Menus, NewKernelHandler, syncobjs,<N>  symbolhandler, lua, lauxlib, lualib, betterControls;<N><N>
unit DissectCodeThread;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}<N>  macport,<N>  {$endif}<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  LCLIntf,sysutils,syncobjs,Classes,disassembler, NewKernelHandler, math,<N>  MemoryQuery, CEFuncProc, maps, LastDisassembleData, commonTypeDefs, AvgLvlTree;<N><N>
<N>type<N>  TAddresslist=record<N>    pos: integer;<N>    maxsize: integer;<N>    a: PPtrUintArray;<N>    isstring: boolean;<N>    pointsto: ptruint; //0 if not a pointer<N>    pointstostring: boolean;<N>  end;<N>  PAddresslist=^TAddresslist;<N><N><N><N><N>type tjumptype=(jtCall=0, jtUnconditional=1, jtConditional=2, jtMemory=3);<N><N>
type tdissectarray= array of record<N>                      address: ptrUint;<N>                      jumptype: tjumptype;<N>                    end;<N><N>type tjumpdata = record<N>                   address:ptrUint;<N>                   codes: integer;<N>                   code: array[0..7] of ptrUint; //default space for 8 addresses<N><N>
                   nrofextracodes: integer;<N>                   extracodes: array of ptrUint; //but can be expanded to more if really needed<N>                 end;<N><N>type tjumparray=array of tjumpdata;<N><N><N>type TStringReference=class(tobject)<N>  address: ptrUint;<N>  s: string;<N>  references: array of ptrUint;<N>  isUnicode: boolean;<N>end;<N><N>
type TDissectReference=class(tobject)<N>  address: ptruint;<N>  addressname: string;   //fill these in later<N>  references: array of record<N>      address: ptruint;<N>      addressname: string;<N>    end;<N>end;<N><N>type TOnCallListEntry=procedure(address: ptruint);<N><N>
type<N><N><N>  TDissectCodeThread = class(TThread)<N>  private<N>    { Private declarations }<N>    calllist: TMap;<N>    unconditionaljumplist: TMap;<N>    conditionaljumplist: TMap;<N>    memorylist: TMap; //e.g strings<N><N>    cs: TCriticalSection;<N><N>
    haswork: TEvent;<N>    ready: TEvent;<N><N>    canceled: boolean;<N><N>    oldAddressToNewAddressTree: TAvgLvlTree; //used for loading back addresses and conver them to the new one<N><N>    usedModuleList: TStringList;<N><N>    function isstring(address: ptrUint; v: pqword=nil): boolean;<N>    function findaddress(list: TMap; address: ptrUint):PAddresslist;<N>    procedure clearList(list: Tmap);<N><N>
    //relocation handlers:<N>    function OldAddressToNewAddressLookup(Tree: TAvgLvlTree; Data1, Data2: pointer): integer;<N>    procedure saveModuleListToStream(s: TStream);<N>    procedure loadModuleListFromStream(s: TStream);<N>    function convertOldAddressToNew(address: ptruint): ptruint;<N>    procedure cleanModuleListRelocator;<N><N>
    procedure saveListToStream(list: TMap; s: TStream);<N>    procedure loadListFromStream(list: TMap; s: TStream);<N>  public<N>    percentagedone: dword;<N>    processid: dword;<N><N>    done: boolean;<N>    currentaddress:ptrUint;<N>    memoryregion: tmemoryregions;<N><N>
unit hookedfunctions;<N><N>{$mode delphi}<N><N>interface<N><N>uses sysutils, windows, messages, syncobjs;<N><N>type TNtAllocateVirtualMemory=function(processHandle: THandle; BaseAddress: PPtrUint; ZeroBits: DWORD; RegionSize: PDWORD; AllocationType: DWORD; Protect: DWORD): DWORD; stdcall;<N>type TNtFreeVirtualMemory=function(processHandle: THandle; BaseAddress: PPtrUint; RegionSize: PDWORD; FreeType: DWORD ): DWORD; stdcall;<N><N>
type TRtlAllocateHeap=function(HeapHandle: pointer; Flags: DWORD; size: integer): pointer; stdcall;<N>type TRtlFreeHeap=function(HeapHandle: pointer; Flags: DWORD; HeapBase: pointer): BOOL; stdcall;<N>type TRtlDestroyHeap=function(HeapHandle: pointer): pointer; stdcall;<N><N>
function CeAllocateVirtualMemory(processHandle: THandle; BaseAddress: PPtrUint; ZeroBits: DWORD; RegionSize: PDWORD; AllocationType: DWORD; Protect: DWORD): DWORD; stdcall;<N>function CeFreeVirtualMemory(processHandle: THandle; BaseAddress: PPtrUint; RegionSize: PDWORD; FreeType: DWORD ): DWORD; stdcall;<N><N>
function CeRtlAllocateHeap(HeapHandle: pointer; Flags: DWORD; size: integer): pointer; stdcall;<N>function CeRtlFreeHeap(HeapHandle: pointer; Flags: DWORD; HeapBase: pointer): BOOL; stdcall;<N>function CeRtlDestroyHeap(HeapHandle: pointer): pointer; stdcall;<N><N>
function CeInitializeAllocHook: BOOL; stdcall;<N><N>var<N>  NtAllocateVirtualMemoryOrig: TNtAllocateVirtualMemory;<N>  NtFreeVirtualMemoryOrig: TNtFreeVirtualMemory;<N>  RtlAllocateHeapOrig: TRtlAllocateHeap;<N>  RtlFreeHeapOrig: TRtlFreeHeap;<N>  RtlDestroyHeapOrig: TRtlDestroyHeap;<N><N>
const<N>  HOOKEVENT_ALLOC=0;<N>  HOOKEVENT_FREE=1;<N>  HOOKEVENT_HEAPALLOC=2;<N>  HOOKEVENT_HEAPFREE=3;<N>  HOOKEVENT_HEAPDESTROY=4;<N><N>type<N>  TAllocData=record<N>    handle: qword;<N>    baseaddress: qword;<N>    allocationType: dword;<N>    protect: dword;<N>    size: dword;<N>    esp: qword;<N>  end;<N><N>
  TFreeData=record<N>    handle: qword;<N>    baseaddress: qword;<N>    size: dword;<N>    FreeType: dword;<N>  end;<N><N>  THeapAllocData=record<N>    HeapHandle: qword;<N>    Flags: DWORD;<N>    Size: dword;<N>    esp:qword;<N>    address: qword;<N>  end;<N><N>
unit luaclientfunctions;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  windows, Classes, SysUtils, syncobjs;<N><N>function CELUA_Initialize(pipename: pchar): BOOL; stdcall;<N>function CELUA_ExecuteFunction(script: pchar; parameters: UINT_PTR): UINT_PTR; stdcall;<N>function CELUA_ExecuteFunctionAsync(script: pchar; parameters: UINT_PTR): UINT_PTR; stdcall;<N><N>
function CELUA_GetFunctionReferenceFromName(functionname: pchar): integer; stdcall;<N>function CELUA_ExecuteFunctionByReference(ref: integer; paramcount: integer; AddressOfParameters: PPointer; async: BOOLEAN): UINT_PTR; stdcall;<N><N>var CELUA_ServerName: array [0..255] of char;<N><N>
unit Unit1;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  luaclientfunctions;<N><N>type<N><N>  { TForm1 }<N><N>  TForm1 = class(TForm)<N>    Button1: TButton;<N>    Memo1: TMemo;<N>    procedure Button1Click(Sender: TObject);<N>    procedure FormCreate(Sender: TObject);<N>  private<N>    { private declarations }<N>  public<N>    { public declarations }<N>  end;<N><N>
var<N>  Form1: TForm1;<N><N>implementation<N><N>{$R *.lfm}<N><N>{ TForm1 }<N><N>procedure TForm1.Button1Click(Sender: TObject);<N>begin<N>  CELUA_ExecuteFunction(pchar(memo1.lines.text), 0);<N>end;<N><N>procedure TForm1.FormCreate(Sender: TObject);<N>begin<N>  if CELUA_Initialize('cheatenginebla') then<N>    caption:='Connected';<N>end;<N><N>
 unit DBK32functions;<N><N>{$MODE Delphi}<N><N>interface<N><N>{$ifdef windows}<N>uses<N>  jwawindows, windows, sysutils, classes, types, registry, multicpuexecution,<N>  forms,dialogs, controls, maps, globals;<N><N>//xp sp2<N>//ThreadsProcess=220<N>//ThreadListEntry=22c<N><N>
{$endif}<N><N>const currentversion=2000027;<N><N>const FILE_ANY_ACCESS=0;<N>const FILE_SPECIAL_ACCESS=FILE_ANY_ACCESS;<N>const FILE_READ_ACCESS=$0001;<N>const FILE_WRITE_ACCESS=$0002;<N>const FILE_RW_ACCESS=FILE_READ_ACCESS or FILE_WRITE_ACCESS;<N><N>const METHOD_BUFFERED=    0;<N>const METHOD_IN_DIRECT=   1;<N>const METHOD_OUT_DIRECT=  2;<N>const METHOD_NEITHER=     3;<N>const FILE_DEVICE_UNKNOWN=$00000022;<N>const IOCTL_UNKNOWN_BASE=FILE_DEVICE_UNKNOWN;<N><N>
unit multicpuexecution;<N>{<N>This unit provides some routines that make it easier to pinpoint which cpu will execute a certain piece of code<N>}<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef darwin}macport,{$endif}<N>  {$ifdef windows}windows,{$endif}classes, sysutils;<N><N>
type TCpuSpecificFunction=function(parameters: pointer): BOOL; stdcall;<N>function foreachcpu(functionpointer: TCpuSpecificFunction; parameters: pointer) :boolean;<N>function forspecificcpu(cpunr: integer; functionpointer: TCpuSpecificFunction; parameters: pointer) :boolean;<N><N>
<N>implementation<N><N><N>type Tforeachcpu=class(tthread)<N>  private<N><N>  public<N>    fp: TCpuSpecificFunction;<N>    parameter: pointer;<N>    r: boolean;<N>    procedure execute; override;<N>  end;<N><N>procedure Tforeachcpu.execute;<N>begin<N>  r:=fp(parameter);<N>end;<N><N>
function forspecificcpu(cpunr: integer; functionpointer: TCpuSpecificFunction; parameters: pointer) :boolean;<N>var PA,SA:DWORD_PTR;<N>begin<N>  {$ifdef windows}<N>  result:=true;<N>  GetProcessAffinityMask(getcurrentprocess,PA,SA);<N><N>  if ((1 shl cpunr) and SA) = 0 then<N>  begin<N>    //cpu doesn't exist, do nothing<N>    OutputDebugString(pchar(format('forspecificcpu:Cpu number %d does not exist',[cpunr])));<N>    exit;<N>  end;<N><N>
<N><N>  SetProcessAffinityMask(GetCurrentProcess,(1 shl cpunr));<N>  sleep(0);<N>  with Tforeachcpu.Create(true) do<N>  begin<N>    fp:=functionpointer;<N>    parameter:=parameters;<N>    start;<N>    waitfor;<N>    if result then result:=r; //one false and it stays false<N>    free;<N>  end;<N>  SetProcessAffinityMask(GetCurrentProcess,PA);<N>  {$else}<N>  result:=false;<N>  {$endif}<N>end;<N><N>
function foreachcpu(functionpointer: TCpuSpecificFunction; parameters: pointer) :boolean;<N>var<N>  cpunr,PA,SA:DWORD_PTR;<N>  r: bool;<N>begin<N>  {$ifdef windows}<N>  result:=true;<N>  GetProcessAffinityMask(getcurrentprocess,PA,SA);<N><N>  for cpunr:=0 to 31 do<N>    if ((1 shl cpunr) and SA)>0 then //cpu found<N>    begin<N>      r:=forspecificcpu(cpunr,functionpointer, parameters);<N>      if result then result:=r;<N>    end;<N><N>
{ Modified for Lazarus by Costas Velissariou (velissariouc@gmail.com) 04/01/2011}<N><N>unit JvDesignUtils;<N><N>{$mode objfpc}{$H+}<N><N>{$warn 5033 off}<N><N>interface<N>uses<N>  {$IFDEF UNITVERSIONING}<N>  JclUnitVersioning,<N>  {$ENDIF UNITVERSIONING}<N>  {$ifdef windows}<N>  windows,<N>  win32proc,<N>  {$endif}<N>  SysUtils, LCLProc, LCLType, LResources, LCLIntf, LMessages,    Classes, Controls,<N>  Graphics, Forms, dialogs;<N><N>
type<N>  TDesignerDCFlag = (<N>    ddcDCOriginValid,         // please comment<N>    ddcFormOriginValid,       //<N>    ddcFormClientOriginValid, //<N>    ddcSizeValid              //<N>  );<N>  TDesignerDCFlags = set of TDesignerDCFlag;<N><N>  { TDesignerDeviceContext }<N><N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit jvRuntimeDesign; <N><N>interface<N><N>uses<N>    tp_register, JvDesignSurface, JvConsts, JvDesignClip, JvDesignUtils, <N>  JvResources, JvDesignImp, LazarusPackageIntf;<N><N>implementation<N><N>procedure Register; <N>begin<N>  RegisterUnit('tp_register', @tp_register.Register); <N>end; <N><N>initialization<N>  RegisterPackage('jvRuntimeDesign', @Register); <N>end.<N>
unit JvDesignImp;<N><N>{$mode objfpc}{$H+}<N><N>{$warn 3057 off}<N>{$WARN 2005 off : Comment level $1 found}<N>interface<N><N>uses<N>  {$IFDEF UNITVERSIONING}<N>  JclUnitVersioning,<N>  {$ENDIF UNITVERSIONING}<N>  {$ifdef windows}<N>  win32proc,<N>  {$endif}<N>  LCLProc, LCLType, LResources, LCLIntf, LMessages, SysUtils, Classes, Controls, Graphics,<N>  Forms, ExtCtrls, Contnrs, JvDesignUtils,<N>  JvDesignSurface, componenteditors, propedits;<N><N>
unit tp_register;<N><N>{$mode objfpc}<N><N>interface<N><N>uses<N>  Classes, SysUtils; <N><N>procedure register;<N><N><N>implementation<N>uses<N>  jvDesignSurface, LResources;<N><N>procedure Register;<N>begin<N>  RegisterComponents('Jv Runtime Design', [TJvDesignSurface, TJvDesignScrollBox, TJvDesignPanel]);<N>end;<N><N>initialization<N>  {$I test.lrs}<N><N>end.<N><N>
{ Modified for Lazarus by Costas Velissariou (velissariouc@gmail.com) 04/01/2011}<N><N>{-----------------------------------------------------------------------------<N>The contents of this file are subject to the Mozilla Public License<N>Version 1.1 (the "License"); you may not use this file except in compliance<N>with the License. You may obtain a copy of the License at<N>http://www.mozilla.org/MPL/MPL-1.1.html<N><N>
Software distributed under the License is distributed on an "AS IS" basis,<N>WITHOUT WARRANTY OF ANY KIND, either expressed or implied. See the License for<N>the specific language governing rights and limitations under the License.<N><N>The Original Code is: JvDesingSurface.pas, released on 2005-08-21.<N><N>
The Initial Developer of the Original Code is Scott J Miles<N>Portions created by Scott J Miles are Copyright (C) 2005 Scott J Miles.<N>All Rights Reserved.<N><N>Contributor(s): Olivier Sannier (JVCL Integration)<N><N>You may retrieve the latest version of this file at the Project JEDI's JVCL<N>home page, located at http://jvcl.delphi-jedi.org<N><N>
Known Issues:<N>  Mantis 3963: When a design surface is active, the ENTIRE form where it is<N>               located suffers impacts from being in design mode. This can not<N>               be circumvented because the Designer property is to be set on<N>               the parent form and it MUST be set for the design mode to be<N>               effective. The only workaround is to not have anything else<N>               on the form being designed.<N><N>
-----------------------------------------------------------------------------}<N>// $Id: JvDesignSurface.pas 12931 2010-11-28 13:36:50Z ahuser $<N><N>unit JvDesignSurface;<N><N>{$mode objfpc}{$H+}<N>{$DEFINE NO_DESIGNHOOK}<N>interface<N><N>uses<N>  Classes, SysUtils,<N>  LCLProc, LCLType, LResources, LCLIntf,<N>  //Messages,<N>  Forms, Controls, Graphics,<N>  Dialogs,<N>  //Windows,<N>  {$ifdef windows}<N>  win32proc,<N>  messages,<N>  {$endif}<N>  ExtCtrls, Contnrs,LMessages, Menus, strutils;<N><N>
unit cepluginsdk;        //more an api than sdk<N><N>{$MODE Delphi}<N><N>interface<N><N>uses windows, sysutils;<N><N>type<N>  TColor=dword;<N>  PColor=^TColor;<N><N>{$ifndef fpc}<N>//if old delphi then define the ptruint type<N>type ptruint=dword;<N>type pptruint=^ptruint'<N>{$endif}<N><N>
const PluginVersionSDK=6;<N><N>type TAutoAssemblerPhase=(aaInitialize=0, aaPhase1=1, aaPhase2=2, aaFinalize=3);<N>type TPluginType=(ptAddressList=0, ptMemoryView=1, ptOnDebugEvent=2, ptProcesswatcherEvent=3, ptFunctionPointerchange=4, ptMainMenu=5, ptDisassemblerContext=6, ptDisassemblerRenderLine=7, ptAutoAssembler=8);<N><N>
type TDWordArray = array[0..0] of DWord;<N>     PDWordArray = ^TDWordArray;<N><N>type<N>  TContinueOption = (co_run=0, co_stepinto=1, co_stepover=2, co_runtill=3);<N><N>type<N>  TBreakpointMethod = (bpmInt3, bpmDebugRegister);<N><N>type<N>  TBreakOption = (bo_Break = 0, bo_ChangeRegister = 1, bo_FindCode = 2, bo_FindWhatCodeAccesses = 3, bo_BreakAndTrace=4);<N>  TBreakPointAction = TBreakOption;<N><N>
unit Unit1;<N><N>{$MODE Delphi}<N><N>{<N>This is just an Version1 plugin example showing the old version plugins work too<N>}<N><N>interface<N><N>uses windows,sysutils,forms,StdCtrls,ExtCtrls;<N><N>type Tfunction1=record<N>  name: pchar;<N>  callbackroutine: pointer;<N>end;<N>type Tfunction3=record<N>  callbackroutine: pointer;<N>end;<N>type PFunction1=^TFunction1;<N>type PFunction2=^TFunction1;<N>type PFunction3=^TFunction3;<N>type PFunction4=^TFunction3;<N>type PFunction5=^TFunction3;<N><N>
type Tce_showmessage=procedure (s: pchar); stdcall;<N>type Tce_registerfunction=function (pluginid,functiontype:integer; init: pointer):integer; stdcall;<N>type Tce_unregisterfunction=function (pluginid,functionid: integer): boolean; stdcall;<N>type Tce_AutoAssembler=function (s: pchar):boolean; stdcall;<N>type Tce_GetMainWindowHandle=function:thandle; stdcall;<N><N>
type TReadProcessMemory=function (hProcess: THandle; const lpBaseAddress: Pointer; lpBuffer: Pointer;<N>  nSize: DWORD; var lpNumberOfBytesRead: DWORD): BOOL; stdcall;<N><N>type TWriteProcessMemory=function (hProcess: THandle; const lpBaseAddress: Pointer; lpBuffer: Pointer;<N>  nSize: DWORD; var lpNumberOfBytesWritten: DWORD): BOOL; stdcall;<N><N>
type TGetProcessNameFromPEProcess=function(peprocess:dword; buffer:pchar;buffersize:dword):integer; stdcall;<N>type TOpenProcess=function(dwDesiredAccess: DWORD; bInheritHandle: BOOL; dwProcessId: DWORD): THandle; stdcall;<N><N>type TPluginVersion =record<N>  version : integer; //write here the minimum version this dll is compatible with<N>  pluginname: pchar;  //make this point to a 0-terminated string (allocated memory, not stack)<N>end;<N><N>
type TExportedFunctions = record<N>  sizeofTExportedFunctions: integer;<N>  showmessage: Tce_showmessage;<N>  registerfunction: Tce_registerfunction;<N>  unregisterfunction: Tce_unregisterfunction;<N>  OpenedProcessID: ^dword;<N>  OpenedProcessHandle: ^thandle;<N><N>
  GetMainWindowHandle: pointer;<N>  AutoAssemble: pointer;<N>  assembler: pointer;<N>  disassembler: pointer;<N>  ChangeRegistersAtAddress: pointer;<N>  InjectDLL: pointer;<N>  freezemem: pointer;<N>  unfreezemem: pointer;<N>  fixmem: pointer;<N>  processlist: pointer;<N>  reloadsettings: pointer;<N>  getaddressfrompointer: pointer;<N><N>
unit exportimplementation;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses windows,sysutils,forms,ExtCtrls, cepluginsdk;<N><N><N>function GetVersion(var PluginVersion:TpluginVersion; sizeofpluginversion:integer):BOOL; stdcall;<N>function InitializePlugin(ExportedFunctions: PExportedFunctions; pluginid: dword):BOOL; stdcall;<N>function DisablePlugin:BOOL; stdcall;<N><N>
var versionname: pchar;<N>    ce_exported: TExportedFunctions;<N>    thispluginid: integer;<N>    <N>implementation<N><N>uses frmEventLogUnit;<N><N><N>function Menuitemclick(disassembleraddress: Pptruint; selected_disassembler_address: Pptruint; hexviewaddress: pptruint): BOOL; stdcall;<N>begin<N>  if frmEventLog=nil then<N>  begin<N>    TControlwindowThread.create(false);<N>  end<N>  else<N>  begin<N>    SetForegroundWindow(frmEventLog.Handle);<N>  end;<N><N>
<N><N>  result:=false;<N>end;<N><N>function MenuitemclickFromDisassembler(selectedaddress: pptruint): BOOL; stdcall;<N>begin<N>  result:=Menuitemclick(0, selectedaddress, selectedaddress);<N>end;<N><N><N>function GetVersion(var PluginVersion:TpluginVersion; sizeofpluginversion:integer):BOOL; stdcall;<N>var s: string;<N>begin<N>  result:=false;<N>  if sizeofpluginversion<>sizeof(TPluginVersion) then exit;<N><N>
<N>  s:='Basic debug event list for CE v6.0+';<N>  getmem(versionname,length(s)+1);<N>  copymemory(versionname,@s[1],length(s));<N>  versionname[length(s)]:=#0;<N>  <N>  PluginVersion.version:=PluginVersionSDK;<N>  PluginVersion.pluginname:=VersionName;<N><N>
<N>  result:=true;<N>end;<N><N>function InitializePlugin(ExportedFunctions: PExportedFunctions; pluginid: dword):BOOL; stdcall;<N>var init, init2: Tfunction1;<N>begin<N>  ce_exported:=ExportedFunctions^;<N>  thispluginid:=pluginid;<N><N><N>  init.callbackroutine:=@Menuitemclick;<N>  init.name:='View debug events';<N>  init.shortcut:='Shift+Ctrl+D';<N><N>
  init2.callbackroutine:=@MenuitemclickFromDisassembler;<N>  init2.name:='View debug events';<N>  init2.shortcut:=nil;<N>  ce_exported.registerfunction(thispluginid, ptMemoryView, @init);<N>  ce_exported.registerfunction(thispluginid, ptDisassemblerContext, @init2);<N><N>
unit pluginconfig;<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>interface<N><N>uses windows, sysutils, cepluginsdk, Contnrs, syncobjs, StrUtils,<N>  classes, lua, lauxlib, lualib;<N><N>function CEPlugin_GetVersion(var PluginVersion:TpluginVersion; sizeofpluginversion:integer):BOOL; stdcall;<N>function CEPlugin_InitializePlugin(ExportedFunctions: PExportedFunctions; pluginid: dword):BOOL; stdcall;<N>function CEPlugin_DisablePlugin:BOOL; stdcall;<N><N>
unit com;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  windows, Classes, SysUtils, syncobjs, math;<N><N><N>type<N>  TServer=class(TThread) //server pipe for dealing with initialization<N>  private<N>    pipe: THandle;<N>  protected<N>    procedure execute; override;<N>  public<N>  end;<N><N>
  TCEConnection=class<N>  private<N>    cs: TCriticalSection;<N>    pipe: THandle;<N>    connected: boolean;<N>  public<N>    function DoCommand(s: string): qword;<N>    procedure DoCommandMR(async: boolean; s: string; returncount: integer; results: PQword);<N>    constructor create;<N>    destructor destroy; override;<N>  end;<N><N>
unit main;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  windows, Classes, SysUtils, zstream;<N><N>procedure launch;<N><N>implementation<N><N>function DeleteFolder(dir: string) : boolean;<N>var<N>  DirInfo: TSearchRec;<N>  r : Integer;<N>begin<N>  ZeroMemory(@DirInfo,sizeof(TSearchRec));<N>  result := true;<N><N>
unit main;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>{$ifndef cpu32}<N>{$error The xmplayer can ONLY be compiled for 32-bit}<N>{$endif}<N><N>uses<N>  windows, Classes, SysUtils,dialogs, xmplayer_defines, uFMOD;<N><N>var pipe: THandle;<N><N>  currentsong: pointer;<N><N>
procedure StartListening;<N><N>implementation<N><N>procedure HandleSetVolumeCommand;<N>var volume: byte; //range from 0 to 25<N>  x: dword;<N>begin<N>  if readfile(pipe, volume, 4, x,nil) then<N>    uFMOD_SetVolume(volume);<N>end;<N><N>procedure HandleLoadFileCommand;<N>var size: integer;<N>  x: dword;<N>  extraparameter: byte;<N>begin<N>  if readfile(pipe, size, 4, x,nil) then //get the size of the xmfile in memory<N>  begin<N>    uFMOD_StopSong;<N><N>
    if currentsong<>nil then<N>      freemem(currentsong);<N><N>    getmem(currentsong, size);<N>    if readfile(pipe, currentsong^, size, x,nil) then    //load the file<N>    begin<N>      //load the extra parameter<N>      if readfile(pipe, extraparameter, 1,x, nil) then    //could be noloop and/or suspended (usually 0)<N>      begin<N>        uFMOD_PlaySong(currentsong, size, XM_MEMORY or extraparameter);<N>      end;<N>    end;<N>  end;<N>end;<N><N>
unit speedhackmain;<N><N>{$MODE Delphi}<N><N><N>interface<N>uses windows, classes, sysutils{$ifdef USECS},syncobjs{$endif};<N><N>procedure InitializeSpeedhack(speed: single); stdcall;<N><N>procedure InitDLL;<N><N>type TGetTickCount=function: DWORD; stdcall;<N>type TGetTickCount64=function: QWORD; stdcall;<N>type TQueryPerformanceCounter=function(var x: int64): BOOL; stdcall;<N><N>
function speedhackversion_GetTickCount: DWORD; stdcall;<N>function speedhackversion_GetTickCount64: QWORD; stdcall;<N>function speedhackversion_QueryPerformanceCounter(var x: int64): BOOL; stdcall;<N><N>type TSimpleLock=record<N>{$ifdef USECS}<N>  cs: TCriticalSection;<N>{$else}<N>  count: integer;<N>  owner: dword;<N>{$endif}<N>end;<N><N>
procedure lock(var l: TSimpleLock);<N>procedure unlock(var l: TSimpleLock);<N><N><N>//function GetTime:dword; stdcall;<N>//function NewQueryPerformanceCounter(var output: int64):BOOl; stdcall;<N>var CETick: dword;<N>    CETick64: int64;<N><N>    PerformanceFrequency: int64;<N>    PerformanceFrequencyMS: int64;<N>    acceleration: single;<N>    sleeptime: dword;<N>    slow: boolean;<N>    tickerstopped: boolean;<N>    speedhackenabled: boolean;<N><N>
<N>   { timeGetTimeInfo:TAPiInfo;<N>    getTickcountInfo: TAPIInfo;<N>    QueryPerformanceCounterInfo: TAPIInfo;  }<N>    winmmlib,kernel32lib: thandle;<N><N>    //5.5:<N>    confighaschanged: integer;<N>    speedmultiplier: single;<N>    realgettime: pointer;<N>    realGetTickCount: pointer;<N>    realGetTickCount64: pointer;<N>    realQueryPerformanceCounter: pointer;<N>    initialoffset: dword;<N>    initialtime: dword;<N>    initialoffset64: int64;<N>    initialtime64: int64;<N><N>
unit Unit1;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef windows}<N>  windows,<N>  {$endif}<N>  {$ifdef darwin}<N>  DateUtils,<N>  {$endif}<N>  LCLIntf, Classes, Messages, SysUtils, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ExtCtrls, LResources, dynlibs;<N><N>
unit Unit1;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  jwawindows, Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ExtCtrls, syncobjs, {psapi,} imagehlp;<N><N>type<N>  TChangeHealthLikeAMofo=class(tthread)<N>  public<N>    procedure execute; override;<N>  end;<N><N>
  TChangeHealthThread=class(tthread)<N>  public<N>    healthaddress: PDWORD;<N>    changehealthevent: TEvent;<N>    procedure updatehealth;<N>    procedure execute; override;<N>    constructor create(suspended: boolean);<N>    destructor destroy; override;<N>end;<N><N>
unit jniTObject;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, jni, unixporthelper;<N><N>procedure InitializeJniTObject(env: PJNIEnv);<N>function JObjectToTObject(PEnv: PJNIEnv; Obj: JObject): TObject;<N><N><N>implementation<N><N><N><N>
//experiment: make a memscan class in java and give it references to things like memscan_firstscan where the java class contains the memscan long<N>var field_object: JFieldID;<N><N>function JObjectToTObject(PEnv: PJNIEnv; Obj: JObject): TObject;<N>//pre: obj Must be a TObject descendant<N>begin<N>  result:=TObject(penv^.GetLongField(penv, obj, field_object));<N>end;<N><N>
procedure TObject_destroy(PEnv: PJNIEnv; Obj: JObject); cdecl;<N>var o: TObject;<N>begin<N>  //get the "object" field inside Obj, free what it represents, and then set it to 0<N>  log('TObject_destroy');<N><N>  o:=JObjectToTObject(PEnv, Obj);<N>  if o<>nil then<N>    tobject(o).free<N>  else<N>    log('Tried to call TObject_destroy on an already destroyed object');<N><N>
  log('TObject_destroy returned');<N>end;<N><N>const methodcount=1;<N>var jnimethods: array [0..methodcount-1] of JNINativeMethod =(<N>  (name: 'destroy'; signature: '()V'; fnPtr: @TObject_destroy)<N>  );<N><N>procedure InitializeJniTObject(env: PJNIEnv);<N>var c: jclass;<N>begin<N>  log('InitializeJniObject entry');<N>  c:=env^.FindClass(env, 'org/cheatengine/TObject');<N><N>
  log('Getting the required fields');<N>  field_object:=env^.GetFieldID(env, c, 'object','J');<N>  log('After getting the fields ('+IntToHex(ptruint(field_object),8)+')');<N><N><N>  env^.RegisterNatives(env, c, @jnimethods[0], methodcount);<N>  env^.DeleteLocalRef(env, c);<N>  log('InitializeJniObject exit');<N>end;<N><N>
unit jniByteInterpreter;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, jni;<N><N>procedure InitializeJniByteInterpreter(env: PJNIEnv);<N><N>implementation<N><N>uses byteinterpreter, commonTypeDefs, unixporthelper;<N><N>//function readAndParseAddress(address: ptrUint; variableType: TVariableType; customtype: TCustomType=nil; showashexadecimal: Boolean=false; showAsSigned: boolean=false; bytesize:integer=1): string;<N><N>
unit jniTMemScan;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, jni, unixporthelper, commonTypeDefs, math;<N><N>procedure InitializeJniTMemScan(env: PJNIEnv);<N><N>implementation<N><N>uses jniTObject, memscan, Globals;<N><N>var scanDoneMethodID: jmethodID;<N><N>
type TJniMemscan=class(TMemScan)<N>private<N>  procedure cleanup;<N>protected<N>  procedure ScanDone; override;<N>public<N>  javaowner: jobject;<N>  destructor destroy; override;<N>end;<N><N>procedure TJniMemscan.ScanDone;  //called by synchronize<N>begin<N>  log('TJniMemscan.ScanDone');<N><N>
  if javaowner<>nil then<N>  begin<N>    MainThreadEnv^.CallVoidMethod(MainThreadEnv, javaowner, scanDoneMethodID);<N>    log('Returned from OnScanDone');<N>  end;<N>end;<N><N>procedure TJniMemscan.cleanup;<N>begin<N>  log('TJniMemscan.destroy');<N>  MainThreadEnv^.DeleteGlobalRef(MainThreadEnv, javaowner);<N>end;<N><N>
destructor TJniMemscan.destroy;<N>begin<N>  log('TJniMemscan.destroy');<N>  if javaowner<>nil then<N>    TThread.Synchronize(nil, cleanup);<N><N>  inherited destroy;<N>end;<N><N>function TMemScan_Create(PEnv: PJNIEnv; Obj: JObject; owner: JObject): jlong; cdecl;<N>var ms: TJniMemscan;<N>begin<N>  log('Creating a memscan object');<N>  ms:=TJniMemscan.create(nil);<N><N>
  if penv^.IsSameObject(PEnv, obj, owner)<>0 then<N>    log('Weird');<N><N>  ms.javaowner:=penv^.NewGlobalRef(penv, owner);<N>  result:=ptruint(ms);<N>end;<N><N>procedure TMemScan_NewScan(PEnv: PJNIEnv; Obj: JObject); cdecl;<N>var ms: TMemScan;<N>begin<N>  log('new scan');<N>  ms:=TMemScan(JObjectToTObject(penv, obj));<N>  ms.newscan;<N>end;<N><N>
function TMemScan_GetProgress(PEnv: PJNIEnv; Obj: JObject):jint; cdecl;<N>var<N>  ms: TMemscan;<N>  total,current: qword;<N><N>  p: integer;<N><N>begin<N>  result:=0;<N>  p:=0;<N>  try<N>    ms:=TMemScan(JObjectToTObject(penv, obj));<N>    if (ms<>nil) then<N>    begin<N>      p:=1;<N>      ms.GetProgress(total, current);<N>      p:=2;<N><N>
      if total>0 then<N>      begin<N>        p:=3;<N>        result:=(current*100) div total;<N>        p:=4;<N>        //log(format('TMemScan_GetProgress returns %d',[result]));<N>      end<N>    end;<N><N>    p:=5;<N>  except<N>    on e:exception do<N>      log('Exception in TMemScan_GetProgress:'+e.message+'  (p='+inttostr(p));<N>  end;<N>end;<N><N>
procedure TMemScan_NextScan(PEnv: PJNIEnv; Obj: JObject; scanOption: jint; roundingtype: jint; sv1: jstring; sv2: jstring; hexadecimal: jboolean; binaryasstring: jboolean; unicode: jboolean; casesensitive: jboolean; percentage: jboolean; compareToSavedScan: jboolean; ssn: jstring); cdecl;<N>var<N>  ms: TJniMemscan;<N>  scanvalue1, scanvalue2, savedscanname: string;<N>begin<N>  log('Next scan');<N>  ms:=TJniMemscan(JObjectToTObject(penv, obj));<N><N>
  scanvalue1:=jniGetString(penv, sv1);<N>  scanvalue2:=jniGetString(penv, sv2);<N>  savedscanname:=jniGetString(penv, ssn);<N><N>  ms.NextScan(TScanOption(scanOption), TRoundingType(roundingtype), scanValue1, scanValue2, hexadecimal<>0, binaryAsString<>0, unicode<>0, casesensitive<>0, percentage<>0, comparetoSavedScan<>0, savedscanname);<N>end;<N><N>
unit jniAddressList;<N>{<N>AddressList replacement to be used by the java version. It only contains data and not responsible for gui updates<N>}<N><N>{$mode delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, jni;<N><N>procedure InitializeJniAddressList(env: PJNIEnv);<N><N>
implementation<N><N>uses MemoryRecordUnit, unixporthelper, commonTypeDefs, syncobjs, math;<N><N>type<N>  TAddressListFreezer=class(TThread)<N>  private<N>  public<N>    procedure execute; override;<N>  end;<N><N>var<N> addresslist: TList=nil; //list of MemoryRecord's<N> addresslistcs: TCriticalsection; //used to protect the list from the freezer thread. Changing memory records is not part of this.<N><N>
 AddressListEntry_class: jclass; //global ref<N> AddressListEntry_init_method: jmethodID;<N> description_fieldid: JFieldID;<N> vartype_fieldid: JFieldID;<N> addressString_fieldid: JFieldID;<N> address_fieldid: JFieldID;<N> offsets_fieldid: JFieldID;<N> index_fieldid: JFieldID;<N> active_fieldid: jfieldID;<N><N>
unit jniSymbolHandler;<N>{<N>Not an TObject implementation. This is accessible without creating an object<N>}<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, jni;<N><N>procedure InitializeJniSymbolHandler(env: PJNIEnv);<N><N>implementation<N><N>
uses symbolhandler;<N><N><N>function symbolhandler_getAddressFromName(PEnv: PJNIEnv; Obj: JObject; name: jstring): jlong; cdecl;<N>var _name: string;<N>begin<N>  result:=0;<N>  _name:=jniGetString(PEnv, name);<N>  try<N>    result:=symhandler.getAddressFromName(_name, false);<N>  except<N>  end;<N>end;<N><N>
function symbolhandler_getAddressFromName2(PEnv: PJNIEnv; Obj: JObject; name: jstring; waitforsymbols: jboolean): jlong; cdecl;<N>var _name: string;<N>begin<N>  result:=0;<N>  _name:=jniGetString(PEnv, name);<N>  try<N>    result:=symhandler.getAddressFromName(_name, waitforsymbols<>0);<N>  except<N>  end;<N>end;<N><N>
unit jnitfoundlist;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, jni;<N><N>procedure InitializeJniTFoundList(env: PJNIEnv);<N><N>implementation<N><N>uses unixporthelper, jniTObject, foundlisthelper, memscan, symbolhandler, math;<N><N>
<N>function TFoundList_initialize(PEnv: PJNIEnv; Obj: JObject): jlong; cdecl;<N>var fl: TFoundList;<N>begin<N>  result:=0;<N><N>  log('TFoundList_initialize');<N>  fl:=TFoundList(JObjectToTObject(penv, obj));<N><N>  if fl<>nil then<N>  begin<N>    try<N>      result:=fl.Initialize;<N>    except<N>      on e:exception do<N>      begin<N>        log(e.Message);<N>      end;<N>    end;<N>  end<N>  else<N>    log('fl is nil');<N><N>
end;<N><N>procedure TFoundList_deinitialize(PEnv: PJNIEnv; Obj: JObject); cdecl;<N>var fl: TFoundList;<N>begin<N>  fl:=TFoundList(JObjectToTObject(penv, obj));<N>  fl.Deinitialize;<N>end;<N><N><N>procedure TFoundList_refetchValueList(PEnv: PJNIEnv; Obj: JObject); cdecl;<N>var fl: TFoundList;<N>begin<N>  fl:=TFoundList(JObjectToTObject(penv, obj));<N>  fl.RefetchValueList;<N>end;<N><N>
<N><N>function TFoundList_getCount(PEnv: PJNIEnv; Obj: JObject): jlong; cdecl;<N>var<N>  extra: dword;<N>  value: string;<N>begin<N>  result:=TFoundList(JObjectToTObject(penv, obj)).count;<N>end;<N><N>function TFoundList_inModule(PEnv: PJNIEnv; Obj: JObject; index: jint): jboolean; cdecl;<N>begin<N>  if TFoundList(JObjectToTObject(penv, obj)).inModule(index) then<N>    result:=1<N>  else<N>    result:=0;<N>end;<N><N>
function TFoundList_getAddress(PEnv: PJNIEnv; Obj: JObject; index: jint): jlong; cdecl;<N>begin<N>  result:=TFoundList(JObjectToTObject(penv, obj)).GetAddress(index);<N>end;<N><N>function TFoundList_getAddressString(PEnv: PJNIEnv; Obj: JObject; index: jint): jstring; cdecl;<N>var<N>  fl: TFoundList;<N>  address: ptruint;<N>  r: string;<N>begin<N>  fl:=TFoundList(JObjectToTObject(penv, obj));<N>  address:=fl.GetAddress(index);<N><N>
  r:=symhandler.getNameFromAddress(address);<N>  result:=penv^.NewStringUTF(penv, pchar(r));<N>end;<N><N>function TFoundList_getVarType(PEnv: PJNIEnv; Obj: JObject): jint; cdecl;<N>begin<N>  result:=integer(TFoundList(JObjectToTObject(penv, obj)).vartype);<N>end;<N><N>
function TFoundList_getVarLength(PEnv: PJNIEnv; Obj: JObject): jint; cdecl;<N>begin<N>  result:=TFoundList(JObjectToTObject(penv, obj)).GetVarLength;<N>end;<N><N><N>function TFoundList_isUnicode(PEnv: PJNIEnv; Obj: JObject): jboolean; cdecl;<N>begin<N>  result:=ifthen(TFoundList(JObjectToTObject(penv, obj)).isUnicode,1,0);<N>end;<N><N>
<N>function TFoundList_getValue(PEnv: PJNIEnv; Obj: JObject; index: jint): jstring; cdecl;<N>var<N>  s: string;<N>  extra: dword;<N>  a: ptruint;<N>begin<N>  a:=TFoundList(JObjectToTObject(penv, obj)).GetAddress(index, extra, s);<N><N>  result:=penv^.NewStringUTF(penv, pchar(s));<N>end;<N><N>
function TFoundList_Create(PEnv: PJNIEnv; Obj: JObject; ownerms: JObject): jlong; cdecl;<N>var ms: TMemscan;<N>  fl: TFoundList;<N>begin<N>  log('Creating a foundlist object');<N>  ms:=TMemScan(JObjectToTObject(penv, ownerms));<N><N>  if (ms<>nil) then<N>    log('ms.ScanResultFolder='+ms.ScanresultFolder)<N>  else<N>    log('ms = nil');<N><N>
unit SimpleThread;<N>//future fpc 2.6+ has a horrible bug with TThread in a dll (sync problem I think)<N>//That's why this basic thread library is used instead<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  windows, Classes, SysUtils;<N><N><N>type TSimpleThread=class<N>  private<N>    threadid: dword;<N>    handle: thandle;<N>    fTerminated: boolean;<N><N>
    procedure suspend;<N>    procedure resume;<N>  protected<N>    procedure execute; virtual; abstract;<N>  public<N>    constructor create(suspended: boolean);<N>    function waitfor(timeout: dword=INFINITE): boolean;<N>    procedure terminate;<N>    property terminated: boolean read fTerminated;<N>end;<N><N>
<N>implementation<N><N><N>function threadstart(self: TSimpleThread): dword; stdcall;<N>begin<N>  //OutputDebugString('threadstart called');<N>  try<N>    self.execute;<N>    result:=0;<N>  except<N>    OutputDebugString('A thread has crashed');<N>    result:=1;<N>  end;<N>end;<N><N>
procedure TSimpleThread.suspend;<N>begin<N>  SuspendThread(handle);<N>end;<N><N>procedure TSimpleThread.resume;<N>begin<N>  ResumeThread(handle);<N>end;<N><N><N>function TSimpleThread.waitfor(timeout: DWORD=INFINITE): boolean;<N>begin<N>  if WaitForSingleObject(handle, timeout)=WAIT_TIMEOUT then<N>    result:=false<N>  else<N>    result:=true;<N>end;<N><N>
procedure TSimpleThread.terminate;<N>begin<N>  fterminated:=true;<N>end;<N><N>constructor TSimpleThread.create(suspended: boolean);<N>begin<N>  handle:=CreateThread(nil, 0, @threadstart, self, CREATE_SUSPENDED, threadid);<N><N>  if handle<>0 then<N>  begin<N>    if not suspended then<N>      resume;<N>  end<N>  else<N>    OutputDebugString('CreateThread failure');<N>end;<N><N>
unit init; <N><N>{$mode DELPHI}<N><N>interface<N><N>uses<N>  jwaWindows, Windows, Classes, SysUtils, VEHDebugSharedMem;<N><N><N>var<N>  ConfigName: array [0..255] of byte;<N>  fm: thandle;<N>  VEHSharedMem: PVEHDebugSharedMem;<N><N><N>procedure InitializeVEH;<N>procedure UnloadVEH;<N><N>
var AddVectoredExceptionHandler: function (FirstHandler: Cardinal; VectoredHandler: PVECTORED_EXCEPTION_HANDLER): pointer; stdcall;<N>    RemoveVectoredExceptionHandler: function(VectoredHandlerHandle: PVOID): ULONG; stdcall;<N>    CreateToolhelp32Snapshot: function(dwFlags, th32ProcessID: DWORD): HANDLE; stdcall;<N>    Thread32First: function(hSnapshot: HANDLE; var lpte: THREADENTRY32): BOOL; stdcall;<N>    Thread32Next: function(hSnapshot: HANDLE; var lpte: THREADENTRY32): BOOL; stdcall;<N><N>
var oldExceptionHandler: pointer=nil;<N>    vehdebugactive: boolean;<N><N>implementation<N><N>uses DebugHandler,threadpoll;<N><N><N>procedure EmulateInitializeEvents;<N>var ep: TEXCEPTIONPOINTERS;<N>    er: TEXCEPTIONRECORD;<N><N>    ths: THandle;<N>    lpte: TThreadEntry32;<N>    check: boolean;<N>    cpid: dword;<N>    isfirst: boolean;<N><N>
    bpc: TContext;<N>begin<N>  //OutputDebugString('EmulateInitializeEvents');<N>  cpid:=GetCurrentProcessId;<N>  ep.ContextRecord:=nil;<N>  ep.ExceptionRecord:=@er;<N>  er.NumberParameters:=0;<N><N>  HandlerCS.Enter;<N><N>  ths:=CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD,0);<N>  if ths<>INVALID_HANDLE_VALUE then<N>  begin<N>    zeromemory(@lpte, sizeof(lpte));<N>    lpte.dwSize:=sizeof(lpte);<N><N>
    isfirst:=true;<N>    check:=Thread32First(ths, lpte);<N>    while check do<N>    begin<N>      if lpte.th32OwnerProcessID=cpid then<N>      begin<N>        if isfirst then<N>        begin<N>          //create process<N>          er.ExceptionCode:=$ce000000; // $ce000000=create process (just made up)<N><N>
          InternalHandler(@ep,lpte.th32ThreadID); //I don't care what the return value is<N>          isfirst:=false;<N>        end else<N>        begin<N>          //create thread<N>          er.ExceptionCode:=$ce000001;<N>          InternalHandler(@ep,lpte.th32ThreadID);<N>        end;<N>      end;<N><N>
      check:=Thread32Next(ths, lpte);<N>    end;<N><N>    CloseHandle(ths);<N>  end;<N><N>  //if VEHSharedMem.ThreadWatchMethod=0 then<N>  //  ThreadPoller:=TThreadPoller.create(false);<N><N>  //tell ce that the debugger has been attached<N>//  ep.ContextRecord:=@VEHSharedMem.CurrentContext[0]; //just some memory properly aligned that can be used as scratchspace<N>//  GetThreadContext(GetCurrentThread, ep.ContextRecord);<N><N>
  er.ExceptionCode:=EXCEPTION_BREAKPOINT;<N>  ep.ContextRecord:=@bpc;<N>  zeromemory(@bpc,sizeof(bpc));<N>  bpc.{$ifdef cpu64}rip{$else}eip{$endif}:=$ffffffce;<N><N>  Handler(@ep); //don't really cause a breakpoint (while I could just do a int3 myself I think it's safer to just emulate the event)<N><N>
<N>  HandlerCS.Leave;<N>end;<N><N>procedure InitializeVEH;<N>var k: THandle;<N>    m: pchar;<N>begin<N>  k:=LoadLibrary('kernel32.dll');<N>  AddVectoredExceptionHandler:=GetProcAddress(k,'AddVectoredExceptionHandler');<N>  RemoveVectoredExceptionHandler:=GetProcAddress(k,'RemoveVectoredExceptionHandler');<N>  CreateToolhelp32Snapshot:=GetProcAddress(k,'CreateToolhelp32Snapshot');<N>  Thread32First:=GetProcAddress(k,'Thread32First');<N>  Thread32Next:=GetProcAddress(k,'Thread32Next');<N><N>
<N>  UnloadVEH;<N><N><N><N>  testandfixcs_start;<N><N>  OutputDebugString('VEHDebug init');<N><N><N>  {if ThreadPoller<>nil then<N>  begin<N>    ThreadPoller.Terminate;<N>    ThreadPoller.WaitFor;<N>    ThreadPoller.free;<N>    ThreadPoller:=nil;<N>  end;  }<N><N>
  testandfixcs_final;<N><N><N>  //get the shared memory object<N>  m:=pchar(@ConfigName[0]);<N>  outputDebugstring(pchar('ConfigName='+m));<N><N>//  fm:=CreateFileMapping(INVALID_HANDLE_VALUE,nil,PAGE_READWRITE,0,sizeof(TVEHDebugSharedMem),@ConfigName[0]);<N><N>
  if fm=0 then<N>    fm:=OpenFileMapping(FILE_MAP_ALL_ACCESS,false,m);<N><N>  OutputDebugString(pchar('fm='+inttohex(fm,8)));<N><N>  if (fm=0) then<N>  begin<N>    OutputDebugString(pchar('GetLastError='+inttostr(getlasterror)));<N>    exit;<N>  end;<N><N>
<N>  VEHSharedMem:=MapViewOfFile(fm,FILE_MAP_ALL_ACCESS,0,0,0);<N>  OutputDebugString(pchar('VEHSharedMem='+inttohex(ptruint(VEHSharedMem),8)));<N><N>  if VEHSharedMem=nil then<N>  begin<N>    OutputDebugString(pchar('GetLastError='+inttostr(getlasterror)));<N>    exit;<N>  end;<N><N>
  VEHSharedMem.VEHVersion:=$cece0000+VEHVERSION;<N><N><N>  OutputDebugString(pchar('HasDebugEvent='+inttohex(VEHSharedMem.HasDebugEvent,8)));<N>  OutputDebugString(pchar('HasHandledDebugEvent='+inttohex(VEHSharedMem.HasHandledDebugEvent,8)));<N><N>  OutputDebugString(pchar('@HasDebugEvent='+inttohex(ptruint(@VEHSharedMem.HasDebugEvent),8)));<N>  OutputDebugString(pchar('@HasHandledDebugEvent='+inttohex(ptruint(@VEHSharedMem.HasHandledDebugEvent),8)));<N><N>
<N>  if assigned(AddVectoredExceptionHandler) then<N>  begin<N>    //if oldExceptionHandler<>nil then<N>   //   outputdebugstring('Old exception handler should have been deleted. If not, this will crash');<N><N><N>    OutputDebugString('Testing if it handles normal debug events');<N>    OutputDebugString('1');<N>    OutputDebugString('2');<N>    OutputDebugString('3');<N><N>
    OutputDebugString('Calling EmulateInitializeEvents');<N><N>    handlerlock:=GetCurrentThreadId;<N>    HandlerCS.enter; //do not handle any external exception while the threadlist is sent to ce<N><N>    OutputDebugString('Registering exception handler');<N>    vehdebugactive:=true;<N>    if oldExceptionHandler=nil then<N>      oldExceptionHandler:=AddVectoredExceptionHandler(1,@Handler);<N><N>
    if oldExceptionHandler=nil then<N>    begin<N>      vehdebugactive:=false;<N>      HandlerCS.leave;<N>      exit;<N>    end;<N><N>    EmulateInitializeEvents;<N><N>    HandlerCS.leave;<N>    handlerlock:=0;<N><N><N>    OutputDebugString('returned from EmulateInitializeEvents');<N><N>
unit DebugHandler;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  windows, Classes, SysUtils, syncobjs, extcont;<N><N><N>function Handler(ExceptionInfo: PEXCEPTION_POINTERS): LONG; stdcall;<N>function InternalHandler(ExceptionInfo: PEXCEPTION_POINTERS; threadid: dword): LONG;<N>procedure testandfixcs_start;<N>procedure testandfixcs_final;<N><N>
var<N>  HandlerCS: TCRITICALSECTION;<N>  HandlerLock: dword;<N><N>implementation<N><N>uses init;<N><N>var<N>  emergency: THandle; //event that is set when<N><N>procedure testandfixcs_start;<N>begin<N>  if emergency=0 then<N>    OutputDebugString('emergency event not created');<N><N>
  setevent(emergency);<N>end;<N><N>procedure testandfixcs_final;<N>begin<N>  handlercs.enter;<N>  handlercs.leave;<N>  resetevent(emergency);<N>end;<N><N><N>function InternalHandler(ExceptionInfo: PEXCEPTION_POINTERS; threadid: dword): LONG;<N>var i: integer;<N>  eventhandles: array [0..1] of THandle;<N>  wr: dword;<N>  contextsize: integer=0;<N>  heartbeat: DWORD;<N>begin<N>  result:=EXCEPTION_CONTINUE_SEARCH;<N><N>
  if not vehdebugactive then exit(EXCEPTION_CONTINUE_SEARCH);<N><N><N>  while (handlerlock<>0) and (handlerlock<>GetCurrentThreadId) do sleep(50);<N><N>  HandlerCS.enter; //block any other thread that has an single step exception until this is handled<N><N>
unit VEHDebugSharedMem;<N>{<N>This unit it used by both CE and the VEHDebug project<N>}<N><N>{$mode delphi}<N><N>interface<N><N>{$IFDEF windows}<N>uses<N>  windows, Classes, SysUtils;<N><N><N>const<N>  TPOLL_TCREATEREALCONTEXT=$00000001;<N>  VEHVERSION=4;<N><N>
unit extcont;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, jwawindows, windows;<N><N>  //credits to jedi code library for filling in the "extended registers"<N>const CONTEXT_EXTENDED=$20;<N><N>type<N>  TJclMMContentType = (mt8Bytes, mt4Words, mt2DWords, mt1QWord, mt2Singles, mt1Double);<N><N>
  TJclMMRegister = packed record<N>    case TJclMMContentType of<N>      mt8Bytes:<N>        (Bytes: array [0..7] of Byte;);<N>      mt4Words:<N>        (Words: array [0..3] of Word;);<N>      mt2DWords:<N>        (DWords: array [0..1] of Cardinal;);<N>      mt1QWord:<N>        (QWords: Int64;);<N>      mt2Singles:<N>        (Singles: array [0..1] of Single;);<N>      mt1Double:<N>        (Doubles: double;);<N>  end;<N><N>
  TJclFPUContentType = (ftExtended, ftMM);<N><N>  TJclFPUData = packed record<N>    case TJclFPUContentType of<N>      ftExtended:<N>        (FloatValue: Extended;);<N>      ftMM:<N>        (MMRegister: TJclMMRegister;<N>         Reserved: Word;);<N>  end;<N><N>
  TJclFPURegister = packed record<N>    Data: TJclFPUData;<N>    Reserved: array [0..5] of Byte;<N>  end;<N><N>  TJclFPURegisters = array [0..7] of TJclFPURegister;<N><N>  TJclXMMContentType = (xt16Bytes, xt8Words, xt4DWords, xt2QWords, xt4Singles, xt2Doubles);<N><N>
  TJclXMMRegister = packed record<N>    case TJclXMMContentType of<N>      xt16Bytes:<N>        (Bytes: array [0..15] of Byte;);<N>      xt8Words:<N>        (Words: array [0..7] of Word;);<N>      xt4DWords:<N>        (DWords: array [0..3] of Cardinal;);<N>      xt2QWords:<N>        (QWords: array [0..1] of Int64;);<N>      xt4Singles:<N>        (Singles: array [0..3] of Single;);<N>      xt2Doubles:<N>        (Doubles: array [0..1] of Double;);<N>  end;<N><N>
  TJclProcessorSize = (ps32Bits, ps64Bits);<N><N>  TJclXMMRegisters = packed record<N>    case TJclProcessorSize of<N>      ps32Bits:<N>        (LegacyXMM: array [0..7] of TJclXMMRegister;<N>         LegacyReserved: array [0..127] of Byte;);<N>      ps64Bits:<N>        (LongXMM: array [0..15] of TJclXMMRegister;);<N>  end;<N><N>
unit Unit10;<N>{Shared code tutorial}<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef windows}windows,{$endif} LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, Unit8, StdCtrls, Buttons, LResources, ExtCtrls, math, betterControls;<N><N>
type<N>  TPlayer=class<N>  private<N>  public<N>    health: Single;<N>    boguscrap: dword;<N>    unrelatedrandomlychangingthing: integer;<N>    team: integer;<N>    name: string[63];<N>    teammate: TPlayer;<N>    healthlabel: TLabel;<N>    wasteofspace: array [0..99123] of byte;<N>    procedure Hit(damage: integer);<N>  end;<N><N>
unit cetranslator;<N><N>{ Copyright (C) 2004-2010 V.I.Volchenko and Lazarus Developers Team<N><N>  This library is free software; you can redistribute it and/or modify it<N>  under the terms of the GNU Library General Public License as published by<N>  the Free Software Foundation; either version 2 of the License, or (at your<N>  option) any later version.<N><N>
  This program is distributed in the hope that it will be useful, but WITHOUT<N>  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or<N>  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Library General Public License<N>  for more details.<N><N>
unit Unit1;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  {$ifdef windows}windows, {$endif}LCLIntf, Messages, SysUtils, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ExtCtrls, LResources{,tlhelp32, XPMan}, betterControls;<N><N>type<N><N>  { TForm1 }<N><N>
unit guitextobject;<N><N>//renders a font.<N>//right now it just renders a single texture with the required text and updates it as needed<N>//todo: build a fontmap<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, graphics, guiobject, gamepanel, gl,glext,math, controls;<N><N>
type<N>  TTextAlign=(taLeft, taCenter, taRight);<N><N>  TGUITextObject=class(TGuiObject)<N>  private<N>    ftext: string; //just as an indication if the texture needs to be updated<N>    fbackgroundcolor: tcolor; //for anti alliasing<N>    fforegroundcolor: tcolor;<N>    ftexture: integer;<N><N>
unit Unit1;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, ExtCtrls,<N>  GamePanel, renderobject,glext, GL,glu, player,scoreboard, target, bullet, guitextobject,<N>  staticguiobject, gamebase, levelselect, gametutorial1, gametutorial2, gametutorial3;<N><N>
type<N><N><N><N>  { TForm1 }<N>  TForm1 = class(TForm)<N>    procedure FormCreate(Sender: TObject);<N>    procedure FormShow(Sender: TObject);<N>  private<N>    { private declarations }<N>    p: TGamePanel;<N>    currentGame: TGameBase;<N><N>    lasttick: qword;<N>    codebase: ptruint;<N>    codesize: ptruint;<N><N>
<N>    integrityCheckThread: TThread;<N>    procedure integritycheckcheck;<N><N>    procedure startgame2(sender: TObject);<N>    procedure startgame3(sender: TObject);<N>    procedure finishedTutorial(sender: TObject);<N>    procedure GameSelect(sender: TObject);<N><N>
<N>    procedure renderGame(sender: TObject);<N>    procedure gametick(sender: TObject);<N>    function KeyHandler(GamePanel: TObject; keventtype: integer; Key: Word; Shift: TShiftState):boolean;<N>  public<N>    { public declarations }<N>  end;<N><N>var<N>  Form1: TForm1;<N><N>
implementation<N><N>{$R *.lfm}<N><N>{ TForm1 }<N><N>uses registry, md5, frmHelpUnit;<N><N>type<N>  TIntegrityCheckThread=class(tthread)<N>  private<N>    codebase: ptruint;<N>    codesize: integer;<N>    integrityCheckValue: dword;<N>    function check1: dword;<N>    function check2: dword;<N>    function check3: dword;<N>    procedure valid;<N>    procedure invalid;<N>  public<N><N>
    heartbeat: qword;<N>    lastcheckwasvalid: boolean;<N>    procedure execute; override;<N>    procedure docheck;<N>  end;<N><N><N>function peinfo_getcodesize(header: pointer; headersize: integer=0): dword;<N>var<N>    ImageNTHeader: PImageNtHeaders;<N>begin<N>  result:=0;<N><N>
  if (headersize=0) or (PImageDosHeader(header)^._lfanew<=headersize-sizeof(TImageNtHeaders)) then<N>  begin<N>    ImageNTHeader:=PImageNtHeaders(ptrUint(header)+PImageDosHeader(header)^._lfanew);<N>    result:=ImageNTHeader^.OptionalHeader.SizeOfCode;<N>  end;<N>end;<N><N>
function peinfo_getdatabase(header: pointer; headersize: integer=0): ptrUint;<N>var<N>    ImageNTHeader: PImageNtHeaders;<N>begin<N>  result:=0;<N>  if (headersize=0) or (PImageDosHeader(header)^._lfanew<=headersize-sizeof(TImageNtHeaders)) then<N>  begin<N>    ImageNTHeader:=PImageNtHeaders(ptrUint(header)+PImageDosHeader(header)^._lfanew);<N>    result:=ImageNTHeader^.OptionalHeader.BaseOfData;<N>  end;<N>end;<N><N>
function peinfo_getcodebase(header: pointer; headersize: integer=0): ptrUint;<N>var<N>    ImageNTHeader: PImageNtHeaders;<N>begin<N>  result:=0;<N>  if (headersize=0) or (PImageDosHeader(header)^._lfanew<=headersize-sizeof(TImageNtHeaders)) then<N>  begin<N>    ImageNTHeader:=PImageNtHeaders(ptrUint(header)+PImageDosHeader(header)^._lfanew);<N>    result:=ImageNTHeader^.OptionalHeader.BaseOfCode;<N>  end;<N>end;<N><N>
function peinfo_getEntryPoint(header: pointer; headersize: integer=0): ptrUint;<N>var<N>    ImageNTHeader: PImageNtHeaders;<N>begin<N>  result:=0;<N>  if (headersize=0) or (PImageDosHeader(header)^._lfanew<=headersize-sizeof(TImageNtHeaders)) then<N>  begin<N>    ImageNTHeader:=PImageNtHeaders(ptrUint(header)+PImageDosHeader(header)^._lfanew);<N>    result:=ImageNTHeader^.OptionalHeader.AddressOfEntryPoint;<N>  end;<N><N>
end;<N><N>function peinfo_getheadersize(header: pointer): dword;<N>var<N>    ImageNTHeader: PImageNtHeaders;<N>begin<N>  result:=0;<N>  if PImageDosHeader(header)^.e_magic<>IMAGE_DOS_SIGNATURE then exit;<N><N>  ImageNTHeader:=PImageNtHeaders(ptrUint(header)+PImageDosHeader(header)^._lfanew);<N>  if ptrUint(ImageNTHeader)-ptrUint(header)>$1000 then exit;<N>  if ImageNTHeader^.Signature<>IMAGE_NT_SIGNATURE then exit;<N><N>
  result:=ImageNTHeader^.OptionalHeader.SizeOfHeaders;<N>end;<N><N>function peinfo_getimagesize(header: pointer): dword;<N>var<N>    ImageNTHeader: PImageNtHeaders;<N>begin<N>  ImageNTHeader:=PImageNtHeaders(ptrUint(header)+PImageDosHeader(header)^._lfanew);<N>  result:=ImageNTHeader^.OptionalHeader.SizeOfImage;<N>end;<N><N>
<N>function TIntegrityCheckThread.check1:dword;<N>var<N>  mem: pword;<N>  r: dword;<N>  i: integer;<N>begin<N>  mem:=pword(codebase);<N>  r:=$deadbeef;<N>  for i:=0 to (codesize div 2)-1 do<N>  begin<N>    r:=r xor mem[i];<N>    inc(r,12);<N>  end;<N><N>  result:=r;<N>end;<N><N>
function TIntegrityCheckThread.check2:dword;<N>var<N>  mem: pword;<N>  r: dword;<N>  i: integer;<N>begin<N>  mem:=pword(codebase);<N>  r:=$feeddead;<N>  for i:=0 to (codesize div 2)-1 do<N>  begin<N>    r:=r + mem[i];<N>  end;<N><N>  result:=r;<N>end;<N><N>
function TIntegrityCheckThread.check3:dword;<N>var<N>  mem: pword;<N>  r: dword;<N>  i: integer;<N>begin<N>  mem:=pword(codebase);<N>  r:=$cececece;<N>  for i:=0 to (codesize div 2)-1 do<N>  begin<N>    r:=r xor mem[i];<N>    dec(r,77);<N>  end;<N><N>  result:=r;<N>end;<N><N>
procedure TIntegrityCheckThread.valid;<N>var<N>  i: integer;<N>  s: string;<N>begin<N>  s:=form1.caption;<N>  i:=Pos(' (Integrity check error)',s);<N>  if i>0 then //valid now<N>  begin<N>    form1.caption:=copy(form1.caption,1,i);<N>  end;<N>end;<N><N>procedure TIntegrityCheckThread.invalid;<N>var s: string;<N>begin<N>  s:=form1.caption;<N>  if Pos(' (Integrity check error)',s)=0 then<N>    form1.caption:=form1.caption+' (Integrity check error)';<N>end;<N><N>
procedure TIntegrityCheckThread.docheck;<N>var<N>  c1,c2,c3: dword;<N>  cf: dword;<N>begin<N>  c1:=check1;<N>  c2:=check2;<N>  c3:=check3;<N><N>  cf:=(c1 xor c2)+c3;<N>  if cf=0 then inc(cf);<N><N>  if integrityCheckValue=0 then<N>    integrityCheckValue:=cf<N>  else<N>  begin<N>    lastcheckwasvalid:=cf=integrityCheckValue;<N>    if lastcheckwasvalid then<N>      synchronize(@Valid)<N>    else<N>      synchronize(@Invalid);<N>  end;<N>end;<N><N>
procedure TIntegrityCheckThread.execute;<N>var<N><N>  m: pointer;<N>begin<N>  m:=pointer(GetModuleHandle(nil));<N><N>  codebase:=ptruint(m)+peinfo_getcodebase(m);<N>  codesize:=peinfo_getcodesize(m);<N><N>  while not terminated do<N>  begin<N>    heartbeat:=GetTickCount64;<N>    docheck;<N><N>
<N>    sleep(100);<N>  end;<N>end;<N><N>procedure TForm1.gametick(sender:TObject);<N>var<N>  currenttime: qword;<N>  diff: qword;<N>begin<N>  currenttime:=GetTickCount64;<N>  diff:=currenttime-lasttick;<N>  lasttick:=currenttime;<N><N>  if currentgame<>nil then<N>    currentgame.gametick(currenttime, diff);<N>end;<N><N>
procedure TForm1.renderGame(sender: TObject);<N>begin<N>  if currentgame<>nil then<N>    currentgame.render;<N>end;<N><N>function TForm1.KeyHandler(GamePanel: TObject; keventtype: integer; Key: Word; Shift: TShiftState):boolean;<N>begin<N>  if currentgame<>nil then<N>    exit(currentgame.keyhandler(GamePanel, keventtype, key, shift))<N>  else<N>    result:=false;<N>end;<N><N>
procedure TForm1.IntegrityCheckCheck;<N>var<N>  itt: TIntegrityCheckThread;<N>  hb: qword;<N>  startwait: qword;<N>begin<N>  itt:=TIntegrityCheckThread(integrityCheckThread);<N>  itt.docheck;<N><N>  hb:=itt.heartbeat;<N>  if ((gettickcount64-hb)>1000) then<N>  begin<N>    startwait:=gettickcount64;<N>    while (gettickcount64-startwait)<5000 do //wait 5 seconds max<N>    begin<N>      if itt.heartbeat>hb then exit;<N>      CheckSynchronize(100);<N>    end;<N><N>
    itt.Terminate;<N>    itt.WaitFor;<N>    itt.lastcheckwasvalid:=false;<N>    form1.caption:=form1.caption+' (total integrity check failure)';<N>  end;<N><N>end;<N><N><N>procedure TForm1.finishedTutorial(sender: TObject);<N>var<N>  s,s2: string;<N>  mem: pword;<N>  r: dword;<N>  i: integer;<N>begin<N>  if usedcheats then<N>  begin<N>    s:='winned';<N>    s2:='. yay';<N>  end<N>  else<N>  begin<N>    s:='beaten';<N><N>
    IntegrityCheckCheck;<N><N>    if TIntegrityCheckThread(integrityCheckThread).lastcheckwasvalid then<N>      s2:=#13#10', and you have beaten the integrity check!'#13#10#13#10'Really well done!'<N>    else<N>      s2:='. Well done';<N>  end;<N><N><N>  showmessage(format('You have %s all 3 ''games'' %s!',[s,s2]));<N>  ExitProcess(0);<N>end;<N><N>
procedure TForm1.startgame3(sender: TObject);<N>begin<N>  IntegrityCheckCheck;<N><N>  if currentgame<>nil then<N>    freeandnil(currentGame);<N><N>  caption:='Step 3';<N>  currentgame:=TGame3.create(p);<N>  currentgame.OnWin:=@finishedTutorial;    //todo someday: rpg kinda game, followed by an online 'game' (chatgame more likely)<N><N>
  frmHelp.Attach(self,'G3');<N>end;<N><N><N>procedure TForm1.startgame2(sender: TObject);<N><N>begin<N>  IntegrityCheckCheck;<N><N>  if currentgame<>nil then<N>    freeandnil(currentGame);<N><N>  caption:='Step 2';<N>  currentgame:=TGame2.create(p);<N>  currentgame.OnWin:=@startgame3;<N>  frmHelp.Attach(self,'G2');<N>end;<N><N>
procedure TForm1.GameSelect(sender: TObject);<N>var gs: TLevelSelect;<N>begin<N>  IntegrityCheckCheck;<N><N>  gs:=TLevelSelect(currentgame);<N>  case gs.level of<N>    1:<N>    begin<N>      if currentgame<>nil then<N>        freeandnil(currentGame);<N><N>
      Caption:='Step 1';<N>      currentGame:=TGame1.create(p);<N>      currentGame.OnWin:=@startGame2;<N>    end;<N>    2: startgame2(sender);<N>    3: startgame3(sender);<N>  end;<N>end;<N><N><N><N>procedure TForm1.FormCreate(Sender: TObject);<N>begin<N>  integrityCheckThread:=TIntegrityCheckThread.create(false);<N>end;<N><N>
procedure TForm1.FormShow(Sender: TObject);<N>var reg: Tregistry;<N>begin<N>  p:=TGamePanel.Create(Self);<N>  p.OnGameRender:=@renderGame;<N>  p.OnGameTick:=@gametick;<N>  p.Align:=alClient;<N>  p.parent:=self;<N><N>  // startgame3(Self);<N>  // startgame2(self);<N><N>
  reg:=tregistry.create;<N>  if reg.OpenKey('\Software\Cheat Engine\GTutorial', false) then<N>  begin<N>    //if reg.ValueExists('This does not count as a solution for tutorial 1') then<N>    begin<N>      //level select screen<N>      Caption:='Select Level';<N>      currentGame:=TLevelSelect.create(p);<N>      currentGame.OnWin:=@GameSelect;<N>    end;<N>  end;<N><N>
  //still here, so game1:<N>  if currentgame=nil then<N>  begin<N>    IntegrityCheckCheck;<N><N>    currentGame:=TGame1.create(p);<N>    currentGame.OnWin:=@startGame2;<N>    frmHelp.Attach(self,'G1');<N>  end;<N><N>  p.AddKeyEventHandler(@keyhandler);<N>  lasttick:=GetTickCount64;<N>end;<N><N>
unit guiobject;<N><N>//not part of the game mechanics, but handles click events and wraps basic gui stuff like text<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, controls, renderobject, gamepanel, types;<N><N>type<N>  TNotifyEventF=function(sender: TObject): boolean of object;<N>  TGUIObject=class(TRenderObject)  //abstract<N>  private<N>    fOwner: TGamePanel;<N><N>
  protected<N>    fOnClick: TNotifyEventF;<N>    function getWidth:single; override;<N>    function getHeight:single; override;<N>    function getTopLeftCorner: tpointf;<N>    function mhandler(sender: TObject; meventtype: integer; Button: TMouseButton; Shift: TShiftState; mX, mY: Integer): boolean; virtual;<N>  public<N>    constructor create(owner: TGamePanel=nil; zpos: integer=-1);<N>    destructor destroy; override;<N>    property OnClick: TNotifyEventF read fOnClick write fOnClick;<N>  end;<N><N>
implementation<N><N>function TGUIObject.getTopLeftCorner: TPointF;<N>begin<N>  //only functions when no rotation is applied<N>  result.x:=x-(width/2)*(rotationpoint.x+1);<N>  result.y:=y-(height/2)*(rotationpoint.y+1);<N>end;<N><N>function TGUIObject.getWidth:single;<N>begin<N>  result:=2;<N>end;<N><N>
function TGUIObject.getHeight:single;<N>begin<N>  result:=2;<N>end;<N><N>function TGUIObject.mhandler(sender: TObject; meventtype: integer; Button: TMouseButton; Shift: TShiftState; mX, mY: Integer): boolean;<N>var gamepos, objectpos: tpointf;<N>begin<N>  if meventtype=0 then<N>  begin<N>    gamepos:=TGamePanel(sender).PixelPosToGamePos(mx,my);<N>    objectpos:=getTopLeftCorner;<N><N>
    if (gamepos.x>=objectpos.x) and (gamepos.x<objectpos.x+width) and (gamepos.y>=objectpos.y) and (gamepos.y<objectpos.y+height) then<N>    begin<N>      if assigned(fOnClick) then<N>        exit(fOnClick(self));<N>    end;<N>  end;<N><N>  result:=false;<N>end;<N><N>
constructor TGUIObject.create(owner: TGamePanel; zpos: integer);<N>begin<N>  fowner:=owner;<N>  if owner<>nil then<N>    owner.AddMouseEventHandler(@mhandler, zpos);<N><N>  inherited create;<N>end;<N><N>destructor TGUIObject.destroy;<N>begin<N>  if fowner<>nil then<N>    fowner.RemoveMouseEventHandler(@mhandler);<N><N>
unit GameTutorial2;<N><N>{$mode objfpc}{$H+}<N><N>//step2:<N>//2 targets, that shoot at the player as well.<N>//targets and player share the same health decreasing code<N><N>interface<N><N>uses<N>  windows, Classes, SysUtils, gamepanel, guitextobject, staticguiobject, gamebase,<N>  target, bullet,Dialogs, Graphics, playerwithhealth, math;<N><N>
type<N>  TGame2=class(TGameBase)<N>  private<N>    fpanel: Tgamepanel;<N>    player: TPlayerWithHealth;<N>    target1,target2: TPlayerWithHealth;<N><N>    bullets: array of Tbullet; //max 5 bullets on the screen at once<N><N>    shotsfired: integer;<N><N>    lastshot: qword;<N>    rotatedirection: single;<N><N>
    usemegabombs: boolean;<N><N>    speedup: boolean;<N>    speed: single;<N><N>    status: TGUITextObject;<N><N>    info: TGUITextObject;<N>    infobutton: TStaticGUIObject;<N><N>    pausescreen: TGUITextObject;<N>    pausebutton: TStaticGUIObject;<N><N>    enemytext: TGUITextObject;<N>    enemytextStartTime: qword;<N><N>
unit animationobject;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, renderobject;<N><N>type<N>  TAnimationObject=class(TRenderobject)<N>  {<N>  Render object just for drawing animations<N>  }<N>  protected<N>    currentTexture: integer;<N>    lastTextureTime: qword;<N>    textures: array of integer;<N><N>
    function getWidth:single; override;<N>    function getHeight:single; override;<N>    function getTexture: integer; override;<N>  public<N>    speed: integer; //ms per frame<N>  end;<N><N>implementation<N><N>function TAnimationObject.getWidth:single;<N>begin<N>  result:=2;<N>end;<N><N>
function TAnimationObject.getHeight:single;<N>begin<N>  result:=2;<N>end;<N><N>function TAnimationObject.getTexture: integer;<N>var t: qword;<N>begin<N>  t:=GetTickCount64;<N>  if t>(lasttexturetime+speed) then<N>  begin<N>    currentTexture:=(texture+1) mod length(textures);<N>    lastTextureTime:=t;<N>  end;<N><N>
unit movingparticle;<N><N>//a particle, but then with a speed and direction. Every render it will update it's position<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, gl,glu,glext, particle, math;<N><N>type TMovingParticle=class(TParticle)<N>  public<N>    starttime: qword;<N>    speed: single;<N>    direction: single;<N>    initialx: single;<N>    initialy: single;<N>    procedure renderRelative; override;<N>end;<N><N>
implementation<N><N>procedure TMovingParticle.renderRelative;<N>//update x and y based on the time, speed and direction<N><N>var<N>  distance: single;<N>  d: single;<N>begin<N>  glRotatef(rotation,0,0,0.5);<N><N>  distance:=speed*(gettickcount64-starttime);<N><N>
unit GameTutorial3;<N><N>{$mode objfpc}{$H+}<N><N>//step3:<N>//a platformer where everything is 1 hit kill<N><N>//Warning: While it's tempting to read through the code to find out how to beat this, try it first without<N><N><N><N>interface<N><N>uses<N>  windows, Classes, SysUtils, gamepanel, guitextobject, staticguiobject, gamebase,<N>  target, bullet,Dialogs, Graphics, playerwithhealth, math, gl, glext, glu,<N>  gamecube, platformenemy, platformplayer;<N><N>
type<N><N>  Tdoor=class(TObject)<N>  private<N>    w: single;<N>    h: single;<N><N>    fx,fy: single;<N>    flocked: boolean;<N>    door: TStaticGUIObject;<N>    lock: TStaticGUIObject;<N>  public<N>    function isinside(_x,_y: single): boolean;<N>    procedure render;<N>    constructor create;<N>    destructor destroy; override;<N>    property locked: boolean read flocked write flocked;<N>    property x: single read fx write fx;<N>    property y: single read fy write fy;<N>  end;<N><N>
<N><N>  TGame3=class(TGameBase)<N>  private<N>    fpanel: Tgamepanel;<N>    pplayer: TPlatformPlayer;<N>    platforms: array of TgameCube;<N>    enemies: array of TPlatformEnemy; //change from gamecube to gameobject after testing<N><N><N>    info: TGUITextObject;<N>    infobutton: TStaticGUIObject;<N><N>
    pausescreen: TGUITextObject;<N>    pausebutton: TStaticGUIObject;<N><N>    door: Tdoor;<N><N>    gametime: qword;<N><N>    walkdirection: single;<N><N>    jumpkeydown: boolean;<N>    yvelocity: single;<N>    falling: boolean;<N><N>    fuckplayer: boolean; //when true the platformenemies will move to form a barrier around the door<N>    fuckplayertime: qword;<N><N>
unit scoreboard;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, guiobject, gamepanel, controls, graphics, gl,glu,GLext,<N>  guitextobject, types, dialogs, globals;<N><N>type<N>  TScoreBoard=class(TGuiObject)<N>  private<N>    instances: integer; static;<N>    ftexture: integer; static;<N><N>
unit globals;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>var<N>  assetsfolder: string='.\badassets\';<N><N><N>implementation<N><N>end.<N><N>
unit GameTutorial1;<N><N><N>//tutorial step1: player and target<N>//the player has an ammo capacity of  5 bullets, and the target heals itself each time the player reloads<N><N>//the task: destroy the target.  (e.g add more bullets, make the bullets do more damage, change to code to instant kill, jump to the success code, ...)<N><N>
<N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  windows, Classes, SysUtils, gamepanel, guitextobject, staticguiobject, gamebase, player,<N>  target, bullet,Dialogs, Graphics;<N><N>type<N>  TGame1=class(TGameBase)<N>  private<N>    fpanel: Tgamepanel;<N>    player: TPlayer;<N><N>
    target: Ttarget;<N>    bullets: array[0..4] of Tbullet; //max 5 bullets on the screen at once<N><N>    reloading: qword;<N>    reloadingtargetstarthp: integer;<N>    shotsfired: integer;<N><N>    lastshot: qword;<N>    rotatedirection: single;<N><N>    status: TGUITextObject;<N><N>
    info: TGUITextObject;<N>    infobutton: TStaticGUIObject;<N><N><N><N>    function infoPopup(sender: tobject): boolean;<N>    function HideInfo(sender: tobject): boolean;<N>  public<N>    procedure gametick(currentTime: qword; diff: integer); override;<N>    procedure render; override;<N>    function KeyHandler(TGamePanel: TObject; keventtype: integer; Key: Word; Shift: TShiftState):boolean; override;<N>    constructor create(p: TGamePanel);<N>    destructor destroy; override;<N>  end;<N><N>
implementation<N><N>uses registry;<N><N>function TGame1.KeyHandler(TGamePanel: TObject; keventtype: integer; Key: Word; Shift: TShiftState):boolean;<N>var<N>  x: boolean;<N>  i: integer;<N>  ct: qword;<N><N><N>begin<N>  if iskeydown(VK_W) and iskeydown(VK_I) and iskeydown(VK_N) then<N>  begin<N>    usedcheats:=true;<N>    if target<>nil then<N>      target.explode; //blow up target<N><N>
unit gameobject;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, renderobject, math, movingparticle;<N><N>//abstract class<N><N>type<N>  TCollisionType=(ctCircles, ctUnrotatedRectangles);<N>  TGameObject=class(TRenderobject)<N>  {<N>  Render object with game mechanics like hitboxes and<N>  }<N>  private<N>    explodetime: qword;<N>    fIsExploding: boolean;<N>    fRange: single;<N>    fRenderCollision: boolean;<N>    explosion: array of TMovingParticle;<N><N>
<N>    function getRange: single;<N>  protected<N>    CollisionType: TCollisionType;<N>  public<N>    procedure explode; virtual; //splits up the objects into a million objects<N>    function exploding: boolean;<N>    function blownup: boolean; //returns true if it has gone far enough<N><N>
    function checkCollision(other: TGameObject):boolean; virtual;<N><N>    property range: single read getRange;<N>    property renderCollision: boolean read fRenderCollision write fRenderCollision;<N><N><N><N>    destructor destroy; override;<N>  end;<N><N>
implementation<N>  {<N>procedure TGameObject.renderRelative;<N>begin<N>  inherited renderRelative;<N><N>  if fRenderCollision then<N>  begin<N>    //todo: render collision box/sphere<N>  end;<N>end; }<N><N><N>function TGameObject.blownup: boolean; //returns true if it has gone far enough<N>begin<N>  if fIsExploding then<N>    result:=gettickcount64>=explodetime+2000<N>  else<N>    result:=false;<N>end;<N><N>
function TGameobject.exploding: boolean;<N>begin<N>  result:=fIsExploding;<N>end;<N><N>procedure TGameObject.explode;<N>var<N>  t: integer;<N>  i: integer;<N>  f: single;<N><N>begin<N>  //boom<N>  //create 64 children<N><N>  if fIsExploding then exit;<N><N>
unit renderobject;<N><N>{$mode objfpc}{$H+}<N>{$modeswitch advancedrecords}<N><N>interface<N><N>uses<N>  Classes, SysUtils,GL, GLext, glu, types;<N><N>type<N>  TRenderObject=class(TObject)<N>  private<N>    children: array of TRenderObject;<N>    fTextureCoords: record<N>      x: single;<N>      y: single;<N>      x2: single;<N>      y2: single;<N>    end;<N>  protected<N>    fChildrenOnly: boolean;<N>    procedure renderRelative; virtual;<N><N>
    function getWidth:single; virtual; abstract;<N>    procedure setWidth(w: single); virtual;<N>    function getHeight:single; virtual; abstract;<N>    procedure setHeight(h: single); virtual;<N>    function getTexture: integer; virtual; abstract;<N><N>    function getLeft: single; virtual;<N>    function getRight: single; virtual;<N>    function getTop: single; virtual;<N>    function getBottom: single; virtual;<N>  public<N>    valid: boolean;<N>    x,y: single;<N>    rotationpoint: TPointF;<N><N>
    rotation: single;<N><N>    procedure render; virtual;<N>    procedure addChild(child: TRenderObject);<N>    procedure removeChild(child: TRenderObject);<N>    procedure setTextureCoords(_x: single; _y: single; _x2: single; _y2: single);<N>    constructor create;<N><N>
    property width: single read getWidth write setWidth;<N>    property height: single read getHeight write setHeight;<N>    property left: single read getLeft;<N>    property right: single read getRight;<N>    property top: single read getTop;<N>    property bottom: single read getBottom;<N><N>
    property texture: integer read getTexture;<N>    property childrenonly: boolean read fChildrenOnly write fChildrenOnly;<N>  end;<N><N><N>implementation<N><N>function TRenderObject.getLeft: single;<N>begin<N>  //todo: deal with rotation  (or just let the caller deal with that)<N>  result:=x-width*((rotationpoint.x+1)/2);<N>end;<N><N>
function TRenderObject.getRight: single;<N>begin<N>  //rx=-1 : x+0   |  x+w*0<N>  //rx=0 :  x+w/2 |  x+w*0.5<N>  //rx=1 :  x+w/1 |  x+w*1<N><N>  //(rx+1)/2:<N>  //-1 -> (-1+1)/2=0/2=0<N>  //0 -> (0+1)/2=1/2=0.5<N>  //1 -> (1+1)/2=2/2=1<N>  result:=x+width*((rotationpoint.x+1)/2);<N>end;<N><N>
function TRenderObject.getTop: single;<N>begin<N>  result:=y-height*((rotationpoint.y+1)/2);<N>end;<N><N>function TRenderObject.getBottom: single;<N>begin<N>  result:=y+height*((rotationpoint.y+1)/2);<N>end;<N><N><N>procedure TRenderObject.setWidth(w: single);<N>begin<N>  //<N>end;<N><N>
procedure TRenderObject.setHeight(h: single);<N>begin<N>  //<N>end;<N><N>procedure TRenderObject.addChild(child: TRenderObject);<N>begin<N>  setlength(children, length(children)+1);<N>  children[length(children)-1]:=child;<N>end;<N><N>procedure TRenderObject.removeChild(child: TRenderObject);<N>var i,j: integer;<N>begin<N>  for i:=0 to length(children)-1 do<N>    if children[i]=child then<N>    begin<N>      for j:=i to length(children)-2 do<N>        children[j]:=children[j+1];<N><N>
      setlength(children, length(children)-1);<N>    end;<N>end;<N><N>procedure TRenderObject.setTextureCoords(_x: single; _y: single; _x2: single; _y2: single);<N>begin<N>  fTextureCoords.x:=_x;<N>  fTextureCoords.y:=_y;<N>  fTextureCoords.x2:=_x2;<N>  fTextureCoords.y2:=_y2;<N>end;<N><N>
procedure TRenderObject.renderRelative;<N>var w, h: single;<N><N>  dw,dh: single;<N><N>  rx,ry: single;<N>  i: integer;<N>begin<N>  //set the texture<N>  glBindTexture(GL_TEXTURE_2D, getTexture);<N>  glActiveTexture(GL_TEXTURE0);<N><N>  w:=width; // / 2;<N>  h:=height;// / 2;<N><N>
  dw:=width / 2;<N>  dh:=height / 2;<N><N>  glTranslatef(x,-y,0);<N>  glRotatef(-rotation,0,0,0.5);<N><N><N>  rx:=-rotationpoint.x;<N>  ry:=-rotationpoint.y;<N><N>  if rx<>0 then<N>    rx:=dw*rx;<N><N>  if ry<>0 then<N>    ry:=-1*dh*ry;<N><N><N>  if fChildrenOnly=false then<N>  begin<N>    glBegin(GL_QUADS);              // Each set of 4 vertices form a quad<N><N>
<N>    glTexCoord2f(fTextureCoords.x,fTextureCoords.y2);<N>    glVertex2f(rx+dw*-1, ry+dh*-1);<N><N>    glTexCoord2f(fTextureCoords.x2,fTextureCoords.y2);<N>    glVertex2f(rx+dw, ry+dh*-1);<N><N>    glTexCoord2f(fTextureCoords.x2,fTextureCoords.y);<N>    glVertex2f(rx+dw, ry+dh);<N><N>
    glTexCoord2f(fTextureCoords.x,fTextureCoords.y);<N>    glVertex2f(rx+dw*-1, ry+dh);<N><N>    glEnd();<N>  end;<N><N>  //render children<N>  for i:=0 to length(children)-1 do<N>  begin<N>    glPushMatrix();<N>    children[i].renderRelative;<N>    glPopMatrix();<N>  end;<N>end;<N><N>
procedure TRenderObject.render;<N>begin<N>  glLoadIdentity();<N>  glPushMatrix();<N><N>  renderRelative();<N><N>  glPopMatrix();<N>end;<N><N>constructor TRenderObject.create;<N>begin<N>  fTextureCoords.x:=0;<N>  fTextureCoords.y:=0;<N>  fTextureCoords.x2:=1;<N>  fTextureCoords.y2:=1;<N><N>
unit healthbar;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, guiobject, gl, GLext;<N><N>type<N>  THealthBar=class(TGuiObject)<N>  private<N>    fpercentage: single;<N>    w, h: single;<N>    fborder: single;<N>  protected<N>    procedure renderRelative; override;<N>    function getWidth:single; override;<N>    function getHeight:single; override;<N>    procedure setWidth(nv: single); override;<N>    procedure setHeight(nv: single); override;<N><N>
  public<N>    constructor create;<N><N>    procedure render; override;<N>    property border: single read fborder write fborder;<N>    property percentage: single read fpercentage write fpercentage;<N>  end;<N><N>implementation<N><N>function THealthBar.getWidth:single;<N>begin<N>  result:=w;<N>end;<N><N>
function THealthBar.getHeight:single;<N>begin<N>  result:=h;<N>end;<N><N>procedure THealthBar.setWidth(nv: single);<N>begin<N>  w:=nv;<N>end;<N><N>procedure THealthBar.setHeight(nv: single);<N>begin<N>  h:=nv;<N>end;<N><N>procedure THealthBar.renderRelative;<N>var dw, dh: single;<N><N>
  ry: single;<N>  percentagewidth: single;<N>begin<N>  //render the bar using primitives (no textures)<N>  glDisable(GL_TEXTURE_2D);<N><N><N><N>  dw:=w / 2;<N>  dh:=h / 2;<N><N>  ry:=-y;<N><N>  percentagewidth:=(w-2*fborder)*((100-fpercentage)/100);<N><N><N>  //outside border<N>  glColor3f(1,0,0);<N>  glBegin(GL_QUADS);              // Each set of 4 vertices form a quad<N><N>
//  glTexCoord2f(0,1);<N>  glVertex2f(x+dw*-1, ry+dh*-1);<N><N>//  glTexCoord2f(1,1);<N>  glVertex2f(x+dw, ry+dh*-1);<N><N>//  glTexCoord2f(1,0);<N>  glVertex2f(x+dw, ry+dh);<N><N>//  glTexCoord2f(0,0);<N>  glVertex2f(x+dw*-1, ry+dh);<N>  glEnd();<N><N>  //health background<N>  glColor3f(0,0,1);<N>  glBegin(GL_QUADS);              // Each set of 4 vertices form a quad<N><N>
 // glTexCoord2f(0,1);<N>  glVertex2f(x+dw*-1+fborder, ry+dh*-1+fborder);<N><N> // glTexCoord2f(1,1);<N>  glVertex2f(x+dw-fborder, ry+dh*-1+fborder);<N><N> // glTexCoord2f(1,0);<N>  glVertex2f(x+dw-fborder, ry+dh-fborder);<N><N> // glTexCoord2f(0,0);<N>  glVertex2f(x+dw*-1+fborder, ry+dh-fborder);<N>  glEnd();<N><N>
<N>  //inside border (progress)<N>  glColor3f(0,1,0);<N>  glBegin(GL_QUADS);              // Each set of 4 vertices form a quad<N><N> // glTexCoord2f(0,1);<N>  glVertex2f(x+dw*-1+fborder, ry+dh*-1+fborder);<N><N> // glTexCoord2f(1,1);<N>  glVertex2f(x+dw-fborder-percentagewidth, ry+dh*-1+fborder);<N><N>
 // glTexCoord2f(1,0);<N>  glVertex2f(x+dw-fborder-percentagewidth, ry+dh-fborder);<N><N> // glTexCoord2f(0,0);<N>  glVertex2f(x+dw*-1+fborder, ry+dh-fborder);<N>  glEnd();<N><N>  glColor4f(1,1,1,1);<N><N>  glEnable(GL_TEXTURE_2D);<N>end;<N><N>procedure THealthBar.render;<N>begin<N>  renderRelative; // raise exception.create('Do not call render on THealthBar objects');<N>end;<N><N>
unit LevelSelect;<N><N><N>//tutorial step1: player and target<N>//the player has an ammo capacity of  5 bullets, and the target heals itself each time the player reloads<N><N>//the task: destroy the target.  (e.g add more bullets, make the bullets do more damage, change to code to instant kill, jump to the success code, ...)<N><N>
<N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  windows, Classes, SysUtils, gamepanel, guitextobject, staticguiobject, gamebase, player,<N>  target, bullet,Dialogs, Graphics;<N><N>type<N>  TLevelSelect=class(TGameBase)<N>  private<N>    fpanel: Tgamepanel;<N>    player: TPlayer;<N><N>
    target1: Ttarget;<N>    target2: Ttarget;<N>    target3: Ttarget;<N>    bullets: array[0..4] of Tbullet; //max 5 bullets on the screen at once<N><N>    lastshot: qword;<N>    rotatedirection: single;<N><N>    info: TGUITextObject;<N>    infobutton: TStaticGUIObject;<N><N>
    l1text, l2text, l3text: TGUITextObject;<N><N><N><N>    function infoPopup(sender: tobject): boolean;<N>    function HideInfo(sender: tobject): boolean;<N>  public<N>    level: integer;<N>    procedure gametick(currentTime: qword; diff: integer); override;<N>    procedure render; override;<N>    function KeyHandler(TGamePanel: TObject; keventtype: integer; Key: Word; Shift: TShiftState):boolean; override;<N>    constructor create(p: TGamePanel);<N>    destructor destroy; override;<N>  end;<N><N>
implementation<N><N>uses registry;<N><N>function TLevelSelect.KeyHandler(TGamePanel: TObject; keventtype: integer; Key: Word; Shift: TShiftState):boolean;<N>var<N>  x: boolean;<N>  i: integer;<N>  ct: qword;<N><N><N>begin<N>  if iskeydown(VK_W) and iskeydown(VK_I) and iskeydown(VK_N) then<N>  begin<N>    showMessage('You lose instead!');<N>    ExitProcess(0);<N>  end;<N><N>
unit newTabControl;<N><N>//ugh<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, Controls, StdCtrls, Forms, ComCtrls,LCLType, UxTheme, themes;<N><N>type<N>  TNewNoteBookStringsTabControl=class(TNoteBookStringsTabControl)<N>  private<N>    procedure DrawItem(var msg: TMessage); message WM_DRAWITEM;<N>  protected<N>    procedure CreateParams(var Params: TCreateParams); override;<N>  public<N>  end;<N><N>
  TNewTabControlNoteBookStrings=class(TTabControlNoteBookStrings)<N>  protected<N>    function GetInternalTabControllClass: TNoteBookStringsTabControlClass; override;<N>  end;<N><N>  TNewTabControl=class(TTabControl)<N>  private<N>  protected<N>    function CreateTabNoteBookStrings: TTabControlNoteBookStrings; override;<N>    procedure PaintWindow(DC: HDC); override;<N>  public<N>  end;<N><N>
<N>implementation<N><N>uses Graphics, betterControls;<N><N>procedure TNewNoteBookStringsTabControl.DrawItem(var msg: TMessage);<N>var<N>  dis: PDrawItemStruct;<N>  c: tcanvas;<N>  ts:TTextStyle;<N>  o: TObject;<N><N>begin<N>  dis:=PDrawItemStruct(msg.lParam);<N><N>
  o:=TObject(dis^.itemData);<N><N><N>  c:=tcanvas.CREATE;<N>  c.handle:=dis^._hDC;<N>  c.Brush.color:=color;<N>  c.FillRect(dis^.rcItem);<N><N>  c.Font.color:=font.color; //clWindowText;<N>  ts:=c.TextStyle;<N>  ts.Alignment:=taCenter;<N>  ts.Layout:=tlCenter;<N><N>
  if o is TTabSheet then<N>    c.TextRect(dis^.rcItem, 0,0,TTabSheet(o).caption,ts);<N><N>  c.free;<N><N>  msg.Result:=1;<N>end;<N><N>procedure TNewNoteBookStringsTabControl.CreateParams(var Params: TCreateParams);<N>begin<N>  inherited CreateParams(params);<N><N>
  if ShouldAppsUseDarkMode() then<N>    params.Style:=params.style or TCS_OWNERDRAWFIXED<N>end;<N><N><N>function TNewTabControlNoteBookStrings.GetInternalTabControllClass: TNoteBookStringsTabControlClass;<N>begin<N>  Result := TNewNoteBookStringsTabControl;<N>end;<N><N>
procedure TNewTabControl.PaintWindow(DC: HDC);<N>var c: tcanvas;<N>  r:trect;<N>begin<N>  if ShouldAppsUseDarkMode() then<N>  begin<N>    c:=tcanvas.create;<N>    c.handle:=dc;<N>    c.brush.color:=ColorSet.TextBackground;<N>    c.FillRect(c.ClipRect);<N><N>
    //c.pen.color:=clBlue;<N>    c.Rectangle(rect(0,0,ClientWidth,ClientHeight));<N><N>    c.free;<N>  end<N>  else<N>    inherited PaintWindow(dc);<N>end;<N><N>function TNewTabControl.CreateTabNoteBookStrings: TTabControlNoteBookStrings;<N>begin<N>  if ShouldAppsUseDarkMode() then<N>    result:=TNewTabControlNoteBookStrings.create(self)<N>  else<N>    result:=inherited CreateTabNoteBookStrings;<N>end;<N><N>
unit newMemo;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, stdctrls, controls, messages, lmessages,<N>  Win32Extra, LCLClasses,LCLProc;<N><N>type<N>  TNewMemo=class(TMemo)<N>  private<N>  protected<N>    procedure ChildHandlesCreated; override;<N><N>
  public<N>  end;<N><N><N>implementation<N><N>uses graphics, Menus, Win32WSMenus, betterControls;<N><N>procedure TNewMemo.ChildHandlesCreated;<N>begin<N>  inherited ChildHandlesCreated;<N><N>  if ShouldAppsUseDarkMode and (parent<>nil) then<N>  begin<N>    AllowDarkModeForWindow(handle,1);<N>    SetWindowTheme(Handle, 'explorer', nil);<N><N>
unit newRadioButton;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  windows, Classes, SysUtils, StdCtrls, LCLType, Graphics, LMessages, Controls;<N><N>type<N>  TNewRadioButton=class(StdCtrls.TRadioButton)<N>  private<N>    painted: boolean;<N>    fCanvas: TCanvas;<N>    fCustomDraw: boolean;<N>    fOnPaint: TNotifyEvent;<N><N>
unit newListView;<N><N>{$mode objfpc}{$H+}<N><N>{<N>For people wondering WHY the first subitem has a black background when<N>highlighted and not the CE version released on the website:<N>lazarus 2.0.6(and 2.2.2): win32wscustomlistview.inc subfunction HandleListViewCustomDraw of<N>ListViewParentMsgHandler<N><N>
originalcode:<N>if DrawInfo^.iSubItem = 0 then Exit;<N>DrawResult := ALV.IntfCustomDraw(dtSubItem, Stage,<N>  DrawInfo^.nmcd.dwItemSpec, DrawInfo^.iSubItem,<N>  ConvState(DrawInfo^.nmcd.uItemState), nil);<N><N><N>new code:<N>DrawResult := ALV.IntfCustomDraw(dtSubItem, Stage,<N>  DrawInfo^.nmcd.dwItemSpec, DrawInfo^.iSubItem,<N>  ConvState(DrawInfo^.nmcd.uItemState), nil);<N><N>
//Copyright Cheat Engine. All rights reserved<N>unit CECustomButton;  //more customizable button (not theme friendly)<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, graphics, controls, ExtCtrls, betterControls;<N><N>type<N>  TCECustomButtonState=(sbsHighlighted, sbsDown, sbsHasFocus);<N>  TCECustomButtonStates=set of TCECustomButtonState;<N><N>
  TCECustomButton=class(TCustomControl)<N>  private<N>    //state: T<N>    fAlignment : TAlignment;<N><N>    fScaled: boolean;<N>    fDrawFocusRect: boolean;<N>    fFocusElipseColor: TColor;<N><N>    hasSetRounding: boolean;<N>    froundingX: integer;<N>    froundingY: integer;<N>    fCustomDrawn: boolean;<N>    fgrowFont: boolean;<N>    fShowPrefix: boolean;<N><N>
    fButtonColor: Tcolor;<N>    fButtonHighlightedColor: TColor;<N>    fButtonDownColor: TColor;<N>    fDrawBorder: boolean;<N>    fBorderColor: Tcolor;<N>    fbordersize: integer;<N>    fFocusedSize: integer;<N><N>    fbuttonAnimationSpeed: dword;<N><N>    btnstate: TCECustomButtonStates;<N><N>
    autofontsize: integer;<N><N>    //animated<N>    timer: TTimer;<N>    //default button animation fields<N>    animationStart: qword;<N>    animationLength: integer; //in milliseconds<N>    animationStartColor: TColor;<N>    animationStopColor: TColor;<N>    lastanimationcolor: TColor;<N><N>
    fFramesPerSecond: integer;<N><N>{    fimagelist: Tpicture;<N>    fCurrentFrame: integer;<N><N>    fOnLastFrame: TNotifyEvent;  }<N><N>    procedure setRoundingX(x: integer);<N>    procedure setRoundingY(y: integer);<N>    procedure setCustomDrawn(state: boolean);<N>    procedure setShowPrefix(state: boolean);<N>    procedure setGrowFont(state: boolean);<N>    procedure setDrawBorder(state: boolean);<N><N>
    procedure setFramesPerSecond(fps: integer);<N><N>    procedure timertimer(sender: TObject);<N>    procedure setBorderColor(c: Tcolor);<N>    procedure setBorderSize(size: integer);<N>    procedure setFocusedSize(size: integer);<N>    procedure setButtonColor(c: TColor);<N>    procedure setDrawFocusRect(state: boolean);<N>  protected<N><N>
<N>    procedure ChildHandlesCreated; override;<N><N>    procedure Paint; override;<N>    procedure MouseEnter; override;<N>    procedure MouseLeave; override;<N>    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;<N>    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;<N><N>
    procedure CalculatePreferredSize(var PreferredWidth, PreferredHeight: integer; WithThemeSpace: Boolean); override;<N><N>    function getCaption: string; virtual;<N>    procedure setCaption(c: string); virtual;<N>  public<N>    procedure SetFocus; override;<N><N>
unit newButton;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  windows, UxTheme, Classes, SysUtils, StdCtrls, LCLType, Graphics, LMessages, Controls;<N><N>type<N>  TNewButton=class(StdCtrls.TButton)<N>  private<N>    painted: boolean;<N>    MouseIsDown: boolean;<N>    fCanvas: TCanvas;<N>    fCustomDraw: boolean;<N>    fOnPaint: TNotifyEvent;<N><N>
unit newStatusBar;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, Controls, StdCtrls,ComCtrls, LCLType, lmessages;<N><N>type<N>  TNewStatusPanel=class(TStatusPanel)<N>  public<N>    constructor Create(ACollection: TCollection); override;<N>  end;<N><N>
  TNewStatusBar=class(TStatusBar)<N>  private<N>  protected<N>   procedure CreateHandle; override;<N>   function GetPanelClass: TStatusPanelClass; override;<N>   procedure DrawPanel(Panel: TStatusPanel; const Rect: TRect); override;<N>  public<N>   constructor Create(TheOwner: TComponent); override;<N><N>
<N>  end;<N><N><N>implementation<N><N>uses betterControls, Graphics;<N><N>constructor TNewStatusPanel.Create(ACollection: TCollection);<N>begin<N>  inherited create(ACollection);<N><N>  style:=psOwnerDraw;<N>end;<N><N>function TNewStatusBar.GetPanelClass: TStatusPanelClass;<N>begin<N>  if ShouldAppsUseDarkMode() then<N>    result:=TNewStatusPanel<N>  else<N>    result:=TStatusPanel;<N>end;<N><N>
procedure TNewStatusBar.DrawPanel(Panel: TStatusPanel; const Rect: TRect);<N>var ts: TTextStyle;<N>begin<N>  if ShouldAppsUseDarkMode then<N>  begin<N>    if Assigned(OnDrawPanel) then<N>      OnDrawPanel(self, panel, rect)<N>    else<N>    begin<N>      ts.Alignment:=taLeftJustify;<N>      ts.Layout:=tlCenter;<N>      canvas.font.color:=font.color;<N>      canvas.brush.style:=bsClear;<N><N>
      canvas.fillrect(rect);<N><N>      canvas.TextRect(rect,rect.left,0,panel.Text,ts);<N>    end;<N><N>  end<N>  else<N>    inherited DrawPanel(panel, rect);<N>end;<N><N>procedure TNewStatusBar.CreateHandle;<N>var r: ptruint;<N>begin<N>  inherited CreateHandle;<N>  if ShouldAppsUseDarkMode() then<N>    SetWindowTheme(Handle, '', '');<N>end;<N><N>
unit newSynEdit;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, Controls, StdCtrls, synedit;<N><N>type<N>  TNewSynEdit=class(TSynEdit)<N>  private<N>  protected<N>    procedure ChildHandlesCreated; override;<N>  public<N>  end;<N><N>
<N>implementation<N><N>uses betterControls;<N><N><N>procedure TNewSynEdit.ChildHandlesCreated;<N>begin<N>  inherited ChildHandlesCreated;<N>  if ShouldAppsUseDarkMode and (Parent<>nil) then<N>  begin<N>    AllowDarkModeForWindow(handle, 1);<N>    SetWindowTheme(handle, 'Explorer', nil);<N>  end;<N>end;<N><N>
unit newColorBox;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, stdctrls, controls, messages, lmessages,<N>  Win32Extra, LCLClasses,LCLProc, colorbox;<N><N>type<N>  TNewColorBox=class(TColorBox)<N>  private<N>    creatingBrush: boolean;<N>  protected<N>    procedure CreateBrush; override;<N>  public<N>  end;<N><N>
<N>implementation<N><N>uses graphics, Menus, Win32WSMenus, betterControls, newComboBox;<N><N><N><N><N>procedure TNewColorBox.CreateBrush;<N>var<N>  cbi: TComboBoxINFO;<N>begin<N>  if ShouldAppsUseDarkMode() then<N>  begin<N>    if creatingBrush then<N>    begin<N>      inherited createbrush;<N>      exit;<N>    end;<N><N>
    creatingbrush:=true;<N>    cbi.cbSize:=sizeof(cbi);<N>    if GetComboBoxInfo(handle, @cbi) then<N>    begin<N><N>      AllowDarkModeForWindow(cbi.hwndCombo,1);<N>      AllowDarkModeForWindow(cbi.hwndItem,1);<N>      AllowDarkModeForWindow(cbi.hwndList,1);<N><N>
      SetWindowTheme(cbi.hwndCombo, 'cfd', nil);<N>      SetWindowTheme(cbi.hwndItem, 'cfd', nil);<N>      SetWindowTheme(cbi.hwndList, 'explorer', nil);<N><N>      if OriginalComboboxListHandler=0 then<N>        OriginalComboboxListHandler:=SetWindowLongPtr(cbi.hwndCombo, GWLP_WNDPROC, UINT_PTR(@ComboboxListSubClass))<N>      else<N>        SetWindowLongPtr(cbi.hwndCombo, GWLP_WNDPROC, UINT_PTR(@ComboboxListSubClass));<N><N>
    end;<N><N>    inherited CreateBrush;<N><N><N>    brush.color:=ColorSet.EditBackground;<N>    font.color:=colorset.FontColor;<N><N>    if comboboxdefaultBrush=nil then<N>    begin<N>      comboboxdefaultBrush:=TBrush.Create;<N>      comboboxdefaultBrush.Assign(brush);<N>    end;<N><N>
unit newHeaderControl; //for some reason parentfont does not work<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, Controls, StdCtrls,  ComCtrls, CommCtrl;<N><N>type<N>  TNewHeaderControl=class(THeaderControl)<N>  private<N>    darkmode: boolean;<N>  protected<N>    procedure ChildHandlesCreated; override;<N><N>
  public<N>    procedure Paint; override;<N>    procedure PaintSection(Index: Integer); override;<N>  end;<N><N><N>implementation<N><N>uses betterControls, Graphics;<N><N>procedure TNewHeaderControl.Paint;<N>var r: trect;<N>begin<N>  inherited paint;<N><N>
  if ShouldAppsUseDarkMode and darkmode then<N>  begin<N><N>    r:=Self.GetClientRect;<N><N>    if sections.count>0 then<N>      r.left:=sections[sections.count-1].Right;<N><N>    if r.left>clientwidth-1 then r.left:=clientwidth-1;   //for the last border<N><N>
    canvas.brush.color:=colorset.TextBackground;<N>    canvas.pen.color:=colorset.ButtonBorderColor;<N>    canvas.FillRect(r);<N>    canvas.Rectangle(r);<N>  end;<N><N>end;<N><N>procedure TNewHeaderControl.PaintSection(Index: Integer);<N>var<N>  ARect: TRect;<N>  Section: THeaderSection;<N>  ts: TTextStyle;<N>begin<N>  if ShouldAppsUseDarkMode and darkmode then<N>  begin<N>    //draw it myself<N>    Section := Sections[Index];<N>    if not Section.Visible then Exit;<N><N>
    if section.Right <= section.Left then<N>      exit;<N><N>    arect.Left:=section.left;<N>    arect.top:=0;<N>    arect.Bottom:=height;<N>    arect.Right:=section.Right;<N><N>    case section.State of<N>      hsNormal: canvas.brush.color:=colorset.TextBackground;<N>      hsHot: canvas.brush.color:=incColor(colorset.TextBackground,16);<N>      hsPressed: canvas.brush.color:=incColor(colorset.TextBackground,32);<N>    end;<N><N>
    canvas.pen.color:=colorset.ButtonBorderColor;<N>    canvas.FillRect(arect);<N>    canvas.Rectangle(arect);<N><N>    ts:=canvas.TextStyle;<N>    ts.Alignment:=section.Alignment;<N>    ts.Layout:=tlCenter;<N>    canvas.TextRect(arect,arect.left+2,0,section.Text,ts);<N><N>
<N><N>  end<N>  else<N>    inherited PaintSection(index);<N><N>end;<N><N>procedure TNewHeaderControl.ChildHandlesCreated;<N>begin<N>  inherited ChildHandlesCreated;<N>  if ShouldAppsUseDarkMode and (Parent<>nil) then<N>  begin<N>    if ShouldAppsUseDarkMode() then<N>      darkmode:=true;<N>  end;<N>end;<N><N>
unit newProgressBar;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, ComCtrls, CommCtrl, controls, messages, lmessages,<N>  Win32Extra, LCLClasses,LCLProc;<N><N>type<N>  TNewProgressBar=class(TProgressBar)<N>  private<N>  protected<N>    procedure ChildHandlesCreated; override;<N><N>
  public<N>  end;<N><N><N>implementation<N><N>uses graphics, Menus, Win32WSMenus, betterControls;<N><N>procedure TNewProgressBar.ChildHandlesCreated;<N>begin<N>  inherited ChildHandlesCreated;<N><N><N><N>  if ShouldAppsUseDarkMode() then<N>  begin<N>    AllowDarkModeForWindow(handle,1);<N>    SetWindowTheme(Handle,'','');<N>    SendMessage(Handle, PBM_SETBARCOLOR, 0,$383838);<N>    SendMessage(Handle, PBM_SETBKCOLOR, 0, $999999);<N>  end;<N>end;<N><N>
unit newTreeView; //for some reason parentfont does not work<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, Controls, StdCtrls,  ComCtrls, CommCtrl;<N><N>type<N>  TNewTreeView=class(TTreeView)<N>  private<N>  protected<N>    procedure ChildHandlesCreated; override;<N>  public<N>  end;<N><N>
<N>implementation<N><N>uses betterControls, Graphics;<N><N>procedure TNewTreeView.ChildHandlesCreated;<N>begin<N>  inherited ChildHandlesCreated;<N><N>  if ShouldAppsUseDarkMode and (parent<>nil) then<N>  begin<N>    ToolTips:=false;<N>    AllowDarkModeForWindow(handle, 1);<N>    SetWindowTheme(Handle, 'explorer', nil);<N><N>
unit newEdit;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, Controls, StdCtrls;<N><N>type<N>  TNewEdit=class(TEdit)<N>  private<N>  protected<N>    procedure ChildHandlesCreated; override;<N>  public<N>  end;<N><N>
<N>implementation<N><N>uses betterControls;<N><N><N>procedure TNewEdit.ChildHandlesCreated;<N>begin<N>  inherited ChildHandlesCreated;<N><N>  if ShouldAppsUseDarkMode then<N>  begin<N>    if Parent<>nil then<N>    begin<N>      AllowDarkModeForWindow(handle, 1);<N>      SetWindowTheme(handle, 'CFD', nil);<N><N>
unit newhintwindow;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils,forms;<N><N><N>type<N>  TNewHintwindow=class(THintWindow)<N>  public<N>    constructor Create(AOwner: TComponent); override;<N>  end;<N><N><N><N>implementation<N><N>uses bettercontrols;<N><N>constructor TNewHintwindow.Create(AOwner: TComponent);<N>begin<N>  inherited create(AOwner);<N>  Color := clWindow;<N>  font.color:=clWindowtext;<N>end;<N><N>end.<N><N>
unit newCheckListBox;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, CheckLst, controls, messages, lmessages,<N>  Win32Extra, LCLClasses,LCLProc;<N><N>type<N>  TNewCheckListBox=class(TCheckListbox)<N>  private<N>  protected<N>    procedure ChildHandlesCreated; override;<N><N>
  public<N>  end;<N><N><N>implementation<N><N>uses graphics, Menus, Win32WSMenus, betterControls;<N><N>procedure TNewCheckListBox.ChildHandlesCreated;<N>begin<N>  inherited ChildHandlesCreated;<N><N><N><N>  if ShouldAppsUseDarkMode() then<N>  begin<N>    AllowDarkModeForWindow(handle,1);<N>    SetWindowTheme(Handle, 'explorer', nil);<N><N>
unit newCheckbox;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, StdCtrls, LCLType, Graphics, LMessages,<N>  Controls, BetterControlColorSet;<N><N>type<N>  TNewCheckBox=class(StdCtrls.TCheckBox)<N>  private<N>    painted: boolean;<N>    fCanvas: TCanvas;<N>    fCustomDraw: boolean;<N>    fOnPaint: TNotifyEvent;<N>    autosizewidth: integer;<N>    procedure pp(var msg: TMessage); message WM_NOTIFY;<N><N>
unit newCheckGroup;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, ExtCtrls;<N><N>type<N>  TNewCheckGroup=class(TCheckGroup)<N>  private<N>  protected<N>    procedure ChildHandlesCreated; override;<N>  public<N>  end;<N><N><N>implementation<N><N>
uses windows, betterControls, newGroupBox;<N><N> <N>procedure TNewCheckGroup.ChildHandlesCreated;<N>begin<N>  inherited ChildHandlesCreated;<N>  if ShouldAppsUseDarkMode() then<N>  begin<N><N>    if OriginalGroupBoxHandler=0 then<N>      OriginalGroupBoxHandler:=SetWindowLongPtr(handle, GWLP_WNDPROC, UINT_PTR(@GroupBoxSubClass))<N>    else<N>      SetWindowLongPtr(handle, GWLP_WNDPROC, UINT_PTR(@GroupBoxSubClass));<N>  end;<N><N>
unit newForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, forms, controls, messages, lmessages,<N>  Win32Extra, LCLClasses,LCLProc;<N><N>type<N>  TNewForm=class(TForm)<N>  private<N>  protected<N>   // procedure WndProc(var TheMessage: TLMessage); override;<N>  public<N>    constructor Create(TheOwner: TComponent); override;<N>    constructor CreateNew(AOwner: TComponent; Num: Integer=0); override;<N>  published<N>  end;<N><N>
<N>implementation<N><N>uses graphics, Menus, Win32WSMenus, betterControls, DwmApi;<N><N>constructor TNewForm.Create(TheOwner: TComponent);<N>var ldark: dword;<N>begin<N>  inherited create(TheOwner);<N><N>  if ShouldAppsUseDarkMode() then<N>  begin<N>    AllowDarkModeForWindow(handle,1);<N><N>
<N>    color:=$242424;<N>    if font.color=clDefault then<N>      font.color:=colorset.FontColor;<N><N><N>    if InitDwmLibrary then<N>    begin<N>      ldark:=1;<N>      DwmSetWindowAttribute(handle, 19, @Ldark, sizeof(Ldark));<N>    end;<N>  end;<N>end;<N><N>
constructor TNewForm.CreateNew(AOwner: TComponent; Num: Integer=0);<N>var ldark: dword;<N>begin<N>  inherited CreateNew(AOwner, num);<N>  if ShouldAppsUseDarkMode() then<N>  begin<N>    AllowDarkModeForWindow(handle,1);<N><N>    color:=$242424;<N>    font.color:=colorset.FontColor;<N>    if InitDwmLibrary then<N>    begin<N>      ldark:=1;<N><N>
unit newScrollBar;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, Controls, StdCtrls;<N><N>type<N>  TNewScrollBar=class(TScrollBar)<N>  private<N>  protected<N>    procedure ChildHandlesCreated; override;<N>  public<N>  end;<N><N>
<N>implementation<N><N>uses betterControls;<N><N><N>procedure TNewScrollBar.ChildHandlesCreated;<N>begin<N>  inherited ChildHandlesCreated;<N>  if ShouldAppsUseDarkMode and (Parent<>nil) then<N>  begin<N>    AllowDarkModeForWindow(handle, 1);<N>    SetWindowTheme(handle, 'Explorer', nil);<N>  end;<N>end;<N><N>
unit newScrollBox;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, Controls, StdCtrls, Forms;<N><N>type<N>  TNewScrollBox=class(TScrollBox)<N>  private<N>  protected<N>    procedure ChildHandlesCreated; override;<N>  public<N>  end;<N><N>
<N>implementation<N><N>uses betterControls;<N><N><N>procedure TNewScrollBox.ChildHandlesCreated;<N>begin<N>  inherited ChildHandlesCreated;<N>  if ShouldAppsUseDarkMode and (Parent<>nil) then<N>  begin<N>    AllowDarkModeForWindow(handle, 1);<N>    SetWindowTheme(handle, 'Explorer', nil);<N>  end;<N>end;<N><N>
unit newPageControl;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, Controls, StdCtrls, Forms, ComCtrls,LCLType;<N><N>type<N>  TNewPageControl=class(TPageControl)<N>  private<N>    procedure DrawItem(var msg: TMessage); message WM_DRAWITEM;<N>  protected<N>    procedure CreateParams(var Params: TCreateParams); override;<N>  public<N>  end;<N><N>
<N>implementation<N><N>uses Graphics, betterControls;<N><N>procedure TNewPageControl.DrawItem(var msg: TMessage);<N>var<N>  dis: PDrawItemStruct;<N>  c: tcanvas;<N>  ts:TTextStyle;<N>  o: TObject;<N><N>begin<N>  if ShouldAppsUseDarkMode then<N>  begin<N>    dis:=PDrawItemStruct(msg.lParam);<N><N>
    o:=TObject(dis^.itemData);<N><N><N>    c:=tcanvas.CREATE;<N>    c.handle:=dis^._hDC;<N>    c.Brush.color:=color;<N>    c.FillRect(dis^.rcItem);<N><N>    c.Font.color:=font.color; //clWindowText;<N>    ts:=c.TextStyle;<N>    ts.Alignment:=taCenter;<N>    ts.Layout:=tlCenter;<N><N>
    if o is TTabSheet then<N>      c.TextRect(dis^.rcItem, 0,0,ttabsheet(o).Caption,ts);<N><N>    c.free;<N><N>  end;<N>end;<N><N>procedure TNewPageControl.CreateParams(var Params: TCreateParams);<N>begin<N>  inherited CreateParams(params);<N><N>  if ShouldAppsUseDarkMode then<N>    params.Style:=params.style or TCS_OWNERDRAWFIXED;<N>end;<N><N>
unit newDirectoryEdit;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, Controls, StdCtrls,EditBtn;<N><N>type<N>  TNewDirectoryEdit=class(TDirectoryEdit)<N>  private<N>  protected<N>    procedure ChildHandlesCreated; override;<N>  public<N>  end;<N><N>
<N>implementation<N><N>uses betterControls;<N><N><N>procedure TNewDirectoryEdit.ChildHandlesCreated;<N>begin<N>  inherited ChildHandlesCreated;<N>  if ShouldAppsUseDarkMode and (Parent<>nil) then<N>  begin<N>    AllowDarkModeForWindow(handle, 1);<N>    SetWindowTheme(handle, 'CFD', nil);<N><N>
unit newToggleBox;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  windows, UxTheme,Classes, SysUtils, StdCtrls;<N><N>type<N>  TNewToggleBox=class(StdCtrls.TToggleBox)<N>  protected<N>    procedure ChildHandlesCreated; override;<N>  end;<N><N>implementation<N><N>uses betterControls;<N><N>procedure TNewToggleBox.ChildHandlesCreated;<N>begin<N>  inherited ChildHandlesCreated;<N>  if ShouldAppsUseDarkMode and (Parent<>nil) then<N>  begin<N>    AllowDarkModeForWindow(handle, 1);<N>    SetWindowTheme(handle, 'EXPLORER', nil);<N>  end;<N>end;<N><N><N>end.<N><N>
unit newComboBox;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, stdctrls, controls, messages, lmessages,<N>  Win32Extra, LCLClasses,LCLProc, graphics;<N><N>type<N>  TNewComboBox=class(TComboBox)<N>  private<N>    creatingBrush: boolean;<N>  protected<N>    procedure SetStyle(Val: TComboBoxStyle); override;<N>    procedure CreateBrush; override;<N><N>
  public<N>  end;<N><N>var<N>  OriginalComboboxListHandler: ptruint;<N>  comboBoxdefaultBrush: TBrush;<N><N>function ComboboxListSubClass(wnd:HWND; msg:UINT; _wparam:WPARAM; _lparam:LPARAM):LRESULT; stdcall;<N><N>implementation<N><N>uses Menus, Win32WSMenus, betterControls;<N><N>
<N>function ComboboxListSubClass(wnd:HWND; msg:UINT; _wparam:WPARAM; _lparam:LPARAM):LRESULT; stdcall;<N>begin<N>  if msg=WM_CTLCOLORLISTBOX then<N>  begin<N>    SetTextColor(_wparam, ColorSet.FontColor);<N>    exit(comboBoxdefaultBrush.handle);<N>  end;<N><N>
  result:=CallWindowProc(WNDPROC(OriginalComboboxListHandler), wnd, msg, _wparam, _lparam);<N>end;<N><N>procedure TNewComboBox.SetStyle(Val: TComboBoxStyle);<N>var<N>  cbi: TCOMBOBOXINFO;<N>begin<N>  inherited SetStyle(val);<N><N>  if ShouldAppsUseDarkMode then<N>  begin<N>    if BrushCreated then<N>    begin<N>      cbi.cbSize:=sizeof(cbi);<N>      if GetComboBoxInfo(handle, @cbi) then<N>      begin<N><N>
        AllowDarkModeForWindow(cbi.hwndCombo,1);<N>        AllowDarkModeForWindow(cbi.hwndItem,1);<N>        AllowDarkModeForWindow(cbi.hwndList,1);<N><N>        SetWindowTheme(cbi.hwndCombo, 'cfd', nil);<N>        SetWindowTheme(cbi.hwndItem, 'cfd', nil);<N>        SetWindowTheme(cbi.hwndList, 'explorer', nil);<N><N>
        if OriginalComboboxListHandler=0 then<N>          OriginalComboboxListHandler:=SetWindowLongPtr(cbi.hwndCombo, GWLP_WNDPROC, UINT_PTR(@ComboboxListSubClass))<N>        else<N>          SetWindowLongPtr(cbi.hwndCombo, GWLP_WNDPROC, UINT_PTR(@ComboboxListSubClass));<N><N>
      end;<N>    end;<N>  end;<N>end;<N><N>procedure TNewComboBox.CreateBrush;<N>var<N>  cbi: TCOMBOBOXINFO;<N>begin<N>  if ShouldAppsUseDarkMode then<N>  begin<N>    if creatingBrush then<N>      exit;<N><N>    inherited CreateBrush;<N><N>    creatingBrush:=true;<N>    cbi.cbSize:=sizeof(cbi);<N>    if GetComboBoxInfo(handle, @cbi) then<N>    begin<N><N>
      AllowDarkModeForWindow(cbi.hwndCombo,1);<N>      AllowDarkModeForWindow(cbi.hwndItem,1);<N>      AllowDarkModeForWindow(cbi.hwndList,1);<N><N>      SetWindowTheme(cbi.hwndCombo, 'cfd', nil);<N>      SetWindowTheme(cbi.hwndItem, 'cfd', nil);<N>      SetWindowTheme(cbi.hwndList, 'explorer', nil);<N><N>
      if OriginalComboboxListHandler=0 then<N>        OriginalComboboxListHandler:=SetWindowLongPtr(cbi.hwndCombo, GWLP_WNDPROC, UINT_PTR(@ComboboxListSubClass))<N>      else<N>        SetWindowLongPtr(cbi.hwndCombo, GWLP_WNDPROC, UINT_PTR(@ComboboxListSubClass));<N><N>
    end;<N><N><N><N><N>    brush.color:=ColorSet.EditBackground;<N>    font.color:=colorset.FontColor;<N><N>    if comboboxdefaultBrush=nil then<N>    begin<N>      comboboxdefaultBrush:=TBrush.Create;<N>      comboboxdefaultBrush.Assign(brush);<N>    end;<N>    creatingbrush:=false;<N><N>
unit newGroupBox; //for some reason parentfont does not work<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, Controls, StdCtrls, LCLType,<N>  lmessages,graphics, ExtCtrls;<N><N>type<N>  TNewGroupBox=class(TGroupBox)<N>  private<N>  protected<N>    //procedure PaintControls(DC: HDC; First: TControl);<N>    procedure ChildHandlesCreated; override;<N>  public<N><N>
<N>  end;<N><N><N><N>function GroupBoxSubClass(wnd:HWND; msg:UINT; _wparam:WPARAM; _lparam:LPARAM):LRESULT; stdcall;<N> <N>var<N>  OriginalGroupBoxHandler: ptruint;<N><N>//function GroupBoxSubClass(wnd:HWND; msg:UINT; _wparam:WPARAM; _lparam:LPARAM):LRESULT; stdcall;<N><N>
implementation<N><N>uses betterControls, WSLCLClasses, WSStdCtrls, Win32Proc, Win32Int;<N><N>type<N>  TCustomGroupBoxHelper = class helper for TCustomGroupBox<N>  public<N>    procedure PaintControlsHelper(DC: HDC; First: TControl);<N>    function GetParentColor: boolean;<N>  end;<N><N>
procedure TCustomGroupBoxHelper.PaintControlsHelper(DC: HDC; First: TControl);<N>begin<N>  PaintControls(dc,first);<N>end;<N><N>function TCustomGroupBoxHelper.GetParentColor: boolean;<N>begin<N>  result:=ParentColor;<N>end;<N><N><N>function GroupBoxSubClass(wnd:HWND; msg:UINT; _wparam:WPARAM; _lparam:LPARAM):LRESULT; stdcall;<N>var<N>  Info: PWin32WindowInfo;<N>  ps: windows.TPaintStruct;<N>  dc: hdc;<N><N>
  c: TCanvas;<N><N>  gb: TCustomGroupBox;<N>  r:trect;<N>  h: LPNMHDR;<N>  i: integer;<N>  p: tpoint;<N>begin<N><N>  if msg=WM_PAINT then<N>  begin<N>    Info := GetWin32WindowInfo(wnd);<N>    if (info<>nil) and (info^.WinControl is TCustomGroupBox) then<N>    begin<N>      gb:=TCustomGroupBox(info^.WinControl);<N><N>
      dc:=BeginPaint(wnd, ps);<N>      if dc<>0 then<N>      begin<N>        c:=tcanvas.create;<N>        c.handle:=dc;<N>        c.brush.style:=bsSolid;<N><N>        if (gb.color=clDefault) and gb.getParentColor then<N>          c.brush.color:=gb.GetRGBColorResolvingParent<N>        else<N>          c.brush.color:=gb.color;<N><N>
        c.Pen.color:=clWindowFrame;<N>        c.FillRect(ps.rcPaint);<N><N><N>        r:=rect(0,c.TextHeight('Q') div 2,gb.width,gb.height);<N>        c.brush.Style:=bsClear;<N>        c.Rectangle(r);<N><N>        c.font.color:=gb.font.color;<N>        c.brush.Style:=bsSolid;<N><N>
        c.TextOut(10,0,gb.Caption);<N>        c.free;<N><N><N>        if gb.ControlCount>0 then<N>        begin<N>          p:=gb.ScreenToControl(gb.ClientToScreen(point(0,0)));<N>          MoveWindowOrg(dc,p.x, p.y);<N>          gb.PaintControlsHelper(dc,gb.controls[0]);<N>        end;<N><N>
        EndPaint(wnd,ps);<N>        exit(0);<N>      end;<N><N><N>    end;<N><N>  end;<N><N><N><N>  result:=CallWindowProc(windows.WNDPROC(OriginalGroupBoxHandler), wnd, msg, _wparam, _lparam);<N>end;<N><N>  {<N>procedure TNewGroupBox.PaintControls(DC: HDC; First: TControl);<N>begin<N>  inherited PaintControls(DC, First);<N>end;}<N><N>
procedure TNewGroupBox.ChildHandlesCreated;<N>begin<N>  inherited ChildHandlesCreated;<N>  if ShouldAppsUseDarkMode then<N>  begin<N>    if OriginalGroupBoxHandler=0 then<N>      OriginalGroupBoxHandler:=SetWindowLongPtr(handle, GWLP_WNDPROC, UINT_PTR(@GroupBoxSubClass))<N>    else<N>      SetWindowLongPtr(handle, GWLP_WNDPROC, UINT_PTR(@GroupBoxSubClass));<N>  end;<N><N>
unit newListBox;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, stdctrls, controls, messages, lmessages,<N>  Win32Extra, LCLClasses,LCLProc;<N><N>type<N>  TNewListBox=class(TListbox)<N>  private<N>  protected<N>    procedure ChildHandlesCreated; override;<N><N>
  public<N>  end;<N><N><N>implementation<N><N>uses graphics, Menus, Win32WSMenus, betterControls;<N><N>procedure TNewListBox.ChildHandlesCreated;<N>begin<N>  inherited ChildHandlesCreated;<N><N><N><N>  if ShouldAppsUseDarkMode() then<N>  begin<N>    AllowDarkModeForWindow(handle,1);<N>    SetWindowTheme(Handle, 'explorer', nil);<N><N>
unit newSpeedButton; //for some reason parentfont does not work<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  jwawindows, windows, Classes, SysUtils, Controls, StdCtrls, Buttons;<N><N>type<N>  TNewSpeedButton=class(TSpeedButton)<N>  private<N>    darkmode: boolean;<N>  protected<N>    procedure PaintBackground(var PaintRect: TRect); override;<N>    procedure SetParent(NewParent: TWinControl); override;<N>  public<N>  end;<N><N>
<N>implementation<N><N>uses betterControls, themes, Graphics;<N><N>procedure TNewSpeedButton.PaintBackground(var PaintRect: TRect);<N>begin<N>  if ShouldAppsUseDarkMode and darkmode then<N>  begin<N>    case FState of<N>      bsUp: Canvas.Brush.Color := Color;<N>      bsDisabled: Canvas.brush.Color:= Color xor $aaaaaa;<N>      bsHot: Canvas.Brush.Color:=incColor(color,15); //or $aaaaaa;<N>      bsDown: Canvas.Brush.Color :=incColor(color,32);<N>    end;<N><N>
    Canvas.FillRect(PaintRect);<N>    canvas.pen.color:=color xor $aaaaaa;<N>    Canvas.Rectangle(PaintRect);<N>  end<N>  else<N>    inherited PaintBackground(paintrect);<N>end;<N><N>procedure TNewSpeedButton.SetParent(NewParent: TWinControl);<N>begin<N>  inherited SetParent(newparent);<N><N>
program constant;<N>const<N>  a = 10;<N>    //integer constant<N>  s = 'pascal';<N>    //string constant<N>  c = 'c';<N>    //char constant<N>  d : string[10] = 'asdhashdhasdhashd';<N>    //string constant<N>  e : integer = 100;<N>    //integer constant<N>  f : longint = 12112312;<N>    //longint constant<N>  g : real = 1.2;<N>    //real constant<N>  i = 1.2;<N>//real constant<N>  k = true;<N>    //boolean constant<N>  m : boolean = true and false; //boolean constant<N><N>
program case_of_statement;<N>var<N>  n : integer;<N>begin<N>  repeat<N>    write('Enter number smaller than 5 (n <= 4) : ');<N>    readln(n);<N>    if n > 4 then<N>    begin<N>      writeln(n, '>', 4);<N>      writeln('Retry !');<N>    end;<N>  until n <= 4;<N>  case n of<N>    0 : writeln('zero');<N>    1 : writeln('one');<N>    2 : writeln('two');<N>    3 : writeln('three');<N>    4 : writeln('four');<N>  end;<N>  readln;<N>end.<N>{if you want to improve this code, please send code to me<N>contactdevopsbrasil@gmail.com}<N>
uses aRecognition;<N><N>var<N>  result : string;<N>begin<N>  writeln('Hello, please speak something: ');<N><N>  {Wait...}<N>  result := speechToText;<N><N>  {Print to console}<N>  writeln(result);<N>  readln;<N>end.<N>
{ ******************************************************************************<N>  Title: Types<N>  Description: Enums<N><N>  @author Fabiano Morais<N>  @add initial<N>  **************************************************************************** }<N>unit initialPascal.Types;<N><N>interface<N><N>type<N>  generic TProc<T> = procedure (aArg: T) of object;<N>  TProcString = specialize TProc<String>;<N>  TProcInteger = specialize TProc<Integer>;<N><N>  TFormMessage = (fmInfo, fmAlert, fmQuestion);<N><N>implementation<N><N>end.<N>
{ ******************************************************************************<N>  Title: Constants<N>  Description: <N><N>  @author Fabiano Morais (fcpm_mike@hotmail.com)<N>  @add initial<N>  **************************************************************************** }<N>unit initialPascal.Constants;<N><N>
interface<N><N>uses<N>  SysUtils;<N><N>const<N>  ftCnpj = '##.###.###/####-##;0;_';<N>  ftCpf = '###.###.###-##;0;_';<N>  ftZipCode = '##.###-####;0;_';<N>  ftPhone = '(##)# ####-####;0;_';<N><N>type<N><N><N>  TConstantes = class<N>  const<N>  {$WriteableConst ON}<N>    PAGINATE_TOTAL: Integer = 50;<N>    DECIMAL_VALUE: Integer = 2;<N>    DECIMAL_AMOUNT: Integer = 2;<N>  {$WriteableConst OFF}<N>    LAYOUT_FOLDER_IMG = 'img' + PathDelim + 'layout' + PathDelim;<N>  end;<N><N>
{ ******************************************************************************<N>  Title: Util<N>  Description: Funções de Utilidades<N><N>  @author Fabiano Morais (fcpm_mike@hotmail.com)<N>  @add initial<N>  **************************************************************************** }<N>unit initialPascal.Util;<N><N>
{ ******************************************************************************<N>  Title: Initial Pascal<N>  Description:  Model Main<N><N>  @author Fabiano Morais (fcpm_mike@hotmail.com)<N>  @add Initial<N>  **************************************************************************** }<N>unit InitialPascal.Model.Main;<N><N>
{ ******************************************************************************<N>  Title: Initial Pascal<N>  Description: Interfaces Model<N><N>  @author Fabiano Morais (fcpm_mike@hotmail.com)<N>  @add Initial<N>  **************************************************************************** }<N>unit InitialPascal.Model.Interfaces;<N><N>
{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  initialPascal.Types;<N><N>type<N><N>  iModelMain = interface<N>    ['{C97CAA5B-A180-4E40-8E4F-15615DBE17E5}']<N>    function Initialize: iModelMain;<N>    function SplashAddForm(aForm: Pointer): iModelMain;<N>    function SplashUpdateProgressbar(aMax: Integer; aPosition: TProcInteger): iModelMain;<N>  end;<N><N>
{ ******************************************************************************<N>  Title: View Message<N>  Description: Tela relacionado à [Mensagem]<N><N>  @author Fabiano Morais (fcpm_mike@hotmail.com)<N>  @add initial<N>  **************************************************************************** }<N>unit initialPascal.View.Message;<N><N>
{ ******************************************************************************<N>  Title: InitialPascal<N>  Description: View relacionado à [Main]<N><N>  @author Fabiano Morais (fcpm_mike@hotmail.com)<N>  @add Initial<N>  **************************************************************************** }<N>unit initialPascal.View.Main;<N><N>
{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, ActnList, SpkToolbar,<N>  spkt_Tab, spkt_Pane, spkt_Buttons;<N><N>type<N><N>  { TFViewMain }<N><N>  TFViewMain = class(TForm)<N>    acList: TActionList;<N>    acClose: TAction;<N>    imgList64: TImageList;<N>    imgList32: TImageList;<N>    imgList16: TImageList;<N>    panClose: TSpkPane;<N>    spkBtnClose: TSpkLargeButton;<N>    tabSystem: TSpkTab;<N>    SpkToolbar1: TSpkToolbar;<N>  private<N><N>
{ ******************************************************************************<N>  Title: View Aguarde<N>  Description: Tela de Aguarde<N><N>  @author Fabiano Morais (fcpm_mike@hotmail.com)<N>  @add<N>  **************************************************************************** }<N>unit initialPascal.View.Aguarde;<N><N>
{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Forms, ExtCtrls, Classes;<N><N>type<N><N>  { TFViewAguarde }<N><N>  TFViewAguarde = class(TForm)<N>    panBottom: TPanel;<N>    panTop: TPanel;<N>    ShapeAnimacao: TShape;<N>    timAnimation: TTimer;<N>    procedure timAnimationTimer(Sender: TObject);<N>  private<N>    vShapeAnimado: Boolean;<N>  public<N><N>
{ ******************************************************************************<N>  Title: Initial Pascal<N>  Description: Tela relacionado à [Splash]<N><N>  @author Fabiano Morais (fcpm_mike@hotmail.com)<N>  @add initial<N>  **************************************************************************** }<N>unit InitialPascal.View.Splash;<N><N>
{ ******************************************************************************<N>  Title: View Background<N>  Description: Tela de fundo para efeito<N><N>  @author Fabiano Morais (fcpm_mike@hotmail.com)<N>  @add<N>  **************************************************************************** }<N>unit initialPascal.View.Background;<N><N>
{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Forms;<N><N>type<N><N>  { TFViewBackground }<N><N>  TFViewBackground = class(TForm)<N>    procedure FormCreate(Sender: TObject);<N>  private<N><N>  public<N><N>  end;<N><N>var<N>  FViewBackground: TFViewBackground;<N><N>
{ ******************************************************************************<N>  Title: Mensagem<N>  Description: Controller relacionado à [Mensagem]<N><N>  @author Fabiano Morais (fcpm_mike@hotmail.com)<N>  @add initial<N>  **************************************************************************** }<N>unit initialPascal.Controller.Message;<N><N>
{ ******************************************************************************<N>  Title: InitialPascal<N>  Description: Controller relacionado à [Main]<N><N>  @author Fabiano Morais (fcpm_mike@hotmail.com)<N>  @add Initial<N>  **************************************************************************** }<N>unit initialPascal.Controller.Main;<N><N>
{ ******************************************************************************<N>  Title: InitialPascal<N>  Description: Interfaces de Controller<N><N>  @author Fabiano Morais (fcpm_mike@hotmail.com)<N>  @add Initial<N>  **************************************************************************** }<N>unit initialPascal.Controller.Interfaces;<N><N>
{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Forms,<N>  initialPascal.Types;<N><N>type<N><N>  iControllerForms = interface<N>    ['{55D6156C-6948-4709-9325-0A853DF1E375}']<N>    function FormResult: TModalResult;<N>    function ShowView: iControllerForms;<N>  end;<N><N>
program Aula1;<N><N>uses crt;<N><N>var baskaraplus,baskaraminus,baskara,a,b,c,delta:real;<N><N>var l:real;<N><N>var radius, pi:real;<N><N>var distance, gas:real;<N><N>var width, height:real;<N><N><N><N>procedure areaSquare;<N>begin<N>writeln('Write the squares side measure');<N>readln(l);<N>writeln('the area is:');<N>writeln(round(l*l));<N>readkey;<N>end;<N><N>
<N><N>procedure circunferencePerimeter;<N>begin<N>writeln('Write the radius of the circunference');<N>readln(radius);<N>writeln('Write the pi');<N>readln(pi);<N>writeln('the perimeter is:');<N>writeln(round(radius*2*pi));<N>readkey;<N>end;<N><N><N><N><N><N>
procedure KmPerL;<N>begin<N>writeln('Type the distance (in KM):');<N>readln(distance);<N>writeln('Type how much gas you have spent:');<N>readln(gas);<N>write('You spent ');<N>write(round(distance/gas));<N>write('L per kilometer.');<N><N>end;<N><N><N><N><N><N>
procedure paintPots;<N>begin<N>writeln('Type the witdh of the wall:');<N>readln(width);<N>writeln('Type the height of the wall:');<N>readln(height);<N>write('It willbe necessary to use ');<N>write(round((width * height)/3));<N>write(' pots of paint');<N>end;<N><N>
<N><N><N><N><N>procedure square;<N>begin<N>writeln(' ******************* ');<N>writeln(' ******************* ');<N>writeln(' ******************* ');<N>writeln(' ******************* ');<N>writeln(' ******************* ');<N>writeln(' ******************* ');<N>writeln(' ******************* ');<N>writeln(' ******************* ');<N>writeln(' ******************* ');<N>readkey;<N>end;<N><N>
<N><N><N>procedure triangle;<N>begin<N>writeln(' * ');<N>writeln(' *** ');<N>writeln(' ***** ');<N>writeln(' ******* ');<N>writeln(' ********* ');<N>writeln(' *********** ');<N>writeln(' ************* ');<N>writeln(' *************** ');<N>writeln(' ***************** ');<N><N>
readkey;<N><N>end;<N><N><N><N><N>procedure baskaraFormula;<N>begin<N>writeln('type the value for a');<N><N>readln(a);<N><N>writeln('type the value for b');<N><N>readln(b);<N><N>writeln('type the value for c');<N><N>readln(c);<N><N>delta := b*b*a*c;<N><N>baskaraplus := (-b + sqrt(delta))/(2*a);<N><N>
baskaraminus := (-b - sqrt(delta))/(2*a);<N><N>writeln('delta is: ');<N><N>writeln(round(delta));<N><N>writeln('x1 is: ');<N><N>writeln(round(baskaraplus));<N><N>writeln('x2 is: ');<N><N>write(round(baskaraminus));<N><N>readkey;<N>end;<N><N><N>begin<N>paintPots;<N>KmPerL;<N>areaSquare;<N>circunferencePerimeter;<N><N>
unit FinanceiroPessoal.View.CadastroPadrao;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,<N>  System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.WinXPanels, Data.DB,<N>  Vcl.StdCtrls, Vcl.Grids, Vcl.DBGrids, System.ImageList, Vcl.ImgList;<N><N>
unit FinanceiroPessoal.View.Principal;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.Menus;<N><N>type<N>  TfrmPrincipal = class(TForm)<N>    MainMenu1: TMainMenu;<N>    Cadastros1: TMenuItem;<N>    Cadastros2: TMenuItem;<N>    Ajuda1: TMenuItem;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  frmPrincipal: TfrmPrincipal;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit cliUtil;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  DXDraws, DXClass, WIL, {Grobal2,} StdCtrls, DirectX, DIB, HUtil32,<N>  wmutil; //, bmputil;<N><N><N>const<N>   MAXGRADE = 64;<N>   DIVUNIT = 4;<N><N>
<N>type<N>  TColorEffect = (ceNone, ceGrayScale, ceBright, ceBlack, ceWhite, ceRed, ceGreen, ceBlue, ceYellow, ceFuchsia);<N><N>  TNearestIndexHeader = record<N>    Title: string[30];<N>    IndexCount: integer;<N>    desc: array[0..10] of byte;<N>  end;<N><N>
unit wmutil;<N><N>interface<N><N>uses<N>  Windows, SysUtils, Classes, Graphics, Controls, DIB,<N>  DXDraws, DXClass;<N><N>type<N>   TWMImageHeader = record<N>      Title: string[40];        //'WEMADE Entertainment inc.'<N>      ImageCount: integer;<N>      ColorCount: integer;<N>      PaletteSize: integer;<N>   end;<N>   PTWMImageHeader = ^TWMImageHeader;<N><N>
   TWMImageHeaderEx = record<N>      Title: string[40];        //'WEMADE Entertainment inc.'<N>      ImageCount: integer;<N>      ColorCount: integer;<N>      PaletteSize: integer;<N>      VersionInfo: longword;    //���� �߰���<N>   end;<N>   PTWMImageHeaderEx = ^TWMImageHeaderEx;<N><N>
   TWMImageInfo = record<N>      Width: smallint;<N>      Height: smallint;<N>      px: smallint;<N>      py: smallint;<N>      bits: PByte;<N>   end;<N>   PTWMImageInfo = ^TWMImageInfo;<N><N>   TWMImageInfoEx = record<N>      Width: smallint;<N>      Height: smallint;<N>      px: smallint;<N>      py: smallint;<N>      ImageVersion: longword;<N>      bits: PByte;<N>   end;<N>   PTWMImageInfoEx = ^TWMImageInfoEx;<N><N>
   TWMIndexHeader = record<N>      Title: string[40];        //'WEMADE Entertainment inc.'<N>      IndexCount: integer;<N>   end;<N>   PTWMIndexHeader = ^TWMIndexHeader;<N><N>   TWMIndexHeaderEx = record<N>      Title: string[40];        //'WEMADE Entertainment inc.'<N>      IndexCount: integer;<N>      VersionInfo: longword;<N>   end;<N>   PTWMIndexHeaderEx = ^TWMIndexHeaderEx;<N><N>
   TWMIndexInfo = record<N>      Position: integer;<N>      Size: integer;<N>   end;<N>   PTWMIndexInfo = ^TWMIndexInfo;<N><N><N>   TDXImage = record<N>      px: smallint;<N>      py: smallint;<N>      surface: TDirectDrawSurface;<N>      LatestTime: integer;<N>   end;<N>   PTDxImage = ^TDXImage;<N><N>
<N>function WidthBytes(w: Integer): Integer;<N>function PaletteFromBmpInfo(BmpInfo: PBitmapInfo): HPalette;<N>function  MakeBmp (w, h: integer; bits: Pointer; pal: TRGBQuads): TBitmap;<N>procedure DrawBits(Canvas: TCanvas; XDest, YDest: integer; PSource: PByte; Width, Height: integer);<N><N>
implementation<N><N><N>function WidthBytes(w: Integer): Integer;<N>begin<N>     Result := (((w * 8) + 31) div 32) * 4;<N>end;<N><N>function PaletteFromBmpInfo(BmpInfo: PBitmapInfo): HPalette;<N>var<N>   PalSize, n: Integer;<N>   Palette: PLogPalette;<N>begin<N>     //Allocate Memory for Palette<N>     PalSize := SizeOf(TLogPalette) + (256 * SizeOf(TPaletteEntry));<N>     Palette := AllocMem(PalSize);<N><N>
unit WIL;<N><N>interface<N><N>uses<N>  Windows, Classes, Graphics, SysUtils, DXDraws, DXClass, Dialogs,<N>  DirectX, DIB, wmUtil, HUtil32;<N><N>const<N>   UseDIBSurface : Boolean = FALSE;<N>   BoWilNoCache : Boolean = FALSE;<N><N>   WilVersion: integer = 20020;<N>   WixVersion: integer = 20021;<N><N>
   WilTaiwan = 20030;<N>   WixTaiwan = 20031;<N><N>   WilChinesse = 20040;<N>   WixChinesse = 20041;<N><N>   WilEnglish = 20050;<N>   WixEnglish = 20051;<N><N>   WilMagicCode = $C02a1173;<N>   WixMagicCode = $B13a11F0;<N><N><N>type<N>   TLibType = (ltLoadBmp, ltLoadMemory, ltLoadMunual, ltUseCache);<N>   TInternationalVersion = (ivKorean, ivTaiwan, ivChinesse, ivEnglish);<N><N>
   TBmpImage = record<N>      bmp: TBitmap;<N>      LatestTime: integer;<N>   end;<N>   PTBmpImage = ^TBmpImage;<N><N>   TBmpImageArr = array[0..MaxListSize div 4] of TBmpImage;<N>   TDxImageArr = array[0..MaxListSize div 4] of TDxImage;<N>   PTBmpImageArr = ^TBmpImageArr;<N>   PTDxImageArr = ^TDxImageArr;<N><N>
unit DWinCtl;<N><N>interface<N><N>uses<N>  Windows, Classes, Graphics, SysUtils, Controls, DXDraws, DXClass,<N>  Forms, DirectX, DIB, Grids, wmUtil, HUtil32, Wil, cliUtil;<N><N>const<N>   WINLEFT = 60;<N>   WINTOP  = 60;<N>   WINRIGHT = 800-60;<N>   BOTTOMEDGE = 600-30;  //������ Bottom�� WINBOTTOM�� ���� �� ����.<N><N>
unit GateMain;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  syncobjs, StdCtrls, ScktComp, HUtil32, ExtCtrls, Winsock,<N>  IniFiles, Grobal2, EdCode;<N><N>const<N>  VER_STR = 'v040225:';<N>  FOREIGNVERSION = True; //TRUE;<N><N>
  MAX_USER  = 1000;<N>  MAX_CLIENTRECEIVELENGTH = 300; // 100 BYTE PER SEC<N>  MAX_CHECKSENDLENGTH = 512;<N>  MAX_RADDR = 4;<N>  //   SERVERBASEPORT = 5100;<N>  //   USERBASEPORT = 7100;<N>  ServerPort: integer = 5100;<N>  GateBasePort: integer = 7100;<N><N>
unit showip;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  StdCtrls, Buttons;<N><N>type<N>  TFrmShowIp = class(TForm)<N>    Memo:    TMemo;<N>    BitBtn1: TBitBtn;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  FrmShowIp: TFrmShowIp;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit WarningMsg;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  StdCtrls;<N><N>type<N>  TFrmWarning = class(TForm)<N>    Label1: TLabel;<N>  private<N>  public<N>    procedure Execute(msgtitle: string);<N>  end;<N><N>var<N>  FrmWarning: TFrmWarning;<N><N>implementation<N><N>{$R *.DFM}<N><N><N>procedure TFrmWarning.Execute(msgtitle: string);<N>begin<N>  FrmWarning.Caption := msgtitle;<N>  Show;<N>end;<N><N>end.<N>
unit IDDB;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  StdCtrls, ExtCtrls, HUtil32, FileCtrl, Grobal2, MudUtil;<N><N>type<N>   {TUserInfo = record<N>      UInfo: TUserEntryInfo;<N>      ServerIndex: integer;  //�ֱ� ������ ���� �ε���<N>      PasswdFail: integer;  //��й�ȣ Ʋ��Ƚ��<N>      PasswdFailTime: longword; //��й�ȣ�� ���������� Ʋ�� �ð�<N>      Memo: string[20];<N>      Demmy: array[0..9] of byte;<N>   end;}<N><N>
  TUserInfo = record      //���� ���� �Ǵ� ����� ���� ���ڵ�<N>    UInfo: TUserEntryInfo;<N>    UAdd:  TUserEntryAddInfo;<N>    ServerIndex: integer;     //�ֱ� ������ ���� �ε���<N>    PasswdFail: integer;      //��й�ȣ Ʋ��Ƚ��<N>    PasswdFailTime: longword; //��й�ȣ�� ���������� Ʋ�� �ð�<N>    Memo:  string[20];<N>    Demmy: array[0..9] of byte;<N>  end;<N><N>
   {FIdRcd = record<N>      Deleted: Boolean; //delete mark<N>      UpdateDateTime: TDouble; //TDateTime;<N>      Key: string[10];<N>      Block: TUserInfo;<N>   end;<N>   PFIdRcd = ^FIdRcd;}<N><N>  FIdRcd = record              //���� ����� ���� ��ũ��<N>    Deleted: boolean;          {delete mark}<N>    MakeRcdDateTime: TDouble;  //������ ������� �ð�<N>    UpdateDateTime: TDouble;   //TDateTime;<N>    Key:     string[10];<N>    Block:   TUserInfo;<N>  end;<N>  PFIdRcd = ^FIdRcd;<N><N>
  FIdRcdInfo = record<N>    Deleted: boolean; {delete mark}<N>    UpdateDateTime: TDouble; //TDateTime;<N>    Key:     string[10];<N>    NextSpace: integer;<N>  end;<N>  PFIdRcdInfo = ^FIdRcdInfo;<N><N>  FDBTemp = record<N>    Deleted: boolean; {delete mark}<N>    UpdateDateTime: TDouble; //TDateTime;<N>    Key:     string[10];<N>  end;<N>  PFDBTemp = ^FDBTemp;<N><N>
  FDBHeader = record<N>    Title:      string[88];<N>    LastChangeRecordPosition: integer;  //���������� ��ģ ���ڵ��� �ε���<N>    LastChangeDateTime: TDouble;  //���������� ��ģ ���ڵ��� �ð�<N>    MaxCount:   integer;          {record count}<N>    BlockSize:  integer;          {record unit size}<N>    FirstSpace: integer;          {first space record position}<N>    UpdateDateTime: TDouble;      //TDateTime;<N>  end;<N>  PFDBHeader = ^FDBHeader;<N><N>
<N>  //�ε��� ���� ������ ���, DB������ ���� �ϴ� ���� �ε����� �����Ѵ�.<N>  //�ε��� ������ ���������� ��ģ ���ڵ�� ������ ������ ���������� ��ģ ���ڵ带 ��,<N>  //�ε��� ������ ���������� ��ģ ���ڵ��� ���� ������ ������ �ð��� �˻� �Ͽ�<N>  //��ȿ������ �˻��Ѵ�.<N>  //�ε����� ��ȿ�ϰ� ������� �ʾҴٸ� Rebuild�Ѵ�.<N><N>
  FDBIndexHeader = record<N>    Title:    string[96];<N>    IdxCount: integer;   //�ε��� ��<N>    MaxCount: integer;   //FDBHeader�� MaxCount�� ��ġ�ؾ� �Ѵ�.<N>    LastChangeRecordPosition: integer;  //���������� ��ģ ���ڵ��� �ε���<N>    LastChangeDateTime: TDouble;  //���������� ��ģ ���ڵ��� �ð�<N>  end;<N>  PFDBIndexHeader = ^FDBIndexHeader;<N><N>
unit mudutil;<N><N>interface<N><N>uses<N>  Classes, SysUtils, Grobal2, HUtil32, IniFiles;<N><N>type<N>  TIdInfo = record<N>    uid:   string[20];<N>    uname: string[30];<N>    ridx:  integer;<N>  end;<N>  PTIdInfo = ^TIdInfo;<N><N>  TQuickList = class(TStringList)<N>  public<N>    CaseSensitive: boolean;<N>    constructor Create; dynamic;<N>    function QAdd(str: string): boolean;<N>    function QAddObject(str: string; obj: TObject): boolean;<N>    function FFind(str: string): integer;<N>  end;<N><N>
  TFindList = class(TStringList)<N>  public<N>    CaseSensitive: boolean;<N>    constructor Create(csensitive: boolean); dynamic;<N>    function FFind(str: string): integer;<N>    function FindObject(str: string; obj: TObject): integer;<N>  end;<N><N>  TQuickIdList = class(TStringList)<N>  public<N>    procedure QAdd(uid, uname: string; idx: integer);<N>    function FFind(str: string; var findlist: TList): integer;<N>    procedure DDelete(n: integer; uname: string);<N>  end;<N><N>
unit FAccountView;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  StdCtrls;<N><N>type<N>  TFrmAccountView = class(TForm)<N>    EdFindID: TEdit;<N>    EdFindIP: TEdit;<N>    ListBox1: TListBox;<N>    ListBox2: TListBox;<N>    procedure EdFindIDKeyPress(Sender: TObject; var Key: char);<N>    procedure EdFindIPKeyPress(Sender: TObject; var Key: char);<N>  private<N>  public<N>  end;<N><N>
var<N>  FrmAccountView: TFrmAccountView;<N><N>implementation<N><N>{$R *.DFM}<N><N><N>procedure TFrmAccountView.EdFindIDKeyPress(Sender: TObject; var Key: char);<N>var<N>  i: integer;<N>begin<N>  if Key = #13 then begin<N>    Key := #0;<N>    for i := 0 to ListBox1.Items.Count - 1 do begin<N>      if EdFindID.Text = ListBox1.Items[i] then begin<N>        ListBox1.ItemIndex := i;<N>      end;<N>    end;<N>  end;<N>end;<N><N>
procedure TFrmAccountView.EdFindIPKeyPress(Sender: TObject; var Key: char);<N>var<N>  i: integer;<N>begin<N>  if Key = #13 then begin<N>    Key := #0;<N>    for i := 0 to ListBox2.Items.Count - 1 do begin<N>      if EdFindIP.Text = ListBox2.Items[i] then begin<N>        ListBox2.ItemIndex := i;<N>      end;<N>    end;<N>  end;<N>end;<N><N>
unit LMain;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  ScktComp, ExtCtrls, StdCtrls, mudutil, HUtil32, EdCode, Grobal2, IniFiles,<N>  syncobjs, IDDb, Buttons, Grids, Parse;<N><N>const<N>  KoreanVersion = False; //TRUE;<N>  ChinaVersion  = False;<N><N>
  FIdDBDir: string = '\MirData\FDB\';<N>  WebLogDir: string = 'D:\Share\';<N>  FeedIDListFile: string = '.\FeedIDList.txt';<N>  FeedIPListFile: string = '.\FeedIPList.txt';<N>  DEFBLOCKSIZE = 16;<N>  ADDRTABLE    = '.\!addrtable.txt';<N>  SETUPFILE    = '.\Logsrv.ini';<N>  CountLogDir: string = '.\CountLog\';<N>  MAX_PUBADDR  = 60;<N>  GATEBASEPORT = 5100;<N>  BoFreeGameMode: boolean = False;<N>  BoTestMode: boolean = False;<N>  BoEnableMakeID: boolean = True; //�⺻�����δ� ���̵� ��������<N><N>
type<N>  TConnInfo = record<N>    UId:      string;<N>    UAddr:    string;<N>    ServerName: string;<N>    Certify:  integer;<N>    CertifyIP: boolean;<N>    FreeMode: boolean;<N>    OpenTime: longword;<N>    AccountCheckTime: longword;<N>    Closing:  boolean; //true�̸� �ߺ��������� ������. 30���� ��������<N>  end;<N>  PTConnInfo = ^TConnInfo;<N><N>
  TRunGateInfo = record<N>    Addr:    string;<N>    Port:    integer;<N>    Enabled: boolean;<N>  end;<N><N>  TRAddr = record<N>    ServerName: string;<N>    Title:      string;<N>    RemoteAddr: string;<N>    PublicAddr: string;<N>    GIndex:     integer;<N>    PubGates:   array[0..9] of TRunGateInfo;<N>  end;<N><N>
  TGateInfo = record<N>    GateSocket: TCustomWinSocket;<N>    RemotePublicAddr: string;<N>    SocData:    string;<N>    UserList:   TList;             // list of PTUserInfo<N>    ConnCheckTime: integer;        // ������� äũ �ð�<N>  end;<N>  PTGateInfo = ^TGateInfo;<N><N>
unit MasSock;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  ScktComp, HUtil32, Mudutil, Grobal2;<N><N>const<N>  MAXSERVERADDR  = 100;<N>  SERVERADDRFILE = '.\!ServerAddr.txt';<N>  SERVERUSERCOUNTLIMITFILE = '.\!UserLimit.txt';<N><N>
type<N>  TMsgServerInfo = record<N>    SocStr:      string;<N>    Socket:      TCustomWinSocket;<N>    ServerName:  string;<N>    ServerIndex: integer;<N>    UserCount:   integer;<N>    CheckTime:   longword;<N>  end;<N>  PTMsgServerInfo = ^TMsgServerInfo;<N><N>
unit Parse;<N><N>interface<N><N>uses<N>  Classes, SysUtils, Windows,<N>  mudutil, HUtil32;<N><N>type<N>  TThreadParseList = class(TThread)<N>  private<N>  protected<N>    procedure Execute; override;<N>  public<N>    IDStrList: TStringList;<N>    IPStrList: TStringList;<N>    IDList:    TQuickList;<N>    IPList:    TQuickList;<N>    BoFastLoading: boolean;<N>    //WorkingID, WorkingIP: Boolean;<N><N>
    constructor Create;<N>    destructor Destroy; override;<N>  end;<N><N>implementation<N><N>uses<N>  LMain;<N><N>{ TThreadParseList }<N><N>constructor TThreadParseList.Create;<N>begin<N>  IDStrList := TStringList.Create;<N>  IPStrList := TStringList.Create;<N>  IDList    := TQuickList.Create;<N>  IPList    := TQuickList.Create;<N>  BoFastLoading := False;<N>  //WorkingID := FALSE;<N>  //WorkingIP := FALSE;<N>  //FreeOnTerminate := TRUE;<N>  inherited Create(False);<N>end;<N><N>
destructor TThreadParseList.Destroy;<N>begin<N>  IDStrList.Free;<N>  IPStrList.Free;<N>  IDList.Free;<N>  IPList.Free;<N>  inherited Destroy;<N>end;<N><N>procedure TThreadParseList.Execute;<N>var<N>  i, n, iday, ihour: integer;<N>  str, uid, uip, sday, shour: string;<N>  rtime: longword;<N>begin<N>  rtime := 0;<N>  while True do begin<N><N>
unit MonSoc;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  ScktComp, ExtCtrls;<N><N>type<N>  TFrmMonSoc = class(TForm)<N>    MonSocket: TServerSocket;<N>    MonTimer:  TTimer;<N>    procedure FormCreate(Sender: TObject);<N>    procedure MonTimerTimer(Sender: TObject);<N>  private<N>  public<N>  end;<N><N>
var<N>  FrmMonSoc: TFrmMonSoc;<N><N>implementation<N><N>{$R *.DFM}<N><N>uses<N>  MasSock;<N><N>procedure TFrmMonSoc.FormCreate(Sender: TObject);<N>begin<N>  with MonSocket do begin<N>    Active := False;<N>    Port   := 3000;<N>    Active := True;<N>  end;<N><N>
unit MICMain;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  ExtCtrls, Grids, DBGrids, ComCtrls, ToolWin, Db, DBTables, DBCtrls,<N>  Buttons, StdCtrls, ImgList, Mask ;<N><N>const ItemDescFileName      = '.\ITEMDESC.TXT';<N>const MagicDescFileName     = '.\MAGICDESC.TXT';<N>const MonsterDescFileName   = '.\MONSTERDESC.TXT';<N>const MobItemDescFileName   = '.\MOBITEMDESC.TXT';<N><N>
unit LogDataMain;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  StdCtrls, IniFiles, ExtCtrls, IdBaseComponent, IdComponent, IdUDPBase,<N>  IdUDPServer, IdSocketHandle;<N><N>const<N>  LogBaseDir: string = 'D:\';<N><N>
type<N>  TFrmLogData = class(TForm)<N>    Label3:  TLabel;<N>    Label4:  TLabel;<N>    Timer1:  TTimer;<N>    IdUDPServer: TIdUDPServer;<N><N>    procedure FormCreate(Sender: TObject);<N>    procedure FormDestroy(Sender: TObject);<N>    procedure Timer1Timer(Sender: TObject);<N>    procedure IdUDPServerUDPRead(Sender: TObject; AData: TStream;<N>      ABinding: TIdSocketHandle);<N>  private<N>    LogList: TStringList;<N>  public<N>    procedure WriteLogs;<N>  end;<N><N>
var<N>  FrmLogData: TFrmLogData;<N><N>implementation<N><N>{$R *.DFM}<N><N><N>procedure TFrmLogData.FormCreate(Sender: TObject);<N>var<N>  ini: TIniFile;<N>begin<N>  LogList := TStringList.Create;<N><N>  ini := TIniFile.Create('.\logdata.ini');<N>  if ini <> nil then begin<N>    LogBaseDir := ini.ReadString('setup', 'basedir', LogBaseDir);<N>    FrmLogData.Caption := FrmLogData.Caption + ' (' +<N>      ini.ReadString('setup', 'caption', '') + ')';<N><N>
unit EDcode;<N><N>interface<N><N>uses<N>  Windows, SysUtils, Classes, Hutil32, Grobal2;<N><N>const<N>  ENDECODEMODE = 1;<N><N>function EncodeMessage(smsg: TDefaultMessage): AnsiString;<N>function DecodeMessage(str: AnsiString): TDefaultMessage;<N>function EncodeString(str: AnsiString): AnsiString;<N>function DecodeString(str: AnsiString): AnsiString;<N>function EncodeBuffer(buf: PAnsiChar; bufsize: integer): AnsiString;<N>procedure DecodeBuffer(src: AnsiString; buf: PAnsiChar; bufsize: integer);<N><N>
unit Grobal2;<N><N>interface<N><N>uses<N>  Windows, SysUtils, Classes, Hutil32;<N><N>type<N>  TMsgHeader = record       //����Ʈ�� ���� ��ſ� ���<N>    Code:    integer;       //$aa55aa55;<N>    SNumber: integer;       //socket number<N>    UserGateIndex: word;    //Gate������ Index<N>    Ident:   word;<N>    UserListIndex: word;    //������ UserList������ Index<N>    temp:    word;<N>    length:  integer;  //body binary �� ����<N>  end;<N>  PTMsgHeader = ^TMsgHeader;<N><N>
  TDefaultMessage = record<N>    Recog:  integer;       //4<N>    Ident:  word;          //2<N>    Param:  word;          //2<N>    Tag:    word;          //2<N>    Series: word;          //2<N>  end;<N>  PTDefaultMessage = ^TDefaultMessage;<N><N>  //Ŭ���̾�Ʈ���� ���<N>  TChrMsg = record<N>    ident:  integer;<N>    x:      integer;<N>    y:      integer;<N>    dir:    integer;<N>    feature: integer;<N>    state:  integer;<N>    saying: string;<N>    sound:  integer;<N>  end;<N>  PTChrMsg = ^TChrMsg;<N><N>
  //�������� ���<N>  TMessageInfo = record<N>    Ident:   word;<N>    wParam:  word;<N>    lParam1: longint;<N>    lParam2: longint;<N>    lParam3: longint;<N>    Sender:  TObject;<N>    target:  TObject;<N>    description: string;<N>  end;<N>  PTMessageInfo = ^TMessageInfo;<N><N>
  TMessageInfoPtr = record<N>    Ident:   word;<N>    wParam:  word;<N>    lParam1: longint;<N>    lParam2: longint;<N>    lParam3: longint;<N>    Sender:  TObject;<N>    //target  : TObject;<N>    deliverytime: longword;  //���� �ð�...<N>    descptr: PChar;<N>  end;<N>  PTMessageInfoPtr = ^TMessageInfoPtr;<N><N>
  TShortMessage = record<N>    Ident: word;<N>    msg:   word;<N>  end;<N><N>  TMessageBodyW = record<N>    Param1: word;<N>    Param2: word;<N>    Tag1:   word;<N>    Tag2:   word;<N>  end;<N><N>  TMessageBodyWL = record<N>    lParam1: longint;<N>    lParam2: longint;<N>    lTag1:   longint;<N>    lTag2:   longint;<N>  end;<N><N>
  TCharDesc = record                  // sm_walk �� �̵� ����<N>    Feature: integer;                 // 4 = (9)<N>    Status:  integer;<N>  end;<N><N>  TPowerClass = record<N>    Min:   byte;<N>    Ever:  byte;<N>    Max:   byte;<N>    dummy: byte;<N>  end;<N><N>
  TNakedAbility = record<N>    DC:    word;<N>    MC:    word;<N>    SC:    word;<N>    AC:    word;<N>    MAC:   word;<N>    HP:    word;<N>    MP:    word;<N>    Hit:   word;<N>    Speed: word;<N>    Reserved: word;<N>  end;<N>  PTNakedAbility = ^TNakedAbility;<N><N>
unit GateMain;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  syncobjs, StdCtrls, ScktComp, HUtil32, ExtCtrls, Winsock,<N>  IniFiles;<N><N>const<N>  VER_STR   = 'v040225:';<N>  MAX_USER  = 1000;<N>  MAX_CLIENTRECEIVELENGTH = 300; // 100 BYTE PER SEC<N>  MAX_CHECKSENDLENGTH = 512;<N>  MAX_RADDR = 4;<N>  //   SERVERBASEPORT = 5100;<N>  //   USERBASEPORT = 7100;<N>  ServerPort: integer = 5500;<N>  GateBasePort: integer = 7000;<N><N>
unit showip;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  StdCtrls, Buttons;<N><N>type<N>  TFrmShowIp = class(TForm)<N>    Memo:    TMemo;<N>    BitBtn1: TBitBtn;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  FrmShowIp: TFrmShowIp;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit MfdbDef;<N><N>interface<N><N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  StdCtrls, ExtCtrls, HUtil32, FileCtrl, Grobal2, MudUtil;<N><N>const<N>  IDXTITLE     = 'legend of mir database index file 2001/7';<N>  SIZEOFTHUMAN = 456;<N><N>
unit CreateId;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  StdCtrls, Buttons;<N><N>type<N>  TFrmCreateId = class(TForm)<N>    EdId:     TEdit;<N>    EdPasswd: TEdit;<N>    Label1:   TLabel;<N>    Label2:   TLabel;<N>    BitBtn1:  TBitBtn;<N>    BitBtn2:  TBitBtn;<N>    procedure FormShow(Sender: TObject);<N>  private<N>  public<N>    TItle: string;<N>    UserId, Passwd: string;<N>    function Execute: boolean;<N>  end;<N><N>
var<N>  FrmCreateId: TFrmCreateId;<N><N>implementation<N><N>{$R *.DFM}<N><N><N>function TFrmCreateId.Execute: boolean;<N>begin<N>  Result    := False;<N>  EdId.Text := '';<N>  EdPasswd.Text := '';<N>  Caption   := Title;<N>  if ShowModal = mrOk then begin<N>    UserId := Trim(EdId.Text);<N>    PassWd := Trim(EdPasswd.Text);<N>    Result := True;<N>  end;<N>end;<N><N>
unit FrmInID;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  StdCtrls, Buttons;<N><N>type<N>  TFrmInputID = class(TForm)<N>    Label1:  TLabel;<N>    EdID:    TEdit;<N>    BitBtn1: TBitBtn;<N>    BitBtn2: TBitBtn;<N>  private<N>    { Private declarations }<N>  public<N>    ID: string;<N>    function Execute: boolean;<N>  end;<N><N>
var<N>  FrmInputID: TFrmInputID;<N><N>implementation<N><N>{$R *.DFM}<N><N><N>function TFrmInputID.Execute: boolean;<N>begin<N>  Result    := False;<N>  EdID.Text := '';<N>  if ShowModal = mrOk then begin<N>    ID     := EdID.Text;<N>    Result := True;<N>  end;<N>end;<N><N>
unit IDSocCli;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  ExtCtrls, ScktComp, IniFiles, EdCode, HUtil32, Grobal2;<N><N>type<N>  TAdmission = record<N>    usrid:    string[14];<N>    ipaddr:   string[15];<N>    Certification: integer;<N>    PayMode:  integer; //0:ü�� 1:����<N>    Selected: boolean;<N>  end;<N>  PTAdmission = ^TAdmission;<N><N>
unit mudutil;<N><N>interface<N><N>uses<N>  Classes, SysUtils, Grobal2, HUtil32, IniFiles;<N><N>type<N>  TIdInfo = record<N>    uid:   string[20];<N>    uname: string[30];<N>    ridx:  integer;<N>  end;<N>  PTIdInfo = ^TIdInfo;<N><N>  TQuickList = class(TStringList)<N>  public<N>    CaseSensitive: boolean;<N>    constructor Create; dynamic;<N>    function QAdd(str: string): boolean;<N>    function QAddObject(str: string; obj: TObject): boolean;<N>    function FFind(str: string): integer;<N>  end;<N><N>
  TFindList = class(TStringList)<N>  public<N>    CaseSensitive: boolean;<N>    constructor Create(csensitive: boolean); dynamic;<N>    function FFind(str: string): integer;<N>    function FindObject(str: string; obj: TObject): integer;<N>  end;<N><N>  TQuickIdList = class(TStringList)<N>  public<N>    procedure QAdd(uid, uname: string; idx: integer);<N>    function FFind(str: string; var findlist: TList): integer;<N>    procedure DDelete(n: integer; uname: string);<N>  end;<N><N>
unit FSMemo;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  StdCtrls, Buttons;<N><N>type<N>  TFrmSysMemo = class(TForm)<N>    EdMemo:  TEdit;<N>    Label1:  TLabel;<N>    BitBtn1: TBitBtn;<N>  private<N>  public<N>    UName:   string;<N>    MemoStr: string;<N>    function Execute: boolean;<N>  end;<N><N>
var<N>  FrmSysMemo: TFrmSysMemo;<N><N>implementation<N><N>{$R *.DFM}<N><N>function TFrmSysMemo.Execute: boolean;<N>begin<N>  Label1.Caption := UName + ' : memo';<N>  EdMemo.Text    := '';<N>  ShowModal;<N>  MemoStr := EdMemo.Text;<N>  Result  := True;<N>end;<N><N>
unit HumDb;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  StdCtrls, ExtCtrls, HUtil32, FileCtrl, Grobal2, MudUtil, MfdbDef;<N><N>type<N>  THumanInfo = record<N>    ChrName:  string[14]; //key<N>    UserId:   string[10];<N>    Delete:   boolean;<N>    DeleteDate: TDouble; //TDateTime;<N>    Mark:     byte;<N>    Selected: boolean;<N>    Demmy:    array[0..2] of byte;<N>  end;<N><N>
  FHumRcd = record<N>    Deleted: boolean; {delete mark}<N>    UpdateDateTime: TDouble;<N>    Key:     string[14];<N>    Block:   THumanInfo;<N>  end;<N>  PFHumRcd = ^FHumRcd;<N><N>  FHumRcdInfo = record<N>    Deleted:  boolean; {delete mark}<N>    UpdateDateTime: TDouble;<N>    Key:      string[14];<N>    Reserved: integer; //NextSpace: integer;<N>  end;<N>  PFHumRcdInfo = ^FHumRcdInfo;<N><N>
  FDBTemp = record<N>    Deleted: boolean; {delete mark}<N>    UpdateDateTime: TDouble;<N>    Key:     string[14];<N>  end;<N>  PFDBTemp = ^FDBTemp;<N><N>  FDBHeader = record<N>    Title:     string[100];<N>    MaxCount:  integer; {record count}<N>    BlockSize: integer; {record unit size}<N>    Reserved:  integer; //FirstSpace: integer; {first space record position}<N>    UpdateDateTime: TDouble;<N>  end;<N>  PFDBHeader = ^FDBHeader;<N><N>
unit qrfilename;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  StdCtrls, Buttons;<N><N>type<N>  TFrmQueryFileName = class(TForm)<N>    EdFileName: TEdit;<N>    BitBtn1:    TBitBtn;<N>    BitBtn2:    TBitBtn;<N>    Label1:     TLabel;<N>  private<N>  public<N>    FileName: string;<N>    function Execute: boolean;<N>  end;<N><N>
var<N>  FrmQueryFileName: TFrmQueryFileName;<N><N>implementation<N><N>{$R *.DFM}<N><N><N>function TFrmQueryFileName.Execute: boolean;<N>begin<N>  if mrOk = ShowModal then begin<N>    FileName := EdFileName.Text;<N>    Result   := True;<N>  end else<N>    Result := False;<N>end;<N><N>
unit GameTool;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  Grids, Buttons, StdCtrls;<N><N>type<N>  TForm1 = class(TForm)<N>    Label1: TLabel;<N>    Edit1:  TEdit;<N>    Label2: TLabel;<N>    Edit2:  TEdit;<N>    SpeedButton1: TSpeedButton;<N>    SpeedButton2: TSpeedButton;<N>    StringGrid1: TStringGrid;<N>    StringGrid2: TStringGrid;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form1: TForm1;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit passwd;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons;<N><N>type<N>  TPasswordDlg = class(TForm)<N>    Label1:    TLabel;<N>    Password:  TEdit;<N>    OKBtn:     TButton;<N>    CancelBtn: TButton;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>    function Execute: boolean;<N>  end;<N><N>
var<N>  PasswordDlg: TPasswordDlg;<N><N>implementation<N><N>{$R *.DFM}<N><N>function TPasswordDlg.Execute: boolean;<N>begin<N>  Password.Text := '';<N>  PasswordDlg.ShowModal;<N>  if Password.Text = 'amir#05!' then<N>    Result := True<N>  else<N>    Result := False;<N>end;<N><N>
unit MasSock;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  ScktComp;<N><N>type<N>  TUserInfo = record<N>    SocStr: string;<N>    Socket: TCustomWinSocket;<N>  end;<N>  PTUserInfo = ^TUserInfo;<N><N>
unit UserMgrEngn;<N><N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Dialogs,<N>  UserMgr, CmdMgr, UserSystem, Grobal2;<N><N>type<N><N>  TUserMgrEngine = class(TThread)<N>  private<N>    FUserMgr: TUserMgr;<N>  protected<N>    procedure Execute; override;<N>  public<N>    constructor Create;<N>    destructor Destroy; override;<N><N>
    function InterGetUserInfo(UserName_: string; var UserInfo_: TUserInfo): boolean;<N><N>    procedure AddUser(UserName_: string; Recog_: integer; ConnState_: integer;<N>      GateIdx_: integer; UserGateIdx_: integer; UserHandle_: integer);<N><N>    procedure DeleteUser(UserName_: string);<N><N>
    procedure InterSendMsg(SendTarget: TSendTarget; TargetSvrIdx: integer;<N>      GateIdx: integer; UserGateIdx: integer; UserHandle: integer;<N>      UserName: string; Recog: integer; Ident: word; Param: word;<N>      Tag: word; Series: word; Body: string);<N><N>
    procedure ExternSendMsg(SendTarget: TSendTarget; TargetSvrIdx: integer;<N>      GateIdx: integer; UserGateIdx: integer; UserHandle: integer;<N>      UserName: string; msg: TDefaultMessage; body: string);<N><N><N>    procedure OnDBRead(Data: string);<N><N>
    procedure OnExternInterMsg(snum: integer; Ident: integer;<N>      UserName: string; Data: string);<N>  end;<N><N>implementation<N><N>uses<N>  svMain;<N> //------------------------------------------------------------------------------<N> // Creator ...<N> //------------------------------------------------------------------------------<N>constructor TUserMgrEngine.Create;<N>begin<N>  inherited Create(True);<N>  //FreeOnTerminate := True;<N><N>
  FUserMgr := TUserMgr.Create;<N>end;<N><N> //------------------------------------------------------------------------------<N> // Destructor ...<N> //------------------------------------------------------------------------------<N>destructor TUserMgrEngine.Destroy;<N>begin<N><N>
  FUserMgr.Free;<N><N>  inherited Destroy;<N>end;<N><N> //------------------------------------------------------------------------------<N> // Tread Execute ...<N> //------------------------------------------------------------------------------<N>procedure TUserMgrEngine.Execute;<N>begin<N>  while True do begin<N>    if Terminated then exit;<N><N>
unit showip;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>  StdCtrls, Buttons;<N><N>type<N>  TFrmShowIp = class(TForm)<N>    Memo:    TMemo;<N>    BitBtn1: TBitBtn;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  FrmShowIp: TFrmShowIp;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit List32;<N><N>{ U_IntList<N>Copyright 2001, Gary Darby, Intellitech Systems Inc., www.DelphiForFun.org<N><N> This program may be used or modified for non-commercial purposes<N> so long as this original notice remains in place.<N> All other rights are reserved<N> }<N>{ List32<N>Modified by Cardinal.<N>TIntList32: based on TIntList. changed int64 to cardinal, added IndexOfObject.<N>TList32: based on TList. added IndexOfObject.<N>}<N><N>
interface<N><N>uses Classes, sysconst, SysUtils;<N><N>const<N>  maxlistsize = maxint div 32;<N><N>type<N>  { TIntList32 class }<N>  TIntList32 = class;<N><N>  PIntItem = ^TIntItem;<N><N>  TIntItem = record<N>    FInt:    cardinal;<N>    FObject: TObject;<N>  end;<N><N>
unit uTooanClass;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N><N>  { ITooanIface }<N>  ITooanIface = interface(IUnknown)<N>  end;<N><N>  { TTooanClass }<N>  TTooanAbstractClass = class Abstract(TInterfacedObject, ITooanIface)<N>  end;<N><N>
unit uHexToStr;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>function StringToHex(str: string): string;<N>function HexToString(str: string): string;<N><N>implementation<N>//-----------------------------------------------<N>//16进制字符转整数,16进制字符与字符串转换中间函数<N>//-----------------------------------------------<N>function HexToInt(hex: string): integer;<N>var<N>  i: integer;<N><N>
unit uSerialPortPrinter;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, uDevice, uPrinter, uTooanClass;<N><N>type<N><N>  { TSerialPortPrinter }<N>  TSerialPortPrinter = class(TTooanAbstractClass, IPrinter)<N>    function GetAllPrinter: IDeviceArray;<N>    function Exists(const DevicePath: string): boolean;<N>    procedure Print(DevicePath, Content: string);<N>  end;<N><N>
<N>implementation<N><N>uses uDevGUID, serial;<N><N>{ TSerialPortPrinter }<N>function TSerialPortPrinter.GetAllPrinter: IDeviceArray;<N>begin<N>  Result := LoadDevices(GUID_DEVCLASS_PORTS);<N>end;<N><N>function TSerialPortPrinter.Exists(const DevicePath: string): boolean;<N>begin<N>  Result := True;<N>end;<N><N>
unit uParallelPortPrinter;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Windows, uDevice, uPrinter, uTooanClass, uLogger;<N><N>type<N><N>  { TParallelPortPrinter }<N>  TParallelPortPrinter = class(TTooanAbstractClass, IPrinter)<N>    function GetAllPrinter: IDeviceArray;<N>    function Exists(const DevicePath: string): boolean;<N>    procedure Print(DevicePath, Content: string);<N>  end;<N><N>
unit uNetworkPrinter;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, uDevice, uPrinter, uTooanClass;<N><N>type<N><N>  { TSerialPortPrinter }<N><N>  { TNetworkPrinter }<N><N>  TNetworkPrinter = class(TTooanAbstractClass, IPrinter)<N>    function GetAllPrinter: IDeviceArray;<N>    function Exists(const DevicePath: string): boolean;<N>    procedure Print(DevicePath, Content: string);<N>  end;<N><N>
implementation<N><N>uses<N>  LConvEncoding,<N>  IdGlobal, IdTelnet;<N><N>{ TNetworkPrinter }<N><N>function TNetworkPrinter.GetAllPrinter: IDeviceArray;<N>begin<N><N>end;<N><N>function TNetworkPrinter.Exists(const DevicePath: string): boolean;<N>begin<N><N>
unit uDriverPrinter;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Windows, winspool, uDevice, uPrinter, uTooanClass, uLogger, uWinSpoolUtils;<N><N>type<N><N>  { TDriverPrinter }<N><N>  TDriverPrinter = class(TTooanAbstractClass, IPrinter)<N>    function GetAllPrinter: IDeviceArray;<N>    function Exists(const DevicePath: string): boolean;<N>    procedure Print(DevicePath, Content: string);<N>  end;<N><N>
unit uDevice;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>uses<N>  Classes, Windows, SysUtils, fpjson, uTooanClass;<N><N>const<N>  SUCCESS_CODE: integer = 10000;<N>  UNKNOW_ERROR_CODE: integer = 99999;<N>  UNSUPPORT_PORTTYPE_ERROR_CODE: integer = 99998;<N>  INVALID_HANDLE_ERROR_CODE: integer = 99997;<N>  OPEN_PRINTER_ERROR_CODE: integer = 80000;<N>  START_DOC_PRINTER_ERROR_CODE: integer = 80001;<N>  START_PAGE_PRINTER_ERROR_CODE: integer = 80002;<N>  WRITE_PRINTER_ERROR_CODE: integer = 80003;<N><N>
type<N>  { IPrinterException }<N>  IPrinterException = interface(ITooanIface)<N>    function GetErrorCode: integer;<N>    procedure SetErrorCode(const AErrorCode: integer);<N>    property ErrorCode: integer read GetErrorCode write SetErrorCode;<N>  end;<N><N>
  { TPrinterException }<N>  TPrinterException = class(TTooanException, IPrinterException)<N>    {<N>  private<N>    FErrorCode: integer;<N>  public<N>    constructor Create(AErrorCode: integer); overload;<N>    constructor Create(AErrorCode: integer; aErrorMessage: string); overload;<N>    destructor Destroy; override;<N><N>
    function GetErrorCode: integer;<N>    procedure SetErrorCode(const AErrorCode: integer);<N><N>    property ErrorCode: integer read GetErrorCode write SetErrorCode;<N>    }<N>  end;<N><N>  { IResult }<N>  IResult = interface(ITooanIface)<N>    function GetSuccess: boolean;<N>    function GetRetCode: integer;<N>    procedure SetRetCode(const ARetCode: integer);<N>    function GetRetMessage: string;<N>    procedure SetRetMessage(const ARetMessage: string);<N>    function AsJSON: string;<N><N>
unit uWinSpoolUtils;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Windows, Classes, SysUtils, winspool, LConvEncoding, uLogger;<N><N>type<N>  TPaper = record<N>    PageSize: integer;<N>    Name: string;<N>    Width: integer;<N>    Height: integer;<N>  end;<N>  TAllPaper = array of TPaper;<N>  TAllPrinter = array of string;<N><N>
unit uPrinter;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>uses<N>  SysUtils, StrUtils, uDevice, uTooanClass;<N><N>type<N>  { IPrinter }<N>  IPrinter = interface(ITooanIface)<N>    function GetAllPrinter: IDeviceArray;<N>    function Exists(const DevicePath: string): boolean;<N>    procedure Print(DevicePath, Content: string);<N>  end;<N><N>
  { TPrinterCreateFactory }<N>  TPrinterCreateFactory = class<N>  public<N>    class  function CreatePrinter(const PortType: string): IPrinter;<N>  end;<N><N>implementation<N><N>uses<N>  uParallelPortPrinter, uSerialPortPrinter, uUSBPortPrinter, uDriverPrinter, uNetworkPrinter;<N><N>
unit uUSBPortPrinter;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>uses<N>  Classes, Windows, SysUtils, StrUtils, uDevice, uPrinter, uTooanClass, uLogger;<N><N>type<N>  { TUsbPrinter }<N>  TUsbPrinter = class(TTooanAbstractClass, IPrinter)<N>    function GetAllPrinter: IDeviceArray;<N>    function Exists(const DevicePath: string): boolean;<N>    procedure Print(DevicePath, Content: string);<N>  end;<N><N>
unit uSetupApi;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N><N>const<N>  DIF_PROPERTYCHANGE = $00000012;<N><N>const<N>  DICS_ENABLE = $00000001;<N>  DICS_DISABLE = $00000002;<N>  DICS_FLAG_GLOBAL = $00000001;  // make change in all hardware profiles<N><N>
const<N>  DIGCF_DEFAULT = $00000001;  // only valid with DIGCF_DEVICEINTERFACE<N>  DIGCF_PRESENT = $00000002;<N>  DIGCF_ALLCLASSES = $00000004;<N>  DIGCF_PROFILE = $00000008;<N>  DIGCF_DEVICEINTERFACE = $00000010;<N>  DIGCF_INTERFACEDEVICE = DIGCF_DEVICEINTERFACE;<N><N>
<N>const<N>  SPDRP_DEVICEDESC = $00000000; // DeviceDesc (R/W)<N>  SPDRP_CLASS = $00000007; // Class (R--tied to ClassGUID)<N>  SPDRP_CLASSGUID = $00000008; // ClassGUID (R/W)<N>  SPDRP_FRIENDLYNAME = $0000000C; // FriendlyName (R/W)<N><N>type<N><N>  HDEVINFO = Pointer;<N><N>
unit uSetupDiEnumDeviceInfo;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>uses<N>  Windows,<N>  uSetupApi;<N><N>type<N>  PSPDevInfoData = ^TSPDevInfoData;<N><N>  SP_DEVINFO_DATA = packed record<N>    cbSize: DWORD;<N>    ClassGuid: TGUID;<N>    DevInst: DWORD; // DEVINST handle<N>    Reserved: ULONG_PTR;<N>  end;<N>  TSPDevInfoData = SP_DEVINFO_DATA;<N><N>function SetupDiEnumDeviceInfo(DeviceInfoSet: HDEVINFO; MemberIndex: DWORD;<N>  var DeviceInfoData: TSPDevInfoData): longbool; stdcall; external 'SetupApi.dll';<N><N>implementation<N><N>end.<N>
unit uSetupDiGetInterfaceDeviceDetail;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>uses<N>  Windows,<N>  uSetupApi,<N>  uSetupDiEnumDeviceInfo,<N>  uSetupDiEnumDeviceInterfaces;<N><N>type<N>{$IFDEF UNICODE}<N>  PSPDeviceInterfaceDetailDataW = ^TSPDeviceInterfaceDetailDataW;<N><N>
unit uSetupDiEnumDeviceInterfaces;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>uses<N>  Windows,<N>  uSetupApi,<N>  uSetupDiEnumDeviceInfo;<N><N>type<N>  PSPDeviceInterfaceData = ^TSPDeviceInterfaceData;<N><N>  SP_DEVICE_INTERFACE_DATA = packed record<N>    cbSize: DWORD;<N>    InterfaceClassGuid: TGUID;<N>    Flags: DWORD;<N>    Reserved: ULONG_PTR;<N>  end;<N>  TSPDeviceInterfaceData = SP_DEVICE_INTERFACE_DATA;<N><N>
function SetupDiEnumDeviceInterfaces(DeviceInfoSet: HDEVINFO; DeviceInfoData: PSPDevInfoData;<N>  const InterfaceClassGuid: TGUID; MemberIndex: DWORD; var DeviceInterfaceData: TSPDeviceInterfaceData): BOOL;<N>  stdcall; external 'SetupApi.dll';<N><N>implementation<N><N>
unit uSetupDiDestroyDeviceInfoList;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>uses<N>  Windows,<N>  uSetupApi;<N><N>function SetupDiDestroyDeviceInfoList(DeviceInfoSet: HDEVINFO): BOOL; stdcall; external 'SetupApi.dll';<N><N>implementation<N><N>end.<N>
 uses crt;<N><N> var<N>        f : text;<N>        s : string;<N><N> begin<N> assign(f, 'fikrifiletext.txt');<N> {$I-}<N> append(f);<N> {$I+}<N> if IOResult<>0 then<N>        begin<N>        rewrite(f)<N>        end;<N> writeln(f,'fikri');<N> writeln(f,'mulyana');<N> close(f);<N><N> end.
unit Logger;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>type<N><N>  { TLogger }<N><N>  TLogger = class<N>  public<N>    procedure Log(s:string); virtual; abstract;<N><N>    class procedure Log(l:TLogger; s:string);<N>  end;<N><N>implementation<N><N>{ TLogger }<N><N>class procedure TLogger.Log(l: TLogger; s: string);<N>begin<N>     if l<>nil then begin<N>       l.Log(s);<N>     end;<N>end;<N><N>end.<N><N>
unit Calculadora.frm.principal;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.Buttons, Vcl.ExtCtrls;<N><N>type<N>  TfrmPrincipal = class(TForm)<N>    pnlPrincipal: TPanel;<N>    btnSairr: TSpeedButton;<N>    procedure btnSairrClick(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit JNIUtils;<N><N>{<N>  JNIUtils - utility methods for use with JNI.pas (JEDI).<N><N>  Written by Keith Wood (kbwood@iprimus.com.au)<N>  23 November 2002<N><N>  Updated by Remy Lebeau (remy@lebeausoftware.org)<N>  09 February 2011<N>}<N><N>interface<N><N>
uses<N>  windows,<N>  Classes, SysUtils, Variants, JNI;<N><N>const<N>  ConstructorName = '<init>';<N>  InitializerName = '<clinit>';<N><N>procedure AddCommonJavaClass(const ClassName: UTF8String); overload;<N>procedure AddCommonJavaClass(const ClassName, Shortcut: UTF8String); overload;<N><N>
unit DX12.D3D11;<N><N>{$IFDEF FPC}<N>{$MODE delphi}{$H+}<N>{$ENDIF}<N><N><N><N>interface<N><N>{$Z4}<N><N>uses<N>    Windows, Classes, SysUtils, DX12.DXGI,<N>    DX12.D3DCommon;<N><N>const<N>    DLL_D3D11 = 'd3d11.dll';<N>    D3DCompiler_DLL = 'D3dcompiler_44.dll';<N><N>
unit DX12.DXGI;<N><N>{ incldues<N>  DXGIFormat.h<N>  DXGIType.h<N>}<N><N><N>{$IFDEF FPC}<N>{$mode delphi}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$Z4}<N><N>uses<N>    Windows, Classes, SysUtils;<N><N>const<N>    DXGI_FORMAT_DEFINED = 1;<N>    DLL_DXGI = 'dxgi.dll';<N><N>
<N>{$REGION 'Copyright (C) CMC Development Team'}<N>{ **************************************************************************<N>  Copyright (C) 2015 CMC Development Team<N><N>  CMC is free software: you can redistribute it and/or modify<N>  it under the terms of the GNU General Public License as published by<N>  the Free Software Foundation, either version 2 of the License, or<N>  (at your option) any later version.<N><N>
  CMC is distributed in the hope that it will be useful,<N>  but WITHOUT ANY WARRANTY; without even the implied warranty of<N>  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<N>  GNU General Public License for more details.<N><N>  You should have received a copy of the GNU General Public License<N>  along with CMC. If not, see <http://www.gnu.org/licenses/>.<N><N>
  Commercial use of this header files is prohibited. Especially the<N>  use by Embarcadero.<N><N>  ************************************************************************** }<N><N>{ **************************************************************************<N>  Additional Copyright (C) for this modul:<N><N>
  Copyright (c) Microsoft Corporation.  All rights reserved.<N>  File name:  D3DCommon.h<N>  Header Version: 10.0.10075.0<N><N>  ************************************************************************** }<N>{$ENDREGION}<N>{$REGION 'Notes'}<N>{ **************************************************************************<N>  Use the DirectX libaries from CMC. They are NOT based on the JSB headers !<N><N>
  Version 0.9 2015.06.04 - First release<N>  ************************************************************************** }<N><N>unit DX12.D3DCommon;<N><N>{$IFDEF FPC}<N>{$mode delphi}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$Z4}<N><N>uses<N>    Windows, Classes, SysUtils;<N><N>
const<N>    IID_ID3D10Blob: TGUID = '{8BA5FB08-5195-40e2-AC58-0D989C3A0102}';<N>    IID_ID3DBlob: TGUID = '{8BA5FB08-5195-40e2-AC58-0D989C3A0102}';<N>    WKPDID_D3DDebugObjectName: TGUID = '{429b8c22-9188-4b0c-8742-acb0bf85c200}';<N>    WKPDID_D3DDebugObjectNameW: TGUID = '{4cca5fd8-921f-42c8-8566-70caf2a9b741}';<N>    WKPDID_CommentStringW: TGUID = '{d0149dc0-90e8-4ec8-8144-e900ad266bb2}';<N><N>
unit frmDonate;<N><N>interface<N><N>uses<N>  System.Classes, Vcl.Controls, Vcl.Forms, Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.Imaging.pngimage;<N><N>type<N>  TfrmDonate = class(TForm)<N>    lbl1: TLabel;<N>    img1: TImage;<N>    img2: TImage;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>procedure ShowDonateForm;<N><N>implementation<N><N>{$R *.dfm}<N><N>procedure ShowDonateForm;<N>begin<N>  with TfrmDonate.Create(nil) do<N>  begin<N>    Position := poScreenCenter;<N>    ShowModal;<N>    Free;<N>  end;<N>end;<N><N>end.<N>
﻿unit uMainForm;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.StrUtils, System.Variants, System.Classes, System.Win.Registry, System.IniFiles, System.Types, System.IOUtils, System.Diagnostics,<N>  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.FileCtrl, Vcl.Clipbrd, Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.Mask, Vcl.Buttons, Winapi.CommCtrl, JNI, JNIUtils, uCommon;<N><N>
type<N>  TfrmDelphiCallJava = class(TForm)<N>    lblJava: TLabel;<N>    procedure FormCreate(Sender: TObject);<N>  private<N>    { Public declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>procedure db_ShowDllForm_Plugins(var frm: TFormClass; var strParentModuleName, strSubModuleName: PAnsiChar); stdcall;<N><N>
implementation<N><N>{$R *.dfm}<N><N>procedure db_ShowDllForm_Plugins(var frm: TFormClass; var strParentModuleName, strSubModuleName: PAnsiChar); stdcall;<N>begin<N>  frm                     := TfrmDelphiCallJava;<N>  strParentModuleName     := '程序员工具';<N>  strSubModuleName        := 'Delphi Call Java';<N>  Application.Handle      := GetMainFormApplication.Handle;<N>  Application.Icon.Handle := GetDllModuleIconHandle(String(strParentModuleName), string(strSubModuleName));<N>end;<N><N>
function GetJavaVM: TJavaVM; stdcall; external 'PBox.exe';<N><N>procedure TfrmDelphiCallJava.FormCreate(Sender: TObject);<N>var<N>  jVM              : TJavaVM;<N>  jEnv             : TJNIEnv;<N>  strClass         : UTF8String;<N>  cls              : JClass;<N>  strMetod         : UTF8String;<N>  strSign          : UTF8String;<N>  strArg, strResult: string;<N>begin<N>  jVM := GetJavaVM;<N>  if jVM = nil then<N>  begin<N>    ShowMessage('创建 Java 虚拟机失败');<N>    Exit;<N>  end;<N><N>
  { 创建 Java 虚拟机运行环境 }<N>  jEnv := TJNIEnv.Create(jVM.Env);<N>  try<N>    if jEnv = nil then<N>    begin<N>      ShowMessage('创建 Java 虚拟机运行环境失败');<N>      Exit;<N>    end;<N><N>    { 获取 Java 类 }<N>    strClass := 'Test';<N>    cls      := jEnv.FindClass(strClass);<N>    if cls = nil then<N>    begin<N>      ShowMessage('没有找到类名');<N>      Exit;<N>    end;<N><N>
    { Java 函数名称、参数类型、参数 }<N>    strMetod := 'Hello';            // 函数名称<N>    strSign  := 'String (String)';  // 参数类型，返回值类型<N>    strArg   := 'from Delphi 11.3'; // 输入参数<N><N>    strResult := CallMethod(jEnv, cls, strMetod, strSign, [strArg], True);<N>    if strResult <> '' then<N>    begin<N>      lblJava.Caption := strResult;<N>    end;<N><N>
﻿unit uMainForm;<N>{$WARN UNIT_PLATFORM OFF}<N><N>interface<N><N>uses Winapi.Windows, System.SysUtils, System.Variants, System.Classes, System.Types, Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls, System.Diagnostics, JNI, JNIUtils, uCommon;<N><N>
﻿unit untSysSearch;<N>{$WARN UNIT_PLATFORM OFF}<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.StrUtils, System.Variants, System.Classes, System.Win.Registry, System.IniFiles, System.Types, System.IOUtils,<N>  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.FileCtrl, Vcl.Clipbrd, Vcl.StdCtrls, uCommon;<N><N>
﻿unit uMainForm;<N>{$WARN UNIT_PLATFORM OFF}<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.StrUtils, System.Variants, System.Classes, System.Win.Registry, System.IniFiles, System.Types, System.IOUtils,<N>  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.FileCtrl, Vcl.Clipbrd, Vcl.StdCtrls, uCommon;<N><N>
type<N>  TfrmCurlUI = class(TForm)<N>  private<N>    { private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>procedure db_ShowDllForm_Plugins(var frm: TFormClass; var strParentModuleName, strSubModuleName: PAnsiChar); stdcall;<N><N>
implementation<N><N>{$R *.dfm}<N><N>procedure db_ShowDllForm_Plugins(var frm: TFormClass; var strParentModuleName, strSubModuleName: PAnsiChar); stdcall;<N>begin<N>  frm                     := TfrmCurlUI;<N>  strParentModuleName     := '网络管理';<N>  strSubModuleName        := 'CurlUI';<N>  Application.Handle      := GetMainFormApplication.Handle;<N>  Application.Icon.Handle := GetDllModuleIconHandle(String(strParentModuleName), string(strSubModuleName));<N>end;<N><N>
﻿unit uProcessAPI;<N><N>interface<N><N>uses<N>  Winapi.Windows, SysUtils, PSAPI, TlHelp32;<N><N>type<N>  PROCESSENTRY32A = record<N>    Size: DWORD;<N>    Usage: DWORD;<N>    ProcessID: DWORD;<N>    DefaultHeapID: ULONG_PTR;<N>    ModuleID: DWORD;<N>    ThreadsCount: DWORD;<N>    ParentProcessID: DWORD;<N>    Priority: Longint;<N>    Flags: DWORD;<N>    ExeFile: array [0 .. MAX_PATH - 1] of AnsiChar;<N>  end;<N><N>
  TProcessEntry32A = PROCESSENTRY32A;<N><N>  THREADENTRY32 = record<N>    Size: DWORD;<N>    Usage: DWORD;<N>    ThreadID: DWORD;<N>    OwnerProcessID: DWORD;<N>    Priority: Longint;<N>    DeltaPriority: Longint;<N>    Flags: DWORD;<N>  end;<N><N>  TThreadEntry32 = THREADENTRY32;<N>  TProcessInfo   = TProcessEntry32A;<N>  TProcessList   = array of TProcessInfo;<N><N>
  TModuleInfo = record<N>    FullPath: AnsiString;<N>    ModuleName: AnsiString;<N>    BaseAddress: UInt64;<N>    EntryAddress: UInt64;<N>    SizeOfImage: Cardinal;<N>  end;<N><N>  TProcessBasicInfo = record<N>    ExitStatus: LongWord;<N>    AffinityMask: UInt64;<N>    BasePriority: LongWord;<N>    UniqueProcessId: UInt64;<N>    InheritedFromUniqueProcessId: UInt64;<N>  end;<N><N>
﻿unit uProcessManager;<N>{$WARN UNIT_PLATFORM OFF}<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.ShlObj, Winapi.ShellAPI, Winapi.ActiveX, Winapi.TlHelp32, Winapi.PsAPI, System.SysUtils, System.Classes, System.IniFiles, System.Math, System.StrUtils,<N>  Vcl.Clipbrd, Vcl.FileCtrl, Vcl.Controls, Vcl.Forms, Vcl.ComCtrls, Vcl.Menus, Vcl.StdCtrls, Vcl.Dialogs, Vcl.Graphics,<N>  uProcessAPI, uCommon;<N><N>
﻿unit uMainForm;<N>{$WARN UNIT_PLATFORM OFF}<N><N>interface<N><N>uses<N>  Winapi.Windows, System.SysUtils, System.Classes, System.IOUtils, Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtDlgs, Vcl.WinXCtrls, Vcl.ExtCtrls, Vcl.Imaging.jpeg,<N>  uCommon;<N><N>
type<N>  TfrmtxtOCR = class(TForm)<N>    srchbxFile: TSearchBox;<N>    dlgOpenPic1: TOpenPictureDialog;<N>    imgShow: TImage;<N>    grpText: TGroupBox;<N>    mmoText: TMemo;<N>    procedure srchbxFileInvokeSearch(Sender: TObject);<N>  private<N>    procedure TextRegconize(const strImageFileName: string);<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit uDM;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes;<N><N>type<N>  TDM = class(TDataModule)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  DM: TDM;<N><N>implementation<N><N>{%CLASSGROUP 'Vcl.Controls.TControl'}<N><N>{$R *.dfm}<N><N>end.<N>
unit OrderEditorForm;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.Buttons, Vcl.Mask,<N>  Vcl.DBCtrls, Vcl.ExtCtrls, DataModuleUnit, Vcl.ComCtrls;<N><N>
unit ClientEditorForm;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, DataModuleUnit, Vcl.StdCtrls,<N>  Vcl.Buttons, Data.DB, Vcl.Grids, Vcl.DBGrids, Vcl.ExtCtrls, Vcl.DBCtrls;<N><N>
type<N>  TClientEditor = class(TForm)<N>    BitBtn1: TBitBtn;<N>    DBNavigator1: TDBNavigator;<N>    DBGrid1: TDBGrid;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  ClientEditor: TClientEditor;<N><N>
unit MainUnit;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Data.DB, Vcl.Grids, Vcl.DBGrids,<N>  Vcl.ExtCtrls, Vcl.DBCtrls, DataModuleUnit, Vcl.StdCtrls, Vcl.Buttons,<N>  Vcl.ToolWin, Vcl.ActnMan, Vcl.ActnCtrls, System.Actions, Vcl.ActnList,<N>  Vcl.PlatformDefaultStyleActnCtrls;<N><N>
unit Unit3;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Data.DB, Vcl.StdCtrls, Vcl.Grids,<N>  Vcl.DBGrids, Vcl.ExtCtrls, Vcl.DBCtrls, Vcl.Buttons, Vcl.Mask;<N><N>
type<N>  TForm3 = class(TForm)<N>    DBNavigator1: TDBNavigator;<N>    DBGrid1: TDBGrid;<N>    Label1: TLabel;<N>    Label2: TLabel;<N>    DBEdit1: TDBEdit;<N>    DataSource1: TDataSource;<N>    Label3: TLabel;<N>    DBEdit2: TDBEdit;<N>    Label4: TLabel;<N>    DBEdit3: TDBEdit;<N>    Label5: TLabel;<N>    DBEdit4: TDBEdit;<N>    BitBtn1: TBitBtn;<N>    procedure BitBtn1Click(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit projeto;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Data.DB, Vcl.StdCtrls, Vcl.Buttons,<N>  Vcl.ExtCtrls, Vcl.DBCtrls, Vcl.Grids, Vcl.DBGrids, Vcl.Mask, Form1, Form2, Form3;<N><N>
type<N>  TForm1 = class(TForm)<N>    Label2: TLabel;<N>    Label3: TLabel;<N>    Label4: TLabel;<N>    DBEdit1: TDBEdit;<N>    DBEdit2: TDBEdit;<N>    DBEdit3: TDBEdit;<N>    DBGrid1: TDBGrid;<N>    DBNavigator1: TDBNavigator;<N>    BitBtn2: TBitBtn;<N>    DataSource1: TDataSource;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit unit10;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs;<N><N>type<N>  TForm1 = class(TForm)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form1: TForm1;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit Unit4;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Data.DB, Vcl.StdCtrls, Vcl.Buttons,<N>  Vcl.Mask, Vcl.DBCtrls, Vcl.Grids, Vcl.DBGrids, Vcl.ExtCtrls;<N><N>
unit Unit5;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Data.DB, Vcl.StdCtrls, Vcl.Buttons,<N>  Vcl.Mask, Vcl.DBCtrls, Vcl.Grids, Vcl.DBGrids, Vcl.ExtCtrls;<N><N>
unit Unit1;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Data.DB, Vcl.StdCtrls, Vcl.Grids,<N>  Vcl.DBGrids, Vcl.ExtCtrls, Vcl.DBCtrls, Vcl.Buttons, Vcl.Mask;<N><N>
// # [ about ]<N>// # - author : Isaac Caires<N>// # . - email : zrfisaac@gmail.com<N>// # . - site : https://sites.google.com/view/zrfisaac-en<N><N>// # [ lazarus ]<N>unit menu_main_form;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>// # - library<N>uses<N>  // # : - lazarus<N>  Classes,<N>  SysUtils,<N>  Forms,<N>  Controls,<N>  Graphics,<N>  Dialogs,<N>  ExtCtrls,<N>  Menus,<N>  ComCtrls,<N>  LCLTranslator,<N>  // # : ./source/*<N>  model_base_form;<N><N>
// # [ about ]<N>// # - author : Isaac Caires<N>// # . - email : zrfisaac@gmail.com<N>// # . - site : https://sites.google.com/view/zrfisaac-en<N><N>// # [ lazarus ]<N>unit menu_about_form;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>uses<N>  Classes,<N>  SysUtils,<N>  Forms,<N>  Controls,<N>  Graphics,<N>  Dialogs,<N>  ExtCtrls,<N>  ComCtrls,<N>  Buttons,<N>  StdCtrls,<N>  model_routine_form;<N><N>
// # [ about ]<N>// # - copyright<N>// # . - name : Isaac Caires<N>// # . - email : zrfisaac@gmail.com<N>// # . - site : https://sites.google.com/view/zrfisaac-en<N><N>// # [ lazarus ]<N>unit model_routine_form;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>
// # - library<N>uses<N>  // # : - lazarus<N>  Classes,<N>  SysUtils,<N>  Forms,<N>  Controls,<N>  Graphics,<N>  Dialogs,<N>  ExtCtrls,<N>  ComCtrls,<N>  // # : ./source/*<N>  model_base_form;<N><N>type<N><N>  { TModelRoutineForm }<N><N>  TModelRoutineForm = class(TModelBaseForm)<N>    pcBack: TPageControl;<N>    pnTitle: TPanel;<N>    procedure bt_CloseClick(Sender: TObject);<N>    procedure FormCreate(Sender: TObject);<N>  end;<N><N>
var<N>  ModelRoutineForm: TModelRoutineForm;<N><N>implementation<N><N>{$R *.lfm}<N><N>{ TModelRoutineForm }<N><N>procedure TModelRoutineForm.bt_CloseClick(Sender: TObject);<N>begin<N>  // # : - routine<N>  if (Self.pnBack.Parent = Self) then<N>    Self.Close<N>  else<N>    Self.pnBack.Parent := Self;<N>end;<N><N>
// # [ about ]<N>// # - author : Isaac Caires<N>// # . - email : zrfisaac@gmail.com<N>// # . - site : https://sites.google.com/view/zrfisaac-en<N><N>// # [ lazarus ]<N>unit menu_prn_report;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>uses<N>  Classes,<N>  SysUtils,<N>  Forms,<N>  Controls,<N>  Graphics,<N>  Dialogs,<N>  ExtCtrls,<N>  ComCtrls,<N>  RLReport,<N>  RLPDFFilter,<N>  RLXLSFilter,<N>  RLHTMLFilter,<N>  RLRichFilter,<N>  RLPreviewForm,<N>  RLPrintDialog,<N>  model_report_form;<N><N>
type<N><N>  { TMenuPrnReport }<N><N>  TMenuPrnReport = class(TModelReportForm)<N>    rlmePortrait: TRLMemo;<N>    rlmeLandscape: TRLMemo;<N>    rlPreview: TRLPreviewSetup;<N>    procedure FormCreate(Sender: TObject);<N>  end;<N><N>var<N>  MenuPrnReport: TMenuPrnReport;<N><N>
implementation<N><N>{$R *.lfm}<N><N>{ TMenuPrnReport }<N><N>procedure TMenuPrnReport.FormCreate(Sender: TObject);<N>begin<N>  // # : - variable<N>  if (MenuPrnReport = Nil) then<N>    MenuPrnReport := Self;<N><N>  // # : - inheritance<N>  inherited;<N>end;<N><N>
//# [ about ]<N>//# - author : Isaac Caires<N>//# . - email : zrfisaac@gmail.com<N>//# . - site : https://zrfisaac.github.io<N><N>//# [ lazarus ]<N>unit menu_config_form;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>uses<N>  Classes,<N>  SysUtils,<N>  Forms,<N>  Controls,<N>  Graphics,<N>  Dialogs,<N>  ExtCtrls,<N>  ComCtrls,<N>  Buttons,<N>  StdCtrls,<N>  LCLTranslator,<N>  model_routine_form;<N><N>
unit model_base_data;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>uses<N>  Classes,<N>  SysUtils;<N><N>type<N>  TModelBaseData = class(TDataModule)<N>  end;<N><N>var<N>  ModelBaseData: TModelBaseData;<N><N>implementation<N><N>{$R *.lfm}<N><N>end.<N><N>
// # [ about ]<N>// # - copyright<N>// # . - name : Isaac Caires<N>// # . - email : zrfisaac@gmail.com<N>// # . - site : https://sites.google.com/view/zrfisaac-en<N><N>// # [ lazarus ]<N>unit model_base_form;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>// # - library<N>uses<N>  // # : - lazarus<N>  Classes,<N>  SysUtils,<N>  Forms,<N>  Controls,<N>  Graphics,<N>  Dialogs,<N>  ExtCtrls;<N><N>type<N><N>  { TModelBaseForm }<N><N>  TModelBaseForm = class(TForm)<N>    pnBack: TPanel;<N>  end;<N><N>var<N>  ModelBaseForm: TModelBaseForm;<N><N>implementation<N><N>{$R *.lfm}<N><N>end.<N><N>
//# [ about ]<N>//# - author : Isaac Caires<N>//# . - email : zrfisaac@gmail.com<N>//# . - site : https://zrfisaac.github.io<N><N>//# [ lazarus ]<N>unit menu_main_data;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>uses<N>  Classes,<N>  SysUtils,<N>  Forms,<N>  Controls,<N>  Graphics,<N>  Dialogs,<N>  LCLType,<N>  IniFiles,<N>  StdCtrls,<N>  model_base_data;<N><N>
// # [ about ]<N>// # - author : Isaac Caires<N>// # . - email : zrfisaac@gmail.com<N>// # . - site : https://sites.google.com/view/zrfisaac-en<N><N>// # [ lazarus ]<N>unit menu_prn_data;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>uses<N>  Classes,<N>  SysUtils,<N>  Forms,<N>  Controls,<N>  Graphics,<N>  Dialogs,<N>  ExtDlgs, Menus,<N>  model_routine_data;<N><N>
type<N><N>  { TMenuPrnData }<N><N>  TMenuPrnData = class(TModelRoutineData)<N>    dgFile_En: TOpenDialog;<N>    dgFile_Pt: TOpenDialog;<N>    miFile_Add: TMenuItem;<N>    miFile_Delete: TMenuItem;<N>    MenuItem2: TMenuItem;<N>    miFile_Invert: TMenuItem;<N>    miFile_Uncheck: TMenuItem;<N>    miFile_Check: TMenuItem;<N>    pmFile: TPopupMenu;<N>    procedure DataModuleCreate(Sender: TObject);<N>    procedure miFile_AddClick(Sender: TObject);<N>  end;<N><N>
var<N>  MenuPrnData: TMenuPrnData;<N><N>implementation<N><N>uses<N>  menu_prn_form;<N><N>{$R *.lfm}<N><N>{ TMenuPrnData }<N><N>procedure TMenuPrnData.DataModuleCreate(Sender: TObject);<N>begin<N>  // # : - variable<N>  if (MenuPrnData = Nil) then<N>    MenuPrnData := Self;<N><N>
unit model_routine_data;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, model_base_data;<N><N>type<N>  TModelRoutineData = class(TModelBaseData)<N>  private<N><N>  public<N><N>  end;<N><N>var<N>  ModelRoutineData: TModelRoutineData;<N><N>implementation<N><N>{$R *.lfm}<N><N>end.<N><N>
unit model_report_form;<N><N>{$mode objfpc}<N>{$H+}<N><N>interface<N><N>uses<N>  Classes,<N>  SysUtils,<N>  Forms,<N>  Controls,<N>  Graphics,<N>  Dialogs,<N>  ExtCtrls,<N>  ComCtrls,<N>  RLReport,<N>  RLPDFFilter,<N>  RLXLSFilter,<N>  RLHTMLFilter,<N>  RLRichFilter,<N>  model_routine_form;<N><N>
type<N><N>  { TModelReportForm }<N><N>  TModelReportForm = class(TModelRoutineForm)<N>    rlHtml: TRLHTMLFilter;<N>    rlPdf: TRLPDFFilter;<N>    rlLandscape: TRLReport;<N>    rlPortrait: TRLReport;<N>    rlRich: TRLRichFilter;<N>    rlXls: TRLXLSFilter;<N>    sbPortrait: TScrollBox;<N>    sbLandscape: TScrollBox;<N>    tsPortrait: TTabSheet;<N>    tsLandscape: TTabSheet;<N>  private<N><N>
unit unGlobals;<N><N>interface<N><N>uses<N>  Math, Registry, cxDropDownEdit, XHelpers;<N><N>type<N>  PAppSettings = ^TAppSettings;<N>  TAppSettings = record<N>    EditorPath  : string;<N>    SaveOptions : record<N>      Dir             : string;<N>      Ext             : string;<N>      CreateOwnerDir  : Boolean;<N>      CreateTypeDir   : Boolean;<N>      OwnerInFileName : Boolean;<N>      TypeInFileName  : Boolean;<N>    end;<N>  end;<N><N>
var<N>  AppSettings: TAppSettings;<N><N>procedure SaveComboBox(R: TRegistry; Combo: TcxComboBox; SortItems: Boolean = True; ComboName: string = '');<N>procedure LoadComboBox(R: TRegistry; Combo: TcxComboBox; ComboName: string = '');<N><N>implementation<N><N>
uses<N>  unConsts;<N><N>const<N>  S_LIST_SUFFIX = '.List';<N><N>procedure SaveComboBox(R: TRegistry; Combo: TcxComboBox; SortItems: Boolean; ComboName: string);<N>var<N>  i: Integer;<N>begin<N>  if ComboName = '' then<N>    ComboName := Combo.Name;<N>  if ComboName = '' then<N>    Exit;<N><N>
  i := Combo.Properties.Items.IndexOf(Combo.Text);<N>  if (i <> -1) and SortItems then begin<N>    Combo.Text := Combo.Properties.Items[i];<N>    Combo.Properties.Items.Delete(i);<N>  end;<N><N>  Combo.Properties.Items.Insert(0, Combo.Text);<N>  R.WriteString(ComboName + S_LIST_SUFFIX, Combo.Properties.Items.DelimitedText);<N>end;<N><N>
procedure LoadComboBox(R: TRegistry; Combo: TcxComboBox; ComboName: string);<N>begin<N>  if ComboName = '' then<N>    ComboName := Combo.Name;<N>  if ComboName = '' then<N>    Exit;<N><N>  Combo.Properties.Items.DelimitedText := R.ReadString(ComboName + S_LIST_SUFFIX, Combo.Properties.Items.DelimitedText);<N>  Combo.ItemIndex                      := Min(0, Combo.Properties.Items.Count - 1);<N>  if Combo.ItemIndex = -1 then<N>    Combo.Text := '';<N>end;<N><N>
unit unConsts;<N><N>interface<N><N>const<N>  T_FUNCTION           = 1;<N>  T_JAVA_SOURCE        = 2;<N>  T_LIBRARY            = 3;<N>  T_PACKAGE            = 4;<N>  T_PACKAGE_BODY       = 5;<N>  T_PROCEDURE          = 6;<N>  T_TRIGGER            = 7;<N>  T_TYPE               = 8;<N>  T_TYPE_BODY          = 9;<N><N>
  S_PROCEDURE          = 'PROCEDURE';<N>  S_JAVA_SOURCE        = 'JAVA_SOURCE';<N>  S_LIBRARY            = 'LIBRARY';<N>  S_PACKAGE            = 'PACKAGE';<N>  S_PACKAGE_BODY       = 'PACKAGE BODY';<N>  S_TRIGGER            = 'TRIGGER';<N>  S_FUNCTION           = 'FUNCTION';<N>  S_TYPE               = 'TYPE';<N>  S_TYPE_BODY          = 'TYPE_BODY';<N><N>
  TYPE_NAMES: array [T_FUNCTION..T_TYPE_BODY] of string = (<N>    S_PROCEDURE,<N>    S_JAVA_SOURCE,<N>    S_LIBRARY,<N>    S_PACKAGE,<N>    S_PACKAGE_BODY,<N>    S_TRIGGER,<N>    S_FUNCTION,<N>    S_TYPE,<N>    S_TYPE_BODY<N>  );<N><N>  S_WRAPPED            = 'WRAPPED';<N><N>
  S_OWNER              = 'Owner';<N>  S_GRID_WIDTH         = 'Grid.Width';<N>  S_SOURCE_AREA        = 'SourceArea';<N>  S_COLOR              = 'Color';<N>  S_FONT_NAME          = 'FontName';<N>  S_FONT_SIZE          = 'FontSize';<N>  S_LINE_NUMBERS       = 'LineNumbers';<N>  S_SQL_SYNTAX         = 'SQLSyntax';<N>  S_EDITOR_PATH        = 'EditorPath';<N><N>
  S_OBJECTS_TYPES      = 'ObjectsTypes';<N><N>  S_APP_SETTINGS       = 'AppSettings';<N><N>  S_SAVE_OPTIONS       = S_APP_SETTINGS + '.SaveOptions';<N>  S_DIRECTORY          = 'Directory';<N>  S_FILE_EXT           = 'FileExt';<N>  S_OWNER_DIR          = 'CreateOwnerDir';<N>  S_TYPE_DIR           = 'CreateTypeDir';<N>  S_OWNER_IN_NAME      = 'OwnerInFileName';<N>  S_TYPE_IN_NAME       = 'TypeInFileName';<N><N>
unit UpDnEdit;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms, <N>  Dialogs, StdCtrls, ComCtrls;<N><N>type<N>  TUpDnEditBox = class(TFrame)<N>    Spinner: TUpDown;<N>    EditBox: TEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit itm_api;<N><N>{ Declarations of imported procedures from the ITM DLL engine }<N><N>interface<N><N>uses Uutils;<N><N><N>// Integrate with ITM, written in Fortran and C.  Most of the C++/Delphi<N>// integration comes courtesy of Rudy's Delphi Cornder<N>// (http://rvelthuis.de/articles/articles-cppobjs.html).<N><N>
unit CDForm;<N>{<N>   Unit:    CDForm.pas<N>   Project: TChartDialog Component<N>   Author:  L. Rossman<N>   Version: 4.0<N>   Delphi:  2010<N>   Date:    11/07/13<N><N>   This is the form unit used for the TChartDialog <N>   dialog box component (ChartDlg.pas).<N>}<N><N>
unit Controle.Impressao.Documento;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Impressao, uniScreenMask,<N>  uniGUIBaseClasses, uniImageList, uniURLFrame, uniBitBtn, uniSpeedButton,<N>  uniLabel, uniButton, uniPanel,  uniTimer;<N><N>
type<N>  TControleImpressaoDocumento = class(TControleImpressao)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>function ControleImpressaoDocumento: TControleImpressaoDocumento;<N><N>implementation<N><N>{$R *.dfm}<N><N>
uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleImpressaoDocumento: TControleImpressaoDocumento;<N>begin<N>  Result := TControleImpressaoDocumento(ControleMainModule.GetFormInstance(TControleImpressaoDocumento));<N>end;<N><N>end.<N><N><N>
unit Controle.Consulta.Modal.Pessoa.TituloPagar;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal.Pessoa, Data.DB,<N>  Data.Win.ADODB, Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses,<N>  uniImageList, uniEdit, uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniLabel;<N><N>
type<N>  TControleConsultaModalPessoaTituloPagar = class(TControleConsultaModalPessoa)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>function ControleConsultaModalPessoaTituloPagar: TControleConsultaModalPessoaTituloPagar;<N><N>
implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleConsultaModalPessoaTituloPagar: TControleConsultaModalPessoaTituloPagar;<N>begin<N>  Result := TControleConsultaModalPessoaTituloPagar(ControleMainModule.GetFormInstance(TControleConsultaModalPessoaTituloPagar));<N>end;<N><N>
unit Controle.Livre.Cheque.Imagem;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Vcl.Imaging.jpeg, uniGUIBaseClasses, uniImage;<N><N>
type<N>  TControleLivreChequeImagem = class(TUniForm)<N>    UniImage1: TUniImage;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>function ControleLivreChequeImagem: TControleLivreChequeImagem;<N><N>implementation<N><N>
{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleLivreChequeImagem: TControleLivreChequeImagem;<N>begin<N>  Result := TControleLivreChequeImagem(ControleMainModule.GetFormInstance(TControleLivreChequeImagem));<N>end;<N><N>
unit Controle.Consulta.Modal.Pessoa;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal, Data.DB, Data.Win.ADODB,<N>  Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses, uniImageList,<N>  uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniEdit, uniLabel, uniBitBtn,<N>  uniSpeedButton;<N><N>
unit Controle.Consulta.Modal.Convenio;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal, Data.DB, Data.Win.ADODB,<N>  Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses, uniImageList,<N>  uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniEdit;<N><N>
type<N>  TControleConsultaModalConvenio = class(TControleConsultaModal)<N>    UniEdit2: TUniEdit;<N>    QryConsultaID: TFloatField;<N>    QryConsultaDESCRICAO: TWideStringField;<N>    CdsConsultaID: TFloatField;<N>    CdsConsultaDESCRICAO: TWideStringField;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleConsultaModalConvenio: TControleConsultaModalConvenio;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  MainModule, uniGUIApplication;<N><N>function ControleConsultaModalConvenio: TControleConsultaModalConvenio;<N>begin<N>  Result := TControleConsultaModalConvenio(UniMainModule.GetFormInstance(TControleConsultaModalConvenio));<N>end;<N><N>
unit Controle.Consulta.Modal.ContaBancaria;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal, Data.DB, Data.Win.ADODB,<N>  Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses, uniImageList,<N>  uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniEdit, uniBitBtn,<N>  uniSpeedButton, uniLabel;<N><N>
unit Controle.Consulta.Modal.TituloCategoria.Receber;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal, Data.DB, Data.Win.ADODB,<N>  Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses, uniImageList,<N>  uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniEdit, uniLabel;<N><N>
type<N>  TControleConsultaModalTituloCategoriaReceber = class(TControleConsultaModal)<N>    QryConsultaID: TFloatField;<N>    QryConsultaDESCRICAO: TWideStringField;<N>    QryConsultaTIPO_TITULO: TWideStringField;<N>    CdsConsultaID: TFloatField;<N>    CdsConsultaDESCRICAO: TWideStringField;<N>    CdsConsultaTIPO_TITULO: TWideStringField;<N>    UniEdit1: TUniEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleConsultaModalTituloCategoriaReceber: TControleConsultaModalTituloCategoriaReceber;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleConsultaModalTituloCategoriaReceber: TControleConsultaModalTituloCategoriaReceber;<N>begin<N>  Result := TControleConsultaModalTituloCategoriaReceber(ControleMainModule.GetFormInstance(TControleConsultaModalTituloCategoriaReceber));<N>end;<N><N>
unit Controle.Operacoes.ConferenciaAssinatura;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Operacoes, Data.Win.ADODB,<N>  Datasnap.Provider, Data.DB, Datasnap.DBClient, uniGUIBaseClasses,<N>  uniImageList, uniBitBtn, uniSpeedButton, uniLabel, uniButton, uniPanel,<N>  uniImage;<N><N>
unit Controle.Consulta.Modal.Produto;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal, Data.DB, Data.Win.ADODB,<N>  Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses, uniImageList,<N>  uniLabel, uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniEdit;<N><N>
unit Controle.Imagem.Informacao;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, uniLabel, uniButton, uniGUIBaseClasses, uniMemo;<N><N>
type<N>  TControleImagemInformacao = class(TUniForm)<N>    UniMemo1: TUniMemo;<N>    UniButton1: TUniButton;<N>    UniLabel1: TUniLabel;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>implementation<N><N>uses<N>  uniGUIApplication;<N><N>
unit Controle.Consulta.Modal.Pessoa.TituloReceber;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal.Pessoa, Data.DB,<N>  Data.Win.ADODB, Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses,<N>  uniImageList, uniEdit, uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniLabel,<N>  uniBitBtn, uniSpeedButton, uniMultiItem, uniComboBox;<N><N>
unit Controle.Modal.Ajuda;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, uniSyntaxEditorBase, uniSyntaxEditor,<N>  uniGUIBaseClasses, uniURLFrame, uniButton, uniTimer, uniPanel, uniScreenMask,<N>  uniHTMLFrame;<N><N>
type<N>  TControleModalAjuda = class(TUniForm)<N>    UniTimer1: TUniTimer;<N>    UniScreenMask1: TUniScreenMask;<N>    UniHTMLFrame1: TUniHTMLFrame;<N>    procedure UniTimer1Timer(Sender: TObject);<N>    procedure UniURLFrame1FrameLoaded(Sender: TObject);<N><N>
  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>function ControleModalAjuda: TControleModalAjuda;<N><N>implementation<N><N>uses<N>  Controle.Main.Module, uniGUIApplication, Controle.Funcoes;<N><N>function ControleModalAjuda: TControleModalAjuda;<N>begin<N>  Result := TControleModalAjuda(ControleMainModule.GetFormInstance(TControleModalAjuda));<N>end;<N><N>
<N>{$R *.dfm}<N><N><N>procedure TControleModalAjuda.UniTimer1Timer(Sender: TObject);<N>begin<N>  UniTimer1.Enabled := False;<N>//  UniURLFrame1.HTML.Text := UniSyntaxEdit1.Text;<N>end;<N><N>procedure TControleModalAjuda.UniURLFrame1FrameLoaded(Sender: TObject);<N>begin<N>  // tem que ter alguma coisa para processar o aguarde, nemq ue seja comentado<N>end;<N><N>
unit Controle.Operacoes.logout;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, uniGUIBaseClasses, uniButton, uniImageList,<N>  uniImage, uniLabel;<N><N>
type<N>  TControleOperacoesLogout = class(TUniForm)<N>    UniImage1: TUniImage;<N>    UniLabel1: TUniLabel;<N>    UniButton1: TUniButton;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>implementation<N><N>
unit Controle.Mensagem.Erro;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, uniGUIBaseClasses, uniMemo, uniImageList,<N>  uniButton, uniBitBtn, uniSpeedButton, uniLabel, uniPanel;<N><N>
type<N>  TControleMensagemErro = class(TUniForm)<N>    UniMemo1: TUniMemo;<N>    UniPanel1: TUniPanel;<N>    UniPanel21: TUniPanel;<N>    UniPanelCaption: TUniPanel;<N>    UniLabelCaption: TUniLabel;<N>    UniSpeedCaptionClose: TUniSpeedButton;<N>    UniImageCaptionClose: TUniImageList;<N>    procedure UniSpeedCaptionCloseClick(Sender: TObject);<N>    procedure UniFormCreate(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleMensagemErro: TControleMensagemErro;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleMensagemErro: TControleMensagemErro;<N>begin<N>  Result := TControleMensagemErro(ControleMainModule.GetFormInstance(TControleMensagemErro));<N>end;<N><N>
unit Controle.Operacoes;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, uniBitBtn, uniSpeedButton, uniLabel, uniButton,<N>  uniGUIBaseClasses, uniPanel, Data.Win.ADODB, Datasnap.Provider, Data.DB,<N>  Datasnap.DBClient, uniImageList;<N><N>
unit Controle.Operacoes.Relatorio;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Operacoes, Data.Win.ADODB,<N>  Datasnap.Provider, Data.DB, Datasnap.DBClient, uniGUIBaseClasses,<N>  uniImageList, uniBitBtn, uniSpeedButton, uniLabel, uniButton, uniPanel,<N>  uniEdit, uniDateTimePicker, uniMultiItem, uniComboBox;<N><N>
type<N>  TControleOperacoes1 = class(TControleOperacoes)<N>    UniDateTimePicker1: TUniDateTimePicker;<N>    UniDateTimePicker2: TUniDateTimePicker;<N>    UniEdit1: TUniEdit;<N>    UniLabel2: TUniLabel;<N>    UniButton1: TUniButton;<N>    UniLabel3: TUniLabel;<N>    UniLabel4: TUniLabel;<N>    UniComboBox1: TUniComboBox;<N>    UniLabel1: TUniLabel;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleOperacoes1: TControleOperacoes1;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleOperacoes1: TControleOperacoes1;<N>begin<N>  Result := TControleOperacoes1(ControleMainModule.GetFormInstance(TControleOperacoes1));<N>end;<N><N>
unit Controle.Consulta.Modal.CPFCliente;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal, Data.DB, Data.Win.ADODB,<N>  Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses, uniImageList,<N>  uniPanel, uniBasicGrid, uniDBGrid, uniBitBtn, uniSpeedButton, uniLabel,<N>  uniButton, uniEdit;<N><N>
type<N>  TControleConsultaModalCPFCliente = class(TControleConsultaModal)<N>    UniEditCPF: TUniEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>function ControleConsultaModalCPFCliente: TControleConsultaModalCPFCliente;<N><N>
implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleConsultaModalCPFCliente: TControleConsultaModalCPFCliente;<N>begin<N>  Result := TControleConsultaModalCPFCliente(ControleMainModule.GetFormInstance(TControleConsultaModalCPFCliente));<N>end;<N><N>
unit Controle.Relatorio.ContasPagarObservacao;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIFrame, Controle.Relatorio.Cadastro.ContasPagar, frxClass,<N>  frxDBSet, uniGUIBaseClasses, uniImageList, Data.DB, Datasnap.Provider,<N>  Data.Win.ADODB, Datasnap.DBClient, uniButton, uniGroupBox, uniEdit,<N>  uniCheckBox, uniBitBtn, uniLabel, uniPanel, uniScrollBox;<N><N>
unit Controle.Consulta.Modal.TipoTitulo;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal, Data.DB, Data.Win.ADODB,<N>  Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses, uniImageList,<N>  uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniEdit, uniLabel, uniBitBtn,<N>  uniSpeedButton;<N><N>
type<N>  TControleConsultaModalTipoTitulo = class(TControleConsultaModal)<N>    CdsConsultaID: TFloatField;<N>    CdsConsultaDESCRICAO: TWideStringField;<N>    CdsConsultaPREFIXO: TWideStringField;<N>    CdsConsultaGERA_BOLETO: TWideStringField;<N>    CdsConsultaATIVO: TWideStringField;<N>    UniEdit1: TUniEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleConsultaModalTipoTitulo: TControleConsultaModalTipoTitulo;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleConsultaModalTipoTitulo: TControleConsultaModalTipoTitulo;<N>begin<N>  Result := TControleConsultaModalTipoTitulo(ControleMainModule.GetFormInstance(TControleConsultaModalTipoTitulo));<N>end;<N><N>
unit Controle.Relatorio.Cadastro;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIFrame, uniLabel, uniButton, uniGUIBaseClasses, uniPanel,<N>  Data.DB, Datasnap.Provider, Data.Win.ADODB, Datasnap.DBClient, uniImageList,<N>  frxClass, frxExportBaseDialog, frxExportPDF, frxDBSet, Controle.Server.Module,<N>  uniScrollBox;<N><N>
unit Controle.Cadastro.VinculoUsuario;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Cadastro, Data.DB, Datasnap.DBClient,<N>  Datasnap.Provider, Data.Win.ADODB, uniGUIBaseClasses, uniImageList, uniButton,<N>  uniPanel, uniMultiItem, uniComboBox, uniDBComboBox, uniDBLookupComboBox,<N>  uniLabel;<N><N>
type<N>  TControleCadastroVinculoUsuario = class(TControleCadastro)<N>    UniLabel1: TUniLabel;<N>    UniDBLookupComboBox1: TUniDBLookupComboBox;<N>    UniLabel3: TUniLabel;<N>    UniDBLookupComboBox2: TUniDBLookupComboBox;<N>    DscUsuario: TDataSource;<N>    ClientDataSet1: TClientDataSet;<N>    DataSetProvider1: TDataSetProvider;<N>    ADOQuery1: TADOQuery;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleCadastroVinculoUsuario: TControleCadastroVinculoUsuario;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  MainModule, uniGUIApplication;<N><N>function ControleCadastroVinculoUsuario: TControleCadastroVinculoUsuario;<N>begin<N>  Result := TControleCadastroVinculoUsuario(UniMainModule.GetFormInstance(TControleCadastroVinculoUsuario));<N>end;<N><N>
unit Controle.Livre.WhatsApp;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIFrame, Controle.Livre, uniGUIBaseClasses;<N><N>type<N>  TControleLivre1 = class(TControleLivre)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>implementation<N><N>{$R *.dfm}<N><N><N><N>end.<N>
unit Controle.Consulta.ProdutoCategoria;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIFrame, Controle.Consulta.TreeView, <N>  Data.DB, Data.Win.ADODB, Datasnap.Provider, Datasnap.DBClient,<N>  uniGUIBaseClasses, uniImageList, uniLabel, uniTreeView, uniButton, uniPanel;<N><N>
unit Controle.Envia.Mensagem.Aguarde;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, uniGUIBaseClasses, uniLabel, uniProgressBar,<N>  Vcl.Imaging.pngimage, uniImage;<N><N>
type<N>  TControleEnviaMensagemAguarde = class(TUniForm)<N>    UniLabel3: TUniLabel;<N>    UniProgressBar1: TUniProgressBar;<N>    UniImage1: TUniImage;<N>    UniLabel2: TUniLabel;<N>    UniLabel4: TUniLabel;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleEnviaMensagemAguarde: TControleEnviaMensagemAguarde;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleEnviaMensagemAguarde: TControleEnviaMensagemAguarde;<N>begin<N>  Result := TControleEnviaMensagemAguarde(ControleMainModule.GetFormInstance(TControleEnviaMensagemAguarde));<N>end;<N><N>
unit Controle.Consulta.Modal.TituloCategoria.Pagar;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Controle.Consulta.Modal, Data.DB,<N>  Data.Win.ADODB, Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses,<N>  uniGUIClasses, uniImageList, uniPanel, uniBasicGrid, uniDBGrid, uniButton,<N>  uniEdit, uniLabel;<N><N>
type<N>  TControleConsultaModalTituloCategoriaPagar = class(TControleConsultaModal)<N>    QryConsultaID: TFloatField;<N>    QryConsultaDESCRICAO: TWideStringField;<N>    QryConsultaTIPO_TITULO: TWideStringField;<N>    CdsConsultaID: TFloatField;<N>    CdsConsultaDESCRICAO: TWideStringField;<N>    CdsConsultaTIPO_TITULO: TWideStringField;<N>    UniEdit1: TUniEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleConsultaModalTituloCategoriaPagar: TControleConsultaModalTituloCategoriaPagar;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleConsultaModalTituloCategoriaPagar: TControleConsultaModalTituloCategoriaPagar;<N>begin<N>  Result := TControleConsultaModalTituloCategoriaPagar(ControleMainModule.GetFormInstance(TControleConsultaModalTituloCategoriaPagar));<N>end;<N><N>
unit Controle.Relatorio.Cadastro.FluxoCaixa;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIFrame, Controle.Relatorio.Cadastro, uniDateTimePicker,<N>  uniGroupBox, uniBitBtn, uniEdit, uniCheckBox, uniGUIBaseClasses, uniImageList,<N>  Data.DB, Datasnap.Provider, Data.Win.ADODB, Datasnap.DBClient, uniButton,<N>  uniLabel, uniPanel, uniScrollBox;<N><N>
unit Controle.Operacoes.Caixa;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Operacoes,  Data.Win.ADODB,<N>  Datasnap.Provider, Data.DB, Datasnap.DBClient, uniGUIBaseClasses,<N>  uniImageList, uniBitBtn, uniSpeedButton, uniLabel, uniButton, uniPanel;<N><N>
type<N>  TControleOperacoesCaixa = class(TControleOperacoes)<N>    UniButton1: TUniButton;<N>    UniButton2: TUniButton;<N>    UniButton3: TUniButton;<N>    UniImageList3: TUniImageList;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleOperacoesCaixa: TControleOperacoesCaixa;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleOperacoesCaixa: TControleOperacoesCaixa;<N>begin<N>  Result := TControleOperacoesCaixa(ControleMainModule.GetFormInstance(TControleOperacoesCaixa));<N>end;<N><N>
unit Controle.Envia.Whatsapp;<N><N>interface<N><N>uses<N>  Funcoes.client;<N><N><N>type<N>  TrecebeRetorno = class<N>  private<N>    FnRetorno: TRetornos;<N>    procedure SetnRetorno(const Value: TRetornos);<N>  published<N>    property nRetorno : TRetornos read FnRetorno write SetnRetorno;<N>  end;<N><N>
type<N>  TBase64 = class<N>  private<N>    FArquivoBase64: string;<N>  published<N>    property ArquivoBase64: string read FArquivoBase64 write FArquivoBase64;<N>  end;<N><N>var<N>  ControleEnviaWhatsapp : Controle.Envia.Whatsapp;<N><N>implementation<N><N>
unit Controle.Livre;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIFrame, uniGUIBaseClasses, UniSFSweetAlert;<N><N>type<N>  TControleLivre = class(TUniFrame)<N>    AlertaLivre: TUniSFSweetAlert;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleLivre: TControleLivre;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  uniGUIApplication, Controle.Main.Module, Controle.Funcoes, System.TypInfo;<N><N>function ControleLivre: TControleLivre;<N>begin<N>  Result := TControleLivre(ControleMainModule.GetFormInstance(TControleLivre));<N>end;<N><N>
unit Client.Aguarde;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, uniProgressBar, uniGUIBaseClasses, uniLabel;<N><N>type<N>  TClientAguarde = class(TUniForm)<N>    UniLabel1: TUniLabel;<N>    UniProgressBar1: TUniProgressBar;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ClientAguarde: TClientAguarde;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ClientAguarde: TClientAguarde;<N>begin<N>  Result := TClientAguarde(ControleMainModule.GetFormInstance(TClientAguarde));<N>end;<N><N>
unit Controle.Consulta.Modal.Banco;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal, Data.DB, Data.Win.ADODB,<N>  Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses, uniImageList,<N>  uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniEdit, uniLabel, uniBitBtn,<N>  uniSpeedButton;<N><N>
type<N>  TControleConsultaModalBanco = class(TControleConsultaModal)<N>    UniEdit1: TUniEdit;<N>    UniEdit2: TUniEdit;<N>    UniEdit3: TUniEdit;<N>    CdsConsultaID: TFloatField;<N>    CdsConsultaCODIGO: TWideStringField;<N>    CdsConsultaATIVO: TWideStringField;<N>    CdsConsultaCPF_CNPJ: TWideStringField;<N>    CdsConsultaRAZAO_SOCIAL: TWideStringField;<N>    CdsConsultaNOME_FANTASIA: TWideStringField;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleConsultaModalBanco: TControleConsultaModalBanco;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleConsultaModalBanco: TControleConsultaModalBanco;<N>begin<N>  Result := TControleConsultaModalBanco(ControleMainModule.GetFormInstance(TControleConsultaModalBanco));<N>end;<N><N>
unit Controle.Consulta.VideoTutoriais;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIFrame, Controle.Consulta,  frxClass, frxDBSet,<N>  frxExportBaseDialog, frxExportPDF, uniGridExporters, uniBasicGrid,<N>   Data.DB, Data.Win.ADODB, Datasnap.Provider,<N>  Datasnap.DBClient, uniGUIBaseClasses, uniImageList, uniCheckBox, uniLabel,<N>  uniPanel, uniDBGrid, uniBitBtn,  uniButton;<N><N>
unit Controle.Consulta.Modal.Cidade;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal, Data.DB, Data.Win.ADODB,<N>  Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses, uniImageList,<N>  uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniEdit, uniLabel, uniBitBtn,<N>  uniSpeedButton;<N><N>
type<N>  TControleConsultaModalCidade = class(TControleConsultaModal)<N>    CdsConsultaID: TFloatField;<N>    CdsConsultaNOME: TWideStringField;<N>    CdsConsultaCODIGO_IBGE: TWideStringField;<N>    CdsConsultaUF: TWideStringField;<N>    UniEdit1: TUniEdit;<N>    UniEdit2: TUniEdit;<N>    UniEdit3: TUniEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleConsultaModalCidade: TControleConsultaModalCidade;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleConsultaModalCidade: TControleConsultaModalCidade;<N>begin<N>  Result := TControleConsultaModalCidade(ControleMainModule.GetFormInstance(TControleConsultaModalCidade));<N>end;<N><N>
unit Controle.Consulta.GerarDocumento;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, uniButton, uniGUIBaseClasses, uniRadioGroup;<N><N>
type<N>  TControleConsultaGerarDocumento = class(TUniForm)<N>    UniRadioGroupExporta1: TUniRadioGroup;<N>    UniButtonConfirmaExportacao: TUniButton;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>function ControleConsultaGerarDocumento: TControleConsultaGerarDocumento;<N><N>
implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleConsultaGerarDocumento: TControleConsultaGerarDocumento;<N>begin<N>  Result := TControleConsultaGerarDocumento(ControleMainModule.GetFormInstance(TControleConsultaGerarDocumento));<N>end;<N><N>
unit ServerModule;<N><N>interface<N><N>uses<N>  Classes, SysUtils, uniGUIServer, uniGUIMainModule, uniGUIApplication, uIdCustomHTTPServer,<N>  uniGUITypes;<N><N>type<N>  TUniServerModule = class(TUniGUIServerModule)<N>  private<N>    { Private declarations }<N>  protected<N>    procedure FirstInit; override;<N>  public<N>    { Public declarations }<N>  end;<N><N>
function UniServerModule: TUniServerModule;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  UniGUIVars;<N><N>function UniServerModule: TUniServerModule;<N>begin<N>  Result:=TUniServerModule(UniGUIServerInstance);<N>end;<N><N>procedure TUniServerModule.FirstInit;<N>begin<N>  InitServerModule(Self);<N>end;<N><N>
unit Base.Dados;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes;<N><N>type<N>  TDataModule1 = class(TDataModule)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  DataModule1: TDataModule1;<N><N>implementation<N><N>{%CLASSGROUP 'Vcl.Controls.TControl'}<N><N>{$R *.dfm}<N><N>end.<N>
unit Controle.Impressao.Documento;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Impressao, uniScreenMask,<N>  uniGUIBaseClasses, uniImageList, uniURLFrame, uniBitBtn, uniSpeedButton,<N>  uniLabel, uniButton, uniPanel,  uniTimer;<N><N>
type<N>  TControleImpressaoDocumento = class(TControleImpressao)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>function ControleImpressaoDocumento: TControleImpressaoDocumento;<N><N>implementation<N><N>{$R *.dfm}<N><N>
uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleImpressaoDocumento: TControleImpressaoDocumento;<N>begin<N>  Result := TControleImpressaoDocumento(ControleMainModule.GetFormInstance(TControleImpressaoDocumento));<N>end;<N><N>end.<N><N><N>
unit Controle.Consulta.Modal.Pessoa.TituloPagar;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal.Pessoa, Data.DB,<N>  Data.Win.ADODB, Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses,<N>  uniImageList, uniEdit, uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniLabel;<N><N>
type<N>  TControleConsultaModalPessoaTituloPagar = class(TControleConsultaModalPessoa)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>function ControleConsultaModalPessoaTituloPagar: TControleConsultaModalPessoaTituloPagar;<N><N>
implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleConsultaModalPessoaTituloPagar: TControleConsultaModalPessoaTituloPagar;<N>begin<N>  Result := TControleConsultaModalPessoaTituloPagar(ControleMainModule.GetFormInstance(TControleConsultaModalPessoaTituloPagar));<N>end;<N><N>
unit Controle.Livre.Cheque.Imagem;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Vcl.Imaging.jpeg, uniGUIBaseClasses, uniImage;<N><N>
type<N>  TControleLivreChequeImagem = class(TUniForm)<N>    UniImage1: TUniImage;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>function ControleLivreChequeImagem: TControleLivreChequeImagem;<N><N>implementation<N><N>
{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleLivreChequeImagem: TControleLivreChequeImagem;<N>begin<N>  Result := TControleLivreChequeImagem(ControleMainModule.GetFormInstance(TControleLivreChequeImagem));<N>end;<N><N>
unit Controle.Consulta.Modal.Pessoa;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal, Data.DB, Data.Win.ADODB,<N>  Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses, uniImageList,<N>  uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniEdit, uniLabel, uniBitBtn,<N>  uniSpeedButton;<N><N>
unit Controle.Consulta.Modal.Convenio;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal, Data.DB, Data.Win.ADODB,<N>  Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses, uniImageList,<N>  uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniEdit;<N><N>
type<N>  TControleConsultaModalConvenio = class(TControleConsultaModal)<N>    UniEdit2: TUniEdit;<N>    QryConsultaID: TFloatField;<N>    QryConsultaDESCRICAO: TWideStringField;<N>    CdsConsultaID: TFloatField;<N>    CdsConsultaDESCRICAO: TWideStringField;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleConsultaModalConvenio: TControleConsultaModalConvenio;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  MainModule, uniGUIApplication;<N><N>function ControleConsultaModalConvenio: TControleConsultaModalConvenio;<N>begin<N>  Result := TControleConsultaModalConvenio(UniMainModule.GetFormInstance(TControleConsultaModalConvenio));<N>end;<N><N>
unit Controle.Consulta.Modal.ContaBancaria;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal, Data.DB, Data.Win.ADODB,<N>  Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses, uniImageList,<N>  uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniEdit, uniBitBtn,<N>  uniSpeedButton, uniLabel;<N><N>
unit Controle.Consulta.Modal.TituloCategoria.Receber;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal, Data.DB, Data.Win.ADODB,<N>  Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses, uniImageList,<N>  uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniEdit, uniLabel;<N><N>
type<N>  TControleConsultaModalTituloCategoriaReceber = class(TControleConsultaModal)<N>    QryConsultaID: TFloatField;<N>    QryConsultaDESCRICAO: TWideStringField;<N>    QryConsultaTIPO_TITULO: TWideStringField;<N>    CdsConsultaID: TFloatField;<N>    CdsConsultaDESCRICAO: TWideStringField;<N>    CdsConsultaTIPO_TITULO: TWideStringField;<N>    UniEdit1: TUniEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleConsultaModalTituloCategoriaReceber: TControleConsultaModalTituloCategoriaReceber;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleConsultaModalTituloCategoriaReceber: TControleConsultaModalTituloCategoriaReceber;<N>begin<N>  Result := TControleConsultaModalTituloCategoriaReceber(ControleMainModule.GetFormInstance(TControleConsultaModalTituloCategoriaReceber));<N>end;<N><N>
unit Controle.Operacoes.ConferenciaAssinatura;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Operacoes, Data.Win.ADODB,<N>  Datasnap.Provider, Data.DB, Datasnap.DBClient, uniGUIBaseClasses,<N>  uniImageList, uniBitBtn, uniSpeedButton, uniLabel, uniButton, uniPanel,<N>  uniImage;<N><N>
unit Controle.Consulta.Modal.Produto;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal, Data.DB, Data.Win.ADODB,<N>  Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses, uniImageList,<N>  uniLabel, uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniEdit;<N><N>
unit Controle.Imagem.Informacao;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, uniLabel, uniButton, uniGUIBaseClasses, uniMemo;<N><N>
type<N>  TControleImagemInformacao = class(TUniForm)<N>    UniMemo1: TUniMemo;<N>    UniButton1: TUniButton;<N>    UniLabel1: TUniLabel;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>implementation<N><N>uses<N>  uniGUIApplication;<N><N>
unit Controle.Consulta.Modal.Pessoa.TituloReceber;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal.Pessoa, Data.DB,<N>  Data.Win.ADODB, Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses,<N>  uniImageList, uniEdit, uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniLabel,<N>  uniBitBtn, uniSpeedButton;<N><N>
unit Controle.Modal.Ajuda;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, uniSyntaxEditorBase, uniSyntaxEditor,<N>  uniGUIBaseClasses, uniURLFrame, uniButton, uniTimer, uniPanel, uniScreenMask,<N>  uniHTMLFrame;<N><N>
type<N>  TControleModalAjuda = class(TUniForm)<N>    UniTimer1: TUniTimer;<N>    UniScreenMask1: TUniScreenMask;<N>    UniHTMLFrame1: TUniHTMLFrame;<N>    procedure UniTimer1Timer(Sender: TObject);<N>    procedure UniURLFrame1FrameLoaded(Sender: TObject);<N><N>
  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>function ControleModalAjuda: TControleModalAjuda;<N><N>implementation<N><N>uses<N>  Controle.Main.Module, uniGUIApplication, Controle.Funcoes;<N><N>function ControleModalAjuda: TControleModalAjuda;<N>begin<N>  Result := TControleModalAjuda(ControleMainModule.GetFormInstance(TControleModalAjuda));<N>end;<N><N>
<N>{$R *.dfm}<N><N><N>procedure TControleModalAjuda.UniTimer1Timer(Sender: TObject);<N>begin<N>  UniTimer1.Enabled := False;<N>//  UniURLFrame1.HTML.Text := UniSyntaxEdit1.Text;<N>end;<N><N>procedure TControleModalAjuda.UniURLFrame1FrameLoaded(Sender: TObject);<N>begin<N>  // tem que ter alguma coisa para processar o aguarde, nemq ue seja comentado<N>end;<N><N>
unit Controle.Operacoes.logout;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, uniGUIBaseClasses, uniButton, uniImageList,<N>  uniImage, uniLabel;<N><N>
type<N>  TControleOperacoesLogout = class(TUniForm)<N>    UniImage1: TUniImage;<N>    UniLabel1: TUniLabel;<N>    UniButton1: TUniButton;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>implementation<N><N>
unit Controle.Mensagem.Erro;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, uniGUIBaseClasses, uniMemo, uniImageList,<N>  uniButton, uniBitBtn, uniSpeedButton, uniLabel, uniPanel;<N><N>
type<N>  TControleMensagemErro = class(TUniForm)<N>    UniMemo1: TUniMemo;<N>    UniPanel1: TUniPanel;<N>    UniPanel21: TUniPanel;<N>    UniPanelCaption: TUniPanel;<N>    UniLabelCaption: TUniLabel;<N>    UniSpeedCaptionClose: TUniSpeedButton;<N>    UniImageCaptionClose: TUniImageList;<N>    procedure UniSpeedCaptionCloseClick(Sender: TObject);<N>    procedure UniFormCreate(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleMensagemErro: TControleMensagemErro;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleMensagemErro: TControleMensagemErro;<N>begin<N>  Result := TControleMensagemErro(ControleMainModule.GetFormInstance(TControleMensagemErro));<N>end;<N><N>
unit Controle.Operacoes;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, uniBitBtn, uniSpeedButton, uniLabel, uniButton,<N>  uniGUIBaseClasses, uniPanel, Data.Win.ADODB, Datasnap.Provider, Data.DB,<N>  Datasnap.DBClient, uniImageList;<N><N>
unit Controle.Operacoes.Relatorio;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Operacoes, Data.Win.ADODB,<N>  Datasnap.Provider, Data.DB, Datasnap.DBClient, uniGUIBaseClasses,<N>  uniImageList, uniBitBtn, uniSpeedButton, uniLabel, uniButton, uniPanel,<N>  uniEdit, uniDateTimePicker, uniMultiItem, uniComboBox;<N><N>
type<N>  TControleOperacoes1 = class(TControleOperacoes)<N>    UniDateTimePicker1: TUniDateTimePicker;<N>    UniDateTimePicker2: TUniDateTimePicker;<N>    UniEdit1: TUniEdit;<N>    UniLabel2: TUniLabel;<N>    UniButton1: TUniButton;<N>    UniLabel3: TUniLabel;<N>    UniLabel4: TUniLabel;<N>    UniComboBox1: TUniComboBox;<N>    UniLabel1: TUniLabel;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleOperacoes1: TControleOperacoes1;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleOperacoes1: TControleOperacoes1;<N>begin<N>  Result := TControleOperacoes1(ControleMainModule.GetFormInstance(TControleOperacoes1));<N>end;<N><N>
unit Controle.Consulta.Modal.TipoTitulo;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal, Data.DB, Data.Win.ADODB,<N>  Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses, uniImageList,<N>  uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniEdit, uniLabel, uniBitBtn,<N>  uniSpeedButton;<N><N>
type<N>  TControleConsultaModalTipoTitulo = class(TControleConsultaModal)<N>    CdsConsultaID: TFloatField;<N>    CdsConsultaDESCRICAO: TWideStringField;<N>    CdsConsultaPREFIXO: TWideStringField;<N>    CdsConsultaGERA_BOLETO: TWideStringField;<N>    CdsConsultaATIVO: TWideStringField;<N>    UniEdit1: TUniEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleConsultaModalTipoTitulo: TControleConsultaModalTipoTitulo;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleConsultaModalTipoTitulo: TControleConsultaModalTipoTitulo;<N>begin<N>  Result := TControleConsultaModalTipoTitulo(ControleMainModule.GetFormInstance(TControleConsultaModalTipoTitulo));<N>end;<N><N>
unit Controle.Relatorio.Cadastro;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIFrame, uniLabel, uniButton, uniGUIBaseClasses, uniPanel,<N>  Data.DB, Datasnap.Provider, Data.Win.ADODB, Datasnap.DBClient, uniImageList,<N>  frxClass, frxExportBaseDialog, frxExportPDF, frxDBSet, Controle.Server.Module,<N>  uniScrollBox;<N><N>
unit Controle.Cadastro.VinculoUsuario;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Cadastro, Data.DB, Datasnap.DBClient,<N>  Datasnap.Provider, Data.Win.ADODB, uniGUIBaseClasses, uniImageList, uniButton,<N>  uniPanel, uniMultiItem, uniComboBox, uniDBComboBox, uniDBLookupComboBox,<N>  uniLabel;<N><N>
type<N>  TControleCadastroVinculoUsuario = class(TControleCadastro)<N>    UniLabel1: TUniLabel;<N>    UniDBLookupComboBox1: TUniDBLookupComboBox;<N>    UniLabel3: TUniLabel;<N>    UniDBLookupComboBox2: TUniDBLookupComboBox;<N>    DscUsuario: TDataSource;<N>    ClientDataSet1: TClientDataSet;<N>    DataSetProvider1: TDataSetProvider;<N>    ADOQuery1: TADOQuery;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleCadastroVinculoUsuario: TControleCadastroVinculoUsuario;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  MainModule, uniGUIApplication;<N><N>function ControleCadastroVinculoUsuario: TControleCadastroVinculoUsuario;<N>begin<N>  Result := TControleCadastroVinculoUsuario(UniMainModule.GetFormInstance(TControleCadastroVinculoUsuario));<N>end;<N><N>
unit Controle.Livre.WhatsApp;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIFrame, Controle.Livre, uniGUIBaseClasses;<N><N>type<N>  TControleLivre1 = class(TControleLivre)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>implementation<N><N>{$R *.dfm}<N><N><N><N>end.<N>
unit Controle.Consulta.ProdutoCategoria;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIFrame, Controle.Consulta.TreeView, <N>  Data.DB, Data.Win.ADODB, Datasnap.Provider, Datasnap.DBClient,<N>  uniGUIBaseClasses, uniImageList, uniLabel, uniTreeView, uniButton, uniPanel;<N><N>
unit Controle.Envia.Mensagem.Aguarde;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, uniGUIBaseClasses, uniLabel, uniProgressBar,<N>  Vcl.Imaging.pngimage, uniImage;<N><N>
type<N>  TControleEnviaMensagemAguarde = class(TUniForm)<N>    UniLabel3: TUniLabel;<N>    UniProgressBar1: TUniProgressBar;<N>    UniImage1: TUniImage;<N>    UniLabel2: TUniLabel;<N>    UniLabel4: TUniLabel;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleEnviaMensagemAguarde: TControleEnviaMensagemAguarde;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleEnviaMensagemAguarde: TControleEnviaMensagemAguarde;<N>begin<N>  Result := TControleEnviaMensagemAguarde(ControleMainModule.GetFormInstance(TControleEnviaMensagemAguarde));<N>end;<N><N>
unit Controle.Consulta.Modal.TituloCategoria.Pagar;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Controle.Consulta.Modal, Data.DB,<N>  Data.Win.ADODB, Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses,<N>  uniGUIClasses, uniImageList, uniPanel, uniBasicGrid, uniDBGrid, uniButton,<N>  uniEdit, uniLabel;<N><N>
type<N>  TControleConsultaModalTituloCategoriaPagar = class(TControleConsultaModal)<N>    QryConsultaID: TFloatField;<N>    QryConsultaDESCRICAO: TWideStringField;<N>    QryConsultaTIPO_TITULO: TWideStringField;<N>    CdsConsultaID: TFloatField;<N>    CdsConsultaDESCRICAO: TWideStringField;<N>    CdsConsultaTIPO_TITULO: TWideStringField;<N>    UniEdit1: TUniEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleConsultaModalTituloCategoriaPagar: TControleConsultaModalTituloCategoriaPagar;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleConsultaModalTituloCategoriaPagar: TControleConsultaModalTituloCategoriaPagar;<N>begin<N>  Result := TControleConsultaModalTituloCategoriaPagar(ControleMainModule.GetFormInstance(TControleConsultaModalTituloCategoriaPagar));<N>end;<N><N>
unit Controle.Relatorio.Cadastro.FluxoCaixa;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIFrame, Controle.Relatorio.Cadastro, uniDateTimePicker,<N>  uniGroupBox, uniBitBtn, uniEdit, uniCheckBox, uniGUIBaseClasses, uniImageList,<N>  Data.DB, Datasnap.Provider, Data.Win.ADODB, Datasnap.DBClient, uniButton,<N>  uniLabel, uniPanel, uniScrollBox;<N><N>
unit Controle.Operacoes.Caixa;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Operacoes,  Data.Win.ADODB,<N>  Datasnap.Provider, Data.DB, Datasnap.DBClient, uniGUIBaseClasses,<N>  uniImageList, uniBitBtn, uniSpeedButton, uniLabel, uniButton, uniPanel;<N><N>
type<N>  TControleOperacoesCaixa = class(TControleOperacoes)<N>    UniButton1: TUniButton;<N>    UniButton2: TUniButton;<N>    UniButton3: TUniButton;<N>    UniImageList3: TUniImageList;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleOperacoesCaixa: TControleOperacoesCaixa;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleOperacoesCaixa: TControleOperacoesCaixa;<N>begin<N>  Result := TControleOperacoesCaixa(ControleMainModule.GetFormInstance(TControleOperacoesCaixa));<N>end;<N><N>
unit Controle.Envia.Whatsapp;<N><N>interface<N><N>uses<N>  Funcoes.client;<N><N><N>type<N>  TrecebeRetorno = class<N>  private<N>    FnRetorno: TRetornos;<N>    procedure SetnRetorno(const Value: TRetornos);<N>  published<N>    property nRetorno : TRetornos read FnRetorno write SetnRetorno;<N>  end;<N><N>
type<N>  TBase64 = class<N>  private<N>    FArquivoBase64: string;<N>  published<N>    property ArquivoBase64: string read FArquivoBase64 write FArquivoBase64;<N>  end;<N><N>var<N>  ControleEnviaWhatsapp : Controle.Envia.Whatsapp;<N><N>implementation<N><N>
unit Controle.Livre;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIFrame, uniGUIBaseClasses, UniSFSweetAlert;<N><N>type<N>  TControleLivre = class(TUniFrame)<N>    AlertaLivre: TUniSFSweetAlert;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleLivre: TControleLivre;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  uniGUIApplication, Controle.Main.Module, Controle.Funcoes, System.TypInfo;<N><N>function ControleLivre: TControleLivre;<N>begin<N>  Result := TControleLivre(ControleMainModule.GetFormInstance(TControleLivre));<N>end;<N><N>
unit Client.Aguarde;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, uniProgressBar, uniGUIBaseClasses, uniLabel;<N><N>type<N>  TClientAguarde = class(TUniForm)<N>    UniLabel1: TUniLabel;<N>    UniProgressBar1: TUniProgressBar;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ClientAguarde: TClientAguarde;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ClientAguarde: TClientAguarde;<N>begin<N>  Result := TClientAguarde(ControleMainModule.GetFormInstance(TClientAguarde));<N>end;<N><N>
unit Controle.Consulta.Modal.Banco;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal, Data.DB, Data.Win.ADODB,<N>  Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses, uniImageList,<N>  uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniEdit, uniLabel, uniBitBtn,<N>  uniSpeedButton;<N><N>
type<N>  TControleConsultaModalBanco = class(TControleConsultaModal)<N>    UniEdit1: TUniEdit;<N>    UniEdit2: TUniEdit;<N>    UniEdit3: TUniEdit;<N>    CdsConsultaID: TFloatField;<N>    CdsConsultaCODIGO: TWideStringField;<N>    CdsConsultaATIVO: TWideStringField;<N>    CdsConsultaCPF_CNPJ: TWideStringField;<N>    CdsConsultaRAZAO_SOCIAL: TWideStringField;<N>    CdsConsultaNOME_FANTASIA: TWideStringField;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleConsultaModalBanco: TControleConsultaModalBanco;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleConsultaModalBanco: TControleConsultaModalBanco;<N>begin<N>  Result := TControleConsultaModalBanco(ControleMainModule.GetFormInstance(TControleConsultaModalBanco));<N>end;<N><N>
unit Controle.Consulta.VideoTutoriais;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIFrame, Controle.Consulta,  frxClass, frxDBSet,<N>  frxExportBaseDialog, frxExportPDF, uniGridExporters, uniBasicGrid,<N>   Data.DB, Data.Win.ADODB, Datasnap.Provider,<N>  Datasnap.DBClient, uniGUIBaseClasses, uniImageList, uniCheckBox, uniLabel,<N>  uniPanel, uniDBGrid, uniBitBtn,  uniButton;<N><N>
unit Controle.Consulta.Modal.Cidade;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, Controle.Consulta.Modal, Data.DB, Data.Win.ADODB,<N>  Datasnap.Provider, Datasnap.DBClient, uniGUIBaseClasses, uniImageList,<N>  uniPanel, uniBasicGrid, uniDBGrid, uniButton, uniEdit, uniLabel, uniBitBtn,<N>  uniSpeedButton;<N><N>
type<N>  TControleConsultaModalCidade = class(TControleConsultaModal)<N>    CdsConsultaID: TFloatField;<N>    CdsConsultaNOME: TWideStringField;<N>    CdsConsultaCODIGO_IBGE: TWideStringField;<N>    CdsConsultaUF: TWideStringField;<N>    UniEdit1: TUniEdit;<N>    UniEdit2: TUniEdit;<N>    UniEdit3: TUniEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
function ControleConsultaModalCidade: TControleConsultaModalCidade;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleConsultaModalCidade: TControleConsultaModalCidade;<N>begin<N>  Result := TControleConsultaModalCidade(ControleMainModule.GetFormInstance(TControleConsultaModalCidade));<N>end;<N><N>
unit Controle.Consulta.GerarDocumento;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics,<N>  Controls, Forms, uniGUITypes, uniGUIAbstractClasses,<N>  uniGUIClasses, uniGUIForm, uniButton, uniGUIBaseClasses, uniRadioGroup;<N><N>
type<N>  TControleConsultaGerarDocumento = class(TUniForm)<N>    UniRadioGroupExporta1: TUniRadioGroup;<N>    UniButtonConfirmaExportacao: TUniButton;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>function ControleConsultaGerarDocumento: TControleConsultaGerarDocumento;<N><N>
implementation<N><N>{$R *.dfm}<N><N>uses<N>  Controle.Main.Module, uniGUIApplication;<N><N>function ControleConsultaGerarDocumento: TControleConsultaGerarDocumento;<N>begin<N>  Result := TControleConsultaGerarDocumento(ControleMainModule.GetFormInstance(TControleConsultaGerarDocumento));<N>end;<N><N>
unit ServerModule;<N><N>interface<N><N>uses<N>  Classes, SysUtils, uniGUIServer, uniGUIMainModule, uniGUIApplication, uIdCustomHTTPServer,<N>  uniGUITypes;<N><N>type<N>  TUniServerModule = class(TUniGUIServerModule)<N>  private<N>    { Private declarations }<N>  protected<N>    procedure FirstInit; override;<N>  public<N>    { Public declarations }<N>  end;<N><N>
function UniServerModule: TUniServerModule;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  UniGUIVars;<N><N>function UniServerModule: TUniServerModule;<N>begin<N>  Result:=TUniServerModule(UniGUIServerInstance);<N>end;<N><N>procedure TUniServerModule.FirstInit;<N>begin<N>  InitServerModule(Self);<N>end;<N><N>
unit Base.Dados;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes;<N><N>type<N>  TDataModule1 = class(TDataModule)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  DataModule1: TDataModule1;<N><N>implementation<N><N>{%CLASSGROUP 'Vcl.Controls.TControl'}<N><N>{$R *.dfm}<N><N>end.<N>
unit SimpleProject.View.Principal;<N><N>interface<N><N>uses<N>  Winapi.Windows,<N>  Winapi.Messages,<N>  System.SysUtils,<N>  System.Variants,<N>  System.Classes,<N>  Vcl.Graphics,<N>  Vcl.Controls,<N>  Vcl.Forms,<N>  Vcl.Dialogs,<N>  Vcl.StdCtrls,<N>  Vcl.ExtCtrls,<N>  Vcl.DBCtrls,<N>  Vcl.Grids,<N>  Vcl.DBGrids,<N>  SimpleProject.Controller,<N>  SimpleProject.Controller.Interfaces,<N>  SimpleAttributes,<N>  Data.DB;<N><N>
unit SimpleProject.Controller.Interfaces;<N><N>interface<N><N>uses<N>  SimpleProject.Model.DAO,<N>  SimpleProject.Model.Entity.Users;<N><N>type<N>  iControllerEntity<T : class> = interface;<N><N>  iController = interface<N>    ['{6A60E341-CB38-4034-B924-FB9B49D98577}']<N>    function USERS : iControllerEntity<TUSERS>;<N>  end;<N><N>  iControllerEntity<T : class> = interface<N>    ['{F7476B60-A9B9-48CA-B1B6-016DADEA41D6}']<N>    function This : iDAOGeneric<T>;<N>    function &End : iController;<N>  end;<N><N><N><N>  implementation<N><N>end.<N>
unit SimpleProject.Controller;<N><N>interface<N><N>uses<N>  SimpleProject.Model.Entity.Users,<N>  SimpleProject.Controller.Generic,<N>  SimpleProject.Controller.Interfaces;<N><N>type<N>  TController = class(TInterfacedObject, iController)<N>    private<N>      FUsers : iControllerEntity<TUSERS>;<N>    public<N>      constructor Create;<N>      destructor Destroy; override;<N>      class function New : iController;<N>      function USERS : iControllerEntity<TUSERS>;<N>  end;<N><N>
implementation<N><N>{ TController }<N><N>constructor TController.Create;<N>begin<N><N>end;<N><N>destructor TController.Destroy;<N>begin<N><N>  inherited;<N>end;<N><N>class function TController.New: iController;<N>begin<N>    Result := Self.Create;<N>end;<N><N>
unit SimpleProject.Model.DAO;<N><N>interface<N><N>uses<N>  System.JSON,<N>  REST.Json,<N>  SimpleInterface,<N>  SimpleDAO,<N>  SimpleAttributes,<N>  SimpleQueryFiredac,<N>  Data.DB,<N>  DataSetConverter4D,<N>  DataSetConverter4D.Impl,<N>  DataSetConverter4D.Helper,<N>  DataSetConverter4D.Util;<N><N>
unit Main;<N><N>interface<N><N>uses<N>  Winapi.Windows,<N>  Winapi.Messages,<N>  System.SysUtils,<N>  System.Variants,<N>  System.Classes,<N>  Vcl.Graphics,<N>  Vcl.Controls,<N>  Vcl.Forms,<N>  Vcl.Dialogs,<N>  Vcl.ExtCtrls,<N>  Router4D,<N>  View.Page.Main.Cadastro,<N>  Vcl.StdCtrls;<N><N>
type<N>  TfMain = class(TForm)<N>    pnlBackground: TPanel;<N>    pnlMain: TPanel;<N>    pnlEmbed: TPanel;<N>    procedure FormCreate(Sender: TObject);<N>  private<N>    procedure RegisterRouters;<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  fMain: TfMain;<N><N>
implementation<N><N>{$R *.dfm}<N><N>uses<N>  View.Page.Customer,<N>  View.Page.Product;<N><N>procedure TfMain.FormCreate(Sender: TObject);<N>begin<N>  RegisterRouters;<N>  TRouter4D.Render<TfViewPageMainCadastro>.SetElement(pnlEmbed, pnlBackground);<N>end;<N><N>
unit View.Page.Product;<N><N>interface<N><N>uses<N>  Winapi.Windows,<N>  Winapi.Messages,<N>  System.SysUtils,<N>  System.Variants,<N>  System.Classes,<N>  Vcl.Graphics,<N>  Vcl.Controls,<N>  Vcl.Forms,<N>  Vcl.Dialogs,<N>  View.Page.Template,<N>  Vcl.ExtCtrls,<N>  Vcl.StdCtrls;<N><N>type<N>  TfViewPageProduct = class(TfViewPageTemplate)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  fViewPageProduct: TfViewPageProduct;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N><N>
unit View.Page.Template;<N><N>interface<N><N>uses<N>  Winapi.Windows,<N>  Winapi.Messages,<N>  System.SysUtils,<N>  System.Variants,<N>  System.Classes,<N>  Vcl.Graphics,<N>  Vcl.Controls,<N>  Vcl.Forms,<N>  Vcl.Dialogs,<N>  Router4D.Interfaces,<N>  Vcl.ExtCtrls,<N>  Vcl.StdCtrls,<N>  Router4D.Props,<N>  Router4D;<N><N>
type<N>  TfViewPageTemplate = class(TForm, IRouter4DComponent)<N>    pnlBackground: TPanel;<N>    btnBack: TButton;<N>    lblTitle: TLabel;<N>    lblSubtitle: TLabel;<N>    procedure btnBackClick(Sender: TObject);<N>  private<N>    function Render: TForm;<N>    procedure UnRender;<N>  public<N>    [Subscribe]<N>    procedure Props(AValue: TProps);<N>  end;<N><N>
var<N>  fViewPageTemplate: TfViewPageTemplate;<N><N>implementation<N><N>{$R *.dfm}<N><N>{ TfViewPageTemplate }<N><N>procedure TfViewPageTemplate.btnBackClick(Sender: TObject);<N>begin<N>  TRouter4D.Link.&To('Start');<N>end;<N><N>procedure TfViewPageTemplate.Props(AValue: TProps);<N>begin<N>  lblSubtitle.Caption := AValue.PropString;<N><N>
unit View.Page.Customer;<N><N>interface<N><N>uses<N>  Winapi.Windows,<N>  Winapi.Messages,<N>  System.SysUtils,<N>  System.Variants,<N>  System.Classes,<N>  Vcl.Graphics,<N>  Vcl.Controls,<N>  Vcl.Forms,<N>  Vcl.Dialogs,<N>  View.Page.Template,<N>  Vcl.ExtCtrls,<N>  Vcl.StdCtrls;<N><N>type<N>  TfViewPageCustomer = class(TfViewPageTemplate)<N>    edt1: TEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  fViewPageCustomer: TfViewPageCustomer;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N><N>
unit Router4DelphiDemo.View.Principal;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs;<N><N>type<N>  TForm2 = class(TForm)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form2: TForm2;<N><N>implementation<N><N>{$R *.fmx}<N><N>end.<N>
unit Router4DelphiDemo.View.Principal;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Layouts;<N><N>type<N>  TViewPrincipal = class(TForm)<N>    Layout1: TLayout;<N>    procedure FormCreate(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>    procedure Animation( aLayout : TFMXObject );<N>  end;<N><N>
var<N>  ViewPrincipal: TViewPrincipal;<N><N>implementation<N><N>uses<N>  Router4D,<N>  Router4DelphiDemo.Views.Layouts.Main,<N>  Router4DelphiDemo.View.Router;<N><N>{$R *.fmx}<N><N>procedure TViewPrincipal.Animation(aLayout: TFMXObject);<N>begin<N>  TLayout(aLayout).Opacity := 0;<N>  TLayout(aLayout).AnimateFloat('Opacity', 1, 0.9);<N>end;<N><N>
unit Router4DelphiDemo.View.Pages.Cadastros;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs,<N>  FMX.Controls.Presentation, FMX.StdCtrls, FMX.Layouts,<N>  Router4D.Interfaces;<N><N>
type<N>  TPageCadastros = class(TForm, iRouter4DComponent)<N>    Layout1: TLayout;<N>    Label1: TLabel;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>    function Render : TFMXObject;<N>    procedure UnRender;<N>  end;<N><N>
unit Router4DelphiDemo.View.Pages.Index;<N><N>interface<N><N>uses<N>  System.SysUtils,<N>  System.Types,<N>  System.UITypes,<N>  System.Classes,<N>  System.Variants,<N>  FMX.Types,<N>  FMX.Controls,<N>  FMX.Forms,<N>  FMX.Graphics,<N>  FMX.Dialogs,<N>  FMX.Layouts,<N>  Router4D.Interfaces, FMX.Controls.Presentation, FMX.StdCtrls;<N><N>
type<N>  TPageIndex = class(TForm, iRouter4DComponent)<N>    Layout1: TLayout;<N>    Label1: TLabel;<N>    Button1: TButton;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>    function Render : TFMXObject;<N>    procedure UnRender;<N>  end;<N><N>
var<N>  PageIndex: TPageIndex;<N><N>implementation<N><N>uses<N>  Router4D,<N>  Router4D.History,<N>  Router4DelphiDemo.Views.Layouts.Main;<N><N>{$R *.fmx}<N><N>function TPageIndex.Render: TFMXObject;<N>begin<N>  Result := Layout1;<N>  //TRouter4D.Render<TMainLayout>.GetElement(Layout1);<N>end;<N><N>
unit Router4DelphiDemo.View.Components.Sidebar;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Layouts,<N>  FMX.ListBox, FMX.Controls.Presentation, FMX.StdCtrls, FMX.Objects;<N><N>
type<N>  TComponentSideBar = class(TForm)<N>    Layout1: TLayout;<N>    ListBox1: TListBox;<N>    ListBoxItem1: TListBoxItem;<N>    ListBoxItem2: TListBoxItem;<N>    Rectangle1: TRectangle;<N>    procedure ListBox1Click(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  ComponentSideBar: TComponentSideBar;<N><N>implementation<N><N>uses<N>  Router4D;<N><N>{$R *.fmx}<N><N>procedure TComponentSideBar.ListBox1Click(Sender: TObject);<N>begin<N>   TRouter4D.Link.&To(ListBox1.Items[ListBox1.ItemIndex])<N>end;<N><N>end.<N><N><N>
unit Router4DelphiDemo.Views.Layouts.Main;<N><N>interface<N><N>uses<N>  System.SysUtils,<N>  System.Types,<N>  System.UITypes,<N>  System.Classes,<N>  System.Variants,<N>  FMX.Types,<N>  FMX.Controls,<N>  FMX.Forms,<N>  FMX.Graphics,<N>  FMX.Dialogs,<N>  FMX.Layouts,<N>  FMX.Controls.Presentation,<N>  FMX.StdCtrls,<N>  Router4D.Interfaces, FMX.Objects;<N><N>
type<N>  TMainLayout = class(TForm, iRouter4DComponent)<N>    Layout1: TLayout;<N>    Layout2: TLayout;<N>    Layout3: TLayout;<N>    Label1: TLabel;<N>    LayoutIndex: TLayout;<N>    Rectangle1: TRectangle;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>     function Render : TFMXObject;<N>     procedure UnRender;<N>  end;<N><N>
var<N>  MainLayout: TMainLayout;<N><N>implementation<N><N>uses<N>  Router4DelphiDemo.View.Pages.Index,<N>  Router4D,<N>  Router4DelphiDemo.View.Components.Sidebar;<N><N>{$R *.fmx}<N><N>{ TMainLayout }<N><N>function TMainLayout.Render: TFMXObject;<N>begin<N>  Result := LayoutIndex;<N>  TRouter4D.Render<TPageIndex>.SetElement(Layout3);<N><N>
unit Router4DelphiDemo.View.Router;<N><N>interface<N><N>type<N>  TRouters = class<N>    private<N>    public<N>      constructor Create;<N>      destructor Destroy; override;<N>  end;<N><N>var<N>  Routers : TRouters;<N><N>implementation<N><N>uses<N>  Router4D,<N>  Router4DelphiDemo.View.Pages.Index,<N>  Router4DelphiDemo.Views.Layouts.Main,<N>  Router4DelphiDemo.View.Pages.Cadastros;<N><N>
{ TRouters }<N><N>constructor TRouters.Create;<N>begin<N>  TRouter4D.Switch.Router('Home', TPageIndex);<N>  TRouter4D.Switch.Router('Cadastros', TPageCadastros);<N>  TRouter4D.Switch.Router('main', TMainLayout);<N>end;<N><N>destructor TRouters.Destroy;<N>begin<N><N>
unit SimpleDemo.View.Components.Button01;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs,<N>  FMX.Controls.Presentation, FMX.StdCtrls, FMX.Objects, FMX.Layouts,<N>  Router4D.Interfaces,<N>  Router4D.Props;<N><N>
unit SimpleDemo.View.Principal;<N><N>interface<N><N>uses<N>  System.SysUtils,<N>  System.Types,<N>  System.UITypes,<N>  System.Classes,<N>  System.Variants,<N>  FMX.Types,<N>  FMX.Controls,<N>  FMX.Forms,<N>  FMX.Graphics,<N>  FMX.Dialogs,<N>  FMX.Controls.Presentation,<N>  FMX.StdCtrls,<N>  FMX.ListBox,<N>  FMX.Layouts,<N>  FMX.Objects, FMX.Edit, FMX.SearchBox, FMX.MultiView;<N><N>
type<N>  TForm2 = class(TForm)<N>    Layout1: TLayout;<N>    Layout2: TLayout;<N>    Layout3: TLayout;<N>    Layout4: TLayout;<N>    Rectangle1: TRectangle;<N>    Rectangle2: TRectangle;<N>    Label1: TLabel;<N>    Layout5: TLayout;<N>    procedure FormShow(Sender: TObject);<N>  private<N>    procedure RegisterRouters;<N>    procedure createSideBar;<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  Form2: TForm2;<N><N>implementation<N><N>uses<N>  Router4D,<N>  SimpleDemo.View.Page.Cadastros,<N>  SimpleDemo.View.Page.Principal;<N><N>{$R *.fmx}<N><N>procedure TForm2.FormShow(Sender: TObject);<N>begin<N>  RegisterRouters;<N>  TRouter4D.Render<TPagePrincipal>.SetElement(Layout4, Layout1);<N>end;<N><N>
procedure TForm2.RegisterRouters;<N>begin<N>  TRouter4D.Switch.Router('Inicio', TPagePrincipal);<N>  TRouter4D.Switch.Router('Cadastros', TPageCadastros);<N>  TRouter4D.Switch.Router('Configuracoes', TPageCadastros);<N>  createSideBar;<N>end;<N><N>procedure TForm2.createSideBar;<N>begin<N>  TRouter4D<N>    .SideBar<N>      .MainContainer(Layout5)<N>      .LinkContainer(Layout4)<N>      .FontSize(15)<N>      .FontColor(4294967295)<N>      .ItemHeigth(60)<N>    .RenderToListBox;<N>end;<N><N>
unit SimpleDemo.View.Page.Cadastros;<N><N>interface<N><N>uses<N>  System.SysUtils,<N>  System.Types,<N>  System.UITypes,<N>  System.Classes,<N>  System.Variants,<N>  FMX.Types,<N>  FMX.Controls,<N>  FMX.Forms,<N>  FMX.Graphics,<N>  FMX.Dialogs,<N>  FMX.Controls.Presentation,<N>  FMX.StdCtrls,<N>  FMX.Layouts,<N>  Router4D.Interfaces,<N>  Router4D.Props, FMX.Edit, FMX.Objects;<N><N>
unit SimpleDemo.View.Page.Cadastros.Sub;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs,<N>  FMX.Controls.Presentation, FMX.StdCtrls, FMX.Layouts,<N>  Router4D.Interfaces;<N><N>
type<N>  TSubCadastros = class(TForm, iRouter4DComponent)<N>    Layout1: TLayout;<N>    Label1: TLabel;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>    function Render : TFMXObject;<N>    procedure UnRender;<N>  end;<N><N>
var<N>  SubCadastros: TSubCadastros;<N><N>implementation<N><N>uses<N>  Router4D.History;<N><N>{$R *.fmx}<N><N>{ TSubCadastros }<N><N>function TSubCadastros.Render: TFMXObject;<N>begin<N>  Result := Layout1;<N>end;<N><N>procedure TSubCadastros.UnRender;<N>begin<N>  //<N>end;<N><N>
{ *******************************************************************************<N>  Copyright 2016-2019 Daniele Spinetti<N><N>  Licensed under the Apache License, Version 2.0 (the "License");<N>  you may not use this file except in compliance with the License.<N>  You may obtain a copy of the License at<N><N>
  http://www.apache.org/licenses/LICENSE-2.0<N><N>  Unless required by applicable law or agreed to in writing, software<N>  distributed under the License is distributed on an "AS IS" BASIS,<N>  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<N>  See the License for the specific language governing permissions and<N>  limitations under the License.<N>  ******************************************************************************** }<N><N>
unit Router4D.History;<N><N>{$I Router4D.inc}<N><N>interface<N><N>uses<N>  Classes,<N>  SysUtils,<N>  {$IFDEF HAS_FMX}<N>  FMX.Forms,<N>  FMX.Types,<N>  {$ELSE}<N>  Vcl.Forms,<N>  Vcl.ExtCtrls,<N>  {$ENDIF}<N>  System.Generics.Collections,<N>  Router4D.Interfaces,<N>  Router4D.Props;<N><N>
unit Router4D.Utils;<N><N>{$I Router4D.inc}<N><N>interface<N><N>uses<N>  System.Rtti,<N>  Router4D.Props,<N>  SysUtils,<N>  Classes;<N><N>type<N>  TRouter4DUtils = class<N>    private<N>    public<N>      class function CreateInstance<T> : T;<N>  end;<N><N>
   TNotifyEventWrapper = class(TComponent)<N>  private<N>    FProc: TProc<TObject, String>;<N>    FAux : String;<N>  public<N>    constructor Create(Owner: TComponent; Proc: TProc<TObject, String>; Aux : String = ''); reintroduce;<N>    class function AnonProc2NotifyEvent(Owner: TComponent; Proc: TProc<TObject, String>; Aux : String = ''): TNotifyEvent;<N>  published<N>    procedure Event(Sender: TObject);<N>  end;<N><N>
{ *******************************************************************************<N>  Copyright 2016-2019 Daniele Spinetti<N><N>  Licensed under the Apache License, Version 2.0 (the "License");<N>  you may not use this file except in compliance with the License.<N>  You may obtain a copy of the License at<N><N>
  http://www.apache.org/licenses/LICENSE-2.0<N><N>  Unless required by applicable law or agreed to in writing, software<N>  distributed under the License is distributed on an "AS IS" BASIS,<N>  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<N>  See the License for the specific language governing permissions and<N>  limitations under the License.<N>  ******************************************************************************** }<N><N>
unit Router4D.Props;<N><N>{$I Router4D.inc}<N><N>interface<N><N>uses<N>  System.Classes,<N>  System.SysUtils,<N>  System.Rtti;<N><N>type<N><N>  TThreadMode = (Posting, Main, Async, Background);<N><N>  TCloneEventCallback = function(const AObject: TObject): TObject of object;<N>  TCloneEventMethod = TFunc<TObject, TObject>;<N><N>
  IEventBus = Interface<N>    ['{7BDF4536-F2BA-4FBA-B186-09E1EE6C7E35}']<N>    procedure RegisterSubscriber(ASubscriber: TObject);<N>    function IsRegistered(ASubscriber: TObject): Boolean;<N>    procedure Unregister(ASubscriber: TObject);<N>    procedure Post(AEvent: TObject; const AContext: String = '';<N>      AEventOwner: Boolean = true);<N><N>
    procedure SetOnCloneEvent(const aCloneEvent: TCloneEventCallback);<N>    procedure AddCustomClassCloning(const AQualifiedClassName: String;<N>      const aCloneEvent: TCloneEventMethod);<N>    procedure RemoveCustomClassCloning(const AQualifiedClassName: String);<N><N>
    property OnCloneEvent: TCloneEventCallback write SetOnCloneEvent;<N>  end;<N><N>  SubscribeAttribute = class(TCustomAttribute)<N>  private<N>    FContext: String;<N>    FThreadMode: TThreadMode;<N>  public<N>    constructor Create(AThreadMode: TThreadMode = TThreadMode.Posting;<N>      const AContext: String = '');<N>    property ThreadMode: TThreadMode read FThreadMode;<N>    property Context: String read FContext;<N>  end;<N><N>
  TDEBEvent<T> = class(TObject)<N>  private<N>    FDataOwner: Boolean;<N>    FData: T;<N>    procedure SetData(const Value: T);<N>    procedure SetDataOwner(const Value: Boolean);<N>  public<N>    constructor Create; overload;<N>    constructor Create(AData: T); overload;<N>    destructor Destroy; override;<N>    property DataOwner: Boolean read FDataOwner write SetDataOwner;<N>    property Data: T read FData write SetData;<N>  end;<N><N>
{ *******************************************************************************<N>  Copyright 2016-2019 Daniele Spinetti<N><N>  Licensed under the Apache License, Version 2.0 (the "License");<N>  you may not use this file except in compliance with the License.<N>  You may obtain a copy of the License at<N><N>
  http://www.apache.org/licenses/LICENSE-2.0<N><N>  Unless required by applicable law or agreed to in writing, software<N>  distributed under the License is distributed on an "AS IS" BASIS,<N>  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<N>  See the License for the specific language governing permissions and<N>  limitations under the License.<N>  ******************************************************************************** }<N><N>
unit Router4D;<N><N>{$I Router4D.inc}<N><N>interface<N><N>uses<N>  System.Generics.Collections,<N>  System.Classes,<N>  System.Rtti,<N>  System.TypInfo,<N>  SysUtils,<N>  {$IFDEF HAS_FMX}<N>  FMX.Types,<N>  {$ELSE}<N>  Vcl.ExtCtrls,<N>  {$ENDIF}<N>  Router4D.Interfaces,<N>  Router4D.History,<N>  Router4D.Render,<N>  Router4D.Link;<N><N>
type<N>  TRouter4D = class(TInterfacedObject, iRouter4D)<N>    private<N>    public<N>      constructor Create;<N>      destructor Destroy; override;<N>      class function New : iRouter4D;<N>      class function Render<T : class, constructor> : iRouter4DRender;<N>      class function Link : iRouter4DLink;<N>      class function Switch : iRouter4DSwitch;<N>      {$IFDEF HAS_FMX}<N>      class function SideBar : iRouter4DSidebar;<N>      {$ENDIF}<N>  end;<N><N>
implementation<N><N>{ TRouter4Delphi }<N><N>uses<N>  Router4D.Utils,<N>  Router4D.Switch,<N>  Router4D.Sidebar;<N><N>constructor TRouter4D.Create;<N>begin<N><N>end;<N><N>destructor TRouter4D.Destroy;<N>begin<N><N>  inherited;<N>end;<N><N>class function TRouter4D.Link: iRouter4DLink;<N>begin<N>  Result := TRouter4DLink.New;<N>end;<N><N>
class function TRouter4D.New: iRouter4D;<N>begin<N>  Result := Self.Create;<N>end;<N><N>class function TRouter4D.Render<T>: iRouter4DRender;<N>begin<N>  Router4DHistory<N>    .AddHistory(<N>      TPersistentClass(T).ClassName,<N>      TPersistentClass(T)<N>    );<N><N>
<N>  Result :=<N>    TRouter4DRender<N>      .New(<N>        Router4DHistory<N>          .GetHistory(<N>            TPersistentClass(T)<N>              .ClassName<N>          )<N>      );<N>end;<N>{$IFDEF HAS_FMX}<N>class function TRouter4D.SideBar: iRouter4DSidebar;<N>begin<N>  Result := TRouter4DSidebar.New;<N>end;<N>{$ENDIF}<N>class function TRouter4D.Switch: iRouter4DSwitch;<N>begin<N>  Result := TRouter4DSwitch.New;<N>end;<N><N>
unit Router4D.Helper;<N><N>interface<N><N>uses<N>  System.Classes,<N>	Vcl.ExtCtrls,<N>	Vcl.Forms,<N>  Vcl.Controls;<N><N>type<N>	TRouter4DHelper = class helper for TPanel<N>  public<N>    procedure RemoveObject; overload;<N>		procedure AddObject(AValue: TForm);<N>	end;<N><N>
implementation<N><N>procedure TRouter4DHelper.AddObject(AValue: TForm);<N>begin<N>	AValue.Parent := Self;<N>  AValue.Show;<N>end;<N><N>procedure TRouter4DHelper.RemoveObject;<N>var<N>	lIndex: Integer;<N>begin<N>	for lIndex := Self.ControlCount - 1 downto 0 do<N>  begin<N>    if (Self.Controls[lIndex] is TForm) then<N>    begin<N>      (Self.Controls[lIndex] as TForm).Close;<N>      (Self.Controls[lIndex] as TForm).parent := nil;<N>    end;<N>  end;<N>end;<N><N>
unit Router4D.Interfaces;<N><N>{$I Router4D.inc}<N><N>interface<N><N>uses<N>  System.Classes,<N>  System.Generics.Collections,<N>  System.UITypes,<N>  SysUtils,<N>  {$IFDEF HAS_FMX}<N>  FMX.Types,<N>  {$ELSE}<N>  Vcl.ExtCtrls,<N>  Vcl.Forms,<N>  {$ENDIF}<N>  Router4D.Props;<N><N>
type<N><N>  iRouter4D = interface<N>    ['{56BF88E9-25AB-49C7-8CB2-F89C95F34816}']<N>  end;<N><N>  iRouter4DComponent = interface<N>    ['{C605AEFB-36DC-4952-A3D9-BA372B998BC3}']<N>    {$IFDEF HAS_FMX}<N>    function Render : TFMXObject;<N>    {$ElSE}<N>    function Render : TForm;<N>    {$ENDIF}<N>    procedure UnRender;<N>  end;<N><N>
unit Unit6;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, uDWAbout, uRESTDWBase, Vcl.StdCtrls;<N><N>type<N>  TForm6 = class(TForm)<N>    Button1: TButton;<N>    RESTServicePooler1: TRESTServicePooler;<N>    procedure Button1Click(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  Form6: TForm6;<N><N>implementation<N><N>uses<N>  Unit1;<N><N>{$R *.dfm}<N><N>procedure TForm6.Button1Click(Sender: TObject);<N>begin<N>  RESTServicePooler1.ServerMethodClass := TDataModule1;<N>  RESTServicePooler1.Active := not RESTServicePooler1.Active;<N>end;<N><N>
unit Unit1;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, uDWDataModule, uDWAbout, uRESTDWServerEvents,<N>  uDWJSONObject, System.Json;<N><N>type<N>  TDataModule1 = class(TServerMethodDataModule)<N>    DWServerEvents1: TDWServerEvents;<N>    procedure DWServerEvents1EventstesteReplyEvent(var Params: TDWParams;<N>      var Result: string);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  DataModule1: TDataModule1;<N><N>implementation<N><N>{%CLASSGROUP 'Vcl.Controls.TControl'}<N><N>{$R *.dfm}<N><N>procedure TDataModule1.DWServerEvents1EventstesteReplyEvent(<N>  var Params: TDWParams; var Result: string);<N>var<N>  Json : TJsonObject;<N>begin<N>  Json := TJSONObject.Create;<N>  try<N>    Json.AddPair('Nome', 'Thulio Bittencourt');<N>    Result := Json.ToJSON;<N>  finally<N>    FreeAndNil(Json);<N>  end;<N>end;<N><N>
unit Unit1;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, uDWDataModule, uDWAbout, uRESTDWServerEvents,<N>  uDWJSONObject, System.Json;<N><N>type<N>  TDataModule1 = class(TServerMethodDataModule)<N>    DWServerEvents1: TDWServerEvents;<N>    procedure DWServerEvents1EventstesteReplyEvent(var Params: TDWParams;<N>      var Result: string);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  DataModule1: TDataModule1;<N><N>implementation<N><N>{%CLASSGROUP 'Vcl.Controls.TControl'}<N><N>{$R *.dfm}<N><N>procedure TDataModule1.DWServerEvents1EventstesteReplyEvent(<N>  var Params: TDWParams; var Result: string);<N>var<N>  Json : TJsonObject;<N>begin<N>  Json := TJSONObject.Create;<N>  try<N>    Json.AddPair('Nome', 'Thulio Bittencourt');<N>    Json.AddPair('Cidade', 'Niteroi');<N>    Result := Json.ToJSON;<N>  finally<N>    FreeAndNil(Json);<N>  end;<N>end;<N><N>
unit Providers.Connection;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf, FireDAC.Stan.Def,<N>  FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys, FireDAC.ConsoleUI.Wait,<N>  Data.DB, FireDAC.Comp.Client, FireDAC.Phys.PG, FireDAC.Phys.PGDef;<N><N>
type<N>  TProvidersConnection = class(TDataModule)<N>    FDConnection: TFDConnection;<N>    FDPhysPgDriverLink: TFDPhysPgDriverLink;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  ProvidersConnection: TProvidersConnection;<N><N>
unit Services.Pedido;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, Providers.Cadastro, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf,<N>  FireDAC.Stan.Def, FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys,<N>  FireDAC.Phys.PG, FireDAC.Phys.PGDef, FireDAC.ConsoleUI.Wait,<N>  FireDAC.Stan.Param, FireDAC.DatS, FireDAC.DApt.Intf, FireDAC.DApt, Data.DB,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, Horse;<N><N>
unit Services.Produto;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, Providers.Cadastro, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf,<N>  FireDAC.Stan.Def, FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys,<N>  FireDAC.Phys.PG, FireDAC.Phys.PGDef, FireDAC.ConsoleUI.Wait,<N>  FireDAC.Stan.Param, FireDAC.DatS, FireDAC.DApt.Intf, FireDAC.DApt, Data.DB,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, Horse.Core.Param;<N><N>
unit Services.Cliente;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, Providers.Cadastro, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf,<N>  FireDAC.Stan.Def, FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys,<N>  FireDAC.Phys.PG, FireDAC.Phys.PGDef, FireDAC.ConsoleUI.Wait,<N>  FireDAC.Stan.Param, FireDAC.DatS, FireDAC.DApt.Intf, FireDAC.DApt, Data.DB,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, Horse.Core.Param;<N><N>
type<N>  TServiceCliente = class(TProvidersCadastro)<N>    vQryPesquisaid: TLargeintField;<N>    vQryPesquisanome: TWideStringField;<N>    vQryPesquisastatus: TSmallintField;<N>    vQryCadastroid: TLargeintField;<N>    vQryCadastronome: TWideStringField;<N>    vQryCadastrostatus: TSmallintField;<N>  private<N>    { Private declarations }<N>  public<N>    function ListAll(const AParams: THorseCoreParam): TFDQuery; override;<N>  end;<N><N>
var<N>  ServiceCliente: TServiceCliente;<N><N>implementation<N><N>{%CLASSGROUP 'System.Classes.TPersistent'}<N><N>{$R *.dfm}<N><N><N>{ TServiceCliente }<N><N>function TServiceCliente.ListAll(const AParams: THorseCoreParam): TFDQuery;<N>begin<N>  if AParams.ContainsKey('nome') then<N>  begin<N>    vQryPesquisa.SQL.Add('and lower(nome) like :nome');<N>    vQryPesquisa.ParamByName('nome').AsString := '%' + AParams.Items['nome']<N>      .ToLower + '%';<N><N>
    vQryRecords.SQL.Add('and lower(nome) like :nome');<N>    vQryRecords.ParamByName('nome').AsString := '%' + AParams.Items['nome']<N>      .ToLower + '%';<N>  end;<N><N>  if AParams.ContainsKey('status') then<N>  begin<N>    vQryPesquisa.SQL.Add('and status = :status');<N>    vQryPesquisa.ParamByName('status').AsSmallInt := AParams.Items['status']<N>      .ToInteger;<N><N>
    vQryRecords.SQL.Add('and status = :status');<N>    vQryRecords.ParamByName('status').AsSmallInt := AParams.Items['status']<N>      .ToInteger;<N>  end;<N><N>  vQryCadastro.SQL.Add(' order by id ');<N>  Result := inherited ListAll(AParams);<N>end;<N><N>
﻿unit Controller.Pedido.Item;<N><N>interface<N><N>uses<N>  Horse;<N><N>procedure Registry;<N><N>implementation<N><N>uses Services.Pedido.Item, System.JSON, DataSet.Serialize, Data.DB;<N><N>procedure ListarItens(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LIdPedido: string;<N>  LRetorno: TJSONObject;<N>  LService: TServicePedidoItem;<N>begin<N>  LService := TServicePedidoItem.Create;<N>  try<N>    LIdPedido := Req.Params['id_pedido'];<N>    LRetorno := TJSONObject.Create;<N><N>
    LRetorno.AddPair('data', LService.ListAllByIdPedido(Req.Query, LIdPedido).ToJSONArray());<N>    LRetorno.AddPair('records', TJSONNumber.Create(LService.GetRecordCount));<N><N>    Res.Send(LRetorno);<N>  finally<N>    LService.Free;<N>  end;<N>end;<N><N>
procedure ObterItem(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LIdPedido, LIdItem: string;<N>  LService: TServicePedidoItem;<N>begin<N>  LService := TServicePedidoItem.Create;<N>  try<N>    LIdItem := Req.Params['id_item'];<N>    LIdPedido := Req.Params['id_pedido'];<N><N>
    if LService.GetByPedido(LIdPedido, LIdItem).IsEmpty then<N>      raise EHorseException.New.Error('Item não cadastrado!')<N>        .Status(THTTPStatus.NotFound);<N><N>    Res.Send(LService.vQryCadastro.ToJSONObject());<N>  finally<N>    LService.Free;<N>  end;<N>end;<N><N>
﻿unit Controller.Usuario;<N><N>interface<N><N>uses<N>  Horse;<N><N>procedure Registry;<N><N>implementation<N><N>uses Services.Usuario, System.JSON, DataSet.Serialize, Data.DB, System.Classes;<N><N>procedure ListarUsuarios(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LRetorno: TJSONObject;<N>  LService: TServiceUsuario;<N>begin<N>  LService := TServiceUsuario.Create;<N>  try<N>    LRetorno := TJSONObject.Create;<N><N>
    LRetorno.AddPair('data', LService.ListAll(Req.Query).ToJSONArray());<N>    LRetorno.AddPair('records', TJSONNumber.Create(LService.GetRecordCount));<N><N>    Res.Send(LRetorno);<N>  finally<N>    LService.Free;<N>  end;<N>end;<N><N>procedure ObterUsuario(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LIdUsuario: string;<N>  LService: TServiceUsuario;<N>begin<N>  LService := TServiceUsuario.Create;<N>  try<N>    LIdUsuario := Req.Params['id'];<N><N>
    if LService.GetById(LIdUsuario).IsEmpty then<N>      raise EHorseException.New.Error('Usuário não cadastrado!')<N>        .Status(THTTPStatus.NotFound);<N><N>    Res.Send(LService.vQryCadastro.ToJSONObject());<N>  finally<N>    LService.Free;<N>  end;<N>end;<N><N>
procedure CadatrarUsuario(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LBody: TJSONObject;<N>  LService: TServiceUsuario;<N>begin<N>  LService := TServiceUsuario.Create;<N>  try<N>    LBody := Req.Body<TJSONObject>;<N>    if LService.Append(LBody) then<N>      Res.Send(LService.vQryCadastro.ToJSONObject())<N>        .Status(THTTPStatus.Created);<N>  finally<N>    LService.Free;<N>  end;<N>end;<N><N>
procedure AlterarUsuario(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LBody: TJSONObject;<N>  LIdUsuario: string;<N>  LService: TServiceUsuario;<N>begin<N>  LService := TServiceUsuario.Create;<N>  try<N>    LIdUsuario := Req.Params['id'];<N><N>
    if LService.GetById(LIdUsuario).IsEmpty then<N>      raise EHorseException.New.Error('Usuário não cadastrado!')<N>        .Status(THTTPStatus.NotFound);<N><N>    LBody := Req.Body<TJSONObject>;<N>    if LService.Update(LBody) then<N>      Res.Status(THTTPStatus.NoContent);<N>  finally<N>    LService.Free;<N>  end;<N>end;<N><N>
procedure DeletarUsuario(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LIdUsuario: string;<N>  LService: TServiceUsuario;<N>begin<N>  LService := TServiceUsuario.Create;<N>  try<N>    LIdUsuario := Req.Params['id'];<N><N>    if LService.GetById(LIdUsuario).IsEmpty then<N>      raise EHorseException.New.Error('Usuário não cadastrado!')<N>        .Status(THTTPStatus.NotFound);<N><N>
    if LService.Delete then<N>      Res.Status(THTTPStatus.NoContent);<N><N>  finally<N>    LService.Free;<N>  end;<N>end;<N><N>procedure CadatrarFotoUsuario(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LIdUsuario: string;<N>  LFoto: TMemoryStream;<N>  LService: TServiceUsuario;<N>begin<N>  LService := TServiceUsuario.Create;<N>  try<N>    LIdUsuario := Req.Params['id'];<N><N>
    if LService.GetById(LIdUsuario).IsEmpty then<N>      raise EHorseException.New.Error('Usuário não cadastrado!')<N>        .Status(THTTPStatus.NotFound);<N><N>    LFoto := Req.Body<TMemoryStream>;<N><N>    if not Assigned(LFoto) then<N>      raise EHorseException.New.Error('Foto inválida!')<N>        .Status(THTTPStatus.BadRequest);<N><N>
    if LService.SalvarFotoUsuario(LFoto) then<N>      Res.Send(LService.vQryCadastro.ToJSONObject())<N>        .Status(THTTPStatus.NoContent);<N>  finally<N>    LService.Free;<N>  end;<N>end;<N><N>procedure ObterFotoUsuario(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LFoto: TStream;<N>  LIdUsuario: string;<N>  LService: TServiceUsuario;<N>begin<N>  LService := TServiceUsuario.Create;<N>  try<N>    LIdUsuario := Req.Params['id'];<N><N>
    if LService.GetById(LIdUsuario).IsEmpty then<N>      raise EHorseException.New.Error('Usuário não cadastrado!')<N>        .Status(THTTPStatus.NotFound);<N><N>    LFoto := LService.ObterFotoUsuario;<N>    if not Assigned(LFoto) then<N>      raise EHorseException.New.Error('Foto não cadastrada!')<N>        .Status(THTTPStatus.BadRequest);<N><N>
    Res.Send(LFoto);<N>  finally<N>    LService.Free;<N>  end;<N>end;<N><N>procedure Registry;<N>begin<N>  THorse.Get('/usuarios', ListarUsuarios);<N>  THorse.Get('/usuarios/:id', ObterUsuario);<N>  THorse.Post('/usuarios', CadatrarUsuario);<N>  THorse.Put('/usuarios/:id', AlterarUsuario);<N>  THorse.Delete('/usuarios/:id', DeletarUsuario);<N>  THorse.Get('/usuarios/:id/foto', ObterFotoUsuario);<N>  THorse.Post('/usuarios/:id/foto', CadatrarFotoUsuario);<N>end;<N><N>
﻿unit Controller.Pedido;<N><N>interface<N><N>uses<N>  Horse;<N><N>procedure Registry;<N><N>implementation<N><N>uses Services.Pedido, System.JSON, DataSet.Serialize, Data.DB;<N><N>procedure ListarPedidos(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LRetorno: TJSONObject;<N>  LService: TServicePedido;<N>begin<N>  LService := TServicePedido.Create;<N>  try<N>    LRetorno := TJSONObject.Create;<N><N>
    LRetorno.AddPair('data', LService.ListAll(Req.Query).ToJSONArray());<N>    LRetorno.AddPair('records', TJSONNumber.Create(LService.GetRecordCount));<N><N>    Res.Send(LRetorno);<N>  finally<N>    LService.Free;<N>  end;<N>end;<N><N>procedure ObterPedido(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LIdPedido: string;<N>  LService: TServicePedido;<N>begin<N>  LService := TServicePedido.Create;<N>  try<N>    LIdPedido := Req.Params['id'];<N><N>
    if LService.GetById(LIdPedido).IsEmpty then<N>      raise EHorseException.New.Error('Pedido não cadastrado!')<N>        .Status(THTTPStatus.NotFound);<N><N>    Res.Send(LService.vQryCadastro.ToJSONObject());<N>  finally<N>    LService.Free;<N>  end;<N>end;<N><N>
procedure CadatrarPedido(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LBody: TJSONObject;<N>  LService: TServicePedido;<N>begin<N>  LService := TServicePedido.Create;<N>  try<N>    LBody := Req.Body<TJSONObject>;<N>    if LService.Append(LBody) then<N>      Res.Send(LService.vQryCadastro.ToJSONObject())<N>        .Status(THTTPStatus.Created);<N>  finally<N>    LService.Free;<N>  end;<N>end;<N><N>
procedure AlterarPedido(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LBody: TJSONObject;<N>  LIdPedido: string;<N>  LService: TServicePedido;<N>begin<N>  LService := TServicePedido.Create;<N>  try<N>    LIdPedido := Req.Params['id'];<N><N>
    if LService.GetById(LIdPedido).IsEmpty then<N>      raise EHorseException.New.Error('Pedido não cadastrado!')<N>        .Status(THTTPStatus.NotFound);<N><N>    LBody := Req.Body<TJSONObject>;<N>    if LService.Update(LBody) then<N>      Res.Status(THTTPStatus.NoContent);<N>  finally<N>    LService.Free;<N>  end;<N>end;<N><N>
procedure DeletarPedido(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LIdPedido: string;<N>  LService: TServicePedido;<N>begin<N>  LService := TServicePedido.Create;<N>  try<N>    LIdPedido := Req.Params['id'];<N><N>    if LService.GetById(LIdPedido).IsEmpty then<N>      raise EHorseException.New.Error('Pedido não cadastrado!')<N>        .Status(THTTPStatus.NotFound);<N><N>
    if LService.Delete then<N>      Res.Status(THTTPStatus.NoContent);<N><N>  finally<N>    LService.Free;<N>  end;<N>end;<N><N>procedure Registry;<N>begin<N>  THorse.Get('/pedidos', ListarPedidos);<N>  THorse.Get('/pedidos/:id', ObterPedido);<N>  THorse.Post('/pedidos', CadatrarPedido);<N>  THorse.Put('/pedidos/:id', AlterarPedido);<N>  THorse.Delete('/pedidos/:id', DeletarPedido);<N>end;<N><N>
unit Providers.Connection;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf, FireDAC.Stan.Def,<N>  FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys, FireDAC.ConsoleUI.Wait,<N>  Data.DB, FireDAC.Comp.Client, FireDAC.Phys.PG, FireDAC.Phys.PGDef;<N><N>
type<N>  TProvidersConnection = class(TDataModule)<N>    FDConnection: TFDConnection;<N>    FDPhysPgDriverLink: TFDPhysPgDriverLink;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  ProvidersConnection: TProvidersConnection;<N><N>
unit Services.Auth;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, Providers.Connection, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf,<N>  FireDAC.Stan.Def, FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys,<N>  FireDAC.Phys.PG, FireDAC.Phys.PGDef, FireDAC.ConsoleUI.Wait, Data.DB,<N>  FireDAC.Comp.Client, FireDAC.Stan.Param, FireDAC.DatS, FireDAC.DApt.Intf,<N>  FireDAC.DApt, FireDAC.Comp.DataSet;<N><N>
type<N>  TServiceAuth = class(TProvidersConnection)<N>    vQryLogin: TFDQuery;<N>    vQryLoginid: TLargeintField;<N>    vQryLoginsenha: TWideStringField;<N>  private<N>    { Private declarations }<N>  public<N>    function PermitirAcesso(const AUsuario, ASenha: string): Boolean;<N>  end;<N><N>
var<N>  ServiceAuth: TServiceAuth;<N><N>implementation<N><N>{%CLASSGROUP 'System.Classes.TPersistent'}<N>{$R *.dfm}<N>{ TServiceAuth }<N><N>uses BCrypt;<N><N>function TServiceAuth.PermitirAcesso(const AUsuario, ASenha: string): Boolean;<N>begin<N>  vQryLogin.ParamByName('login').AsString := AUsuario;<N>  vQryLogin.Open();<N><N>
unit Unit1;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs;<N><N>type<N>  TForm1 = class(TForm)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form1: TForm1;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit unitCadPacientes;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs;<N><N>type<N>  TformCadPacientes = class(TForm)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  formCadPacientes: TformCadPacientes;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit unitPrincipal;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,<N>  System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.Menus, Vcl.StdCtrls, Vcl.Buttons,<N>  Vcl.ExtCtrls, Vcl.Imaging.jpeg;<N><N>
type<N>  TformPrincipal = class(TForm)<N>    Panel1: TPanel;<N>    BitBtn1: TBitBtn;<N>    BitBtn2: TBitBtn;<N>    MainMenu1: TMainMenu;<N>    Sistema1: TMenuItem;<N>    Sair1: TMenuItem;<N>    Cadastros1: TMenuItem;<N>    Image1: TImage;<N>    procedure Sair1Click(Sender: TObject);<N>    procedure BitBtn1Click(Sender: TObject);<N>    procedure BitBtn2Click(Sender: TObject);<N><N>
  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  formPrincipal: TformPrincipal;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses unitCadPacientes, unitCadAgendamentos;<N><N>procedure TformPrincipal.BitBtn1Click(Sender: TObject);<N>begin<N>  formCadPacientes.ShowModal;<N>end;<N><N>
unit unitCadAgendamentos;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs;<N><N>type<N>  TformCadAgendamentos = class(TForm)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  formCadAgendamentos: TformCadAgendamentos;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit Unit2;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs;<N><N>type<N>  TForm2 = class(TForm)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form2: TForm2;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit UfraTeam.Registry;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants, <N>  FMX.Types, FMX.Graphics, FMX.Controls, FMX.Forms, FMX.Dialogs, FMX.StdCtrls,<N>  FMX.Controls.Presentation, FMX.Edit, FMX.Objects, FMX.Layouts;<N><N>
type<N>  TfraTeamRegistry = class(TFrame)<N>    rectPrincipal: TRectangle;<N>    lytPrincipal: TLayout;<N>    Image1: TImage;<N>    lytBotoes: TLayout;<N>    rectNome: TRectangle;<N>    edtNome: TEdit;<N>    rectSalvar: TRectangle;<N>    Label1: TLabel;<N>    rectVoltar: TRectangle;<N>    Label2: TLabel;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit UfrmLogin.Authentication;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects,<N>  FMX.Layouts, FMX.Controls.Presentation, FMX.StdCtrls, FMX.Edit;<N><N>
unit UfrmLogin;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects,<N>  FMX.Layouts, FMX.Controls.Presentation, FMX.StdCtrls;<N><N>
unit UfrmHome;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects,<N>  FMX.Layouts, FMX.Controls.Presentation, FMX.StdCtrls, FMX.MultiView,<N>  FMX.ListBox;<N><N>
type<N>  TfrmHome = class(TForm)<N>    rectPrincipal: TRectangle;<N>    MultiView1: TMultiView;<N>    Rectangle1: TRectangle;<N>    imgLogo: TImage;<N>    lytLogo: TLayout;<N>    lstMenu: TListBox;<N>    btnMenu: TSpeedButton;<N>    lytContainer: TLayout;<N>    imgDevsHome: TImage;<N>    StyleBook1: TStyleBook;<N><N>
    procedure lstMenuItemClick(const Sender: TCustomListBox; const Item: TListBoxItem);<N>    procedure FormClose(Sender: TObject; var Action: TCloseAction);<N>  private<N>    { Private declarations }<N>    procedure AbrirTeam;<N>    procedure AbrirMatch;<N>    procedure AbrirBet;<N><N>
    procedure RemoverTelaAnterior;<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  frmHome: TfrmHome;<N><N>implementation<N><N>{$R *.fmx}<N><N>uses<N>  UfraTeam,<N>  UfraMatch,<N>  UfraBet,<N>  UUtils.Enums;<N><N>procedure TfrmHome.AbrirTeam;<N>begin<N>  if not Assigned(FraTeam) then<N>    FraTeam := TFraTeam.Create(Application);<N><N>
  FraTeam.Align := TAlignLayout.Center;<N>  lytContainer.AddObject(FraTeam);<N>end;<N><N>procedure TfrmHome.FormClose(Sender: TObject; var Action: TCloseAction);<N>begin<N>  Action  := TCloseAction.caFree;<N>  frmHome := nil;<N>end;<N><N>procedure TfrmHome.AbrirMatch;<N>begin<N>  if not Assigned(FraMatch) then<N>    FraMatch := TFraMatch.Create(Application);<N><N>
  FraMatch.Align := TAlignLayout.Center;<N>  lytContainer.AddObject(FraMatch);<N>end;<N><N>procedure TfrmHome.AbrirBet;<N>begin<N>  if not Assigned(FraBet) then<N>    FraBet := TFraBet.Create(Application);<N><N>  FraBet.Align := TAlignLayout.Center;<N>  lytContainer.AddObject(FraBet);<N>end;<N><N>
procedure TfrmHome.lstMenuItemClick(const Sender: TCustomListBox;<N>  const Item: TListBoxItem);<N>begin<N>  Self.RemoverTelaAnterior;<N><N>  case TEnumMenu(Item.Index) of<N>    mnuTime:<N>      Self.AbrirTeam;<N>    mnuPartidas:<N>      Self.AbrirMatch;<N>    mnuPalpites:<N>      Self.AbrirBet;<N>    mnuSair:<N>      Self.Close;<N>  end;<N><N>
  MultiView1.HideMaster;<N>end;<N><N>procedure TfrmHome.RemoverTelaAnterior;<N>var<N>  I: Integer;<N>begin<N>  for I := Pred(lytContainer.ControlsCount) downto 0 do<N>    if lytContainer.Controls[I].Name <> 'imgDevsHome' then<N>      lytContainer.RemoveObject(I);<N>end;<N><N>
unit UfraTeam.Registry;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants, <N>  FMX.Types, FMX.Graphics, FMX.Controls, FMX.Forms, FMX.Dialogs, FMX.StdCtrls,<N>  FMX.Controls.Presentation, FMX.Edit, FMX.Objects, FMX.Layouts;<N><N>
unit UfraMatch.Registry;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants, <N>  FMX.Types, FMX.Graphics, FMX.Controls, FMX.Forms, FMX.Dialogs, FMX.StdCtrls,<N>  FMX.Controls.Presentation, FMX.Edit, FMX.Objects, FMX.Layouts, FMX.ListBox,<N><N>
unit UfraMatch.Registry;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants, <N>  FMX.Types, FMX.Graphics, FMX.Controls, FMX.Forms, FMX.Dialogs, FMX.StdCtrls,<N>  FMX.Controls.Presentation, FMX.Edit, FMX.Objects, FMX.Layouts, FMX.ListBox,<N><N>
unit UService.Intf;<N><N>interface<N><N>type<N>  IService = interface<N>    procedure CarregarToken;<N>    procedure Registrar;<N>    procedure Listar;<N>    procedure Excluir;<N><N>    function ObterRegistro(const aId: Integer): TObject;<N>  end;<N><N>implementation<N><N>end.<N>
unit UService.Base;<N><N>interface<N><N>uses<N>  UService.Intf, REST.Client, REST.Types;<N><N>type<N>  TServiceBase = class(TInterfacedObject, IService)<N>    private<N>      FToken: String;<N>    protected<N>      FRESTClient: TRESTClient;<N>      FRESTRequest: TRESTRequest;<N>      FRESTResponse: TRESTResponse;<N><N>
      procedure CarregarToken;<N><N>      procedure Registrar; virtual; abstract;<N>      procedure Listar; virtual; abstract;<N>      procedure Excluir; virtual; abstract;<N><N>      function ObterRegistro(const aId: Integer): TObject; virtual; abstract;<N>    public<N>      constructor Create;<N>      destructor  Destroy; override;<N>  end;<N><N>
unit UUtils.Enums;<N><N>interface<N><N>type<N>  TEnumMenu = (mnuHome, mnuTime, mnuPartidas, mnuPalpites, mnuSair);<N><N>implementation<N><N>end.<N>
unit UUtils.Functions;<N><N>interface<N><N>type<N>  TUtilsFunctions = class<N>    public<N>      class function IIF<T>(const aConditional: Boolean; const aValueTrue,aValueFalse: T): T;<N>  end;<N><N>implementation<N><N>{ TUtilsFunctions }<N><N>class function TUtilsFunctions.IIF<T>(const aConditional: Boolean; const aValueTrue,<N>  aValueFalse: T): T;<N>begin<N>  if aConditional then<N>    Result := aValueTrue<N>  else<N>    Result := aValueFalse;<N>end;<N><N>end.<N>
unit UUtils.Constants;<N><N>interface<N><N>const<N>  URL_BASE_LOGIN = 'http://localhost:9000/v1/login';<N>  URL_BASE_USER  = 'http://localhost:9000/v1/users';<N>  URL_BASE_TEAM  = 'http://localhost:9000/v1/teams';<N>  URL_BASE_MATCH = 'http://localhost:9000/v1/matchs';<N>  URL_BASE_BET   = 'http://localhost:9000/v1/bets';<N><N>  API_SUCESSO             = 200;<N>  API_CRIADO              = 201;<N>  API_SUCESSO_SEM_RETORNO = 204;<N>  API_NAO_AUTORIZADO      = 401;<N><N>implementation<N><N>end.<N>
unit UDAO.Base;<N><N>interface<N><N>uses<N>  UDAO.Intf,<N>  System.JSON,<N>  DataSet.Serialize;<N><N>type<N>  TDAOBase = class(TInterfacedObject, IDAO)<N>    protected<N>      FTabela: String;<N>    public<N>      function ObterRegistros: TJSONArray; virtual;<N>      function ProcurarPorId(const aIdentificador: Integer): TJSONObject; virtual;<N>      function AdicionarRegistro(aRegistro: TJSONObject): Boolean;<N>      function DeletarRegistro(const aIdentificador: Integer): Boolean;<N>    end;<N><N>
implementation<N><N>uses<N>  FireDAC.Comp.Client,<N>  System.SysUtils,<N>  UUtil.Banco;<N><N>{ TDAOBase }<N><N>function TDAOBase.AdicionarRegistro(aRegistro: TJSONObject): Boolean;<N>begin<N>  try<N>    Result := TUtilBanco.AdicionarRegistro(FTabela, aRegistro.ToJSON);<N>  except<N>    on e: Exception do<N>      raise Exception.Create('Erro ao Adicionar Registro: '<N>        + e.Message);<N>  end;<N>end;<N><N>
function TDAOBase.DeletarRegistro(const aIdentificador: Integer): Boolean;<N>begin<N>  try<N>    Result := TUtilBanco.RemoverRegistro(FTabela, aIdentificador);<N>  except<N>    on e: Exception do<N>      raise Exception.Create('Erro ao Remover Registro: ' + e.Message);<N>  end;<N>end;<N><N>
function TDAOBase.ObterRegistros: TJSONArray;<N>begin<N>  try<N>    Result := TUtilBanco.ExecutarConsulta(Format('SELECT * FROM %s',<N>      [FTabela]));<N>  except<N>    on e: Exception do<N>      raise Exception.Create('Erro ao Obter Registros: ' + e.Message);<N>  end;<N>end;<N><N>
function TDAOBase.ProcurarPorId(const aIdentificador: Integer): TJSONObject;<N>var<N>  xJSONArray: TJSONArray;<N>begin<N>  try<N>    xJSONArray := TUtilBanco.ExecutarConsulta(<N>                    Format('SELECT * FROM %s WHERE ID = %d',<N>                      [FTabela, aIdentificador]));<N><N>
    if xJSONArray.Count = 0 then<N>    begin<N>      Result := TJSONObject.Create;<N>      xJSONArray.Free;<N>      Exit;<N>    end;<N><N>    Result := TJSONObject.ParseJSONValue(<N>      TEncoding.ASCII.GetBytes(<N>        xJSONArray[0].ToJSON), 0) as TJSONObject;<N>  except<N>    on e: Exception do<N>      raise Exception.Create('Erro ao Obter Registros: ' + e.Message);<N>  end;<N>end;<N><N>
unit UDAO.Bets;<N><N>interface<N><N>uses<N>  UDAO.Base, System.JSON;<N><N>type<N>  TDAOBets = class(TDAOBase)<N>    private<N>      function FindUser(const aId: Integer): TJSONObject;<N>      function FindMatch(const aId: Integer): TJSONObject;<N>    public<N>      Constructor Create;<N>      function ObterRegistros: TJSONArray; override;<N>      function ProcurarPorId(const aIdentificador: Integer): TJSONObject; override;<N>  end;<N><N>
implementation<N><N>uses<N>  System.SysUtils, UDAO.Intf, UDAO.Users, UDAO.Matchs;<N><N>{ TDAOBets }<N><N>constructor TDAOBets.Create;<N>begin<N>  FTabela := 'bets';<N>end;<N><N>function TDAOBets.FindMatch(const aId: Integer): TJSONObject;<N>var<N>  xDAO: IDAO;<N>begin<N>  xDAO := TDAOMatchs.Create;<N>  try<N>    Result := xDAO.ProcurarPorId(aId);<N>  finally<N>    xDAO := nil;<N>  end;<N>end;<N><N>
function TDAOBets.FindUser(const aId: Integer): TJSONObject;<N>var<N>  xDAO: IDAO;<N>begin<N>  xDAO := TDAOUsers.Create;<N>  try<N>    Result := xDAO.ProcurarPorId(aId);<N>  finally<N>    xDAO := nil;<N>  end;<N>end;<N><N>function TDAOBets.ObterRegistros: TJSONArray;<N>var<N>  xJSONArray, xJSONArrayAux: TJSONArray;<N>  xJSONObject: TJSONObject;<N>  I: Integer;<N>  xIdUser: Integer;<N>  xIdMatch: Integer;<N>begin<N>  xJSONArray := inherited;<N><N>
  if xJSONArray.Count = 0 then<N>    Exit(xJSONArray);<N><N>  xJSONArrayAux := TJSONArray.Create;<N><N>  for I := 0 to Pred(xJSONArray.Count) do<N>  begin<N>    xJSONObject := TJSONObject.ParseJSONValue(<N>      TEncoding.ASCII.GetBytes(<N>        xJSONArray[I].ToJSON), 0) as TJSONObject;<N><N>
    xIdUser := StrToInt(xJSONObject.GetValue('idUser').Value);<N>    xJSONObject.AddPair('user', Self.FindUser(xIdUser));<N>    xJSONObject.RemovePair('idUser');<N><N>    xIdMatch := StrToInt(xJSONObject.GetValue('idMatch').Value);<N>    xJSONObject.AddPair('match', Self.FindMatch(xIdMatch));<N>    xJSONObject.RemovePair('idMatch');<N><N>
    xJSONArrayAux.AddElement(xJSONObject);<N>  end;<N><N>  FreeAndNil(xJSONArray);<N>  Result := xJSONArrayAux;<N>end;<N><N>function TDAOBets.ProcurarPorId(const aIdentificador: Integer): TJSONObject;<N>var<N>  xJSONObject: TJSONObject;<N>  xIdUser: Integer;<N>  xIdMatch: Integer;<N>begin<N>  xJSONObject := inherited;<N><N>
  if xJSONObject.Count = 0 then<N>    Exit(xJSONObject);<N><N>  xIdUser := StrToInt(xJSONObject.GetValue('idUser').Value);<N>  xJSONObject.AddPair('user', Self.FindUser(xIdUser));<N>  xJSONObject.RemovePair('idUser');<N><N>  xIdMatch := StrToInt(xJSONObject.GetValue('idMatch').Value);<N>  xJSONObject.AddPair('match', Self.FindMatch(xIdMatch));<N>  xJSONObject.RemovePair('idMatch');<N><N>
unit UDAO.Intf;<N><N>interface<N><N>uses<N>  System.JSON;<N><N>type<N>  IDAO = Interface<N>    function ObterRegistros: TJSONArray;<N>    function ProcurarPorId(const aIdentificador: Integer): TJSONObject;<N>    function AdicionarRegistro(aRegistro: TJSONObject): Boolean;<N>    function DeletarRegistro(const aIdentificador: Integer): Boolean;<N>  End;<N><N>implementation<N><N>end.<N>
unit UDAO.Matchs;<N><N>interface<N><N>uses<N>  UDAO.Base, System.JSON;<N><N>type<N>  TDAOMatchs = class(TDAOBase)<N>    private<N>      function FindTeam(const aId: Integer): TJSONObject;<N>    public<N>      Constructor Create;<N>      function ObterRegistros: TJSONArray; override;<N>      function ProcurarPorId(const aIdentificador: Integer): TJSONObject; override;<N>  end;<N><N>
implementation<N><N>uses<N>  System.SysUtils, UDAO.Intf, UDAO.Teams;<N><N>{ TDAOMatchs }<N><N>function TDAOMatchs.FindTeam(const aId: Integer): TJSONObject;<N>var<N>  xDAO: IDAO;<N>begin<N>  xDAO := TDAOTeams.Create;<N>  try<N>    Result := xDAO.ProcurarPorId(aId);<N>  finally<N>    xDAO := nil;<N>  end;<N>end;<N><N>
constructor TDAOMatchs.Create;<N>begin<N>  FTabela := 'matchs';<N>end;<N><N>function TDAOMatchs.ObterRegistros: TJSONArray;<N>var<N>  xJSONArray, xJSONArrayAux: TJSONArray;<N>  xJSONObject: TJSONObject;<N>  I: Integer;<N>  xIdTeam: Integer;<N>begin<N>  xJSONArray := inherited;<N><N>
  if xJSONArray.Count = 0 then<N>    Exit(xJSONArray);<N><N>  xJSONArrayAux := TJSONArray.Create;<N><N>  for I := 0 to Pred(xJSONArray.Count) do<N>  begin<N>    xJSONObject := TJSONObject.ParseJSONValue(<N>      TEncoding.ASCII.GetBytes(<N>        xJSONArray[I].ToJSON), 0) as TJSONObject;<N><N>
    xIdTeam := StrToInt(xJSONObject.GetValue('idTeamA').Value);<N>    xJSONObject.AddPair('teamA', Self.FindTeam(xIdTeam));<N>    xJSONObject.RemovePair('idTeamA');<N><N>    xIdTeam := StrToInt(xJSONObject.GetValue('idTeamB').Value);<N>    xJSONObject.AddPair('teamB', Self.FindTeam(xIdTeam));<N>    xJSONObject.RemovePair('idTeamB');<N><N>
    xJSONArrayAux.AddElement(xJSONObject);<N>  end;<N><N>  FreeAndNil(xJSONArray);<N>  Result := xJSONArrayAux;<N>end;<N><N>function TDAOMatchs.ProcurarPorId(const aIdentificador: Integer): TJSONObject;<N>var<N>  xJSONObject: TJSONObject;<N>  xIdTeam: Integer;<N>begin<N>  xJSONObject := inherited;<N><N>
  if xJSONObject.Count = 0 then<N>    Exit(xJSONObject);<N><N>  xIdTeam := StrToInt(xJSONObject.GetValue('idTeamA').Value);<N>  xJSONObject.AddPair('teamA', Self.FindTeam(xIdTeam));<N>  xJSONObject.RemovePair('idTeamA');<N><N>  xIdTeam := StrToInt(xJSONObject.GetValue('idTeamB').Value);<N>  xJSONObject.AddPair('teamB', Self.FindTeam(xIdTeam));<N>  xJSONObject.RemovePair('idTeamB');<N><N>
unit UDAO.Teams;<N><N>interface<N><N>uses<N>  UDAO.Base;<N><N>type<N>  TDAOTeams = class(TDAOBase)<N>    public<N>      constructor Create;<N>  end;<N><N>implementation<N><N>{ TDAOTeams }<N><N>constructor TDAOTeams.Create;<N>begin<N>  FTabela := 'teams';<N>end;<N><N>end.<N>
unit UEntity.Matchs;<N><N>interface<N><N>uses<N>  UEntity.Teams,<N>  System.JSON,<N>  GBSwagger.Model.Attributes;<N><N>type<N>  TMatch = class<N>    private<N>      FId: Integer;<N>      FDate: TDate;<N>      FHour: TTime;<N>      FTeamA: TTeam;<N>      FTeamB: TTeam;<N>      FResultTeamA: Byte;<N>      FResultTeamB: Byte;<N>      FStatus: Byte;<N>      FJSON: TJSONObject;<N><N>
      function GetDate: TDate;<N>      function GetHour: TTime;<N>      function GetId: Integer;<N>      function GetResultTeamA: Byte;<N>      function GetResultTeamB: Byte;<N>      function GetStatus: Byte;<N>      function GetTeamA: TTeam;<N>      function GetTeamB: TTeam;<N>      function GetJSON: TJSONObject;<N><N>
unit TGC.Component;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, TGC.Client;<N><N>procedure Register;<N><N>implementation<N><N>procedure Register;<N>begin<N>  RegisterComponents('Telegram Client', [TTelegramClient]);<N>end;<N><N>end.<N><N>
﻿unit Unit5;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Memo.Types,<N>  FMX.Controls.Presentation, FMX.ScrollBox, FMX.Memo, FMX.Layouts, FMX.StdCtrls,<N>  System.JSON, System.Generics.Collections;<N><N>
type<N>  TProp = record<N>    AType: string;<N>    AName: string;<N>    FName: string;<N>  end;<N><N>  TForm5 = class(TForm)<N>    MemoIn: TMemo;<N>    MemoOut: TMemo;<N>    Layout1: TLayout;<N>    ButtonProc: TButton;<N>    procedure ButtonProcClick(Sender: TObject);<N>    procedure FormCreate(Sender: TObject);<N>    procedure FormDestroy(Sender: TObject);<N>  private<N>    FProps: TList<TProp>;<N>    procedure ProcUpdateOption(JSON: TJSONObject);<N>    procedure BuildClass;<N>  end;<N><N>
﻿unit Unit4;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, TGC.Client,<N>  FMX.Memo.Types, FMX.Controls.Presentation, FMX.ScrollBox, FMX.Memo,<N>  TGC.Handler, TGC.Handler.UpdateAuthorizationState, FMX.StdCtrls;<N><N>
﻿unit TGC.Handler.UpdateOption;<N><N>interface<N><N>uses<N>  System.Classes, System.SysUtils, System.JSON, TGC.Handler, TGC.Options;<N><N>type<N>  TUpdateOption = class(THandler)<N>  private<N>    FOptions: TtgOptions;<N>    procedure UpdateOption(const FieldName, AType: string; Value: TJSONValue);<N>  public<N>    procedure Execute(JSON: TJSONObject); override;<N>    constructor Create(AClient: TObject); override;<N>  end;<N><N>
﻿unit TGC.Handler.UpdateAuthorizationState;<N><N>interface<N><N>uses<N>  System.Classes, System.SysUtils, System.JSON, TGC.Handler, HGM.JSONParams;<N><N>type<N>  TSetTdlibParameters = class(TJSONParam)<N>  end;<N><N>  TTermsOfServiceText = class<N>  private<N>    FText: string;<N>  public<N>    property Text: string read FText write FText;<N>  end;<N><N>
  TTermsOfService = class<N>  private<N>    FMin_user_age: Integer;<N>    FShow_popup: Boolean;<N>    FText: TTermsOfServiceText;<N>  public<N>    property MinUserAge: Integer read FMin_user_age write FMin_user_age;<N>    property ShowPopup: Boolean read FShow_popup write FShow_popup;<N>    property Text: TTermsOfServiceText read FText write FText;<N>    destructor Destroy; override;<N>  end;<N><N>
  TUpdateAuthorizationState = class(THandler)<N>  private<N>    procedure SendSetParams;<N>    procedure DoNeedRegistration(JSON: TJSONObject);<N>  public<N>    procedure Execute(JSON: TJSONObject); override;<N>  end;<N><N>implementation<N><N>uses<N>  TGC.Client, REST.Json;<N><N>
﻿unit TGC.Builder.SendMessage;<N><N>interface<N><N>uses<N>  TGC.Classes;<N><N>type<N>  TInputMessageContent = class(TParam);<N><N>  TTextEntityType = class(TParam);<N><N>  /// <summary><N>  /// A bank card number. The getBankCardInfo method can be used to get information about the bank card.<N>  /// </summary><N>  TTextEntityTypeBankCardNumber = class(TTextEntityType)<N>    constructor Create; reintroduce;<N>  end;<N><N>
  /// <summary><N>  /// A bold text.<N>  /// </summary><N>  TTextEntityTypeBold = class(TTextEntityType)<N>    constructor Create; reintroduce;<N>  end;<N><N>  /// <summary><N>  /// A bot command, beginning with "/".<N>  /// </summary><N>  TTextEntityTypeBotCommand = class(TTextEntityType)<N>    constructor Create; reintroduce;<N>  end;<N><N>
  /// <summary><N>  /// A cashtag text, beginning with "$" and consisting of capital English letters (e.g., "$USD").<N>  /// </summary><N>  TTextEntityTypeCashtag = class(TTextEntityType)<N>    constructor Create; reintroduce;<N>  end;<N><N>  /// <summary><N>  /// Text that must be formatted as if inside a code HTML tag.<N>  /// </summary><N>  TTextEntityTypeCode = class(TTextEntityType)<N>    constructor Create; reintroduce;<N>  end;<N>  /// <summary><N>  /// An email address.<N>  /// </summary><N><N>
  TTextEntityTypeEmailAddress = class(TTextEntityType)<N>    constructor Create; reintroduce;<N>  end;<N><N>  /// <summary><N>  /// A hashtag text, beginning with "#".<N>  /// </summary><N>  TTextEntityTypeHashtag = class(TTextEntityType)<N>    constructor Create; reintroduce;<N>  end;<N><N>
﻿unit TGC.Classes;<N><N>interface<N><N>uses<N>  System.Classes, HGM.JSONParams, System.Generics.Collections, System.SysUtils;<N><N>type<N>  TThreadObject<T: class, constructor> = class<N>  private<N>    FLock: TObject;<N>  protected<N>    FObject: T;<N>  public<N>    constructor Create;<N>    destructor Destroy; override;<N>    function Lock: T;<N>    procedure Locked(Proc: TProc<T>);<N>    procedure Unlock; inline;<N>  end;<N><N>
  TSafeDictionary<KeyType, ValueType> = class(TDictionary<KeyType, ValueType>)<N>    constructor Create;<N>  end;<N><N>  TThreadDict<KeyType, ValueType> = class(TThreadObject<TSafeDictionary<KeyType, ValueType>>)<N>  public<N>    procedure Add(const Key: KeyType; const Item: ValueType);<N>    procedure Clear;<N>    procedure Remove(const Key: KeyType); inline;<N>  end;<N><N>
  TParam = class(TJSONParam)<N>    function Extra(const Value: Int64): TParam;<N>    constructor Create(AType: string); reintroduce;<N>  end;<N><N>  TGetMe = class(TParam)<N>    constructor Create; reintroduce;<N>  end;<N><N>implementation<N><N>{ TParam }<N><N>
constructor TParam.Create(AType: string);<N>begin<N>  inherited Create;<N>  Add('@type', AType);<N>end;<N><N>function TParam.Extra(const Value: Int64): TParam;<N>begin<N>  Result := TParam(Add('@extra', Value));<N>end;<N><N>{ TGetMe }<N><N>constructor TGetMe.Create;<N>begin<N>  inherited Create('getMe');<N>end;<N><N>
{ TThreadObject<T> }<N><N>constructor TThreadObject<T>.Create;<N>begin<N>  if T.ClassName.StartsWith('TDictionary<') then<N>    raise Exception.Create('Not allow default TDictionary');<N>  inherited Create;<N>  FLock := TObject.Create;<N>  FObject := T.Create;<N>end;<N><N>
destructor TThreadObject<T>.Destroy;<N>begin<N>  Lock;<N>  try<N>    FObject.Free;<N>    inherited Destroy;<N>  finally<N>    Unlock;<N>    FLock.Free;<N>  end;<N>end;<N><N>function TThreadObject<T>.Lock: T;<N>begin<N>  TMonitor.Enter(FLock);<N>  Result := FObject;<N>end;<N><N>
procedure TThreadObject<T>.Locked(Proc: TProc<T>);<N>begin<N>  Lock;<N>  try<N>    Proc(FObject);<N>  finally<N>    Unlock;<N>  end;<N>end;<N><N>procedure TThreadObject<T>.Unlock;<N>begin<N>  TMonitor.Exit(FLock);<N>end;<N>{ TThreadDict<TKey, ValueType> }<N><N>
procedure TThreadDict<KeyType, ValueType>.Add(const Key: KeyType; const Item: ValueType);<N>begin<N>  Lock;<N>  try<N>    FObject.AddOrSetValue(Key, Item);<N>  finally<N>    Unlock;<N>  end;<N>end;<N><N>procedure TThreadDict<KeyType, ValueType>.Clear;<N>begin<N>  Lock;<N>  try<N>    FObject.Clear;<N>  finally<N>    Unlock;<N>  end;<N>end;<N><N>
procedure TThreadDict<KeyType, ValueType>.Remove(const Key: KeyType);<N>begin<N>  Lock;<N>  try<N>    Remove(Key);<N>  finally<N>    Unlock;<N>  end;<N>end;<N>{ TSafeDictionary<KeyType, ValueType> }<N><N>constructor TSafeDictionary<KeyType, ValueType>.Create;<N>begin<N>  inherited Create(0);<N>end;<N><N>
﻿unit TGC.Handler;<N><N>interface<N><N>uses<N>  System.Classes, System.JSON;<N>//{"@type":"updateOption","name":"version","value":{"@type":"optionValueString","value":"1.7.0"}}<N><N>type<N>  THandler = class<N>  private<N>    FClient: TObject;<N>  public<N>    procedure Execute(JSON: TJSONObject); virtual; abstract;<N>    constructor Create(AClient: TObject); virtual;<N>    property Client: TObject read FClient;<N>  end;<N><N>
﻿unit TGC.Handler.Error;<N><N>interface<N><N>uses<N>  System.Classes, System.SysUtils, System.JSON, TGC.Handler;<N><N>type<N>  TError = class(THandler)<N>  public<N>    procedure Execute(JSON: TJSONObject); override;<N>  end;<N><N>implementation<N><N>uses<N>  TGC.Client;<N><N>{ TError }<N><N>procedure TError.Execute(JSON: TJSONObject);<N>begin<N>  inherited;<N>  TTelegramClientCustom(Client).Error(JSON.GetValue<integer>('code', -1), JSON.GetValue('message', ''));<N>end;<N><N>end.<N><N>
﻿unit TGC.Client;<N><N>interface<N><N>uses<N>  System.Classes, System.SysUtils, System.Generics.Collections, System.Threading,<N>  System.JSON, TGC.Wrapper, TGC.Handler, TGC.Handler.UpdateAuthorizationState,<N>  TGC.Entity.User, TGC.Classes, TGC.Options, TGC.Builder.SendMessage,<N>  TGC.Entity.Message;<N><N>
const<N>  DEFAULT_WAIT_TIMEOUT = 10.0;<N><N>type<N>  TRequestId = Int64;<N><N>  TTelegramClientCustom = class;<N><N>  TOnReceiveRaw = procedure(Sender: TObject; const Data: string) of object;<N><N>  TOnNeedAuthConfirm = procedure(Sender: TObject; const Link: string) of object;<N><N>
unit TGC.Wrapper;<N><N>interface<N><N>type<N>  TGChar = PAnsiChar;<N><N>  TVoid = IntPtr;<N><N>const<N>  {$IFDEF MSWINDOWS}<N>  TDLibDLLName: string = 'tdjson.dll';<N>  {$ELSE}<N>  TDLibDLLName: string = 'libtdjson.so';<N>  {$ENDIF}<N><N>type<N>  /// <summary><N>  /// A type of callback function that will be called when a message is added to the internal TDLib log.<N>  /// </summary><N>  TLogMessageCallback = procedure(ErrorMessage: TGChar);<N><N>
unit Name_DB;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes;<N><N>type<N>  TDataModule1 = class(TDataModule)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  DataModule1: TDataModule1;<N><N>implementation<N><N>{%CLASSGROUP 'Vcl.Controls.TControl'}<N><N>{$R *.dfm}<N><N>end.<N>
unit HosxpReg;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs;<N><N>type<N>  TForm1 = class(TForm)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form1: TForm1;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit Hosxp_Create;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.StdCtrls, DM_hosxp,<N>  Data.DB, Vcl.Grids, Vcl.DBGrids ;<N><N>
unit Hosxp_edit;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.StdCtrls, Data.DB,<N>  Vcl.Grids, Vcl.DBGrids, DM_hosxp;<N><N>
type<N>  THosxp_editmain = class(TForm)<N>    Panel_edit: TPanel;<N>    grid_edit: TDBGrid;<N>    Button1: TButton;<N>    procedure Button1Click(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  Hosxp_editmain: THosxp_editmain;<N><N>implementation<N><N>{$R *.dfm}<N><N>procedure THosxp_editmain.Button1Click(Sender: TObject);<N>var iCD4,iID:integer;<N>begin<N>iID := StrToInt(Inputbox('ID',' ID to change :',''));<N>iCD4 := StrToInt(Inputbox('value','change CD4 value by:',''));<N><N>
with dm_database do<N>begin<N>  if dm_table.Locate('ID',iID,[])=true then<N>    begin<N>      dm_table.Edit;<N>      dm_table['CD4']:=iCD4;<N>      dm_table.post;<N>    end<N>  else<N>    begin<N>      showmessage('not found!');<N>    end;<N><N>end;<N><N><N><N>
unit HosxpCal;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ExtCtrls;<N><N>type<N>  TForm1 = class(TForm)<N>    Edit1: TEdit;<N>    Panel1: TPanel;<N>    Label1: TLabel;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form1: TForm1;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit DM_hosxp;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, Data.DB, Data.Win.ADODB;<N><N>type<N>  Tdm_database = class(TDataModule)<N>    dm_connect: TADOConnection;<N>    dm_table: TADOTable;<N>    dm_dsc: TDataSource;<N>    dm_query: TADOQuery;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  dm_database: Tdm_database;<N><N>implementation<N><N>{%CLASSGROUP 'Vcl.Controls.TControl'}<N><N>{$R *.dfm}<N><N>end.<N>
unit HosxpAddition;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ExtCtrls;<N><N>type<N>  TForm2 = class(TForm)<N>    Panel1: TPanel;<N>    Panel2: TPanel;<N>    Label1: TLabel;<N>    Label2: TLabel;<N>    Label3: TLabel;<N>    Label4: TLabel;<N>    btn_add_save: TButton;<N>    btn_add_cancel: TButton;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form2: TForm2;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit HosxpLogin;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, ExtCtrls, StdCtrls, jpeg;<N><N>type<N>  THosxpLogins = class(TForm)<N>    Image1: TImage;<N>    username: TEdit;<N>    Login: TButton;<N>    password: TEdit;<N>    Cancel: TButton;<N>    procedure LoginClick(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>    NewString : integer;<N><N>
unit HosxpCreate;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ExtCtrls;<N><N>type<N>  THosxpCreate1 = class(TForm)<N>    Label1: TLabel;<N>    Label2: TLabel;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  HosxpCreate1: THosxpCreate1;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit HosxpUpdate;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs;<N><N>type<N>  TForm3 = class(TForm)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form3: TForm3;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit HosxpData;<N><N>interface<N><N>uses<N>  SysUtils, Classes, WideStrings, DBXMySql, DB, SqlExpr;<N><N>type<N>  TDataModule1 = class(TDataModule)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  DataModule1: TDataModule1;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
{<N>  Copyright 2014 Stas'M Corp.<N><N>  Licensed under the Apache License, Version 2.0 (the "License");<N>  you may not use this file except in compliance with the License.<N>  You may obtain a copy of the License at<N><N>      http://www.apache.org/licenses/LICENSE-2.0<N><N>
  Unless required by applicable law or agreed to in writing, software<N>  distributed under the License is distributed on an "AS IS" BASIS,<N>  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<N>  See the License for the specific language governing permissions and<N>  limitations under the License.<N>}<N><N>
unit LiteINI;<N><N>interface<N><N>uses<N>  SysUtils;<N><N>type<N>  SList = Array of String;<N>  INIValue = record<N>    Name: String;<N>    Value: String;<N>  end;<N>  INISection = record<N>    Name: String;<N>    Values: Array of INIValue;<N>  end;<N>  INIFile = Array of INISection;<N><N>
{<N>  Copyright 2014 Stas'M Corp.<N><N>  Licensed under the Apache License, Version 2.0 (the "License");<N>  you may not use this file except in compliance with the License.<N>  You may obtain a copy of the License at<N><N>      http://www.apache.org/licenses/LICENSE-2.0<N><N>
  Unless required by applicable law or agreed to in writing, software<N>  distributed under the License is distributed on an "AS IS" BASIS,<N>  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<N>  See the License for the specific language governing permissions and<N>  limitations under the License.<N>}<N><N>
unit LicenseUnit;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls;<N><N>type<N>  TLicenseForm = class(TForm)<N>    mText: TMemo;<N>    bAccept: TButton;<N>    bDecline: TButton;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
{<N>  Copyright 2017 Stas'M Corp.<N><N>  Licensed under the Apache License, Version 2.0 (the "License");<N>  you may not use this file except in compliance with the License.<N>  You may obtain a copy of the License at<N><N>      http://www.apache.org/licenses/LICENSE-2.0<N><N>
  Unless required by applicable law or agreed to in writing, software<N>  distributed under the License is distributed on an "AS IS" BASIS,<N>  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<N>  See the License for the specific language governing permissions and<N>  limitations under the License.<N>}<N><N>
{<N>  Copyright 2015 Stas'M Corp.<N><N>  Licensed under the Apache License, Version 2.0 (the "License");<N>  you may not use this file except in compliance with the License.<N>  You may obtain a copy of the License at<N><N>      http://www.apache.org/licenses/LICENSE-2.0<N><N>
  Unless required by applicable law or agreed to in writing, software<N>  distributed under the License is distributed on an "AS IS" BASIS,<N>  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<N>  See the License for the specific language governing permissions and<N>  limitations under the License.<N>}<N><N>
unit MainUnit;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, OleServer, MSTSCLib_TLB, OleCtrls, Registry;<N><N>type<N>  TFrm = class(TForm)<N>    RDP: TMsRdpClient2;<N>    procedure RDPDisconnected(ASender: TObject; discReason: Integer);<N>    procedure FormCreate(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  Frm: TFrm;<N>  SecurityLayer, UserAuthentication: DWORD;<N><N>implementation<N><N>{$R *.dfm}<N><N>procedure TFrm.FormCreate(Sender: TObject);<N>var<N>  Reg: TRegistry;<N>begin<N>  RDP.DisconnectedText := 'Disconnected.';<N>  RDP.ConnectingText := 'Connecting...';<N>  RDP.ConnectedStatusText := 'Connected.';<N>  RDP.UserName := '';<N>  RDP.Server := '127.0.0.2';<N>  Reg := TRegistry.Create;<N>  Reg.RootKey := HKEY_LOCAL_MACHINE;<N><N>
  if Reg.OpenKey('\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp', True) then<N>  begin<N>    try<N>      SecurityLayer := Reg.ReadInteger('SecurityLayer');<N>      UserAuthentication := Reg.ReadInteger('UserAuthentication');<N>      Reg.WriteInteger('SecurityLayer', 0);<N>      Reg.WriteInteger('UserAuthentication', 0);<N>    except<N><N>
    end;<N>    Reg.CloseKey;<N>  end;<N><N>  if Reg.OpenKeyReadOnly('\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp') then begin<N>    try<N>      RDP.AdvancedSettings2.RDPPort := Reg.ReadInteger('PortNumber');<N>    except<N><N>    end;<N>    Reg.CloseKey;<N>  end;<N>  Reg.Free;<N>  Sleep(1000);<N>  RDP.Connect;<N>end;<N><N>
unit ControllerEndereco;<N><N>interface<N><N>uses<N>  Endereco, unDm, FireDAC.Comp.Client;<N><N>type<N>  TControleEndereco = class<N>  private<N><N><N>  public<N>    procedure DadosEndereco(pEndereco: TEndereco);<N>    procedure AlterarRegistro(oEndereco: TEndereco);<N>    procedure InserirRegistro(oEndereco: TEndereco);<N>    function RegistroExistente(pIdPessoa: longInt): Boolean;<N>  end;<N><N>
unit Endereco;<N><N>interface<N><N>uses SysUtils;<N><N>type<N>  TEndereco = class<N>  private<N>    FIdEndereco: LongInt;<N>    FIdPessoa : LongInt;<N>    FDsCep: string;<N>    procedure SetDsCep(const Value: string);<N>  public<N>    property IdEndereco: LongInt read FIdEndereco write FIdEndereco;<N>    property IdPessoa: LongInt read FIdPessoa write FIdPessoa;<N>    property DsCep: string read FDsCep write SetDsCep;<N>  end;<N><N>
unit Unit1;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls;<N><N>type<N>  TForm1 = class(TForm)<N>    Label1: TLabel;<N>    Edit1: TEdit;<N>    Button1: TButton;<N>    procedure Button1Click(Sender: TObject);<N>    procedure FormCreate(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  Form1: TForm1;<N><N>implementation<N><N>{$R *.dfm}<N><N>function WypiszPodmioty(klucz, nip: PAnsiChar): PAnsiChar; cdecl; external 'gus_api.dll';<N>procedure TForm1.Button1Click(Sender: TObject);<N>begin<N>  Label1.Caption := WypiszPodmioty('', PAnsiChar(Edit1.Text));<N>end;<N><N>
unit JsonComponent;<N><N>{$mode objfpc}{$H+}<N>{<N>       Adaptado por Amaury Carvalho (amauryspires@gmail.com), 2023<N>       Original: https://forum.lazarus.freepascal.org/index.php?topic=31147.0<N>}<N><N>interface<N><N>uses Classes, typinfo, SysUtils, jsonscanner, fpjson, fpjsonrtti;<N><N>
unit LotoModel;<N><N>{$mode objfpc}{$H+}<N>{<N>       Criado por Amaury Carvalho (amauryspires@gmail.com), 2019<N>}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls,<N>  Graphics, Dialogs, ComCtrls, Menus, Grids, ExtCtrls, StdCtrls, MaskEdit,<N>  Process, LotoIni, CSN, Clipbrd, LCLIntf, fphttpclient, Zipper,<N>  sax_html, dom_html, dom, fpjson, jsonparser, opensslsockets;<N><N>
type<N>  TJsonLF = class(TObject)<N>  public<N>    tipoJogo: string;<N>    numero: string;<N>    numeroConcursoAnterior: string;<N>    numeroConcursoProximo: string;<N>    dataApuracao: string;<N>    listaDezenas: string;<N>    dezenasSorteadasOrdemSorteio: string;<N>    ultimoConcurso: string;<N>    constructor Create(json: string);<N>  end;<N><N>
type<N>  TLotoModel = class(TObject)<N>  private<N>    oCSN: TCSN;<N>    random_balls: array[0..1, 0..24] of integer;<N><N>    array_check: array [1..25] of boolean;<N>    last_checks: integer;<N><N>    ballot_bets_data2: array of array of integer;<N>    ballot_bets_csn2: array of double;<N>    ballot_bets_check2: array of array of integer;<N>    ballot_bets_wins2: array of array of boolean;<N>    ballot_bets_total2: array [0..4] of integer;<N><N>
    procedure GetRandomBalls;<N>    procedure QSort(var numbers: array of integer; left: integer;<N>      right: integer; var secondary: array of integer);<N><N>  public<N>    errorMessage: string;<N><N>    ballot_max_csn: double;<N>    ballot_history_data: array of array of integer;<N>    ballot_history_csn: array of double;<N>    ballot_history_count: integer;<N><N>
    ballot_bets_data: array of array of integer;<N>    ballot_bets_csn: array of double;<N>    ballot_bets_count: integer;<N>    ballot_bets_check: array of array of integer;<N>    ballot_bets_wins: array of array of boolean;<N>    ballot_bets_total: array [0..4] of integer;<N>    ballot_bets_skip_last: boolean;<N>    has_data: boolean;<N>    stop: boolean;<N><N>
    chart_data: array of array of double;<N>    chart_count: integer;<N>    chart_waterline, chart_outliers, chart_tendency: boolean;<N>    chart_probability: double;<N>    chart_theoretical_data: array of double;<N>    chart_theoretical_count: integer;<N>    chart_theoretical_min, chart_theoretical_max: integer;<N><N>
    constructor Create;<N><N>    function ImportFromInternet(sb: TStatusBar): boolean;<N>    function ImportFromInternetFile(): boolean;<N>    function ImportFromLocalFile(sFile: string): boolean;<N>    function RefreshGrid(sgGrid: TStringGrid): boolean;<N>    procedure RefreshTotals(sLines: TStrings);<N><N>
    function DoBets(size: integer): boolean;<N>    function DoCheck(bet_index, history_index: integer): integer;<N>    function DoChecks(checks: integer): boolean;<N>    function DoBetsAndChecks(checks: integer): boolean;<N>    procedure MemorizeBets;<N>    procedure RememberBets;<N>    procedure RefreshBets(sgGrid: TStringGrid);<N><N>
    function AddBet(sBet: string): boolean;<N>    procedure RemoveBet(iRow: integer);<N>    procedure ClearBets();<N><N>    procedure ChartHistogram(size: integer);<N>    procedure ChartHistogram(size: integer; module: double);<N>    procedure ChartTimeSeries(size: integer);<N>    procedure ChartPositional(size, position: integer);<N>    procedure ChartTheoreticalDistMinMax(size: integer);<N><N>
unit LotoModel;<N><N>{$mode objfpc}{$H+}<N>{<N>       Criado por Amaury Carvalho (amauryspires@gmail.com), 2019<N>}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls,<N>  Graphics, Dialogs, ComCtrls, Menus, Grids, ExtCtrls, StdCtrls, MaskEdit,<N>  Process, LotoIni, CSN, Clipbrd, LCLIntf, fphttpclient, Zipper,<N>  sax_html, dom_html, dom, fpjson, jsonparser, opensslsockets;<N><N>
type<N>  TJsonLF = class(TObject)<N>  public<N>    tipoJogo: string;<N>    numero: string;<N>    numeroConcursoAnterior: string;<N>    numeroConcursoProximo: string;<N>    dataApuracao: string;<N>    listaDezenas: string;<N>    dezenasSorteadasOrdemSorteio: string;<N>    ultimoConcurso: string;<N>    constructor Create(json: string);<N>  end;<N><N>
type<N>  TLotoModel = class(TObject)<N>  private<N>    oCSN: TCSN;<N>    random_balls: array[0..1, 0..24] of integer;<N><N>    array_check: array [1..25] of boolean;<N>    last_checks: integer;<N><N>    ballot_bets_data2: array of array of integer;<N>    ballot_bets_csn2: array of double;<N>    ballot_bets_check2: array of array of integer;<N>    ballot_bets_wins2: array of array of boolean;<N>    ballot_bets_total2: array [0..4] of integer;<N><N>
    procedure GetRandomBalls;<N>    procedure QSort(var numbers: array of integer; left: integer;<N>      right: integer; var secondary: array of integer);<N><N>  public<N>    errorMessage: string;<N><N>    ballot_max_csn: double;<N>    ballot_history_data: array of array of integer;<N>    ballot_history_csn: array of double;<N>    ballot_history_count: integer;<N><N>
    ballot_bets_data: array of array of integer;<N>    ballot_bets_csn: array of double;<N>    ballot_bets_count: integer;<N>    ballot_bets_check: array of array of integer;<N>    ballot_bets_wins: array of array of boolean;<N>    ballot_bets_total: array [0..4] of integer;<N>    ballot_bets_skip_last: boolean;<N>    has_data: boolean;<N>    stop: boolean;<N><N>
    chart_data: array of array of double;<N>    chart_count: integer;<N>    chart_waterline, chart_outliers, chart_tendency: boolean;<N>    chart_probability: double;<N>    chart_theoretical_data: array of double;<N>    chart_theoretical_count: integer;<N>    chart_theoretical_min, chart_theoretical_max: integer;<N><N>
    constructor Create;<N><N>    function ImportFromInternet(sb: TStatusBar): boolean;<N>    function ImportFromInternetFile(): boolean;<N>    function ImportFromLocalFile(sFile: string): boolean;<N>    function RefreshGrid(sgGrid: TStringGrid): boolean;<N>    procedure RefreshTotals(sLines: TStrings);<N><N>
    function DoBets(size: integer): boolean;<N>    function DoCheck(bet_index, history_index: integer): integer;<N>    function DoChecks(checks: integer): boolean;<N>    function DoBetsAndChecks(checks: integer): boolean;<N>    procedure MemorizeBets;<N>    procedure RememberBets;<N>    procedure RefreshBets(sgGrid: TStringGrid);<N><N>
    function AddBet(sBet: string): boolean;<N>    procedure RemoveBet(iRow: integer);<N>    procedure ClearBets();<N><N>    procedure ChartHistogram(size: integer);<N>    procedure ChartHistogram(size: integer; module: double);<N>    procedure ChartTimeSeries(size: integer);<N>    procedure ChartPositional(size, position: integer);<N>    procedure ChartTheoreticalDistMinMax(size: integer);<N><N>
unit MegaModel;<N><N>{$mode objfpc}{$H+}<N>{<N>       Criado por Amaury Carvalho (amauryspires@gmail.com), 2019<N>}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls,<N>  Graphics, Dialogs, ComCtrls, Menus, Grids, ExtCtrls, StdCtrls, MaskEdit,<N>  Process, MegaIni, CSN, Clipbrd, LCLIntf, fphttpclient, Zipper,<N>  sax_html, dom_html, dom, fpjson, jsonparser, opensslsockets;<N><N>
type<N>  TJsonMS = class(TObject)<N>  public<N>    tipoJogo: string;<N>    numero: string;<N>    numeroConcursoAnterior: string;<N>    numeroConcursoProximo: string;<N>    dataApuracao: string;<N>    listaDezenas: string;<N>    dezenasSorteadasOrdemSorteio: string;<N>    ultimoConcurso: string;<N>    constructor Create(json: string);<N>  end;<N><N>
type<N>  TMegaModel = class(TObject)<N>  private<N>    oCSN: TCSN;<N>    random_balls: array[0..1, 0..59] of integer;<N><N>    array_check: array [1..60] of boolean;<N>    last_checks: integer;<N><N>    ballot_bets_data2: array of array of integer;<N>    ballot_bets_csn2: array of double;<N>    ballot_bets_check2: array of array of integer;<N>    ballot_bets_wins2: array of array of boolean;<N>    ballot_bets_total2: array [0..3] of integer;<N><N>
    procedure GetRandomBalls;<N>    procedure QSort(var numbers: array of integer; left: integer;<N>      right: integer; var secondary: array of integer);<N><N>  public<N>    errorMessage: string;<N><N>    ballot_max_csn: double;<N>    ballot_history_data: array of array of integer;<N>    ballot_history_csn: array of double;<N>    ballot_history_count: integer;<N><N>
    ballot_bets_data: array of array of integer;<N>    ballot_bets_csn: array of double;<N>    ballot_bets_count: integer;<N>    ballot_bets_check: array of array of integer;<N>    ballot_bets_wins: array of array of boolean;<N>    ballot_bets_total: array [0..3] of integer;<N>    ballot_bets_skip_last: boolean;<N>    has_data: boolean;<N>    stop: boolean;<N><N>
    chart_data: array of array of double;<N>    chart_count: integer;<N>    chart_waterline, chart_outliers, chart_tendency: boolean;<N>    chart_probability: double;<N>    chart_theoretical_data: array of double;<N>    chart_theoretical_count: integer;<N>    chart_theoretical_min, chart_theoretical_max: integer;<N><N>
    constructor Create;<N><N>    function ImportFromInternet(sb: TStatusBar): boolean;<N>    function ImportFromInternetFile(): boolean;<N>    function ImportFromLocalFile(sFile: string): boolean;<N>    function RefreshGrid(sgGrid: TStringGrid): boolean;<N>    procedure RefreshTotals(sLines: TStrings);<N><N>
    function DoBets(size: integer): boolean;<N>    function DoCheck(bet_index, history_index: integer): integer;<N>    function DoChecks(checks: integer): boolean;<N>    function DoBetsAndChecks(checks: integer): boolean;<N>    procedure MemorizeBets;<N>    procedure RememberBets;<N>    procedure RefreshBets(sgGrid: TStringGrid);<N><N>
    function AddBet(sBet: string): boolean;<N>    procedure RemoveBet(iRow: integer);<N>    procedure ClearBets();<N><N>    procedure ChartHistogram(size: integer);<N>    procedure ChartHistogram(size: integer; module: double);<N>    procedure ChartTimeSeries(size: integer);<N>    procedure ChartPositional(size, position: integer);<N>    procedure ChartTheoreticalDistMinMax(size: integer);<N><N>
unit Unit1;<N><N>{$mode objfpc}{$H+}<N>{<N>       Criado por Amaury Carvalho (amauryspires@gmail.com), 2019<N>}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, TAGraph, Forms, Controls,<N>  Graphics, Dialogs, ComCtrls, Menus, Grids, ExtCtrls, StdCtrls, MaskEdit,<N>  Process, MegaModel, Clipbrd, LCLIntf, Spin, Unit2, MegaIni,<N>  FileInfo, CSN, NN, TASeries, TATools, TASources,<N>  uab, ubyteprediction;<N><N>
unit Unit2;<N><N>{$mode objfpc}{$H+}<N>{<N>       Criado por Amaury Carvalho (amauryspires@gmail.com), 2019<N>}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  EditBtn, MaskEdit, MegaIni;<N><N>type<N><N>
unit MegaModel;<N><N>{$mode objfpc}{$H+}<N>{<N>       Criado por Amaury Carvalho (amauryspires@gmail.com), 2019<N>}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls,<N>  Graphics, Dialogs, ComCtrls, Menus, Grids, ExtCtrls, StdCtrls, MaskEdit,<N>  Process, MegaIni, CSN, Clipbrd, LCLIntf, fphttpclient, Zipper,<N>  sax_html, dom_html, dom, fpjson, jsonparser, opensslsockets;<N><N>
type<N>  TJsonMS = class(TObject)<N>  public<N>    tipoJogo: string;<N>    numero: string;<N>    numeroConcursoAnterior: string;<N>    numeroConcursoProximo: string;<N>    dataApuracao: string;<N>    listaDezenas: string;<N>    dezenasSorteadasOrdemSorteio: string;<N>    ultimoConcurso: string;<N>    constructor Create(json: string);<N>  end;<N><N>
type<N>  TMegaModel = class(TObject)<N>  private<N>    oCSN: TCSN;<N>    random_balls: array[0..1, 0..59] of integer;<N><N>    array_check: array [1..60] of boolean;<N>    last_checks: integer;<N><N>    ballot_bets_data2: array of array of integer;<N>    ballot_bets_csn2: array of double;<N>    ballot_bets_check2: array of array of integer;<N>    ballot_bets_wins2: array of array of boolean;<N>    ballot_bets_total2: array [0..3] of integer;<N><N>
    procedure GetRandomBalls;<N>    procedure QSort(var numbers: array of integer; left: integer;<N>      right: integer; var secondary: array of integer);<N><N>  public<N>    errorMessage: string;<N><N>    ballot_max_csn: double;<N>    ballot_history_data: array of array of integer;<N>    ballot_history_csn: array of double;<N>    ballot_history_count: integer;<N><N>
    ballot_bets_data: array of array of integer;<N>    ballot_bets_csn: array of double;<N>    ballot_bets_count: integer;<N>    ballot_bets_check: array of array of integer;<N>    ballot_bets_wins: array of array of boolean;<N>    ballot_bets_total: array [0..3] of integer;<N>    ballot_bets_skip_last: boolean;<N>    has_data: boolean;<N>    stop: boolean;<N><N>
    chart_data: array of array of double;<N>    chart_count: integer;<N>    chart_waterline, chart_outliers, chart_tendency: boolean;<N>    chart_probability: double;<N>    chart_theoretical_data: array of double;<N>    chart_theoretical_count: integer;<N>    chart_theoretical_min, chart_theoretical_max: integer;<N><N>
    constructor Create;<N><N>    function ImportFromInternet(sb: TStatusBar): boolean;<N>    function ImportFromInternetFile(): boolean;<N>    function ImportFromLocalFile(sFile: string): boolean;<N>    function RefreshGrid(sgGrid: TStringGrid): boolean;<N>    procedure RefreshTotals(sLines: TStrings);<N><N>
    function DoBets(size: integer): boolean;<N>    function DoCheck(bet_index, history_index: integer): integer;<N>    function DoChecks(checks: integer): boolean;<N>    function DoBetsAndChecks(checks: integer): boolean;<N>    procedure MemorizeBets;<N>    procedure RememberBets;<N>    procedure RefreshBets(sgGrid: TStringGrid);<N><N>
    function AddBet(sBet: string): boolean;<N>    procedure RemoveBet(iRow: integer);<N>    procedure ClearBets();<N><N>    procedure ChartHistogram(size: integer);<N>    procedure ChartHistogram(size: integer; module: double);<N>    procedure ChartTimeSeries(size: integer);<N>    procedure ChartPositional(size, position: integer);<N>    procedure ChartTheoreticalDistMinMax(size: integer);<N><N>
unit Unit1;<N><N>{$mode objfpc}{$H+}<N>{<N>       Criado por Amaury Carvalho (amauryspires@gmail.com), 2019<N>}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, TAGraph, Forms, Controls,<N>  Graphics, Dialogs, ComCtrls, Menus, Grids, ExtCtrls, StdCtrls, MaskEdit,<N>  Process, MegaModel, Clipbrd, LCLIntf, Spin, Unit2, MegaIni,<N>  FileInfo, CSN, NN, TASeries, TATools, TASources,<N>  uab, ubyteprediction;<N><N>
unit Unit2;<N><N>{$mode objfpc}{$H+}<N>{<N>       Criado por Amaury Carvalho (amauryspires@gmail.com), 2019<N>}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  EditBtn, MaskEdit, MegaIni;<N><N>type<N><N>
unit TMegaIni;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, IniFiles;<N><N>implementation<N><N>type<N>    TMegaIni1 = class(TObject)<N>      private<N><N>      public<N>        TempPath, AppPath : string;<N>        WGetPath : string;<N>        DataPath : string;<N>        DataFileName : string;<N>        Slash : c;<N>        procedure Load;<N>        procedure Save;<N>      end;<N><N>procedure TMegaIni1.Load;<N>begin<N><N>end;<N><N>procedure TMegaIni1.Save;<N>begin<N><N>end;<N><N>end.<N><N>
PROGRAM SortMonth(INPUT, OUTPUT);<N>USES DateIO;<N>VAR<N>  M1, M2: Month;<N>BEGIN<N>  ReadMonth(INPUT, M1);<N>  WriteMonth(OUTPUT, M1)<N>END.<N>
<N>unit PayGoSDK;<N><N>interface<N><N>uses<N>  Androidapi.JNIBridge,<N>  Androidapi.JNI.App,<N>  Androidapi.JNI.GraphicsContentViewText,<N>  Androidapi.JNI.JavaTypes,<N>  Androidapi.JNI.Os,<N>  Androidapi.JNI.Util;<N><N>type<N>// ===== Forward declarations =====<N><N>
<N>unit InterfaceAutomacao_v2_0_0_8;<N><N>interface<N><N>uses<N>  Androidapi.JNIBridge,<N>  Androidapi.JNI.App,<N>  Androidapi.JNI.GraphicsContentViewText,<N>  Androidapi.JNI.JavaTypes,<N>  Androidapi.JNI.Os,<N>  Androidapi.JNI.Util;<N><N>type<N>// ===== Forward declarations =====<N><N>
<N>unit Interface2;<N><N>interface<N><N>uses<N>  Androidapi.JNIBridge,<N>  Androidapi.JNI.App,<N>  Androidapi.JNI.GraphicsContentViewText,<N>  Androidapi.JNI.JavaTypes,<N>  Androidapi.JNI.Os,<N>  Androidapi.JNI.Util;<N><N>type<N>// ===== Forward declarations =====<N><N>
<N>unit G700Interface;<N><N>interface<N><N>uses<N>  Androidapi.JNIBridge,<N>  Androidapi.JNI.App,<N>  Androidapi.JNI.GraphicsContentViewText,<N>  Androidapi.JNI.JavaTypes,<N>  Androidapi.JNI.Os,<N>  Androidapi.JNI.Util,<N>  Androidapi.JNI.Widget;<N><N>type<N>// ===== Forward declarations =====<N><N>
﻿unit Unit1;<N><N>interface<N><N>uses<N><N>  //InterfaceAutomacao_v1_6_0_0,<N>  InterfaceAutomacao_v2_0_0_8,<N><N>  Unit2,<N><N>  GEDIPrinter,    //Esta unit inicializa o Modulo de impressao G700.<N>  G700Interface,<N><N>  Androidapi.JNI.JavaTypes,<N>  Androidapi.Helpers,<N>  Androidapi.Log,<N><N>
  System.SysUtils,<N>  System.Types,<N>  System.UITypes,<N>  System.Classes,<N>  System.Variants,<N><N>  FMX.Platform.Android,<N>  FMX.Types,<N>  FMX.Controls,<N>  FMX.Forms,<N>  FMX.Graphics,<N>  FMX.Dialogs,<N>  FMX.Controls.Presentation,<N>  FMX.StdCtrls,<N>  FMX.Layouts,<N>  FMX.Edit,<N>  FMX.Objects,<N>  FMX.ListBox,<N>  FMX.DialogService,<N><N>
unit Unit2;<N><N>interface<N><N>uses<N>  Androidapi.JNI.JavaTypes,<N>  Androidapi.Helpers,<N>  Androidapi.Log,<N><N>  System.SysUtils,<N>  System.Types,<N>  System.UITypes,<N>  System.Classes,<N>  System.Variants,<N><N>  FMX.Platform.Android,<N>  FMX.Types,<N>  FMX.Controls,<N>  FMX.Forms,<N>  FMX.Graphics,<N>  FMX.Dialogs,<N>  FMX.Controls.Presentation,<N>  FMX.StdCtrls,<N>  FMX.Layouts,<N>  FMX.Edit,<N>  FMX.Objects,<N>  FMX.ListBox,<N>  FMX.DialogService,<N><N>
  //InterfaceAutomacao_v1_6_0_0,<N>  InterfaceAutomacao_v2_0_0_8,<N><N>  Androidapi.JNIBridge,<N>  Androidapi.JNI.App,<N>  Androidapi.Jni.GraphicsContentViewText, // Required<N>  Androidapi.JNI.Util,<N>  Androidapi.Jni.OS;                      // Required<N><N>
<N>unit InterfaceAutomacao_v1_6_0_0;<N><N>interface<N><N>uses<N>  Androidapi.JNIBridge,<N>  Androidapi.JNI.App,<N>  Androidapi.JNI.GraphicsContentViewText,<N>  Androidapi.JNI.JavaTypes,<N>  Androidapi.JNI.Os,<N>  Androidapi.JNI.Util;<N><N>type<N>// ===== Forward declarations =====<N><N>
unit start_trd;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, Process, SysUtils, ComCtrls, Forms;<N><N>type<N>  StartRestore = class(TThread)<N>  private<N><N>    { Private declarations }<N>  protected<N>  var<N>    Result: TStringList;<N><N>
    procedure Execute; override;<N><N>    procedure ShowLog;<N>    procedure StartProgress;<N>    procedure StopProgress;<N><N>  end;<N><N>implementation<N><N>uses Unit1;<N><N>{ TRD }<N><N>procedure StartRestore.Execute;<N>var<N>  ExProcess: TProcess;<N>begin<N>  try //Вывод лога и прогресса<N>    Synchronize(@StartProgress);<N><N>
unit start_trd;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, Process, SysUtils, ComCtrls, Forms;<N><N>type<N>  StartRestore = class(TThread)<N>  private<N><N>    { Private declarations }<N>  protected<N>  var<N>    Result: TStringList;<N><N>
    procedure Execute; override;<N><N>    procedure ShowLog;<N>    procedure StartProgress;<N>    procedure StopProgress;<N><N>  end;<N><N>implementation<N><N>uses Unit1;<N><N>{ TRD }<N><N>procedure StartRestore.Execute;<N>var<N>  ExProcess: TProcess;<N>begin<N>  try //Вывод лога и прогресса<N>    Synchronize(@StartProgress);<N><N>
unit UfraLogin;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects,<N>  FMX.Controls.Presentation, FMX.StdCtrls, FMX.Ani, FMX.Layouts;<N><N>type<N>  TfrmHome = class(TForm)<N>  private<N>    { Private declarations }<N><N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  frmHome: TfrmHome;<N><N>implementation<N><N>{$R *.fmx}<N><N>end.<N>
unit UfrmOrcamentoCompletoCliente;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs,<N>  FMX.ListView.Types, FMX.ListView.Appearances, FMX.ListView.Adapters.Base,<N>  FMX.Objects, FMX.ListBox, FMX.Controls.Presentation, FMX.StdCtrls,<N>  FMX.ListView, FMX.Layouts;<N><N>
unit UfrmOrcamentosCliente;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs,<N>  FMX.ListView.Types, FMX.ListView.Appearances, FMX.ListView.Adapters.Base,<N>  FMX.Objects, FMX.ListView, FMX.Controls.Presentation, FMX.StdCtrls,<N>  FMX.Layouts;<N><N>
unit UfrmHomeMecanico;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes,<N>  System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects,<N>  FMX.Controls.Presentation, FMX.StdCtrls, FMX.Layouts, FMX.ListView.Types,<N>  FMX.ListView.Appearances, FMX.ListView.Adapters.Base, FMX.ListView,<N>  FMX.ListBox, FMX.MultiView;<N><N>
unit UService.Intf;<N><N>interface<N><N>type<N>  IService = interface<N>    procedure CarregarToken;<N>    procedure Registrar;<N>    procedure Listar;<N>    procedure Excluir;<N><N>    function ObterRegistro(const aId: Integer): TObject;<N>  end;<N><N>implementation<N><N>end.<N>
unit UService.Base;<N><N>interface<N><N>uses<N>  REST.Client,<N>  REST.Types,<N>  UService.Intf;<N><N>type<N>  TServiceBase = class(TInterfacedObject, IService)<N>    private<N>    FToken: String;<N><N>  protected<N>    FRESTClient: TRESTClient;<N>    FRESTRequest: TRESTRequest;<N>    FRESTResponse: TRESTResponse;<N><N>
    procedure CarregarToken;<N><N>    procedure Registrar; virtual; abstract;<N>    procedure Listar; virtual; abstract;<N>    procedure Excluir; virtual; abstract;<N><N>    function ObterRegistro(const aId: Integer): TObject; virtual; abstract;<N><N>  public<N>    constructor Create;<N>    destructor Destroy; override;<N><N>
unit UUtils.Enums;<N><N>interface<N>type<N>  TEnumMenu = (mnuOrcamentos, mnuServico, mnuPecas,<N>    mnuGerenciarUsuario, mnuSair);<N><N>implementation<N><N>end.<N>
unit UUtils.Functions;<N><N>interface<N><N>type<N>  TUtilsFunctions = class<N>  public<N>    class function IIF<T>(const aConditional: Boolean;<N>      const aValueTrue, aValueFalse: T): T;<N>  end;<N><N>implementation<N><N>{ TUtilsFunctions }<N><N>class function TUtilsFunctions.IIF<T>(const aConditional: Boolean;<N>  const aValueTrue, aValueFalse: T): T;<N>begin<N>  if aConditional then<N>    Result := aValueTrue<N>  else<N>    Result := aValueFalse;<N>end;<N><N>end.<N>
unit UDAO.Base;<N><N>interface<N><N>uses<N>  UDAO.Intf,<N>  System.JSON,<N>  DataSet.Serialize;<N><N>type<N>  TDAOBase = class(TInterfacedObject, IDAO)<N>    protected<N>      FTabela: String;<N>    public<N>      function ObterRegistros: TJSONArray; virtual;<N>      function ProcurarPorId(const aIdentificador: Integer): TJSONObject; virtual;<N>      function AdicionarRegistro(aRegistro: TJSONObject): Boolean;<N>      function DeletarRegistro(const aIdentificador: Integer): Boolean;<N>    end;<N><N>
implementation<N><N>uses<N>  FireDAC.Comp.Client,<N>  System.SysUtils,<N>  UUtil.Banco;<N><N>{ TDAOBase }<N><N>function TDAOBase.AdicionarRegistro(aRegistro: TJSONObject): Boolean;<N>begin<N>  try<N>    Result := TUtilBanco.AdicionarRegistro(FTabela, aRegistro.ToJSON);<N>  except<N>    on e: Exception do<N>      raise Exception.Create('Erro ao Adicionar Registro: '<N>        + e.Message);<N>  end;<N>end;<N><N>
function TDAOBase.DeletarRegistro(const aIdentificador: Integer): Boolean;<N>begin<N>  try<N>    Result := TUtilBanco.RemoverRegistro(FTabela, aIdentificador);<N>  except<N>    on e: Exception do<N>      raise Exception.Create('Erro ao Remover Registro: ' + e.Message);<N>  end;<N>end;<N><N>
function TDAOBase.ObterRegistros: TJSONArray;<N>begin<N>  try<N>    Result := TUtilBanco.ExecutarConsulta(Format('SELECT * FROM %s',<N>      [FTabela]));<N>  except<N>    on e: Exception do<N>      raise Exception.Create('Erro ao Obter Registros: ' + e.Message);<N>  end;<N>end;<N><N>
function TDAOBase.ProcurarPorId(const aIdentificador: Integer): TJSONObject;<N>var<N>  xJSONArray: TJSONArray;<N>begin<N>  try<N>    xJSONArray := TUtilBanco.ExecutarConsulta(<N>                    Format('SELECT * FROM %s WHERE ID = %d',<N>                      [FTabela, aIdentificador]));<N><N>
    if xJSONArray.Count = 0 then<N>    begin<N>      Result := TJSONObject.Create;<N>      xJSONArray.Free;<N>      Exit;<N>    end;<N><N>    Result := TJSONObject.ParseJSONValue(<N>      TEncoding.ASCII.GetBytes(<N>        xJSONArray[0].ToJSON), 0) as TJSONObject;<N>  except<N>    on e: Exception do<N>      raise Exception.Create('Erro ao Obter Registros: ' + e.Message);<N>  end;<N>end;<N><N>
unit UDAO.Servico;<N><N>interface<N><N>uses<N>  UDAO.Base;<N><N>type<N>  TDAOServico = class(TDAOBase)<N>    public<N>      constructor Create;<N>  end;<N><N>implementation<N><N>{ TDAOTeams }<N><N>constructor TDAOServico.Create;<N>begin<N>  FTabela := 'servico';<N>end;<N><N>end.<N>
unit UDAO.Carro;<N><N>interface<N><N>uses<N>  UDAO.Base, JSON;<N><N>type<N>  TDAOCarro = class(TDAOBase)<N>    private<N>      function ProcurarUsuario(const aId: Integer): TJSONObject;<N>    public<N>      function ObterRegistros: TJSONArray; override;<N>      function ProcurarPorId(const aIdentificador: Integer): TJSONObject; override;<N>      constructor Create;<N>  end;<N><N>
implementation<N><N>uses<N>  SysUtils, UDAO.Intf, UDAO.Usuario;<N><N>{ TDAOCarro }<N><N>constructor TDAOCarro.Create;<N>begin<N>  FTabela := 'carro'<N>end;<N><N>function TDAOCarro.ObterRegistros: TJSONArray;<N>var<N>  xJSONArray, xJSONArrayAux: TJSONArray;<N>  xJSONObject: TJSONObject;<N>  I: Integer;<N>  xIdUser: Integer;<N>begin<N>  xJSONArray := inherited;<N><N>
  if xJSONArray.Count = 0 then<N>    Exit(xJSONArray);<N><N>  xJSONArrayAux := TJSONArray.Create;<N><N>  for I := 0 to Pred(xJSONArray.Count) do<N>  begin<N>    xJSONObject := TJSONObject.ParseJSONValue(<N>      TEncoding.ASCII.GetBytes(<N>        xJSONArray[I].ToJSON), 0) as TJSONObject;<N><N>
    xIdUser := StrToInt(xJSONObject.GetValue('idUsuario').Value);<N>    xJSONObject.AddPair('usuario', Self.ProcurarUsuario(xIdUser));<N>    xJSONObject.RemovePair('idUsuario');<N><N>    xJSONArrayAux.AddElement(xJSONObject);<N>  end;<N><N>  FreeAndNil(xJSONArray);<N>  Result := xJSONArrayAux;<N>end;<N><N>
function TDAOCarro.ProcurarPorId(const aIdentificador: Integer): TJSONObject;<N>var<N>  xJSONObject: TJSONObject;<N>  xIdUser: Integer;<N>begin<N>  xJSONObject := inherited;<N><N>  if xJSONObject.Count = 0 then<N>    Exit(xJSONObject);<N><N>  xIdUser := StrToInt(xJSONObject.GetValue('idUsuario').Value);<N>  xJSONObject.AddPair('usuario', Self.ProcurarUsuario(xIdUser));<N>  xJSONObject.RemovePair('idUsuario');<N><N>
  Result := xJSONObject;<N>end;<N><N>function TDAOCarro.ProcurarUsuario(const aId: Integer): TJSONObject;<N>var<N>  xDAO: IDAO;<N>begin<N>  xDAO := TDAOUsuario.Create;<N>  try<N>    Result := xDAO.ProcurarPorId(aId);<N>  finally<N>    xDAO := nil;<N>  end;<N>end;<N><N>
unit UDAO.ItemServico;<N><N>interface<N><N>uses<N>  UDAO.Base, System.JSON, UDAO.Orcamento;<N><N>type<N>  TDAOItemServico = class(TDAOBase)<N>  private<N>    function ProcurarServicoPorId(const aId: Integer): TJSONObject;<N>    function ProcurarOrcamentoPorId(const aId: Integer): TJSONObject;<N>  public<N>    Constructor Create;<N>    function ObterRegistros: TJSONArray; override;<N>    function ProcurarPorId(const aIdentificador: Integer): TJSONObject;<N>      override;<N><N>
  end;<N><N>implementation<N><N>{ TDAOItemServico }<N>uses<N>  System.SysUtils, UDAO.Intf, UDAO.Servico;<N><N>constructor TDAOItemServico.Create;<N>begin<N>  FTabela := 'itemservico';<N>end;<N><N>function TDAOItemServico.ProcurarServicoPorId(const aId: Integer): TJSONObject;<N>var<N>  xDAO: IDAO;<N>begin<N>  xDAO := TDAOServico.Create;<N>  try<N>    Result := xDAO.ProcurarPorId(aId);<N>  finally<N>    xDAO := nil;<N>  end;<N>end;<N><N>
function TDAOItemServico.ObterRegistros: TJSONArray;<N>var<N>  xJSONArray, xJSONArrayAux: TJSONArray;<N>  xJSONObject: TJSONObject;<N>  I: Integer;<N>  xIdServico, xIdOrcamento: Integer;<N>begin<N>  xJSONArray := inherited;<N><N>  if xJSONArray.Count = 0 then<N>    Exit(xJSONArray);<N><N>
  xJSONArrayAux := TJSONArray.Create;<N><N>  for I := 0 to Pred(xJSONArray.Count) do<N>  begin<N>    xJSONObject := TJSONObject.ParseJSONValue<N>      (TEncoding.ASCII.GetBytes(xJSONArray[I].ToJSON), 0) as TJSONObject;<N><N>    xIdServico := StrToInt(xJSONObject.GetValue('idServico').Value);<N>    xJSONObject.AddPair('servico', Self.ProcurarServicoPorId(xIdServico));<N>    xJSONObject.RemovePair('idServico');<N><N>
    xIdOrcamento := StrToInt(xJSONObject.GetValue('idOrcamento').Value);<N>    xJSONObject.AddPair('orcamento', Self.ProcurarOrcamentoPorId(xIdOrcamento));<N>    xJSONObject.RemovePair('idOrcamento');<N><N>    xJSONArrayAux.AddElement(xJSONObject);<N>  end;<N>  FreeAndNil(xJSONArray);<N>  Result := xJSONArrayAux;<N>end;<N><N>
function TDAOItemServico.ProcurarOrcamentoPorId(const aId: Integer)<N>  : TJSONObject;<N>var<N>  xDAO: IDAO;<N>begin<N>  xDAO := TDAOOrcamento.Create;<N>  try<N>    Result := xDAO.ProcurarPorId(aId);<N>  finally<N>    xDAO := nil;<N>  end;<N>end;<N><N>function TDAOItemServico.ProcurarPorId(const aIdentificador: Integer)<N>  : TJSONObject;<N>var<N>  xJSONObject: TJSONObject;<N>  xIdServico, xIdOrcamento: Integer;<N>begin<N>  xJSONObject := inherited;<N><N>
  if xJSONObject.Count = 0 then<N>    Exit(xJSONObject);<N><N>  xIdServico := StrToInt(xJSONObject.GetValue('idServico').Value);<N>  xJSONObject.AddPair('servico', Self.ProcurarServicoPorId(xIdServico));<N>  xJSONObject.RemovePair('idServico');<N><N>  xIdOrcamento := StrToInt(xJSONObject.GetValue('idOrcamento').Value);<N>  xJSONObject.AddPair('orcamento', Self.ProcurarOrcamentoPorId(xIdOrcamento));<N>  xJSONObject.RemovePair('idOrcamento');<N><N>
unit UDAO.ItemPeca;<N><N>interface<N><N>uses<N>  UDAO.Base, System.JSON;<N><N>type<N>  TDAOItemPeca = class(TDAOBase)<N>  private<N>    function ProcurarPecaPorId(const aId: Integer): TJSONObject;<N>    function ProcurarOrcamentoPorId(const aId: Integer): TJSONObject;<N>  public<N>    Constructor Create;<N>    function ObterRegistros: TJSONArray; override;<N>    function ProcurarPorId(const aIdentificador: Integer): TJSONObject;<N>      override;<N>  end;<N><N>
implementation<N><N>{ TDAOItemServico }<N>uses<N>  System.SysUtils, UDAO.Intf, UDAO.Pecas, UDAO.Orcamento;<N><N>constructor TDAOItemPeca.Create;<N>begin<N>  FTabela := 'itempeca';<N>end;<N><N>function TDAOItemPeca.ProcurarPecaPorId(const aId: Integer): TJSONObject;<N>var<N>  xDAO: IDAO;<N>begin<N>  xDAO := TDAOPecas.Create;<N>  try<N>    Result := xDAO.ProcurarPorId(aId);<N>  finally<N>    xDAO := nil;<N>  end;<N>end;<N><N>
function TDAOItemPeca.ProcurarPorId(const aIdentificador: Integer): TJSONObject;<N>var<N>  xJSONObject: TJSONObject;<N>  xIdPeca, xIdOrcamento: Integer;<N>begin<N>  xJSONObject := inherited;<N><N>  if xJSONObject.Count = 0 then<N>    Exit(xJSONObject);<N><N>
  xIdPeca := StrToInt(xJSONObject.GetValue('idPeca').Value);<N>  xJSONObject.AddPair('peca', Self.ProcurarPecaPorId(xIdPeca));<N>  xJSONObject.RemovePair('idPeca');<N><N>  xIdOrcamento := StrToInt(xJSONObject.GetValue('idOrcamento').Value);<N>  xJSONObject.AddPair('orcamento', Self.ProcurarOrcamentoPorId(xIdOrcamento));<N>  xJSONObject.RemovePair('idOrcamento');<N><N>
  Result := xJSONObject;<N>end;<N><N>function TDAOItemPeca.ObterRegistros: TJSONArray;<N>var<N>  xJSONArray, xJSONArrayAux: TJSONArray;<N>  xJSONObject: TJSONObject;<N>  I: Integer;<N>  xIdPeca, xIdOrcamento: Integer;<N>begin<N>  xJSONArray := inherited;<N><N>
  if xJSONArray.Count = 0 then<N>    Exit(xJSONArray);<N><N>  xJSONArrayAux := TJSONArray.Create;<N><N>  for I := 0 to Pred(xJSONArray.Count) do<N>  begin<N>    xJSONObject := TJSONObject.ParseJSONValue<N>      (TEncoding.ASCII.GetBytes(xJSONArray[I].ToJSON), 0) as TJSONObject;<N><N>
    xIdPeca := StrToInt(xJSONObject.GetValue('idPeca').Value);<N>    xJSONObject.AddPair('peca', Self.ProcurarPecaPorId(xIdPeca));<N>    xJSONObject.RemovePair('idPeca');<N><N>    xIdOrcamento := StrToInt(xJSONObject.GetValue('idOrcamento').Value);<N>    xJSONObject.AddPair('orcamento', Self.ProcurarOrcamentoPorId(xIdOrcamento));<N>    xJSONObject.RemovePair('idOrcamento');<N><N>
    xJSONArrayAux.AddElement(xJSONObject);<N>  end;<N><N>  FreeAndNil(xJSONArray);<N>  Result := xJSONArrayAux;<N>end;<N><N>function TDAOItemPeca.ProcurarOrcamentoPorId(const aId: Integer): TJSONObject;<N>var<N>  xDAO: IDAO;<N>begin<N>  xDAO := TDAOOrcamento.Create;<N>  try<N>    Result := xDAO.ProcurarPorId(aId);<N>  finally<N>    xDAO := nil;<N>  end;<N>end;<N><N>
unit UDAO.Orcamento;<N><N>interface<N><N>uses<N>  UDAO.Base, System.JSON, UDAO.Carro, UDAO.Usuario;<N><N>type<N>  TDAOOrcamento = class(TDAOBase)<N>  private<N>    function ProcurarUsuarioPorId(const aId: Integer): TJSONObject;<N>    function ProcurarCarroPorId(const aId: Integer): TJSONObject;<N>  public<N>    Constructor Create;<N>    function ObterRegistros: TJSONArray; override;<N>    function ProcurarPorId(const aIdentificador: Integer): TJSONObject;<N>      override;<N>  end;<N><N>
implementation<N><N>uses<N>  System.SysUtils, UDAO.Intf;<N><N>{ TDAOOrcamento }<N><N>constructor TDAOOrcamento.Create;<N>begin<N>  FTabela := 'orcamento';<N>end;<N><N>function TDAOOrcamento.ObterRegistros: TJSONArray;<N>var<N>  xJSONArray, xJSONArrayAux: TJSONArray;<N>  xJSONObject: TJSONObject;<N>  I: Integer;<N>  xIdUsuario, xIdCarro: Integer;<N>begin<N>  xJSONArray := inherited;<N><N>
  if xJSONArray.Count = 0 then<N>    Exit(xJSONArray);<N><N>  xJSONArrayAux := TJSONArray.Create;<N><N>  for I := 0 to Pred(xJSONArray.Count) do<N>  begin<N>    xJSONObject := TJSONObject.ParseJSONValue<N>      (TEncoding.ASCII.GetBytes(xJSONArray[I].ToJSON), 0) as TJSONObject;<N><N>
    xIdUsuario := StrToInt(xJSONObject.GetValue('idUsuario').Value);<N>    xJSONObject.AddPair('usuario', Self.ProcurarUsuarioPorId(xIdUsuario));<N>    xJSONObject.RemovePair('idUsuario');<N><N>    xIdCarro := StrToInt(xJSONObject.GetValue('idCarro').Value);<N>    xJSONObject.AddPair('carro', Self.ProcurarCarroPorId(xIdCarro));<N>    xJSONObject.RemovePair('idCarro');<N><N>
    xJSONArrayAux.AddElement(xJSONObject);<N>  end;<N>  FreeAndNil(xJSONArray);<N>  Result := xJSONArrayAux;<N><N>end;<N><N>function TDAOOrcamento.ProcurarCarroPorId(const aId: Integer): TJSONObject;<N>var<N>  xDAO: IDAO;<N>begin<N>  xDAO := TDAOCarro.Create;<N>  try<N>    Result := xDAO.ProcurarPorId(aId);<N>  finally<N>    xDAO := nil;<N>  end;<N>end;<N><N>
function TDAOOrcamento.ProcurarPorId(const aIdentificador: Integer)<N>  : TJSONObject;<N>var<N>  xJSONObject: TJSONObject;<N>  xIdUsuario, xIdCarro: Integer;<N>begin<N>  xJSONObject := inherited;<N><N>  if xJSONObject.Count = 0 then<N>    Exit(xJSONObject);<N><N>
  xIdUsuario := StrToInt(xJSONObject.GetValue('idUsuario').Value);<N>  xJSONObject.AddPair('usuario', Self.ProcurarUsuarioPorId(xIdUsuario));<N>  xJSONObject.RemovePair('idUsuario');<N><N>  xIdCarro := StrToInt(xJSONObject.GetValue('idCarro').Value);<N>  xJSONObject.AddPair('carro', Self.ProcurarCarroPorId(xIdCarro));<N>  xJSONObject.RemovePair('idCarro');<N><N>
  Result := xJSONObject;<N>end;<N><N>function TDAOOrcamento.ProcurarUsuarioPorId(const aId: Integer): TJSONObject;<N>var<N>  xDAO: IDAO;<N>begin<N>  xDAO := TDAOUsuario.Create;<N>  try<N>    Result := xDAO.ProcurarPorId(aId);<N>  finally<N>    xDAO := nil;<N>  end;<N>end;<N><N>
unit UDAO.Intf;<N><N>interface<N><N>uses<N>  System.JSON;<N><N>type<N>  IDAO = Interface<N>    function ObterRegistros: TJSONArray;<N>    function ProcurarPorId(const aIdentificador: Integer): TJSONObject;<N>    function AdicionarRegistro(aRegistro: TJSONObject): Boolean;<N>    function DeletarRegistro(const aIdentificador: Integer): Boolean;<N>  End;<N><N>implementation<N><N>end.<N>
unit UDAO.Pecas;<N><N>interface<N><N>uses<N>  UDAO.Base;<N><N>type<N>  TDAOPecas = class(TDAOBase)<N>  public<N>    constructor Create;<N>  end;<N><N>implementation<N><N>{ TDAOPecas }<N><N>constructor TDAOPecas.Create;<N>begin<N>  FTabela := 'peca';<N>end;<N><N><N>end.<N>
unit UEntity.Logins;<N><N>interface<N><N>type<N>  TLogin = class<N>  private<N>    FLogin: String;<N>    FSenha: String;<N>    FToken: String;<N><N>    function GetLogin: String;<N>    function GetSenha: String;<N>    function GetToken: String;<N><N>    procedure SetLogin(const Value: String);<N>    procedure SetSenha(const Value: String);<N>    procedure SetToken(const Value: String);<N><N>
  public<N>    constructor Create(const aLogin, aSenha: String);<N><N>    property Login: String read GetLogin write SetLogin;<N>    property Senha: String read GetSenha write SetSenha;<N>    property Token: String read GetToken write SetToken;<N>  end;<N><N>
implementation<N><N>{ TLogin }<N><N>constructor TLogin.Create(const aLogin, aSenha: String);<N>begin<N>  FLogin := aLogin;<N>  FSenha := aSenha;<N>end;<N><N>function TLogin.GetLogin: String;<N>begin<N>  Result := FLogin;<N>end;<N><N>function TLogin.GetSenha: String;<N>begin<N>  Result := FSenha;<N>end;<N><N>
function TLogin.GetToken: String;<N>begin<N>  Result := FToken;<N>end;<N><N>procedure TLogin.SetLogin(const Value: String);<N>begin<N>  FLogin := Value;<N>end;<N><N>procedure TLogin.SetSenha(const Value: String);<N>begin<N>  FSenha := Value;<N>end;<N><N>procedure TLogin.SetToken(const Value: String);<N>begin<N>  FToken := Value;<N>end;<N><N>
unit UEntity.Carros;<N><N>interface<N><N>uses<N>  UEntity.Usuarios,<N>  System.JSON;<N><N>type<N>  TCarro = class<N>  private<N>    FId: Integer;<N>    FModelo: String;<N>    FCor: String;<N>    FPlaca: String;<N>    FAno: Integer;<N>    FMarca: String;<N>    FUsuario: TUsuario;<N>    FJSON: TJSONObject;<N><N>
    function GetId: Integer;<N>    function GetModelo: String;<N>    function GetCor: String;<N>    function GetPlaca: String;<N>    function GetAno: Integer;<N>    function GetMarca: String;<N>    function GetUsuario: TUsuario;<N>    function GetJSON: TJSONObject;<N><N>
    procedure SetId(const Value: Integer);<N>    procedure SetModelo(const Value: String);<N>    procedure SetCor(const Value: String);<N>    procedure SetPlaca(const Value: String);<N>    procedure SetAno(const Value: Integer);<N>    procedure SetMarca(const Value: String);<N>    procedure SetUsuario(const Value: TUsuario);<N><N>
  public<N>    constructor Create; overload;<N>    constructor Create(const aId: Integer); overload;<N>    constructor Create(const aUsuario: TUsuario); overload;<N><N>    constructor Create(aId, aAno: Integer; aModelo, aCor, aPlaca, aMarca: String;<N>                        aUsuario: TUsuario); overload;<N><N>
    destructor Destroy; override;<N><N>     property Id: Integer read GetId write SetId;<N>     property Modelo: String read GetModelo write SetModelo;<N>     property Cor: String read GetCor write SetCor;<N>     property Placa: String read GetPlaca write SetPlaca;<N>     property Ano: Integer read GetAno write SetAno;<N>     property Marca: String read GetMarca write SetMarca;<N>     property Usuario: TUsuario read GetUsuario write SetUsuario;<N><N>
     property JSON: TJSONObject read GetJSON;<N>  end;<N><N>implementation<N><N>uses<N>  System.SysUtils;<N><N>{ TCarro }<N><N>constructor TCarro.Create;<N>begin<N>  FJSON := TJSONObject.Create;<N>end;<N><N>constructor TCarro.Create(const aId: Integer);<N>begin<N>  FId := aId;<N>  Self.Create;<N>end;<N><N>
<N>constructor TCarro.Create(const aUsuario: TUsuario);<N>begin<N>  FUsuario := aUsuario;<N>  Self.Create;<N>end;<N><N>constructor TCarro.Create(aId, aAno: Integer; aModelo, aCor, aPlaca, aMarca: String;<N>  aUsuario: TUsuario);<N>begin<N>  FId      := aId;<N>  FAno     := aAno;<N>  FModelo  := aModelo;<N>  FCor     := aCor;<N>  FPlaca   := aPlaca;<N>  FMarca   := aMarca;<N>  FUsuario := aUsuario;<N>  Self.Create;<N>end;<N><N>
destructor TCarro.Destroy;<N>begin<N>  FreeAndNil(FUsuario);<N>  FreeAndNil(FJSON);<N>  inherited;<N>end;<N><N>function TCarro.GetAno: Integer;<N>begin<N>  Result := FAno;<N>end;<N><N>function TCarro.GetCor: String;<N>begin<N>  Result := FCor;<N>end;<N><N>
function TCarro.GetId: Integer;<N>begin<N>  Result := FId;<N>end;<N><N>function TCarro.GetJSON: TJSONObject;<N>begin<N>  FJSON.AddPair('id',      FId.ToString);<N>  FJSON.AddPair('modelo',  FModelo);<N>  FJSON.AddPair('cor',     FCor);<N>  FJSON.AddPair('placa',   FPlaca);<N>  FJSON.AddPair('ano',     FAno.ToString);<N>  FJSON.AddPair('marca',   FMarca);<N>  FJSON.AddPair('idusuario', FUsuario.id.ToString);<N>  Result := FJSON;<N>end;<N><N>
function TCarro.GetMarca: String;<N>begin<N>  Result := FMarca;<N>end;<N><N>function TCarro.GetModelo: String;<N>begin<N>  Result := FModelo;<N>end;<N><N>function TCarro.GetPlaca: String;<N>begin<N>  Result := FPlaca;<N>end;<N><N>function TCarro.GetUsuario: TUsuario;<N>begin<N>  Result := FUsuario;<N>end;<N><N>
procedure TCarro.SetAno(const Value: Integer);<N>begin<N>  FAno := Value;<N>end;<N><N>procedure TCarro.SetCor(const Value: String);<N>begin<N>  FCor := Value;<N>end;<N><N>procedure TCarro.SetId(const Value: Integer);<N>begin<N>  FId := Value;<N>end;<N><N>procedure TCarro.SetMarca(const Value: String);<N>begin<N>  FMarca := Value;<N>end;<N><N>
procedure TCarro.SetModelo(const Value: String);<N>begin<N>  FModelo := Value;<N>end;<N><N>procedure TCarro.SetPlaca(const Value: String);<N>begin<N>  FPlaca := Value;<N>end;<N><N>procedure TCarro.SetUsuario(const Value: TUsuario);<N>begin<N>  FUsuario := Value;<N>end;<N><N>
unit UEntity.Pecas;<N><N>interface<N><N>uses<N>  System.JSON;<N><N>type<N>  TPeca = class<N>  private<N>    FId: Integer;<N>    FNome: String;<N>    FValorUnAtual: Double;<N>    FUnMedida: String;<N>    FJSON: TJSONObject;<N><N>    function GetId: Integer;<N>    function GetNome: String;<N>    function GetValorUnAtual: Double;<N>    function GetUnMedida: String;<N>    function GetJSON: TJSONObject;<N><N>
    procedure SetId(const Value: Integer);<N>    procedure SetNome(const Value: String);<N>    procedure SetValorUnAtual(const Value: Double);<N>    procedure SetUnMedida(const Value: String);<N><N>  public<N>    constructor Create; overload;<N>    constructor Create(const aId: Integer); overload;<N><N>
    constructor Create(aId: Integer; aNome, aUnMedida: String;<N>      aValorUnAtual: Double); overload;<N><N>    destructor Destroy; override;<N><N>    property Id: Integer read GetId write SetId;<N>    property Nome: String read GetNome write SetNome;<N>    property ValorUnatual: Double read GetValorUnatual write SetValorUnatual;<N>    property UnMedida: String read GetUnMedida write SetUnMedida;<N><N>
    property JSON: TJSONObject read GetJSON;<N><N>  end;<N><N>implementation<N><N>uses<N>  System.SysUtils;<N><N>{ TPecas }<N><N>constructor TPeca.Create;<N>begin<N>  FJSON := TJSONObject.Create;<N>end;<N><N>constructor TPeca.Create(const aId: Integer);<N>begin<N>  FId := aId;<N>  Self.Create;<N>end;<N><N>
constructor TPeca.Create(aId: Integer; aNome, aUnMedida: String; aValorUnAtual: Double);<N>begin<N>  FId           := aId;<N>  FNome         := aNome;<N>  FunMedida     := aUnMedida;<N>  FValorUnAtual := aValorUnAtual;<N><N>  Self.Create;<N>end;<N><N>destructor TPeca.Destroy;<N>begin<N>  FreeAndNil(FJSON);<N>  inherited;<N>end;<N><N>
function TPeca.GetId: Integer;<N>begin<N>  Result := FId;<N>end;<N><N>function TPeca.GetJSON: TJSONObject;<N>begin<N>  FJSON.AddPair('id',         FId.ToString);<N>  FJSON.AddPair('nome',       FNome);<N>  FJSON.AddPair('unmedida',   FUnMedida);<N>  FJSON.AddPair('valoratual', FValorUnAtual.ToString);<N><N>
  Result := FJSON;<N>end;<N><N>function TPeca.GetNome: String;<N>begin<N>  Result := FNome;<N>end;<N><N>function TPeca.GetUnMedida: String;<N>begin<N>  Result := FUnMedida;<N>end;<N><N>function TPeca.GetValorUnAtual: Double;<N>begin<N>  Result := FValorUnAtual;<N>end;<N><N>
procedure TPeca.SetId(const Value: Integer);<N>begin<N>  FId := Value;<N>end;<N><N>procedure TPeca.SetNome(const Value: String);<N>begin<N>  FNome := Value;<N>end;<N><N>procedure TPeca.SetUnMedida(const Value: String);<N>begin<N>  FUnMedida := Value;<N>end;<N><N>
unit UEntity.Servicos;<N><N>interface<N><N>uses<N>  System.JSON;<N><N>type<N>  TServico = class<N>  private<N>    FId: Integer;<N>    FNome: String;<N>    FValorUnAtual: Double;<N>    FUnMedida: String;<N>    FJSON: TJSONObject;<N><N>    function GetId: Integer;<N>    function GetNome: String;<N>    function GetValorUnAtual: Double;<N>    function GetUnMedida: String;<N>    function GetJSON: TJSONObject;<N><N>
    procedure SetId(const Value: Integer);<N>    procedure SetNome(const Value: String);<N>    procedure SetValorUnAtual(const Value: Double);<N>    procedure SetUnMedida(const Value: String);<N><N>  public<N>    constructor Create; overload;<N>    constructor Create(const aId: Integer); overload;<N><N>
    constructor Create(aId: Integer; aNome, aUnMedida: String;<N>                        aValorUnAtual: Double); overload;<N><N>    destructor Destroy; override;<N><N>    property Id: Integer read GetId write SetId;<N>    property Nome: String read GetNome write SetNome;<N>    property ValorUnAtual: Double read GetValorUnAtual write SetValorUnAtual;<N>    property UnMedida: String read GetUnMedida write SetUnMedida;<N><N>
    property JSON: TJSONObject read GetJSON;<N>  end;<N><N>implementation<N><N>uses<N>  System.SysUtils;<N><N>{ TServico }<N><N>constructor TServico.Create;<N>begin<N>  FJSON := TJSONObject.Create;<N>end;<N><N>constructor TServico.Create(const aId: Integer);<N>begin<N>  FId := aId;<N>  Self.Create;<N>end;<N><N>
constructor TServico.Create(aId: Integer; aNome, aUnMedida: String; aValorUnAtual: Double);<N>begin<N>  FId           := aId;<N>  FNome         := aNome;<N>  FUnMedida     := aUnMedida;<N>  FValorUnAtual := aValorUnAtual;<N>  Self.Create;<N>end;<N><N>destructor TServico.Destroy;<N>begin<N>  FreeAndNil(FJSON);<N>  inherited;<N>end;<N><N>
function TServico.GetNome: String;<N>begin<N>  Result := FNome;<N>end;<N><N>function TServico.GetId: Integer;<N>begin<N>  Result := FId;<N>end;<N><N>function TServico.GetJSON: TJSONObject;<N>begin<N>  FJSON.AddPair('nome', FNome);<N>  FJSON.AddPair('valoratual', FValorUnAtual.ToString);<N>  FJSON.AddPair('unmedida', FUnMedida);<N>  Result := FJSON;<N>end;<N><N>
function TServico.GetUnMedida: String;<N>begin<N>  Result := FUnMedida;<N>end;<N><N>function TServico.GetValorUnAtual: Double;<N>begin<N>  Result := FValorUnAtual;<N>end;<N><N>procedure TServico.SetNome(const Value: String);<N>begin<N>  FNome := Value;<N>end;<N><N>
procedure TServico.SetId(const Value: Integer);<N>begin<N>  FId := Value;<N>end;<N><N>procedure TServico.SetUnMedida(const Value: String);<N>begin<N>  FUnMedida := Value;<N>end;<N><N>procedure TServico.SetValorUnAtual(const Value: Double);<N>begin<N>  FValorUnAtual := Value;<N>end;<N><N>
unit UEntity.ItemPecas;<N><N>interface<N><N>uses<N>  UEntity.Orcamentos,<N>  UEntity.Pecas,<N>  System.JSON;<N><N>type<N>  TItemPeca = class<N>  private<N>    FId: Integer;<N>    FQnt: Integer;<N>    FValorUn: Double;<N>    FValorTotal: Double;<N>    FOrcamento: TOrcamento;<N>    FPeca: TPeca;<N>    FJSON: TJSONObject;<N><N>
unit UEntity.Orcamentos;<N><N>interface<N><N>uses<N>  UEntity.Usuarios,<N>  UEntity.Carros,<N>  System.JSON;<N><N>type<N>  TOrcamento = class<N>  private<N>    FId: Integer;<N>    FTotalPeca: Double;<N>    FTotalServico: Double;<N>    FValorTotal: Double;<N>    FDescricao: String;<N>    FStatus: String;<N>    FCarro: TCarro;<N>    FUsuario: TUsuario;<N>    FJSON: TJSONObject;<N><N>
    function GetId: Integer;<N>    function GetTotalPeca: Double;<N>    function GetTotalServico: Double;<N>    function GetValorTotal: Double;<N>    function GetDescricao: String;<N>    function GetStatus: String;<N>    function GetCarro: TCarro;<N>    function GetUsuario: TUsuario;<N>    function GetJSON: TJSONObject;<N><N>
    procedure SetId(const Value: Integer);<N>    procedure SetTotalPeca(const Value: Double);<N>    procedure SetTotalServico(const Value: Double);<N>    procedure SetValorTotal(const Value: Double);<N>    procedure SetDescricao(const Value: String);<N>    procedure SetStatus(const Value: String);<N>    procedure SetCarro(const Value: TCarro);<N>    procedure SetUsuario(const Value: TUsuario);<N><N>
  public<N>    constructor Create; overload;<N>    constructor Create(const aId: Integer); overload;<N><N>    constructor Create(aId: Integer; aTotalPeca, aTotalServico,<N>      aValorTotal: Double; aDescricao, aStatus: String;<N>        aCarro: TCarro; aUsuario: TUsuario); overload;<N><N>
unit UEntity.Usuarios;<N><N>interface<N><N>uses<N>  System.JSON;<N><N>type<N>  TUsuario = class<N>  private<N><N>    FId: Integer;<N>    FTipoUsuario: Boolean;<N>    FNome: String;<N>    FCPF: String;<N>    FCelular: String;<N>    FEmail: String;<N>    FLogin: String;<N>    FSenha: String;<N>    FJSON: TJSONObject;<N><N>
    function GetId: Integer;<N>    function GetTipoUsuario: Boolean;<N>    function GetNome: String;<N>    function GetCPF: String;<N>    function GetCelular: String;<N>    function GetEmail: String;<N>    function GetLogin: String;<N>    function GetSenha: String;<N>    function GetJSON: TJSONObject;<N><N>
    procedure SetId(const Value: Integer);<N>    procedure SetTipoUsuario(const Value: Boolean);<N>    procedure SetNome(const Value: String);<N>    procedure SetCPF(const Value: String);<N>    procedure SetCelular(const Value: String);<N>    procedure SetEmail(const Value: String);<N>    procedure SetLogin(const Value: String);<N>    procedure SetSenha(const Value: String);<N><N>
  public<N>    constructor Create; overload;<N>    constructor Create(const aId: Integer); overload;<N>    constructor Create(const aNome, aLogin, aSenha: String); overload;<N>    constructor Create(const aId: Integer; const aTipoUsuario, aNome,<N>      aCPF: String; const aCelular: String; const aEmail: String;<N>      const aLogin: String; const aSenha: String); overload;<N><N>
unit UEntity.ItemServicos;<N><N>interface<N><N>uses<N>  UEntity.Servicos,<N>  UEntity.Orcamentos,<N>  System.JSON;<N><N>type<N>  TItemServico = class<N>  private<N>    FId: Integer;<N>    FQnt: Integer;<N>    FValorUn: Double;<N>    FValorTotal: Double;<N>    FServico: TServico;<N>    FOrcamento: TOrcamento;<N>    FJSON: TJSONObject;<N><N>
unit UController.Login;<N><N>interface<N><N>uses<N>  Horse,<N>  JOSE.Core.JWT,<N>  JOSE.Core.Builder,<N>  UController.Base,<N>  UEntity.Logins;<N><N>type<N>  TControllerLogin = class(TControllerBase)<N>    private<N>    public<N>    class procedure PostLogin(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>  end;<N><N>
implementation<N><N>uses<N>  JSON, SysUtils, UController.Usuario;<N><N>{ TControllerLogin }<N><N>class procedure TControllerLogin.PostLogin(Req: THorseRequest;<N>  Res: THorseResponse; Next: TProc);<N>var<N>  xToken: TJWT;<N>  xCompactToken: String;<N>  xJSONLogin: TJSONObject;<N>  xUser, xPassword: String;<N>begin<N>  xToken := TJWT.Create;<N>  try<N>    xToken.Claims.Issuer := 'Lamborghini';<N>    xToken.Claims.Subject := 'Projeto final em grupo';<N>    xToken.Claims.Expiration := Now + 1;<N><N>
    xJSONLogin := Req.Body<TJSONObject>;<N>    if not Assigned(xJSONLogin) then<N>    begin<N>      Res.Status(THTTPStatus.BadRequest);<N>      Exit;<N>    end;<N><N>    if not xJSONLogin.TryGetValue<String>('login', xUser) then<N>    begin<N>      Res.Status(THTTPStatus.BadRequest);<N>      Exit;<N>    end;<N><N>
    if not xJSONLogin.TryGetValue<String>('senha', xPassword) then<N>    begin<N>      Res.Status(THTTPStatus.BadRequest);<N>      Exit;<N>    end;<N><N>    xToken.Claims.SetClaimOfType<Integer>('id', UController.Usuario.GidUsuario);<N>    xToken.Claims.SetClaimOfType<String>('login', xUser);<N><N>
unit Conexao;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Data.DB, Data.Win.ADODB;<N><N>type<N>  TfrmConecta = class(TForm)<N>    Conexao: TADOConnection;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  frmConecta: TfrmConecta;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit plugin;<N><N>interface<N><N>uses<N>  Winapi.Windows,  Winapi.Messages, System.SysUtils,<N>  System.Classes, Vcl.ComCtrls, SciSupport, Vcl.Forms,<N>  Vcl.Controls, NppPlugin, Vcl.Dialogs, Vcl.Graphics, StrUtils;<N><N>type<N>  TModalResultArray = array[False..True] of TModalResult;<N>  TMenuItemCheck = (miHidden,miShown);<N><N>
  PDarkModeColors = ^TDarkModeColors;<N>  TDarkModeColors = record<N>  //public<N>      background: Longint;<N>      softerBackground: Longint;<N>      hotBackground: Longint;<N>      pureBackground: Longint;<N>      errorBackground: Longint;<N>      text: Longint;<N>      darkerText: Longint;<N>      disabledText: Longint;<N>      linkText: Longint;<N>      edge: Longint;<N>      hotEdge: Longint;<N>      disabledEdge: Longint;<N>  end;<N><N>
  TDarkModeColorsDelphi = record<N>  //public<N>      background: TColor;<N>      softerBackground: TColor;<N>      hotBackground: TColor;<N>      pureBackground: TColor;<N>      errorBackground: TColor;<N>      text: TColor;<N>      darkerText: TColor;<N>      disabledText: TColor;<N>      linkText: TColor;<N>      edge: TColor;<N>      hotEdge: TColor;<N>      disabledEdge: TColor;<N>  end;<N><N>
unit frmMainUnit;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, System.Math, Winapi.ShellApi, System.UITypes, System.Generics.Collections,<N>  Vcl.StdCtrls, System.RegularExpressions, System.RegularExpressionsCore, Vcl.Buttons,<N>  Vcl.ExtCtrls, Vcl.ComCtrls, Vcl.Dialogs, System.ImageList, Vcl.ImgList, Vcl.Menus, Vcl.Samples.Spin,<N>  DateUtils,<N><N>
  JclSysInfo, JclFileUtils,<N><N>  nppplugin, plugin, NppDockingForms,<N><N>  Data.DbxSqlite, Data.FMTBcd, Data.DB, Data.SqlExpr,<N>  FireDAC.UI.Intf, FireDAC.ConsoleUI.Wait, FireDAC.Stan.Intf, FireDAC.Comp.UI,<N>  FDSqliteTypes, FDSqliteManger, FireDAC.Stan.Def, FireDAC.DApt,<N>  FireDAC.Phys.SQLiteWrapper.Stat, FireDAC.Stan.ExprFuncs, FireDAC.Phys.SQLiteDef,<N>  FireDAC.Phys, FireDAC.Phys.SQLite, FireDAC.Stan.Async;<N><N>
unit frmSettingsUnit;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, nppplugin, plugin, NppForms, NppDockingForms,<N>  Vcl.ExtCtrls, Vcl.StdCtrls;<N><N>
﻿unit frmAboutUnit;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,<N>  System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms,<N>  Vcl.Dialogs, Vcl.StdCtrls, Vcl.Buttons, Vcl.ExtCtrls,<N>  System.IniFiles, System.Win.Registry, System.Actions, Vcl.ActnList,<N>  plugin, NppForms, ShellAPI;<N><N>
unit FDSqliteManger;<N><N>interface<N><N>uses Data.FMTBcd,<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Data.DB, Data.SqlExpr, Data.DbxSqlite, system.DateUtils, System.Generics.Collections,<N>  JclSysInfo, JclFileUtils, Vcl.Forms, System.Sqlite, FDSqliteTypes, FireDAC.Comp.Client, FireDAC.Phys.SQLite,<N>  FireDAC.Phys.SQLiteWrapper, FireDAC.Stan.Param, FireDAC.Stan.Def, FireDAC.DApt;<N><N>
unit scisupport;<N><N>// Support unit for scintilla use in pascal. The constants are all created from scintilla.iface by<N>// a python script.<N><N>interface<N><N>uses Windows;<N><N>type<N>  TScintillaMessageFnc = function(ptr : Pointer; Msg: UINT; wParam: WPARAM; lParam: LPARAM) : NativeInt; cdecl;<N>  uptr_t = UINT_PTR;<N>  sptr_t = INT_PTR;<N>  TNotifyHeader = record<N>	  hwndFrom : Pointer;<N>	  idFrom   : UINT_PTR;<N>	  code     : INT_PTR;<N>  end;<N><N>
procedure DLLEntryPoint(dwReason: Integer);<N>begin<N>  case dwReason of<N>    DLL_PROCESS_ATTACH:<N>    begin<N>      NPlugin := TdsPlugin.Create;<N>    end;<N>    DLL_PROCESS_DETACH:<N>    begin<N>      if (Assigned(NPlugin)) then NPlugin.Destroy;<N>    end;<N>  end;<N>end;<N><N>
procedure setInfo(NppData: TNppData); cdecl; export;<N>begin<N>  NPlugin.SetInfo(NppData);<N>end;<N><N>function getName: nppPchar; cdecl; export;<N>begin<N>  Result := NPlugin.GetName;<N>end;<N><N>function getFuncsArray(var nFuncs:integer):Pointer;cdecl; export;<N>begin<N>  Result := NPlugin.GetFuncsArray(nFuncs);<N>end;<N><N>
procedure beNotified(sn: PSCNotification); cdecl; export;<N>begin<N>  NPlugin.BeNotified(sn);<N>end;<N><N>function messageProc(msg: Integer; wParam: WPARAM; lParam: LPARAM): LRESULT; cdecl; export;<N>var<N>  Message:TMessage;<N>begin<N>  Message.Msg := msg;<N>  Message.WParam := wParam;<N>  Message.LParam := lParam;<N>  Message.Result := 0;<N>  NPlugin.MessageProc(Message);<N>  Result := Message.Result;<N>end;<N><N>
{$IFDEF NPPUNICODE}<N>function isUnicode : Boolean; cdecl; export;<N>begin<N>  Result := true;<N>end;<N>{$ENDIF}<N><N>exports<N>  setInfo, getName, getFuncsArray, beNotified, messageProc;<N>{$IFDEF NPPUNICODE}<N>exports<N>  isUnicode;<N>{$ENDIF}<N><N><N><N>
{<N>    This file is part of DBGP Plugin for Notepad++<N>    Copyright (C) 2007  Damjan Zobo Cvetko<N><N>    This program is free software; you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation; either version 2 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License along<N>    with this program; if not, write to the Free Software Foundation, Inc.,<N>    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.<N>}<N><N>unit NppForms;<N><N>interface<N><N>
{<N>    This file is part of DBGP Plugin for Notepad++<N>    Copyright (C) 2007  Damjan Zobo Cvetko<N><N>    This program is free software; you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation; either version 2 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License along<N>    with this program; if not, write to the Free Software Foundation, Inc.,<N>    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.<N>}<N><N>unit NppDockingForms;<N><N>
{<N>    This file is part of DBGP Plugin for Notepad++<N>    Copyright (C) 2007  Damjan Zobo Cvetko<N><N>    This program is free software; you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation; either version 2 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License along<N>    with this program; if not, write to the Free Software Foundation, Inc.,<N>    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.<N>}<N><N>unit nppplugin;<N><N>interface<N><N>
unit URelatorioVendaPagamento;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf,<N>  FireDAC.DApt.Intf, FireDAC.Stan.Async, FireDAC.DApt, Data.DB,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, RLReport, Udm;<N><N>
unit UEntidade;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf,<N>  FireDAC.DApt.Intf, FireDAC.Stan.Async, FireDAC.DApt, Data.DB,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, Vcl.Grids, Vcl.DBGrids,<N>  Vcl.DBCtrls, Vcl.ExtCtrls, UDM;<N><N>
type<N>  TFEntidade = class(TForm)<N>    FdqSequencia: TFDQuery;<N>    DsEntidade: TDataSource;<N>    Panel1: TPanel;<N>    DBNavigator1: TDBNavigator;<N>    DBGrid1: TDBGrid;<N>    procedure DsEntidadeStateChange(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  FEntidade: TFEntidade;<N><N>implementation<N><N>{$R *.dfm}<N><N>procedure TFEntidade.DsEntidadeStateChange(Sender: TObject);<N>begin<N>  if DsEntidade.State = dsInsert then<N>  begin<N>    FdqSequencia.Open;<N>    dm.DtEntidadecod_entidade.ReadOnly := False;<N>    DsEntidade.DataSet.FieldByName('cod_entidade').AsInteger := FdqSequencia.FieldByName('cod_entidade').AsInteger;<N>    dm.DtEntidadecod_entidade.ReadOnly := True;<N>    FdqSequencia.close;<N>  end;<N>end;<N><N>
unit URelatorio;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, RLReport, udm, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS,<N>  FireDAC.Phys.Intf, FireDAC.DApt.Intf, FireDAC.Stan.Async, FireDAC.DApt,<N>  Data.DB, FireDAC.Comp.DataSet, FireDAC.Comp.Client, Datasnap.DBClient;<N><N>
unit UPincipal;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.Menus, Vcl.ExtCtrls,<N>  UProduto, UEntidade, UMovimentoEntrada, UMovimentoVenda;<N><N>
unit UProduto;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Data.DB, Vcl.StdCtrls, Vcl.Mask,<N>  Vcl.DBCtrls, Vcl.Grids, Vcl.DBGrids, Vcl.ExtCtrls, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS,<N>  FireDAC.Phys.Intf, FireDAC.DApt.Intf, FireDAC.Stan.Async, FireDAC.DApt,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, udm;<N><N>
type<N>  TFProduto = class(TForm)<N>    DsProduto: TDataSource;<N>    DBGrid1: TDBGrid;<N>    Panel1: TPanel;<N>    DBNavigator1: TDBNavigator;<N>    FdqSequencia: TFDQuery;<N>    Button1: TButton;<N>    procedure DsProdutoStateChange(Sender: TObject);<N>    procedure Button1Click(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit udm;<N><N>{$MODE DELPHI}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, ZConnection, ZDataset;<N><N>type<N><N>  { TDM }<N><N>  TDM = class(TDataModule)<N>    Conexao: TZConnection;<N>    ZQuery1: TZQuery;<N>    procedure DataModuleCreate(Sender: TObject);<N>    procedure DataModuleDestroy(Sender: TObject);<N>  private<N><N>
  public<N>    function FormataCNPJ(CNPJ : string): string;<N>  end;<N><N>var<N>  DM: TDM;<N><N>implementation<N><N>{$R *.lfm}<N><N>{ TDM }<N><N>Function TDM.FormataCNPJ(CNPJ : string): string;<N>begin<N>  Result := Copy(CNPJ,1,2)+'.'+Copy(CNPJ,3,3)+'.'+Copy(CNPJ,6,3)+'/'+Copy(CNPJ,9,4)+'-'+Copy(CNPJ,13,2);<N>end;<N><N>
procedure TDM.DataModuleCreate(Sender: TObject);<N>var<N>  local : String;<N>begin<N>  local := ExtractFilePath(Paramstr(0));<N>  {$ifdef horse_cgi}<N>     Conexao.LibraryLocation := local + 'libfbclient.so';<N>  {$else}<N>     Conexao.LibraryLocation := local + 'fbclient.dll';<N>  {$endif}<N><N>
  try<N>    Conexao.Connected := true;<N>  except on ex:exception do<N>    raise Exception.Create('Erro ao acessar o banco: ' + ex.Message);<N>  end;<N><N>end;<N><N>procedure TDM.DataModuleDestroy(Sender: TObject);<N>begin<N>  Conexao.Connected := False;<N>end;<N><N>
unit udm;<N><N>{$MODE DELPHI}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, ZConnection, ZDataset;<N><N>type<N><N>  { TDM }<N><N>  TDM = class(TDataModule)<N>    Conexao: TZConnection;<N>    ZQuery1: TZQuery;<N>    procedure DataModuleCreate(Sender: TObject);<N>    procedure DataModuleDestroy(Sender: TObject);<N>  private<N><N>
  public<N>    function FormataCNPJ(CNPJ : string): string;<N>  end;<N><N>var<N>  DM: TDM;<N><N>implementation<N><N>{$R *.lfm}<N><N>{ TDM }<N><N>Function TDM.FormataCNPJ(CNPJ : string): string;<N>begin<N>  Result := Copy(CNPJ,1,2)+'.'+Copy(CNPJ,3,3)+'.'+Copy(CNPJ,6,3)+'/'+Copy(CNPJ,9,4)+'-'+Copy(CNPJ,13,2);<N>end;<N><N>
procedure TDM.DataModuleCreate(Sender: TObject);<N>var<N>  local : String;<N>begin<N>  local := ExtractFilePath(Paramstr(0));<N>  {$ifdef horse_cgi}<N>     Conexao.LibraryLocation := local + 'libfbclient.so';<N>  {$else}<N>     Conexao.LibraryLocation := local + 'fbclient.dll';<N>  {$endif}<N><N>
  try<N>    Conexao.Connected := true;<N>  except on ex:exception do<N>    raise Exception.Create('Erro ao acessar o banco: ' + ex.Message);<N>  end;<N><N>end;<N><N>procedure TDM.DataModuleDestroy(Sender: TObject);<N>begin<N>  Conexao.Connected := False;<N>end;<N><N>
unit udmglobal;<N><N>{$MODE DELPHI}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, ZConnection, ZDataset;<N><N>type<N><N>  { TDMGlobal }<N><N>  TDMGlobal = class(TDataModule)<N>    Conexao: TZConnection;<N>    ZQuery1: TZQuery;<N>  private<N><N>  public<N>     procedure ConectarBanco;<N>  end;<N><N>
var<N>  DMGlobal: TDMGlobal;<N><N>implementation<N><N>{$R *.lfm}<N><N>{ TDMGlobal }<N><N>procedure TDMGlobal.ConectarBanco;<N>var<N>  local : String;<N>begin<N>  local := ExtractFilePath(Paramstr(0));<N>  {$ifdef horse_cgi}<N>     Conexao.LibraryLocation := local + 'libfbclient.so';<N>  {$else}<N>     Conexao.LibraryLocation := local + 'fbclient.dll';<N>  {$endif}<N><N>
unit Horse.Core.RouterTree.NextCaller;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections, fpHTTP, httpprotocol,<N>{$ELSE}<N>  System.NetEncoding, System.SysUtils, Web.HTTPApp, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Commons, Horse.Request, Horse.Response, Horse.Callback;<N><N>
﻿unit Web.WebConst;<N><N>interface<N><N>resourcestring<N>  sDuplicateActionName = 'Duplicate action name';<N>  sOnlyOneDispatcher = 'Only one WebDispatcher per form/data module';<N>  sHTTPItemName = 'Name';<N>  sHTTPItemURI = 'PathInfo';<N>  sHTTPItemEnabled = 'Enabled';<N>  sHTTPItemDefault = 'Default';<N>  sHTTPItemProducer = 'Producer';<N>  sHTTPItemMethod = 'Method';<N><N>
unit Horse.Proc;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF NOT DEFINED(FPC)}<N>uses System.SysUtils;<N>{$ENDIF}<N><N>type<N>  TNextProc = {$IF DEFINED(FPC)}procedure of object{$ELSE}System.SysUtils.TProc{$ENDIF};<N>  TProc = {$IF DEFINED(FPC)}procedure{$ELSE}System.SysUtils.TProc{$ENDIF};<N><N>{$IF DEFINED(FPC)}<N>  TProc<T> = procedure(Arg1: T);<N>{$ENDIF}<N><N>implementation<N><N>end.<N>
unit Horse.Provider.CGI;<N><N>interface<N><N>{$IF DEFINED(HORSE_CGI) AND NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, System.SysUtils;<N><N>type<N>  THorseProvider<T: class> = class(THorseProviderAbstract<T>)<N>  private<N>    class procedure InternalListen; static;<N>  public<N>    class procedure Listen; overload; override;<N>    class procedure Listen(const ACallback: TProc<T>); reintroduce; overload; static;<N>  end;<N>{$ENDIF}<N><N>
implementation<N><N>{$IF DEFINED(HORSE_CGI) AND NOT DEFINED(FPC)}<N>uses Web.WebBroker, Web.CGIApp, Horse.WebModule;<N><N>class procedure THorseProvider<T>.InternalListen;<N>begin<N>  Application.Initialize;<N>  Application.WebModuleClass := WebModuleClass;<N>  DoOnListen;<N>  Application.Run;<N>end;<N><N>
class procedure THorseProvider<T>.Listen;<N>begin<N>  inherited;<N>  InternalListen;<N>end;<N><N>class procedure THorseProvider<T>.Listen(const ACallback: TProc<T>);<N>begin<N>  inherited;<N>  SetOnListen(ACallback);<N>  InternalListen;<N>end;<N>{$ENDIF}<N><N>
unit Horse.Provider.FPC.Apache;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_APACHE) AND DEFINED(FPC)}<N>uses<N>{$IFDEF unix}<N>  cthreads,<N>{$ENDIF}<N>  fphttp, httpdefs, httpd24, fpApache24, custapache24, SysUtils, Classes, Horse.Provider.Abstract,<N>  Horse.Constants, Horse.Proc;<N><N>
unit Horse.Provider.FPC.Daemon;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_DAEMON)}<N>uses SysUtils, Classes, httpdefs, fpHTTP, fphttpserver, Horse.Request, Horse.Response, Horse.Core, Horse.Provider.Abstract, Horse.Constants,<N>  Horse.Proc, Horse.Commons, Horse.Exception;<N><N>
unit Horse.Core.Param.Field;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, DateUtils, Generics.Collections,<N>{$ELSE}<N>  System.SysUtils, System.Classes, System.DateUtils, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Exception, Horse.Commons, Horse.Core.Param.Field.Brackets,<N>  Horse.Core.Param.Config;<N><N>
type<N><N>  THorseCoreParamField = class<N>  private<N>    FContains: Boolean;<N>    FFieldName: string;<N>    FRequired: Boolean;<N>    FRequiredMessage: string;<N>    FInvalidFormatMessage: string;<N>    FDateFormat: string;<N>    FTimeFormat: string;<N>    FReturnUTC: Boolean;<N>    FTrueValue: string;<N>    FValue: string;<N>    FStream: TStream;<N>    FLhsBrackets: THorseCoreParamFieldLhsBrackets;<N><N>
    function GetFormatSettings: TFormatSettings;<N>    procedure RaiseHorseException(const AMessage: string); overload;<N>    procedure RaiseHorseException(const AMessage: string; const Args: array of const); overload;<N>    function TryISO8601ToDate(const AValue: string; out Value: TDateTime): Boolean;<N><N>
unit Horse.Provider.FPC.LCL;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_LCL)}<N>uses SysUtils, Classes, httpdefs, fpHTTP, fphttpapp, Horse.Provider.Abstract, Horse.Constants, Horse.Proc;<N><N>type<N><N>
unit Horse.Session;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections;<N>{$ELSE}<N>  System.SysUtils, System.Generics.Collections;<N>{$ENDIF}<N><N>type<N>  TSession = class<N>  end;<N><N>
unit Horse.Callback;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  Generics.Collections, fpHTTP,<N>{$ELSE}<N>  Web.HTTPApp, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Request, Horse.Response, Horse.Proc, Horse.Commons;<N><N>
{ ****************************************************************************** }<N>{ }<N>{ Linux Daemon with Delphi }<N>{ }<N>{ Author: Paolo Rossi (2017) }<N>{ }<N>{ http://www.paolorossi.net }<N>{ http://blog.paolorossi.net }<N>{ https://github.com/paolo-rossi }<N>{ }<N>{ ****************************************************************************** }<N>unit ThirdParty.Posix.Syslog;<N><N>
unit Horse.Core.Group.Contract;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses Horse.Core.Route.Contract, Horse.Core.RouterTree, Horse.Callback;<N><N>type<N>  IHorseCoreGroup<T: class> = interface<N>    ['{5EB734D6-6944-473E-9C79-506647E2F5E8}']<N>    function Prefix(const APrefix: string): IHorseCoreGroup<T>;<N>    function Route(const APath: string): IHorseCoreRoute<T>;<N><N>
unit Horse.WebModule;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, httpdefs, fpHTTP, fpWeb,<N>{$ELSE}<N>  System.SysUtils, System.Classes, Web.HTTPApp,<N>{$ENDIF}<N>  Horse.Core, Horse.Commons;<N><N>
unit Horse.Provider.FPC.FastCGI;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(FPC) AND DEFINED(HORSE_FCGI)}<N>uses SysUtils, Classes, fpFCGI, httpdefs, fpHTTP, Horse.Provider.Abstract, Horse.Constants, Horse.Proc;<N><N>
unit Horse.Exception.Interrupted;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils;<N>{$ELSE}<N>  System.SysUtils;<N>{$ENDIF}<N><N>type<N>  EHorseCallbackInterrupted = class(Exception)<N>    constructor Create; reintroduce;<N>  end;<N><N>implementation<N><N>constructor EHorseCallbackInterrupted.Create;<N>begin<N>  inherited Create(EmptyStr);<N>end;<N><N>end.<N>
unit Horse.Core.Files;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, Generics.Collections;<N>{$ELSE}<N>  System.SysUtils, System.Classes, System.Generics.Collections;<N>{$ENDIF}<N><N>
unit Horse.Core.Param.Header;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, Generics.Collections, fpHTTP, fphttpserver, httpprotocol, HTTPDefs,<N>{$ELSE}<N>  System.Classes, System.SysUtils, System.Generics.Collections,<N>  Web.HTTPApp, IdCustomHTTPServer, IdHeaderList, Horse.Rtti,<N>{$ENDIF}<N>  Horse.Core.Param, Horse.Commons, Horse.Rtti.Helper;<N><N>
type<N>  THorseCoreParamHeader = class<N>  private<N>    class function GetHeadersList(const AWebRequest: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF}): TStrings;<N>  public<N>    class function GetHeaders(const AWebRequest: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF}): THorseList;<N>  end;<N><N>
unit Horse.Core.Route.Contract;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses Horse.Core.RouterTree, Horse.Callback;<N><N>type<N>  IHorseCoreRoute<T: class> = interface<N>    ['{8D593D98-44B3-4FD2-A21B-BA29F784B3AA}']<N>    function AddCallback(const ACallback: THorseCallback): IHorseCoreRoute<T>;<N>    function AddCallbacks(const ACallbacks: TArray<THorseCallback>): IHorseCoreRoute<T>;<N><N>
    function All(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const ACallbacks: array of THorseCallback; const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    function Get(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Get(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Get(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Get(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Put(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Put(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Put(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Put(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Head(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Head(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Head(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Head(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Post(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Post(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Post(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Post(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
unit Horse.Request;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, fpHTTP, HTTPDefs,<N>{$ELSE}<N>  System.SysUtils, System.Classes, Web.HTTPApp,<N>  {$IF CompilerVersion > 32.0}<N>    Web.ReqMulti,<N>  {$ENDIF}<N>{$ENDIF}<N>  Horse.Core.Param, Horse.Core.Param.Header, Horse.Commons, Horse.Session;<N><N>
unit Horse.Provider.ISAPI;<N><N>interface<N><N>{$IF DEFINED(HORSE_ISAPI) AND NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, System.SysUtils, Web.Win.ISAPIApp;<N><N>type<N>  THorseProvider<T: class> = class(THorseProviderAbstract<T>)<N>  private<N>    class procedure InternalListen; static;<N>  public<N>    class procedure Listen; overload; override;<N>    class procedure Listen(const ACallback: TProc<T>); reintroduce; overload; static;<N>  end;<N>{$ENDIF}<N><N>
implementation<N><N>{$IF DEFINED(HORSE_ISAPI) AND NOT DEFINED(FPC)}<N>uses Web.WebBroker, System.Win.ComObj, Winapi.ActiveX, Horse.WebModule;<N><N>exports<N>  GetExtensionVersion,<N>  HttpExtensionProc,<N>  TerminateExtension;<N><N>class procedure THorseProvider<T>.InternalListen;<N>begin<N>  CoInitFlags := COINIT_MULTITHREADED;<N>  Application.Initialize;<N>  Application.WebModuleClass := WebModuleClass;<N>  DoOnListen;<N>  Application.Run;<N>end;<N><N>
class procedure THorseProvider<T>.Listen;<N>begin<N>  inherited;<N>  InternalListen;<N>end;<N><N>class procedure THorseProvider<T>.Listen(const ACallback: TProc<T>);<N>begin<N>  inherited;<N>  SetOnListen(ACallback);<N>  InternalListen;<N>end;<N>{$ENDIF}<N><N>
unit Horse.Core.Group;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils,<N>{$ELSE}<N>  System.SysUtils,<N>{$ENDIF}<N>  Horse.Core.Group.Contract, Horse.Core.Route.Contract, Horse.Core.RouterTree, Horse.Callback;<N><N>
type<N>  THorseCoreGroup<T: class> = class(TInterfacedObject, IHorseCoreGroup<T>)<N>  private<N>    FHorseCore: TObject;<N>    FPrefix: string;<N>    function NormalizePath(const APath: string): string;<N>  public<N>    constructor Create;<N><N>    function Prefix(const APrefix: string): IHorseCoreGroup<T>;<N>    function Route(const APath: string): IHorseCoreRoute<T>;<N><N>
unit Horse.Provider.Daemon;<N><N>interface<N><N>{$IF DEFINED(HORSE_DAEMON) AND NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, Horse.Constants, Horse.Provider.IOHandleSSL, IdHTTPWebBrokerBridge, IdSSLOpenSSL, IdContext,<N>  System.SyncObjs, System.SysUtils, Posix.SysTypes;<N><N>
unit Horse.Constants;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>const<N>  DEFAULT_HOST = '0.0.0.0';<N>  DEFAULT_PORT = 9000;<N>  START_RUNNING = 'Server is runing on %s:%d';<N>  HORSE_VERSION = '3.0.2';<N><N>implementation<N><N>end.<N>
unit Horse.Commons;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$MODESWITCH TypeHelpers}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  Classes,<N>  SysUtils,<N>  StrUtils,<N>  RegExpr<N>{$ELSE}<N>    System.Classes,<N>  System.SysUtils,<N>  System.RegularExpressions<N>{$ENDIF}<N>    ;<N><N>
unit Horse.Core.RouterTree;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections, fpHTTP, httpprotocol,<N>{$ELSE}<N>  System.SysUtils, System.NetEncoding, Web.HTTPApp, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Request, Horse.Response, Horse.Proc, Horse.Commons, Horse.Callback;<N><N>
unit Horse.Rtti.Helper;<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  RTTI;<N>{$ELSE}<N>  System.Rtti;<N>{$ENDIF}<N><N>type<N>  THorseRttiTypeHelper = class helper for TRttiType<N>  public<N>    {$IF NOT DEFINED(FPC)}<N>    function FieldValueAsObject(const AInstance: Pointer; const AFieldName: string): TObject;<N>    {$ENDIF}<N>  end;<N><N>
implementation<N><N>{$IF NOT DEFINED(FPC)}<N>function THorseRttiTypeHelper.FieldValueAsObject(const AInstance: Pointer; const AFieldName: string): TObject;<N>var<N>  LField: TRttiField;<N>begin<N>  Result := nil;<N>  LField := GetField(AFieldName);<N>  if Assigned(LField) then<N>    Result := LField.GetValue(AInstance).AsObject;<N>end;<N>{$ENDIF}<N><N>
unit Horse.Response;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, fpHTTP, HTTPDefs,<N>{$ELSE}<N>  System.SysUtils, System.Classes, Web.HTTPApp,<N>  {$IF CompilerVersion > 32.0}<N>    Web.ReqMulti,<N>  {$ENDIF}<N>{$ENDIF}<N>  Horse.Commons, Horse.Core.Files;<N><N>
unit Horse.Provider.Console;<N><N>interface<N><N>{$IF NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, Horse.Constants, Horse.Provider.IOHandleSSL, IdHTTPWebBrokerBridge, IdSSLOpenSSL, IdContext,<N>  System.Classes, System.SyncObjs, System.SysUtils;<N><N>
unit Horse.Core.Param;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, DateUtils, Generics.Collections, fpHTTP, fphttpserver, HTTPDefs,<N>{$ELSE}<N>  System.SysUtils, System.Classes, System.DateUtils, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Exception, Horse.Commons, Horse.Core.Param.Field;<N><N>
unit Horse.Core;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections,<N>{$ELSE}<N>  System.SysUtils, System.Generics.Collections, Web.HTTPApp,<N>{$ENDIF}<N>  Horse.Core.RouterTree, Horse.Commons, Horse.Request, Horse.Response, Horse.Constants, Horse.Callback,<N>  Horse.Core.Group.Contract, Horse.Core.Route.Contract;<N><N>
unit Horse.Core.Route;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils,<N>{$ELSE}<N>  System.SysUtils,<N>{$ENDIF}<N>  Horse.Core.Route.Contract, Horse.Core.RouterTree, Horse.Callback;<N><N>
type<N>  THorseCoreRoute<T: class> = class(TInterfacedObject, IHorseCoreRoute<T>)<N>  private<N>    FPath: string;<N>    FHorseCore: TObject;<N>  public<N>    constructor Create(const APath: string);<N><N>    function This: IHorseCoreRoute<T>;<N>    function AddCallback(const ACallback: THorseCallback): IHorseCoreRoute<T>;<N>    function AddCallbacks(const ACallbacks: TArray<THorseCallback>): IHorseCoreRoute<T>;<N><N>
    function All(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const ACallbacks: array of THorseCallback; const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    function Get(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Get(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Get(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Get(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Put(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Put(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Put(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Put(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Head(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Head(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Head(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Head(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Post(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Post(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Post(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Post(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
unit DataSet.Serialize.Language;<N><N>interface<N><N>type<N>  /// <summary><N>  ///   Languages handled by helper Validate (JSON).<N>  /// </summary><N>  TLanguageType = (ptBR, enUS);<N><N>implementation<N><N>end.<N>
unit DataSet.Serialize;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson,<N>{$ELSE}<N>  System.JSON, Data.DB,<N>{$ENDIF}<N>  DataSet.Serialize.Language, DataSet.Serialize.Config;<N><N>type<N>  TLanguageType = DataSet.Serialize.Language.TLanguageType;<N>  TDataSetSerializeConfig = DataSet.Serialize.Config.TDataSetSerializeConfig;<N>  TCaseNameDefinition = DataSet.Serialize.Config.TCaseNameDefinition;<N><N>
unit DataSet.Serialize.Export;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  Classes, DB, Generics.Collections, fpjson;<N>{$ELSE}<N>  Data.DB, System.JSON;<N>{$ENDIF}<N><N>type<N>  {$IF DEFINED(FPC)}<N>  { TJSONExtFloatNumber }<N>  TJSONExtFloatNumber =class(TJSONFloatNumber)<N>    function GetAsString: TJSONStringType; override;<N>  end;<N>  {$ENDIF}<N><N>
unit DataSet.Serialize.UpdatedStatus;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB;<N>{$ELSE}<N>  Data.DB;<N>{$ENDIF}<N><N>type<N>  TUpdateStatusHelper = record helper for TUpdateStatus<N>    function ToString: string;<N>  end;<N><N>
implementation<N><N>function TUpdateStatusHelper.ToString: string;<N>begin<N>  case Self of<N>    usModified:<N>      Result := 'MODIFIED';<N>    usInserted:<N>      Result := 'INSERTED';<N>    usDeleted:<N>      Result := 'DELETED';<N>  else<N>    Result := 'UNMODIFIED';<N>  end;<N>end;<N><N>
﻿unit DataSet.Serialize.Import;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson, Generics.Collections,<N>{$ELSE}<N>  System.JSON, Data.DB, System.StrUtils, System.SysUtils, System.Rtti,<N>  {$IF CompilerVersion >= 20}<N>    System.Character,<N>  {$ENDIF}<N>{$ENDIF}<N>  DataSet.Serialize.Language, DataSet.Serialize.Utils;<N><N>
unit DataSet.Serialize.Samples.Basic;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses Classes, SysUtils, memds, DB, Forms, Controls, Graphics, Dialogs, ComCtrls,<N>  ExtCtrls, StdCtrls, DBGrids, fpjson, DataSet.Serialize, TypInfo;<N><N>type<N><N>  { TFrmBasic }<N><N>
unit DataSet.Serialize.Samples.Master.Detail;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, ExtCtrls, ComCtrls, StdCtrls, Grids, DBGrids, DataSet.Serialize,<N>  ZConnection, ZDataset, fpjson, DB;<N><N>
unit DataSet.Serialize.Samples.Basic;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics, System.JSON, Vcl.Controls,<N>  Vcl.Forms, Vcl.Dialogs, Vcl.ComCtrls, Vcl.ExtCtrls, Vcl.StdCtrls, Data.DB, Vcl.Grids, Vcl.DBGrids, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, DataSet.Serialize;<N><N>
unit DataSet.Serialize.Samples.Configuration;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.StdCtrls, DataSet.Serialize, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf, Data.DB,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, Vcl.CheckLst, Vcl.Grids, Vcl.DBGrids, System.JSON;<N><N>
unit DataSet.Serialize.Samples.Master.Detail;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.ComCtrls, Vcl.StdCtrls, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf, Data.DB, FireDAC.Comp.DataSet,<N>  FireDAC.Comp.Client, Vcl.Grids, Vcl.DBGrids, DataSet.Serialize, System.JSON;<N><N>
unit DataSet.Serialize.Language;<N><N>interface<N><N>type<N>  /// <summary><N>  ///   Languages handled by helper Validate (JSON).<N>  /// </summary><N>  TLanguageType = (ptBR, enUS);<N><N>implementation<N><N>end.<N>
unit DataSet.Serialize;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson,<N>{$ELSE}<N>  System.JSON, Data.DB,<N>{$ENDIF}<N>  DataSet.Serialize.Language, DataSet.Serialize.Config;<N><N>type<N>  TLanguageType = DataSet.Serialize.Language.TLanguageType;<N>  TDataSetSerializeConfig = DataSet.Serialize.Config.TDataSetSerializeConfig;<N>  TCaseNameDefinition = DataSet.Serialize.Config.TCaseNameDefinition;<N><N>
unit DataSet.Serialize.Export;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  Classes, DB, Generics.Collections, fpjson;<N>{$ELSE}<N>  Data.DB, System.JSON;<N>{$ENDIF}<N><N>type<N>  {$IF DEFINED(FPC)}<N>  { TJSONExtFloatNumber }<N>  TJSONExtFloatNumber =class(TJSONFloatNumber)<N>    function GetAsString: TJSONStringType; override;<N>  end;<N>  {$ENDIF}<N><N>
unit DataSet.Serialize.UpdatedStatus;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB;<N>{$ELSE}<N>  Data.DB;<N>{$ENDIF}<N><N>type<N>  TUpdateStatusHelper = record helper for TUpdateStatus<N>    function ToString: string;<N>  end;<N><N>
implementation<N><N>function TUpdateStatusHelper.ToString: string;<N>begin<N>  case Self of<N>    usModified:<N>      Result := 'MODIFIED';<N>    usInserted:<N>      Result := 'INSERTED';<N>    usDeleted:<N>      Result := 'DELETED';<N>  else<N>    Result := 'UNMODIFIED';<N>  end;<N>end;<N><N>
﻿unit DataSet.Serialize.Import;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson, Generics.Collections,<N>{$ELSE}<N>  System.JSON, Data.DB, System.StrUtils, System.SysUtils, System.Rtti,<N>  {$IF CompilerVersion >= 20}<N>    System.Character,<N>  {$ENDIF}<N>{$ENDIF}<N>  DataSet.Serialize.Language, DataSet.Serialize.Utils;<N><N>
unit Horse.Jhonson;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, HTTPDefs, fpjson, jsonparser,<N>{$ELSE}<N>  System.Classes, System.JSON, System.SysUtils, Web.HTTPApp,<N>{$ENDIF}<N>  Horse, Horse.Commons;<N><N>
function Jhonson: THorseCallback; overload;<N>function Jhonson(const ACharset: string): THorseCallback; overload;<N><N>procedure Middleware(Req: THorseRequest; Res: THorseResponse; Next: {$IF DEFINED(FPC)}TNextProc{$ELSE}TProc{$ENDIF});<N><N>implementation<N><N>
var<N>  Charset: string;<N><N>function Jhonson: THorseCallback; overload;<N>begin<N>  Result := Jhonson('UTF-8');<N>end;<N><N>function Jhonson(const ACharset: string): THorseCallback; overload;<N>begin<N>  Charset := ACharset;<N>  Result := Middleware;<N>end;<N><N>
unit Horse.BasicAuthentication;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils,<N>  base64,<N>  Classes,<N>{$ELSE}<N>  System.SysUtils,<N>  System.NetEncoding,<N>  System.Classes,<N>{$ENDIF}<N>  Horse,<N>  Horse.Commons;<N><N>
unit service.contrato;<N><N>{$mode Delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils,<N>  fpjson,<N>  ZDataset,<N>  DataSet.Serialize;<N><N><N>function ListarContratos: TJSONArray;<N>function BuscarContrato: TJSONArray;<N>function Inserir: Boolean;<N>function Editar: Boolean;<N>function Excluir: Boolean;<N><N>
<N>implementation<N><N>function ListarContratos: TJSONArray;<N>var<N>    qry: TZQuery;<N>begin<N>    try<N>        qry := TZQuery.Create(nil);<N>        qry.Connection := FConn;<N><N>        with qry do<N>        begin<N>            Active := false;<N>            SQL.Clear;<N>            SQL.Add('SELECT * FROM CONTRATO');<N><N>
            if NUMERO > 0 then<N>            begin<N>                SQL.Add('WHERE NUMERO = :NUMERO');<N>                ParamByName('NUMERO').Value := NUMERO;<N>            end;<N><N>            SQL.Add('ORDER BY NUMERO');<N>            Active := true;<N>        end;<N><N>
        Result := qry.ToJSONArray;<N><N>    finally<N>        FreeAndNil( qry );<N>    end;<N>end;<N><N><N>function BuscarContrato: TJSONArray;<N>begin<N><N>end;<N><N>function Inserir: Boolean;<N>begin<N><N>end;<N><N>function Editar: Boolean;<N>begin<N><N>
Library Apache;<N><N>{$DEFINE Apache2_4}<N>{$DEFINE FPCAPACHE_2_4}<N>{$MODE DELPHI}{$H+}<N><N>Uses<N>{$ifdef unix}<N>  cthreads,<N>{$endif}<N>  Horse, httpd24, fpApache24, custapache24;<N><N>const<N>  ModuleName = 'apache_horse_module';<N><N>var<N>  ApacheModuleData : module; {$ifdef unix} public name ModuleName;{$endif unix}<N><N>
exports ApacheModuleData name ModuleName;<N><N>procedure GetPing(Req: THorseRequest; Res: THorseResponse; Next: TNextProc);<N>begin<N>  Res.Send('pong');<N>end;<N><N>begin<N>  THorse.Get('/ping', GetPing);<N><N>  THorse.DefaultModule := @ApacheModuleData;<N>  THorse.HandlerName := 'apache_horse_module-handle';<N>  THorse.ModuleName := ModuleName;<N><N>
unit Views.Main;<N><N>{$MODE DELPHI}{$H+}<N><N>interface<N><N>uses Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, Buttons, Horse;<N><N>type<N><N>  { TFrmMain }<N><N>  TFrmMain = class(TForm)<N>    btnStart: TBitBtn;<N>    btnStop: TBitBtn;<N>    edtPort: TEdit;<N>    Label1: TLabel;<N>    procedure btnStartClick(Sender: TObject);<N>    procedure btnStopClick(Sender: TObject);<N>  private<N>    procedure Status;<N>    procedure Start;<N>    procedure Stop;<N>  end;<N><N>
var<N>  FrmMain: TFrmMain;<N><N>implementation<N><N>procedure DoPing(Req: THorseRequest; Res: THorseResponse; Next: TNextProc);<N>begin<N>  Res.Send('pong');<N>end;<N><N>{$R *.lfm}<N><N>procedure TFrmMain.btnStartClick(Sender: TObject);<N>begin<N>  Start;<N>  Status;<N>end;<N><N>
procedure TFrmMain.btnStopClick(Sender: TObject);<N>begin<N>  Stop;<N>  Status;<N>end;<N><N>procedure TFrmMain.Status;<N>begin<N>  btnStop.Enabled := THorse.IsRunning;<N>  btnStart.Enabled := not THorse.IsRunning;<N>  edtPort.Enabled := not THorse.IsRunning;<N>end;<N><N>
unit DaemonManager;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, DaemonApp;<N><N>type<N><N>  { TDaemon_Manager }<N><N>  TDaemon_Manager = class(TDaemonMapper)<N>    procedure Daemon_ManagerCreate(Sender: TObject);<N>  private<N><N>
  public<N><N>  end;<N><N>var<N>  Daemon_Manager: TDaemon_Manager;<N><N>implementation<N><N>procedure RegisterMapper;<N>begin<N>  RegisterDaemonMapper(TDaemon_Manager)<N>end;<N><N>{$R *.lfm}<N><N>{ TDaemon_Manager }<N><N>procedure TDaemon_Manager.Daemon_ManagerCreate(Sender: TObject);<N>begin<N><N>
unit DaemonMain;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, DaemonApp;<N><N>type<N>  TDaemon_Main = class(TDaemon)<N>    procedure DataModuleCreate(Sender: TObject);<N>    procedure DataModuleShutDown(Sender: TCustomDaemon);<N>    procedure DataModuleStart(Sender: TCustomDaemon; var OK: Boolean);<N>  end;<N><N>
var<N>  Daemon_Main: TDaemon_Main;<N><N>implementation<N><N>uses<N>  Horse;<N><N>procedure RegisterDaemon;<N>begin<N>  RegisterDaemonClass(TDaemon_Main)<N>end;<N><N>procedure RunHorse;<N>begin<N>  THorse.Listen(9000);<N>end;<N><N>procedure Ping(Req: THorseRequest; Res: THorseResponse; Next: TNextProc);<N>begin<N>  Res.Send('pong');<N>end;<N><N>
{$R *.lfm}<N><N>{ TDaemon_Main }<N><N>procedure TDaemon_Main.DataModuleCreate(Sender: TObject);<N>begin<N>  THorse.Get('ping', @Ping);<N>end;<N><N>procedure TDaemon_Main.DataModuleShutDown(Sender: TCustomDaemon);<N>begin<N>  THorse.StopListen;<N>end;<N><N>
unit Main.Form;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Horse, Vcl.StdCtrls, Vcl.Samples.Spin, Vcl.Mask, Vcl.ExtCtrls, Vcl.ComCtrls;<N><N>
unit Main.Service;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.SvcMgr, Vcl.Dialogs;<N><N>type<N>  TMainService = class(TService)<N>    procedure ServiceCreate(Sender: TObject);<N>    procedure ServiceStart(Sender: TService; var Started: Boolean);<N>    procedure ServiceStop(Sender: TService; var Stopped: Boolean);<N>  public<N>    function GetServiceController: TServiceController; override;<N>  end;<N><N>
var<N>  MainService: TMainService;<N><N>implementation<N><N>uses Horse;<N><N>{$R *.dfm}<N><N>procedure ServiceController(CtrlCode: DWord); stdcall;<N>begin<N>  MainService.Controller(CtrlCode);<N>end;<N><N>function TMainService.GetServiceController: TServiceController;<N>begin<N>  Result := ServiceController;<N>end;<N><N>
procedure TMainService.ServiceCreate(Sender: TObject);<N>begin<N>  THorse.Get('ping',<N>    procedure(Req: THorseRequest; Res: THorseResponse; Next: TProc)<N>    begin<N>      Res.Send('pong');<N>    end);<N>end;<N><N>procedure TMainService.ServiceStart(Sender: TService; var Started: Boolean);<N>begin<N>  THorse.Listen;<N>  Started := True;<N>end;<N><N>
unit Tests.Api.Vcl;<N><N>interface<N><N>uses<N>  DUnitX.TestFramework, System.JSON, RESTRequest4D.Request, System.Classes,<N>  Controllers.Api, Horse, Horse.Jhonson, SysUtils;<N><N>type<N>  [TestFixture]<N>  TApiTest = class(TObject)<N>  private<N>    FJSONObject: TJSONObject;<N>    FJSONArray: TJSONArray;<N><N>
    procedure CreateApi;<N>    procedure StartApiListen;<N>    procedure StartApiListenPort;<N>    procedure StartApiListenHost;<N>    procedure StartApiListens;<N>    procedure StartApiPortListens;<N>    procedure StopApiListen;<N>    procedure StopApi;<N>  public<N>    [TearDown]<N>    procedure TearDown;<N><N>
    [Test]<N>    procedure TestGet;<N>    [Test]<N>    [TestCase('Test01', 'POST request test')]<N>    procedure TestPost(const AValue: string);<N>    [Test]<N>    [TestCase('Test01', 'PUT request test')]<N>    procedure TestPut(const AValue: string);<N>    [Test]<N>    [TestCase('Test01', '1')]<N>    procedure TestDelete(const AValue: string);<N>    [Test]<N>    procedure TestGStartApiPortListens;<N>    [Test]<N>    procedure TestCreateApi;<N>    [Test]<N>    procedure TestToHorse;<N>  end;<N><N>
implementation<N><N>{ TApiTest }<N><N>procedure TApiTest.StartApiListen;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        THorse<N>          .Use(Jhonson);<N><N>        Controllers.Api.Registry;<N>        THorse.MaxConnections := 10;<N>        THorse.Listen;<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiListenPort;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen(9000);<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiListenHost;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen('0.0.0.0');<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiListens;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen(<N>          procedure(Horse: THorse)<N>          begin<N>          end);<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiPortListens;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen(9000,<N>          procedure(Horse: THorse)<N>          begin<N>          end);<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StopApiListen;<N>begin<N>  THorse.StopListen;<N>end;<N><N>procedure TApiTest.StopApi;<N>begin<N>  // Warnings have been disabled for this segment as the stop has been depreciated.<N>  {$WARNINGS OFF}<N>  THorse.StopListen;<N>  {$WARNINGS ON}<N>end;<N><N>
procedure TApiTest.TestGStartApiPortListens;<N>begin<N>  StartApiPortListens;<N>  StopApi;<N>end;<N><N>procedure TApiTest.TestGet;<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListen;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')<N>    .Accept('application/json')<N>    .Get;<N><N>
  FJSONArray := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONArray;<N><N>  Assert.AreEqual(9000, THorse.Port);<N>  Assert.AreEqual('0.0.0.0', THorse.Host);<N>  Assert.AreEqual(10, THorse.MaxConnections);<N>  Assert.AreEqual(LResponse.StatusCode, 200);<N>  Assert.AreEqual(FJSONArray.Count, 3);<N>  StopApiListen;<N>end;<N><N>
procedure TApiTest.TestPost(const AValue: string);<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListenPort;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')<N>    .Accept('application/json')<N>    .AddBody('{"value": "' + AValue + '"}')<N>    .Post;<N><N>
  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;<N>  Assert.AreEqual(LResponse.StatusCode, 201);<N><N>  if (not FJSONObject.GetValue('value').Null) then<N>    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)<N>  else<N>    Assert.Fail('The return is not without correct format.');<N>  StopApiListen;<N>end;<N><N>
procedure TApiTest.TestPut(const AValue: string);<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListenHost;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')<N>    .Accept('application/json')<N>    .AddBody('{"value": "' + AValue + '"}')<N>    .Put;<N><N>
  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;<N>  Assert.AreEqual(LResponse.StatusCode, 200);<N><N>  if (not FJSONObject.GetValue('value').Null) then<N>    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)<N>  else<N>    Assert.Fail('The return is not in the correct format.');<N>  StopApiListen;<N>end;<N><N>
procedure TApiTest.TestDelete(const AValue: string);<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListens;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test/' + AValue)<N>    .Accept('application/json')<N>    .Delete;<N><N>  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;<N>  Assert.AreEqual(LResponse.StatusCode, 200);<N><N>
  if (not FJSONObject.GetValue('value').Null) then<N>    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)<N>  else<N>    Assert.Fail('The return is not in the correct format.');<N>  StopApiListen;<N>end;<N><N>procedure TApiTest.CreateApi;<N>begin<N>  // Warnings have been disabled for this segment as the create has been depreciated.<N>  {$WARNINGS OFF}<N>  THorse.Create;<N>  {$WARNINGS ON}<N>end;<N><N>
procedure TApiTest.TearDown;<N>begin<N>  FreeAndNil(FJSONObject);<N>  FreeAndNil(FJSONArray);<N>end;<N><N>procedure TApiTest.TestCreateApi;<N>begin<N>  Assert.WillRaise(CreateApi, Exception, 'The Horse instance has already been created');<N>end;<N><N>procedure TApiTest.TestToHorse;<N>begin<N>  Assert.IsNotNull(THorse.ToModule.ToHorse, 'Module instance must not be null');<N>end;<N><N>
unit Tests.Horse.Core.Param;<N><N>interface<N><N>uses<N>  DUnitX.TestFramework,<N>  Horse.Exception,<N>  Horse.Core.Param,<N>  System.Generics.Collections,<N>  System.Classes,<N>  System.DateUtils,<N>  System.SysUtils;<N><N>type<N>  [TestFixture]<N>  TTestHorseCoreParam = class<N>  private<N>    FParams: TDictionary<string, String>;<N>    FHorseParam: THorseCoreParam;<N>    FData: TDateTime;<N>    FTime: TTime;<N>    FFormatSettings: TFormatSettings;<N>    FStream: TStream;<N><N>
    function RequiredMessage(const AKey: String): string;<N>    function ConvertErrorMessage(const AKey, AValue, AType: String): string;<N><N>  public<N>    [Setup]<N>    procedure Setup;<N><N>    [TearDown]<N>    procedure TearDown;<N><N>    [Test]<N>    procedure ContainsKey;<N><N>
    [Test]<N>    procedure NotContainsKey;<N><N>    [Test]<N>    procedure ContainsKeyDiferentCase;<N><N>    [Test]<N>    procedure ContainsValue;<N><N>    [Test]<N>    procedure NotContainsValue;<N><N>    [Test]<N>    procedure ToArray;<N><N>    [Test]<N>    procedure TryGetValueTrue;<N><N>
    [Test]<N>    procedure TryGetValueFalse;<N><N>    [Test]<N>    procedure TryGetValueDiferentCase;<N><N>    [Test]<N>    procedure Content;<N><N>    [Test]<N>    procedure Count;<N><N>    [Test]<N>    procedure List;<N><N>    [Test]<N>    procedure Index;<N><N>
    [Test]<N>    procedure IndexNotFound;<N><N>    [Test]<N>    procedure IndexDiferentCase;<N><N>    [Test]<N>    procedure AsBoolean;<N><N>    [Test]<N>    [TestCase('TrueValue1', 'True,true,true')]<N>    [TestCase('TrueValue2', '1,1,true')]<N>    [TestCase('FalseValue1', 'False,true,false')]<N>    [TestCase('FalseValue2', '5,1,false')]<N>    procedure AsBooleanParam(AParamValue, ATrueValue: string; AResult: Boolean);<N><N>
    [Test]<N>    procedure AsBooleanNotRequired;<N><N>    [Test]<N>    procedure AsBooleanRequired;<N><N>    [Test]<N>    procedure AsCurrency;<N><N>    [Test]<N>    procedure AsCurrencyDecimalSeparator;<N><N>    [Test]<N>    procedure AsCurrencyNotRequired;<N><N>
    [Test]<N>    procedure AsCurrencyRequired;<N><N>    [Test]<N>    procedure AsCurrencyErrorFormat;<N><N>    [Test]<N>    procedure AsDateTime;<N><N>    [Test]<N>    procedure AsDateTimeRequired;<N><N>    [Test]<N>    procedure AsDateTimeNotRequired;<N><N>
    [Test]<N>    procedure AsDateTimeOnlyData;<N><N>    [Test]<N>    procedure AsDateTimeChangeFormat;<N><N>    [Test]<N>    procedure AsDateTimeInvalidFormat;<N><N>    [Test]<N>    procedure AsDate;<N><N>    [Test]<N>    procedure AsDateRequired;<N><N>    [Test]<N>    procedure AsDateNotRequired;<N><N>
    [Test]<N>    procedure AsDateChangeFormat;<N><N>    [Test]<N>    procedure AsDateInvalidFormat;<N><N>    [Test]<N>    procedure AsExtended;<N><N>    [Test]<N>    procedure AsExtendedDecimalSeparator;<N><N>    [Test]<N>    procedure AsExtendedNotRequired;<N><N>
    [Test]<N>    procedure AsExtendedRequired;<N><N>    [Test]<N>    procedure AsExtendedErrorFormat;<N><N>    [Test]<N>    procedure AsFloat;<N><N>    [Test]<N>    procedure AsFloatDecimalSeparator;<N><N>    [Test]<N>    procedure AsFloatNotRequired;<N><N>
    [Test]<N>    procedure AsFloatRequired;<N><N>    [Test]<N>    procedure AsFloatErrorFormat;<N><N>    [Test]<N>    procedure AsInteger;<N><N>    [Test]<N>    procedure AsIntegerNotRequired;<N><N>    [Test]<N>    procedure AsIntegerRequired;<N><N>    [Test]<N>    procedure AsIntegerErrorFormat;<N><N>
    [Test]<N>    procedure AsInt64;<N><N>    [Test]<N>    procedure AsInt64NotRequired;<N><N>    [Test]<N>    procedure AsInt64Required;<N><N>    [Test]<N>    procedure AsInt64ErrorFormat;<N><N>    [Test]<N>    procedure AsISO8601DateTime;<N><N>    [Test]<N>    procedure AsISO8601DateTimeOnlyData;<N><N>
    [Test]<N>    procedure AsISO8601DateTimeNotRequired;<N><N>    [Test]<N>    procedure AsISO8601DateTimeRequired;<N><N>    [Test]<N>    procedure AsISO8601DateTimeErrorFormat;<N><N>    [Test]<N>    procedure AsStream;<N><N>    [Test]<N>    procedure AsStreamNotFoundNotRequired;<N><N>
    [Test]<N>    procedure AsStreamNotFoundRequired;<N><N>    [Test]<N>    procedure AsStreamSaveToFile;<N><N>    [Test]<N>    procedure AsStreamNotFoundSaveToFile;<N><N>    [Test]<N>    procedure AsString;<N><N>    [Test]<N>    procedure AsStringRequired;<N><N>
    [Test]<N>    procedure AsStringNotRequired;<N><N>    [Test]<N>    procedure AsStringDiferentCase;<N><N>    [Test]<N>    procedure AsTime;<N><N>    [Test]<N>    procedure AsTimeRequired;<N><N>    [Test]<N>    procedure AsTimeNotRequired;<N><N>    [Test]<N>    procedure AsTimeChangeFormat;<N><N>
    [Test]<N>    procedure AsTimeInvalidFormat;<N>  end;<N><N>implementation<N><N>{ TTestHorseCoreParam }<N><N>procedure TTestHorseCoreParam.AsBoolean;<N>begin<N>  FParams.AddOrSetValue('Key1', 'True');<N>  Assert.IsTrue(FHorseParam.Field('Key1').Required.AsBoolean);<N>end;<N><N>
procedure TTestHorseCoreParam.AsBooleanNotRequired;<N>begin<N>  Assert.IsFalse(FHorseParam.Field('Key1').AsBoolean);<N>end;<N><N>procedure TTestHorseCoreParam.AsBooleanParam(AParamValue, ATrueValue: string; AResult: Boolean);<N>begin<N>  FParams.AddOrSetValue('Key1', AParamValue);<N>  Assert.AreEqual(AResult, FHorseParam.Field('Key1').Required.TrueValue(ATrueValue).AsBoolean);<N>end;<N><N>
procedure TTestHorseCoreParam.AsBooleanRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsBoolean;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>procedure TTestHorseCoreParam.AsCurrency;<N>begin<N>  FParams.AddOrSetValue('Key1', '5.5');<N>  Assert.AreEqual('5,5', CurrToStr( FHorseParam.Field('Key1').AsCurrency));<N>end;<N><N>
procedure TTestHorseCoreParam.AsCurrencyDecimalSeparator;<N>begin<N>  FParams.AddOrSetValue('Key1', '5,5');<N>  Assert.AreEqual('5,5', CurrToStr( FHorseParam.Field('Key1').AsCurrency));<N>end;<N><N>procedure TTestHorseCoreParam.AsCurrencyErrorFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', '5a');<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsCurrency;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', '5a', 'numeric'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsCurrencyNotRequired;<N>begin<N>  Assert.AreEqual('0', CurrToStr(FHorseParam.Field('Key1').AsCurrency));<N>end;<N><N>procedure TTestHorseCoreParam.AsCurrencyRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsCurrency;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsDate;<N>begin<N>  FData := EncodeDate(2021, 11, 13);<N>  FParams.Add('Key1', '2021-11-13 10:25:32');<N><N>  Assert.AreEqual(DateToStr(FData), DateToStr(FHorseParam.Field('Key1').AsDate));<N>end;<N><N>procedure TTestHorseCoreParam.AsDateChangeFormat;<N>begin<N>  FData := EncodeDate(2021, 11, 13);<N>  FParams.Add('Key1', '13/11/2021');<N><N>
  Assert.AreEqual(DateToStr(FData), DateToStr(FHorseParam.Field('Key1').Required.DateFormat('dd/MM/yyyy').AsDate));<N>end;<N><N>procedure TTestHorseCoreParam.AsDateInvalidFormat;<N>begin<N>  FParams.Add('Key1', '2021/11-13');<N><N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsDate;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', '2021/11-13', 'date'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsDateNotRequired;<N>begin<N>  Assert.IsTrue(FHorseParam.Field('Key1').AsDate = 0);<N>end;<N><N>procedure TTestHorseCoreParam.AsDateRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsDate;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsDateTime;<N>begin<N>  FData := EncodeDateTime(2021, 11, 13, 10, 25, 32, 0);<N>  FParams.Add('Key1', '2021-11-13 10:25:32');<N><N>  Assert.AreEqual(DateToStr(FData), DateToStr(FHorseParam.Field('Key1').AsDateTime));<N>end;<N><N>
procedure TTestHorseCoreParam.AsDateTimeChangeFormat;<N>begin<N>  FData := EncodeDateTime(2021, 11, 13, 10, 25, 32, 0);<N>  FParams.Add('Key1', '13/11/2021 10:25:32');<N><N>  Assert.AreEqual(DateToStr(FData), DateToStr(FHorseParam.Field('Key1').Required.DateFormat('dd/MM/yyyy').AsDateTime));<N>end;<N><N>
procedure TTestHorseCoreParam.AsDateTimeInvalidFormat;<N>begin<N>  FParams.Add('Key1', '2021/11-13 10:25:32');<N><N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsDateTime;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', '2021/11-13 10:25:32', 'datetime'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsDateTimeNotRequired;<N>begin<N>  Assert.IsTrue(FHorseParam.Field('Key1').Required(False).AsDateTime = 0);<N>end;<N><N>procedure TTestHorseCoreParam.AsDateTimeOnlyData;<N>begin<N>  FData := EncodeDate(2021, 11, 13);<N>  FParams.Add('Key1', '2021-11-13');<N><N>
  Assert.AreEqual(DateToStr(FData), DateToStr(FHorseParam.Field('Key1').AsDateTime));<N>end;<N><N>procedure TTestHorseCoreParam.AsDateTimeRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsDateTime;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsExtended;<N>begin<N>  FParams.AddOrSetValue('Key1', '5.5');<N>  Assert.AreEqual('5,5', FHorseParam.Field('Key1').AsExtended.ToString(FFormatSettings));<N>end;<N><N>procedure TTestHorseCoreParam.AsExtendedDecimalSeparator;<N>begin<N>  FParams.AddOrSetValue('Key1', '5,5');<N>  Assert.AreEqual('5,5', FHorseParam.Field('Key1').AsExtended.ToString(FFormatSettings));<N>end;<N><N>
procedure TTestHorseCoreParam.AsExtendedErrorFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', '5a');<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsExtended;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', '5a', 'numeric'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsExtendedNotRequired;<N>begin<N>  Assert.AreEqual('0', FHorseParam.Field('Key1').AsExtended.ToString);<N>end;<N><N>procedure TTestHorseCoreParam.AsExtendedRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsExtended;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsFloat;<N>begin<N>  FParams.AddOrSetValue('Key1', '5.5');<N>  Assert.AreEqual('5,5', FHorseParam.Field('Key1').AsFloat.ToString(FFormatSettings));<N>end;<N><N>procedure TTestHorseCoreParam.AsFloatDecimalSeparator;<N>begin<N>  FParams.AddOrSetValue('Key1', '5,5');<N>  Assert.AreEqual('5,5', FHorseParam.Field('Key1').AsFloat.ToString(FFormatSettings));<N>end;<N><N>
procedure TTestHorseCoreParam.AsFloatErrorFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', '5a');<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsFloat;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', '5a', 'numeric'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsFloatNotRequired;<N>begin<N>  Assert.AreEqual('0', FHorseParam.Field('Key1').Required(False).AsFloat.ToString);<N>end;<N><N>procedure TTestHorseCoreParam.AsFloatRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required(True).AsFloat;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsInt64;<N>begin<N>  FParams.AddOrSetValue('Key1', '5');<N>  Assert.AreEqual('5', FHorseParam.Field('Key1').AsInt64.ToString);<N>end;<N><N>procedure TTestHorseCoreParam.AsInt64ErrorFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value');<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsInt64;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', 'Value', 'int64'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsInt64NotRequired;<N>begin<N>  Assert.AreEqual('0', FHorseParam.Field('Key1').Required(False).AsInt64.ToString);<N>end;<N><N>procedure TTestHorseCoreParam.AsInt64Required;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required(True).AsInt64;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsInteger;<N>begin<N>  FParams.AddOrSetValue('Key1', '5');<N>  Assert.AreEqual(5, FHorseParam.Field('Key1').AsInteger);<N>end;<N><N>procedure TTestHorseCoreParam.AsIntegerErrorFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value');<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsInteger;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', 'Value', 'integer'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsIntegerNotRequired;<N>begin<N>  Assert.AreEqual(0, FHorseParam.Field('Key1').AsInteger);<N>end;<N><N>procedure TTestHorseCoreParam.AsIntegerRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required(True).AsInteger;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsISO8601DateTime;<N>begin<N>  FData := EncodeDateTime(2021, 11, 13, 10, 21, 22, 0);<N>  FParams.AddOrSetValue('Key1', '2021-11-13T10:21:22');<N><N>  Assert.AreEqual(DateToStr(FData), DateToStr(FHorseParam.Field('Key1').AsISO8601DateTime));<N>end;<N><N>
procedure TTestHorseCoreParam.AsISO8601DateTimeErrorFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', '2021-11-13 10:21:22');<N>  Assert.WillNotRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsISO8601DateTime;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsISO8601DateTimeNotRequired;<N>begin<N>  Assert.IsTrue(FHorseParam.Field('Key1').Required(False).AsISO8601DateTime = 0);<N>end;<N><N>procedure TTestHorseCoreParam.AsISO8601DateTimeOnlyData;<N>begin<N>  FData := EncodeDateTime(2021, 11, 13, 10, 21, 22, 0);<N>  FParams.AddOrSetValue('Key1', '2021-11-13');<N><N>
  Assert.AreEqual(FormatDateTime('dd/MM/yyyy', FData), FormatDateTime('dd/MM/yyyy', FHorseParam.Field('Key1').AsISO8601DateTime));<N>end;<N><N>procedure TTestHorseCoreParam.AsISO8601DateTimeRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsISO8601DateTime;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsStream;<N>begin<N>  FStream := TStringStream.Create('1234');<N>  FHorseParam.AddStream('Key1', FStream);<N><N>  Assert.IsNotNull(FHorseParam.Field('Key1').AsStream);<N>  Assert.AreEqual<Int64>(0, FHorseParam.Field('Key1').AsStream.Position);<N>end;<N><N>
procedure TTestHorseCoreParam.AsStreamNotFoundNotRequired;<N>begin<N>  Assert.IsNull(FHorseParam.Field('Key1').AsStream);<N>end;<N><N>procedure TTestHorseCoreParam.AsStreamNotFoundRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required(True).AsStream<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsStreamNotFoundSaveToFile;<N>var<N>  LFile: String;<N>begin<N>  LFile := 'test.txt';<N>  Assert.IsFalse(FileExists(LFile));<N><N>  FHorseParam.Field('Key1').SaveToFile(LFile);<N>  Assert.IsFalse(FileExists(LFile));<N>end;<N><N>
procedure TTestHorseCoreParam.AsStreamSaveToFile;<N>var<N>  LFile: String;<N>begin<N>  LFile := 'test.txt';<N>  Assert.IsFalse(FileExists(LFile));<N><N>  FStream := TStringStream.Create('1234');<N>  FHorseParam.AddStream('Key1', FStream);<N><N>  FHorseParam.Field('Key1').SaveToFile(LFile);<N>  Assert.IsTrue(FileExists(LFile));<N>  DeleteFile(LFile);<N>end;<N><N>
procedure TTestHorseCoreParam.AsString;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value');<N>  Assert.AreEqual('Value', FHorseParam.Field('Key1').AsString);<N>end;<N><N>procedure TTestHorseCoreParam.AsStringDiferentCase;<N>begin<N>  FParams.AddOrSetValue('key1', 'Value');<N>  Assert.AreEqual('Value', FHorseParam.Field('Key1').AsString);<N>end;<N><N>
procedure TTestHorseCoreParam.AsStringNotRequired;<N>begin<N>  Assert.IsEmpty(FHorseParam.Field('Key1').AsString);<N>end;<N><N>procedure TTestHorseCoreParam.AsStringRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsString;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsTime;<N>begin<N>  FTime := EncodeTime(10, 15, 54, 0);<N>  FParams.AddOrSetValue('Key1', '10:15:54');<N><N>  Assert.AreEqual(FTime, FHorseParam.Field('Key1').AsTime);<N>end;<N><N>procedure TTestHorseCoreParam.AsTimeChangeFormat;<N>begin<N>  FTime := EncodeTime(10, 15, 0, 0);<N>  FParams.AddOrSetValue('Key1', '10:15:54');<N><N>
  Assert.AreEqual(FTime, FHorseParam.Field('Key1').TimeFormat('hh:mm').AsTime);<N>end;<N><N>procedure TTestHorseCoreParam.AsTimeInvalidFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', '10/00');<N><N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      Assert.AreEqual(FTime, FHorseParam.Field('Key1').AsTime);<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', '10/00', 'time'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsTimeNotRequired;<N>begin<N>  Assert.IsTrue(FHorseParam.Field('Key1').AsTime = 0);<N>end;<N><N>procedure TTestHorseCoreParam.AsTimeRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      Assert.AreEqual(FTime, FHorseParam.Field('Key1').Required.AsTime);<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.ContainsKey;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value');<N>  Assert.IsTrue(FHorseParam.ContainsKey('Key1'));<N>end;<N><N>procedure TTestHorseCoreParam.ContainsKeyDiferentCase;<N>begin<N>  FParams.AddOrSetValue('key1', 'Value');<N>  Assert.IsTrue(FHorseParam.ContainsKey('KEY1'));<N>end;<N><N>
procedure TTestHorseCoreParam.ContainsValue;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value');<N>  Assert.IsTrue(FHorseParam.ContainsValue('Value'));<N>end;<N><N>procedure TTestHorseCoreParam.Content;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value1');<N>  FParams.AddOrSetValue('Key2', 'Value2');<N><N>
  Assert.AreEqual(2, FHorseParam.Content.Count);<N>  Assert.AreEqual('Key1', FHorseParam.Content.Names[0]);<N>  Assert.AreEqual('Key2', FHorseParam.Content.Names[1]);<N>  Assert.AreEqual('Value1', FHorseParam.Content.ValueFromIndex[0]);<N>  Assert.AreEqual('Value2', FHorseParam.Content.ValueFromIndex[1]);<N>end;<N><N>
function TTestHorseCoreParam.ConvertErrorMessage(const AKey, AValue, AType: String): string;<N>begin<N>  result := Format('The %s param ''%s'' is not valid a %s type.', [AKey, AValue, AType]);<N>end;<N><N>procedure TTestHorseCoreParam.Count;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value1');<N>  FParams.AddOrSetValue('Key2', 'Value2');<N><N>
  Assert.AreEqual(2, FHorseParam.Count);<N>end;<N><N>procedure TTestHorseCoreParam.Index;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value1');<N>  Assert.AreEqual('Value1', FHorseParam['Key1']);<N>end;<N><N>procedure TTestHorseCoreParam.IndexDiferentCase;<N>begin<N>  FParams.AddOrSetValue('KEY1', 'Value1');<N>  Assert.AreEqual('Value1', FHorseParam['key1']);<N>end;<N><N>
procedure TTestHorseCoreParam.IndexNotFound;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value1');<N>  Assert.IsEmpty(FHorseParam.Items['Value1']);<N>end;<N><N>procedure TTestHorseCoreParam.List;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value1');<N>  FParams.AddOrSetValue('Key2', 'Value2');<N><N>
  Assert.AreEqual(2, FHorseParam.Count);<N>  Assert.AreEqual(FParams, FHorseParam.Dictionary);<N>end;<N><N>procedure TTestHorseCoreParam.NotContainsKey;<N>begin<N>  FParams.AddOrSetValue('Key', 'Value');<N>  Assert.IsFalse(FHorseParam.ContainsKey('Value'));<N>end;<N><N>
procedure TTestHorseCoreParam.NotContainsValue;<N>begin<N>  FParams.AddOrSetValue('Key', 'Value');<N>  Assert.IsFalse(FHorseParam.ContainsValue('Key'));<N>end;<N><N>function TTestHorseCoreParam.RequiredMessage(const AKey: String): string;<N>begin<N>  result := Format('The %s param is required.', [AKey]);<N>end;<N><N>
procedure TTestHorseCoreParam.Setup;<N>begin<N>  FParams := TDictionary<String, String>.Create;<N>  FHorseParam := THorseCoreParam.create(FParams);<N>  FFormatSettings := TFormatSettings.Create;<N>  FFormatSettings.DecimalSeparator := ',';<N>  FData := 0;<N>  FTime := 0;<N>end;<N><N>
procedure TTestHorseCoreParam.TearDown;<N>begin<N>  FreeAndNil(FHorseParam);<N>  FreeAndNil(FStream);<N>end;<N><N>procedure TTestHorseCoreParam.ToArray;<N>var<N>  LPairs: TArray<TPair<String, String>>;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value1');<N>  FParams.AddOrSetValue('Key2', 'Value2');<N><N>
  LPairs := FHorseParam.ToArray;<N><N>  Assert.AreEqual(2, Length(LPairs));<N>  Assert.AreEqual('Key1', LPairs[0].Key);<N>  Assert.AreEqual('Value1', LPairs[0].Value);<N>  Assert.AreEqual('Key2', LPairs[1].Key);<N>  Assert.AreEqual('Value2', LPairs[1].Value);<N>end;<N><N>
procedure TTestHorseCoreParam.TryGetValueDiferentCase;<N>var<N>  LValue: String;<N>begin<N>  FParams.AddOrSetValue('KEY1', 'Value1');<N>  Assert.IsTrue(FHorseParam.TryGetValue('key1', LValue));<N>  Assert.AreEqual('Value1', LValue);<N>end;<N><N>procedure TTestHorseCoreParam.TryGetValueFalse;<N>var<N>  LValue: String;<N>begin<N>  Assert.IsFalse(FHorseParam.TryGetValue('Key1', LValue));<N>end;<N><N>
unit Tests.Api.Console;<N><N>interface<N><N>uses<N>  DUnitX.TestFramework, System.JSON, RESTRequest4D.Request, System.Classes,<N>  Controllers.Api, Horse, Horse.Jhonson, SysUtils;<N><N>type<N>  [TestFixture]<N>  TApiTest = class(TObject)<N>  private<N>    FJSONObject: TJSONObject;<N>    FJSONArray: TJSONArray;<N><N>
    procedure CreateApi;<N>    procedure StartApiListen;<N>    procedure StartApiListenPort;<N>    procedure StartApiListenHost;<N>    procedure StartApiListens;<N>    procedure StartApiPortListens;<N>    procedure StopApiListen;<N>    procedure StopApi;<N>  public<N>    [TearDown]<N>    procedure TearDown;<N><N>
    [Test]<N>    procedure TestGet;<N>    [Test]<N>    [TestCase('Test01', 'POST request test')]<N>    procedure TestPost(const AValue: string);<N>    [Test]<N>    [TestCase('Test01', 'PUT request test')]<N>    procedure TestPut(const AValue: string);<N>    [Test]<N>    [TestCase('Test01', '1')]<N>    procedure TestDelete(const AValue: string);<N>    [Test]<N>    procedure TestGStartApiPortListens;<N>    [Test]<N>    procedure TestCreateApi;<N>    [Test]<N>    procedure TestToHorse;<N>  end;<N><N>
implementation<N><N>{ TApiTest }<N><N>procedure TApiTest.StartApiListen;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        THorse<N>          .Use(Jhonson);<N><N>        Controllers.Api.Registry;<N>        THorse.MaxConnections := 10;<N>        THorse.Listen;<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiListenPort;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen(9000);<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiListenHost;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen('0.0.0.0');<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiListens;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen(<N>          procedure(Horse: THorse)<N>          begin<N>          end,<N>          procedure(Horse: THorse)<N>          begin<N>          end);<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiPortListens;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen(9000,<N>          procedure(Horse: THorse)<N>          begin<N>          end,<N>          procedure(Horse: THorse)<N>          begin<N>          end);<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StopApiListen;<N>begin<N>  THorse.StopListen;<N>end;<N><N>procedure TApiTest.StopApi;<N>begin<N>  // Warnings have been disabled for this segment as the stop has been depreciated.<N>  {$WARNINGS OFF}<N>  THorse.StopListen;<N>  {$WARNINGS ON}<N>end;<N><N>
procedure TApiTest.TestGStartApiPortListens;<N>begin<N>  StartApiPortListens;<N>  StopApi;<N>end;<N><N>procedure TApiTest.TestGet;<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListen;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')<N>    .Accept('application/json')<N>    .Get;<N><N>
  FJSONArray := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONArray;<N>  Assert.AreEqual(9000, THorse.Port);<N>  Assert.AreEqual('0.0.0.0', THorse.Host);<N>  Assert.AreEqual(10, THorse.MaxConnections);<N>  Assert.AreEqual(LResponse.StatusCode, 200);<N>  Assert.AreEqual(FJSONArray.Count, 3);<N>  StopApiListen;<N>end;<N><N>
procedure TApiTest.TestPost(const AValue: string);<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListenPort;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')<N>    .Accept('application/json')<N>    .AddBody('{"value": "' + AValue + '"}')<N>    .Post;<N><N>
  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;<N>  Assert.AreEqual(LResponse.StatusCode, 201);<N><N>  if (not FJSONObject.GetValue('value').Null) then<N>    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)<N>  else<N>    Assert.Fail('The return is not without correct format.');<N>  StopApiListen;<N>end;<N><N>
procedure TApiTest.TestPut(const AValue: string);<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListenHost;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')<N>    .Accept('application/json')<N>    .AddBody('{"value": "' + AValue + '"}')<N>    .Put;<N><N>
  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;<N>  Assert.AreEqual(LResponse.StatusCode, 200);<N><N>  if (not FJSONObject.GetValue('value').Null) then<N>    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)<N>  else<N>    Assert.Fail('The return is not in the correct format.');<N>  StopApiListen;<N>end;<N><N>
procedure TApiTest.TestDelete(const AValue: string);<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListens;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test/' + AValue)<N>    .Accept('application/json')<N>    .Delete;<N><N>  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;<N>  Assert.AreEqual(LResponse.StatusCode, 200);<N><N>
  if (not FJSONObject.GetValue('value').Null) then<N>    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)<N>  else<N>    Assert.Fail('The return is not in the correct format.');<N>  StopApiListen;<N>end;<N><N>procedure TApiTest.CreateApi;<N>begin<N>  // Warnings have been disabled for this segment as the create has been depreciated.<N>  {$WARNINGS OFF}<N>  THorse.Create;<N>  {$WARNINGS ON}<N>end;<N><N>
procedure TApiTest.TearDown;<N>begin<N>  FreeAndNil(FJSONObject);<N>  FreeAndNil(FJSONArray);<N>end;<N><N>procedure TApiTest.TestCreateApi;<N>begin<N>  Assert.WillRaise(CreateApi, Exception, 'The Horse instance has already been created');<N>end;<N><N>procedure TApiTest.TestToHorse;<N>begin<N>  Assert.IsNotNull(THorse.ToModule.ToHorse, 'Module instance must not be null');<N>end;<N><N>
unit Tests.Commons;<N><N>interface<N><N>uses<N>  DUnitX.TestFramework, Horse.Commons;<N><N>type<N>  [TestFixture]<N>  TCommonsTest = class(TObject)<N>  public<N>    [Test]<N>    procedure TestMimeTypesToString;<N>  end;<N><N>implementation<N><N>{ TCommonsTest }<N><N>
unit Tests.Horse.Core.Files;<N><N>interface<N><N>uses<N>  DUnitX.TestFramework,<N>  Horse.Core.Files,<N>  System.Classes,<N>  System.SysUtils;<N><N>type<N>  [TestFixture]<N>  TTestHorseCoreFile = class<N>  private<N>    FHorseFile: THorseCoreFile;<N>    FFileName: String;<N><N>
  public<N>    [Setup]<N>    procedure Setup;<N><N>    [Teardown]<N>    procedure Teardown;<N><N>    [Test]<N>    procedure EmptyFileName;<N><N>    [Test]<N>    procedure InvalidFileName;<N><N>    [Test]<N>    procedure DelphiFile;<N>  end;<N><N>implementation<N><N>
{ TTestHorseCoreFile }<N><N>procedure TTestHorseCoreFile.DelphiFile;<N>begin<N>  FFileName := ExtractFilePath(GetModuleName(HInstance));<N>  FFileName := FFileName.Replace('tests\', 'src\Horse.pas');<N><N>  FHorseFile := THorseCoreFile.Create(FFileName);<N><N>
  Assert.AreEqual('text/x-pascal', FHorseFile.ContentType);<N>  Assert.IsNotNull(FHorseFile.ContentStream);<N>  Assert.IsTrue(FHorseFile.Size > 0);<N>end;<N><N>procedure TTestHorseCoreFile.EmptyFileName;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseFile := THorseCoreFile.Create(EmptyStr);<N>    end,<N>    Exception,<N>    'Invalid FileName');<N>end;<N><N>
procedure TTestHorseCoreFile.InvalidFileName;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseFile := THorseCoreFile.Create('C:\InvalidFile.txt2');<N>    end,<N>    Exception,<N>    'File not exist');<N>end;<N><N>procedure TTestHorseCoreFile.Setup;<N>begin<N>  FFileName := EmptyStr;<N>end;<N><N>
unit Controllers.Api;<N><N>interface<N><N>uses<N>  Horse, System.JSON, Horse.Commons;<N><N>procedure Registry;<N>procedure DoGetApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>procedure DoPostApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>procedure DoPutApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>procedure DoDeleteApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N><N>
implementation<N><N>procedure Registry;<N>begin<N>  THorse<N>    .Group<N>      .Prefix('/Api')<N>        .Delete('/Test/:id', DoDeleteApi)<N>        .Route('/Test')<N>          .Get(DoGetApi)<N>          .Post(DoPostApi)<N>          .Put(DoPutApi)<N>end;<N><N>
procedure DoGetApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LList: TJSONArray;<N>  LObject01: TJSONObject;<N>  LObject02: TJSONObject;<N>  LObject03: TJSONObject;<N>begin<N>  LList := TJSONArray.Create;<N>  try<N>    LObject01 := TJSONObject.Create;<N>    LObject01.AddPair(TJSONPair.Create('value', 'test01'));<N>    LList.AddElement(LObject01);<N><N>
    LObject02 := TJSONObject.Create;<N>    LObject02.AddPair(TJSONPair.Create('value', 'test02'));<N>    LList.AddElement(LObject02);<N><N>    LObject03 := TJSONObject.Create;<N>    LObject03.AddPair(TJSONPair.Create('value', 'test03'));<N>    LList.AddElement(LObject03);<N><N>
    Res.Send(LList.ToString);<N>  finally<N>    LList.Free;<N>  end;<N>end;<N><N>procedure DoPostApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LValue: string;<N>  LRequest: TJSONObject;<N>  LResponse: TJSONObject;<N>begin<N>  LValue := '';<N>  LRequest := TJSONObject.ParseJSONValue(Req.Body) as TJSONObject;<N>  try<N>    if (not LRequest.GetValue('value').Null) then<N>      LValue := LRequest.GetValue('value').value;<N><N>
    LResponse := TJSONObject.Create;<N>    try<N>      LResponse.AddPair(TJSONPair.Create('value', LValue));<N><N>      Res.Send(LResponse.ToString).Status(THTTPStatus.Created);<N>    finally<N>      LResponse.Free;<N>    end;<N>  finally<N>    LRequest.Free;<N>  end;<N>end;<N><N>
procedure DoPutApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LValue: string;<N>  LRequest: TJSONObject;<N>  LResponse: TJSONObject;<N>begin<N>  LValue := '';<N>  LRequest := TJSONObject.ParseJSONValue(Req.Body) as TJSONObject;<N>  try<N>    if (not LRequest.GetValue('value').Null) then<N>      LValue := LRequest.GetValue('value').value;<N><N>
    LResponse := TJSONObject.Create;<N>    try<N>      LResponse.AddPair(TJSONPair.Create('value', LValue));<N><N>      Res.Send(LResponse.ToString);<N>    finally<N>      LResponse.Free;<N>    end;<N>  finally<N>    LRequest.Free;<N>  end;<N>end;<N><N>procedure DoDeleteApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LValue: string;<N>  LResponse: TJSONObject;<N>begin<N>  LValue := Req.Params['id'];<N><N>
unit Horse.Core.RouterTree.NextCaller;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections, fpHTTP, httpprotocol,<N>{$ELSE}<N>  System.NetEncoding, System.SysUtils, Web.HTTPApp, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Commons, Horse.Request, Horse.Response, Horse.Callback;<N><N>
﻿unit Web.WebConst;<N><N>interface<N><N>resourcestring<N>  sDuplicateActionName = 'Duplicate action name';<N>  sOnlyOneDispatcher = 'Only one WebDispatcher per form/data module';<N>  sHTTPItemName = 'Name';<N>  sHTTPItemURI = 'PathInfo';<N>  sHTTPItemEnabled = 'Enabled';<N>  sHTTPItemDefault = 'Default';<N>  sHTTPItemProducer = 'Producer';<N>  sHTTPItemMethod = 'Method';<N><N>
unit Horse.Proc;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF NOT DEFINED(FPC)}<N>uses System.SysUtils;<N>{$ENDIF}<N><N>type<N>  TNextProc = {$IF DEFINED(FPC)}procedure of object{$ELSE}System.SysUtils.TProc{$ENDIF};<N>  TProc = {$IF DEFINED(FPC)}procedure{$ELSE}System.SysUtils.TProc{$ENDIF};<N><N>{$IF DEFINED(FPC)}<N>  TProc<T> = procedure(Arg1: T);<N>{$ENDIF}<N><N>implementation<N><N>end.<N>
unit Horse.Provider.CGI;<N><N>interface<N><N>{$IF DEFINED(HORSE_CGI) AND NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, System.SysUtils;<N><N>type<N>  THorseProvider<T: class> = class(THorseProviderAbstract<T>)<N>  private<N>    class procedure InternalListen; static;<N>  public<N>    class procedure Listen; overload; override;<N>    class procedure Listen(const ACallback: TProc<T>); reintroduce; overload; static;<N>  end;<N>{$ENDIF}<N><N>
implementation<N><N>{$IF DEFINED(HORSE_CGI) AND NOT DEFINED(FPC)}<N>uses Web.WebBroker, Web.CGIApp, Horse.WebModule;<N><N>class procedure THorseProvider<T>.InternalListen;<N>begin<N>  Application.Initialize;<N>  Application.WebModuleClass := WebModuleClass;<N>  DoOnListen;<N>  Application.Run;<N>end;<N><N>
class procedure THorseProvider<T>.Listen;<N>begin<N>  inherited;<N>  InternalListen;<N>end;<N><N>class procedure THorseProvider<T>.Listen(const ACallback: TProc<T>);<N>begin<N>  inherited;<N>  SetOnListen(ACallback);<N>  InternalListen;<N>end;<N>{$ENDIF}<N><N>
unit Horse.Provider.FPC.Apache;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_APACHE) AND DEFINED(FPC)}<N>uses<N>{$IFDEF unix}<N>  cthreads,<N>{$ENDIF}<N>  fphttp, httpdefs, httpd24, fpApache24, custapache24, SysUtils, Classes, Horse.Provider.Abstract,<N>  Horse.Constants, Horse.Proc;<N><N>
unit Horse.Provider.FPC.Daemon;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_DAEMON)}<N>uses SysUtils, Classes, httpdefs, fpHTTP, fphttpserver, Horse.Request, Horse.Response, Horse.Core, Horse.Provider.Abstract, Horse.Constants,<N>  Horse.Proc, Horse.Commons, Horse.Exception;<N><N>
unit Horse.Core.Param.Field;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, DateUtils, Generics.Collections,<N>{$ELSE}<N>  System.SysUtils, System.Classes, System.DateUtils, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Exception, Horse.Commons, Horse.Core.Param.Field.Brackets,<N>  Horse.Core.Param.Config;<N><N>
type<N><N>  THorseCoreParamField = class<N>  private<N>    FContains: Boolean;<N>    FFieldName: string;<N>    FRequired: Boolean;<N>    FRequiredMessage: string;<N>    FInvalidFormatMessage: string;<N>    FDateFormat: string;<N>    FTimeFormat: string;<N>    FReturnUTC: Boolean;<N>    FTrueValue: string;<N>    FValue: string;<N>    FStream: TStream;<N>    FLhsBrackets: THorseCoreParamFieldLhsBrackets;<N><N>
    function GetFormatSettings: TFormatSettings;<N>    procedure RaiseHorseException(const AMessage: string); overload;<N>    procedure RaiseHorseException(const AMessage: string; const Args: array of const); overload;<N>    function TryISO8601ToDate(const AValue: string; out Value: TDateTime): Boolean;<N><N>
unit Horse.Provider.FPC.LCL;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_LCL)}<N>uses SysUtils, Classes, httpdefs, fpHTTP, fphttpapp, Horse.Provider.Abstract, Horse.Constants, Horse.Proc;<N><N>type<N><N>
unit Horse.Session;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections;<N>{$ELSE}<N>  System.SysUtils, System.Generics.Collections;<N>{$ENDIF}<N><N>type<N>  TSession = class<N>  end;<N><N>
unit Horse.Callback;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  Generics.Collections, fpHTTP,<N>{$ELSE}<N>  Web.HTTPApp, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Request, Horse.Response, Horse.Proc, Horse.Commons;<N><N>
{ ****************************************************************************** }<N>{ }<N>{ Linux Daemon with Delphi }<N>{ }<N>{ Author: Paolo Rossi (2017) }<N>{ }<N>{ http://www.paolorossi.net }<N>{ http://blog.paolorossi.net }<N>{ https://github.com/paolo-rossi }<N>{ }<N>{ ****************************************************************************** }<N>unit ThirdParty.Posix.Syslog;<N><N>
unit Horse.Core.Group.Contract;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses Horse.Core.Route.Contract, Horse.Core.RouterTree, Horse.Callback;<N><N>type<N>  IHorseCoreGroup<T: class> = interface<N>    ['{5EB734D6-6944-473E-9C79-506647E2F5E8}']<N>    function Prefix(const APrefix: string): IHorseCoreGroup<T>;<N>    function Route(const APath: string): IHorseCoreRoute<T>;<N><N>
unit Horse.WebModule;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, httpdefs, fpHTTP, fpWeb,<N>{$ELSE}<N>  System.SysUtils, System.Classes, Web.HTTPApp,<N>{$ENDIF}<N>  Horse.Core, Horse.Commons;<N><N>
unit Horse.Provider.FPC.FastCGI;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(FPC) AND DEFINED(HORSE_FCGI)}<N>uses SysUtils, Classes, fpFCGI, httpdefs, fpHTTP, Horse.Provider.Abstract, Horse.Constants, Horse.Proc;<N><N>
unit Horse.Exception.Interrupted;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils;<N>{$ELSE}<N>  System.SysUtils;<N>{$ENDIF}<N><N>type<N>  EHorseCallbackInterrupted = class(Exception)<N>    constructor Create; reintroduce;<N>  end;<N><N>implementation<N><N>constructor EHorseCallbackInterrupted.Create;<N>begin<N>  inherited Create(EmptyStr);<N>end;<N><N>end.<N>
unit Horse.Core.Files;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, Generics.Collections;<N>{$ELSE}<N>  System.SysUtils, System.Classes, System.Generics.Collections;<N>{$ENDIF}<N><N>
unit Horse.Core.Param.Header;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, Generics.Collections, fpHTTP, fphttpserver, httpprotocol, HTTPDefs,<N>{$ELSE}<N>  System.Classes, System.SysUtils, System.Generics.Collections,<N>  Web.HTTPApp, IdCustomHTTPServer, IdHeaderList, Horse.Rtti,<N>{$ENDIF}<N>  Horse.Core.Param, Horse.Commons, Horse.Rtti.Helper;<N><N>
type<N>  THorseCoreParamHeader = class<N>  private<N>    class function GetHeadersList(const AWebRequest: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF}): TStrings;<N>  public<N>    class function GetHeaders(const AWebRequest: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF}): THorseList;<N>  end;<N><N>
unit Horse.Core.Route.Contract;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses Horse.Core.RouterTree, Horse.Callback;<N><N>type<N>  IHorseCoreRoute<T: class> = interface<N>    ['{8D593D98-44B3-4FD2-A21B-BA29F784B3AA}']<N>    function AddCallback(const ACallback: THorseCallback): IHorseCoreRoute<T>;<N>    function AddCallbacks(const ACallbacks: TArray<THorseCallback>): IHorseCoreRoute<T>;<N><N>
    function All(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const ACallbacks: array of THorseCallback; const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    function Get(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Get(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Get(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Get(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Put(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Put(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Put(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Put(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Head(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Head(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Head(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Head(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Post(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Post(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Post(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Post(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
unit Horse.Request;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, fpHTTP, HTTPDefs,<N>{$ELSE}<N>  System.SysUtils, System.Classes, Web.HTTPApp,<N>  {$IF CompilerVersion > 32.0}<N>    Web.ReqMulti,<N>  {$ENDIF}<N>{$ENDIF}<N>  Horse.Core.Param, Horse.Core.Param.Header, Horse.Commons, Horse.Session;<N><N>
unit Horse.Provider.ISAPI;<N><N>interface<N><N>{$IF DEFINED(HORSE_ISAPI) AND NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, System.SysUtils, Web.Win.ISAPIApp;<N><N>type<N>  THorseProvider<T: class> = class(THorseProviderAbstract<T>)<N>  private<N>    class procedure InternalListen; static;<N>  public<N>    class procedure Listen; overload; override;<N>    class procedure Listen(const ACallback: TProc<T>); reintroduce; overload; static;<N>  end;<N>{$ENDIF}<N><N>
implementation<N><N>{$IF DEFINED(HORSE_ISAPI) AND NOT DEFINED(FPC)}<N>uses Web.WebBroker, System.Win.ComObj, Winapi.ActiveX, Horse.WebModule;<N><N>exports<N>  GetExtensionVersion,<N>  HttpExtensionProc,<N>  TerminateExtension;<N><N>class procedure THorseProvider<T>.InternalListen;<N>begin<N>  CoInitFlags := COINIT_MULTITHREADED;<N>  Application.Initialize;<N>  Application.WebModuleClass := WebModuleClass;<N>  DoOnListen;<N>  Application.Run;<N>end;<N><N>
class procedure THorseProvider<T>.Listen;<N>begin<N>  inherited;<N>  InternalListen;<N>end;<N><N>class procedure THorseProvider<T>.Listen(const ACallback: TProc<T>);<N>begin<N>  inherited;<N>  SetOnListen(ACallback);<N>  InternalListen;<N>end;<N>{$ENDIF}<N><N>
unit Horse.Core.Group;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils,<N>{$ELSE}<N>  System.SysUtils,<N>{$ENDIF}<N>  Horse.Core.Group.Contract, Horse.Core.Route.Contract, Horse.Core.RouterTree, Horse.Callback;<N><N>
type<N>  THorseCoreGroup<T: class> = class(TInterfacedObject, IHorseCoreGroup<T>)<N>  private<N>    FHorseCore: TObject;<N>    FPrefix: string;<N>    function NormalizePath(const APath: string): string;<N>  public<N>    constructor Create;<N><N>    function Prefix(const APrefix: string): IHorseCoreGroup<T>;<N>    function Route(const APath: string): IHorseCoreRoute<T>;<N><N>
unit Horse.Provider.Daemon;<N><N>interface<N><N>{$IF DEFINED(HORSE_DAEMON) AND NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, Horse.Constants, Horse.Provider.IOHandleSSL, IdHTTPWebBrokerBridge, IdSSLOpenSSL, IdContext,<N>  System.SyncObjs, System.SysUtils, Posix.SysTypes;<N><N>
unit Horse.Constants;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>const<N>  DEFAULT_HOST = '0.0.0.0';<N>  DEFAULT_PORT = 9000;<N>  START_RUNNING = 'Server is runing on %s:%d';<N>  HORSE_VERSION = '3.0.2';<N><N>implementation<N><N>end.<N>
unit Horse.Commons;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$MODESWITCH TypeHelpers}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  Classes,<N>  SysUtils,<N>  StrUtils,<N>  RegExpr<N>{$ELSE}<N>    System.Classes,<N>  System.SysUtils,<N>  System.RegularExpressions<N>{$ENDIF}<N>    ;<N><N>
unit Horse.Core.RouterTree;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections, fpHTTP, httpprotocol,<N>{$ELSE}<N>  System.SysUtils, System.NetEncoding, Web.HTTPApp, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Request, Horse.Response, Horse.Proc, Horse.Commons, Horse.Callback;<N><N>
unit Horse.Rtti.Helper;<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  RTTI;<N>{$ELSE}<N>  System.Rtti;<N>{$ENDIF}<N><N>type<N>  THorseRttiTypeHelper = class helper for TRttiType<N>  public<N>    {$IF NOT DEFINED(FPC)}<N>    function FieldValueAsObject(const AInstance: Pointer; const AFieldName: string): TObject;<N>    {$ENDIF}<N>  end;<N><N>
implementation<N><N>{$IF NOT DEFINED(FPC)}<N>function THorseRttiTypeHelper.FieldValueAsObject(const AInstance: Pointer; const AFieldName: string): TObject;<N>var<N>  LField: TRttiField;<N>begin<N>  Result := nil;<N>  LField := GetField(AFieldName);<N>  if Assigned(LField) then<N>    Result := LField.GetValue(AInstance).AsObject;<N>end;<N>{$ENDIF}<N><N>
unit Horse.Response;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, fpHTTP, HTTPDefs,<N>{$ELSE}<N>  System.SysUtils, System.Classes, Web.HTTPApp,<N>  {$IF CompilerVersion > 32.0}<N>    Web.ReqMulti,<N>  {$ENDIF}<N>{$ENDIF}<N>  Horse.Commons, Horse.Core.Files;<N><N>
unit Horse.Provider.Console;<N><N>interface<N><N>{$IF NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, Horse.Constants, Horse.Provider.IOHandleSSL, IdHTTPWebBrokerBridge, IdSSLOpenSSL, IdContext,<N>  System.Classes, System.SyncObjs, System.SysUtils;<N><N>
unit Horse.Core.Param;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, DateUtils, Generics.Collections, fpHTTP, fphttpserver, HTTPDefs,<N>{$ELSE}<N>  System.SysUtils, System.Classes, System.DateUtils, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Exception, Horse.Commons, Horse.Core.Param.Field;<N><N>
unit Horse.Core;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections,<N>{$ELSE}<N>  System.SysUtils, System.Generics.Collections, Web.HTTPApp,<N>{$ENDIF}<N>  Horse.Core.RouterTree, Horse.Commons, Horse.Request, Horse.Response, Horse.Constants, Horse.Callback,<N>  Horse.Core.Group.Contract, Horse.Core.Route.Contract;<N><N>
unit Horse.Core.Route;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils,<N>{$ELSE}<N>  System.SysUtils,<N>{$ENDIF}<N>  Horse.Core.Route.Contract, Horse.Core.RouterTree, Horse.Callback;<N><N>
type<N>  THorseCoreRoute<T: class> = class(TInterfacedObject, IHorseCoreRoute<T>)<N>  private<N>    FPath: string;<N>    FHorseCore: TObject;<N>  public<N>    constructor Create(const APath: string);<N><N>    function This: IHorseCoreRoute<T>;<N>    function AddCallback(const ACallback: THorseCallback): IHorseCoreRoute<T>;<N>    function AddCallbacks(const ACallbacks: TArray<THorseCallback>): IHorseCoreRoute<T>;<N><N>
    function All(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const ACallbacks: array of THorseCallback; const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    function Get(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Get(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Get(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Get(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Put(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Put(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Put(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Put(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Head(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Head(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Head(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Head(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Post(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Post(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Post(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Post(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
unit uDM;<N><N>{$MODE DELPHI}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, ZConnection;<N><N>type<N><N>  { TDM }<N><N>  TDM = class(TDataModule)<N>    Conexao: TZConnection;<N>    procedure DataModuleCreate(Sender: TObject);<N>  private<N><N>  public<N><N>
  end;<N><N>var<N>  DM: TDM;<N><N>implementation<N><N>{$R *.lfm}<N><N>{ TDM }<N><N>procedure TDM.DataModuleCreate(Sender: TObject);<N>var<N>  local : String;<N>begin<N>  local := ExtractFilePath(Paramstr(0));<N>  {$ifdef horse_cgi}<N>     Conexao.LibraryLocation := local + 'libfbclient.so';<N>  {$else}<N>     Conexao.LibraryLocation := local + 'fbclient.dll';<N>  {$endif}<N>end;<N><N>
unit udmglobal;<N><N>{$MODE DELPHI}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, ZConnection, ZDataset;<N><N>type<N><N>  { TDMGlobal }<N><N>  TDMGlobal = class(TDataModule)<N>    Conexao: TZConnection;<N>    qry: TZQuery;<N>    procedure DataModuleCreate(Sender: TObject);<N>  private<N><N>
program programafac;<N>uses crt;<N>var<N> opcion:char;<N> respuesta:Integer;<N> cedula:string;<N> NOMBRE:String;<N> boletos: Integer;<N> tipos: integer;<N> preciot: real;<N> viaje: integer;<N> ticket: integer;<N> linea: integer;<N> subestacion: Char;<N> i: integer;<N> llegada, salida: integer;<N> salidat, llegadat : string;<N> pasaje: string;<N> comprar : integer;<N> monto: real;<N> cambio: real;<N> menu, usar: integer;<N> viajes, cedula2: string;<N> bolet: integer;<N><N>
<N>begin<N><N>  clrscr();<N>  textColor(04));<N>  writeln('//////////////////////////////////////////////');<N>  delay(2));<N>  Writeln()'     BIENVENIDOS AL METRO DE CARACAS   ');<N>  writeln();<N>  writeln('   -----------------------------------  ');<N><N>
  textColor(14));<N>  Writeln ('        RIF-40000000000     '));<N>  writeln ();<N>  writeln('/////////////////////////////////////'));<N>  writeln ('INDIQUE QUE DESEA HACER');<N>  writeln ('1 COMPRAR BOLETO');<N>  Writeln ('2  SALIR ');<N>  readln (respuesta);<N><N>
unit Aula;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls;<N><N>type<N>  TForm1 = class(TForm)<N>    Edit1: TEdit;<N>    Button1: TButton;<N>    RadioButton1: TRadioButton;<N>    RadioButton2: TRadioButton;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form1: TForm1;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit ClientVcl.LogForm;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls;<N><N>type<N>  TClientVclLogForm = class(TForm)<N>    mmLog: TMemo;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  ClientVclLogForm: TClientVclLogForm;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit NFCe.Service;<N><N>interface<N><N>uses<N>  System.Classes, System.SysUtils, System.Generics.Collections,<N><N>  XData.Server.Module,<N>  XData.Service.Common,<N>  XData.Sys.Exceptions,<N><N>  NFCe.Service.Interfaces,<N>  NFCe.DTO,<N>  NFCe.Emissor;<N><N>
unit NFCe.DTO;<N><N>interface<N><N>uses<N>  Generics.Collections,<N><N>  Bcl.Json.Attributes;<N><N>type<N>  TDestinatarioDTO = class;<N>  TDadosDetalheDTO = class;<N>  TDadosPagamentoDTO = class;<N>  TDetalhamentoPagamentoDTO = class;<N>  TGrupoCartaoDTO = class;<N>  TProtocoloNFCeDTO = class;<N>  TEventoNFeDTO = class;<N>  TDetEventoDTO = class;<N>  TRetornoEventoNFeDTO = class;<N>  TProtocoloEventoNFeDTO = class;<N><N>
  TRetornoStatusServicoDTO = class<N>  public<N>    cStat: integer;<N>    xMotivo: string;<N>    versao: string;<N>    tpAmb: string;<N>    verAplic: string;<N>    cUF: integer;<N>    dhRecbto: TDateTime;<N>    xObs: string;<N>  end;<N><N>  TRetornoEnvioNFCeDTO = class<N>  public<N>    cStat: integer;<N>    xMotivo: string;<N>    versao: string;<N>    tpAmb: string;<N>    verAplic: string;<N>    cUF: integer;<N>    protNFe: TProtocoloNFCeDTO;<N>  end;<N><N>
unit Common.Exceptions;<N><N>interface<N><N>uses<N>  SysUtils;<N><N>type<N>  ENuvemFiscalException = class(Exception);<N><N>implementation<N><N>end.<N>
unit Config.Service;<N><N>interface<N><N>uses<N>  XData.Server.Module,<N>  XData.Service.Common,<N>  XData.Sys.Exceptions,<N><N>  Config.Service.Interfaces,<N>  Config.DTO,<N><N>  Server.Config;<N><N>type<N>  [ServiceImplementation]<N>  TConfigService = class(TInterfacedObject, IConfigService)<N>  public<N>    function Emitente: TConfigEmitenteDTO;<N>    function Ambiente: TConfigAmbienteDTO;<N>  end;<N><N>
implementation<N><N>{ TConfigService }<N><N>function TConfigService.Ambiente: TConfigAmbienteDTO;<N>begin<N>  Result := TConfigAmbienteDTO.Create;<N>  try<N>    Result.Producao := ServerConfig.Producao;<N>  except<N>    Result.Free;<N>    raise;<N>  end;<N>end;<N><N>
unit Config.Service.Interfaces;<N><N>interface<N><N>uses<N>  System.Classes, System.SysUtils,<N><N>  XData.Service.Common,<N><N>  Config.DTO;<N><N>type<N>  [ServiceContract]<N>  [URIPath('config')]<N>  IConfigService = interface(IInvokable)<N>    ['{7FA1A880-E068-4A41-9C21-88E25FBCF0D4}']<N>    [HttpGet, URIPath('emitente')]<N>    function Emitente: TConfigEmitenteDTO;<N>    [HttpGet, URIPath('ambiente')]<N>    function Ambiente: TConfigAmbienteDTO;<N>  end;<N><N>implementation<N><N>initialization<N>  RegisterServiceType(TypeInfo(IConfigService));<N><N>end.<N>
﻿unit UnBurningUtility.Types;<N><N>interface<N><N>  Type<N>      TStatusBurn      = ( SbCopy,<N>                         SbMD5,<N>                         SbAbort,<N>                         SbBurning,<N>                         SbBurned,<N>                         SbError,<N>                         sbCheckFile );<N><N>      TpLivLog = (tplivException,<N>                  tpLivError,<N>                  tpLivWarning,<N>                  tpLivInfo);<N><N>implementation<N><N>end.<N>
Program FahrenHeitToCelcius(input,output);<N>{*The program is to input temperature in Fahrenheit and convert it to Degrees Centigrade written by Clinton Ogada v.1 2/20/2023*}<N>const fahrenheit = 32;<N>const y = 5/9;<N>var<N>x,celcius: Real;<N>begin<N>  writeln ('Enter the temperature in Fahrenheit');<N>   Readln (x);<N>   celcius:= (x - fahrenheit) * y;<N>   writeln('the temperature is', celcius :2:2);<N>  readln<N>end.<N>
Program Resistance(input,output);<N>{*The program is to calculate the total resistance of three resistors written by Clinton Ogada v.1 2/20/2023*}<N>var<N>R,x,r1,r2,r3: Real;<N>begin<N>  { Read in the values of the three resistors }<N>  writeln('Enter the values of the three resistors:');<N>  readln(r1, r2, r3);<N>   x:= 1/r1 + 1/r2 + 1/r3;<N>   R:= 1/x;<N>   writeln('The total resistance is:', R :0:2);<N>  readln<N>end.<N>
Program CalculateDistance(input,output);<N>{*This program to calculates the distance between two given points on the earth's surface*}<N>uses math;<N>const<N>  EarthRadius = 6371.0; // Earth's radius in km<N>var<N>  lat1, lon1, lat2, lon2, dLat, dLon, a, c, distance: real;<N><N>
function ToRadians(degrees: real): real;<N>begin<N>  ToRadians := degrees * PI / 180.0;<N>end;<N><N>begin<N>  // Input latitude and longitude of point 1<N>  write('Enter latitude of point 1 in degrees: ');<N>  readln(lat1);<N>  write('Enter longitude of point 1 in degrees: ');<N>  readln(lon1);<N><N>
  // Input latitude and longitude of point 2<N>  write('Enter latitude of point 2 in degrees: ');<N>  readln(lat2);<N>  write('Enter longitude of point 2 in degrees: ');<N>  readln(lon2);<N><N>  // Convert latitude and longitude to radians<N>  lat1 := ToRadians(lat1);<N>  lon1 := ToRadians(lon1);<N>  lat2 := ToRadians(lat2);<N>  lon2 := ToRadians(lon2);<N><N>
  // Calculate the differences in latitude and longitude<N>  dLat := lat2 - lat1;<N>  dLon := lon2 - lon1;<N><N>  // Calculate the Haversine formula<N>  a := power(sin(dLat/2), 2) + cos(lat1) * cos(lat2) * power(sin(dLon/2), 2);<N>  c := 2 * arctan2(sqrt(a), sqrt(1-a));<N>  distance := EarthRadius * c;<N><N>
Program ApproxPi(input,output);<N>{*This program has a function for generating pseudo-random numbers then obtain an approximation to p *}<N>{*Written by Clinton Ogada v1*}<N>uses crt;<N><N>var<N>  num_attempts, num_hits, i: integer;<N>  x, y: real;<N><N>begin<N>  randomize;<N>  clrscr;<N><N>
  writeln('Approximating pi using Monte Carlo simulation...');<N>  write('Enter number of attempts: ');<N>  readln(num_attempts);<N><N>  num_hits := 0;<N><N>  for i := 1 to num_attempts do<N>  begin<N>    x := random;<N>    y := random;<N><N>    if sqr(x - 0.5) + sqr(y - 0.5) <= 0.25 then<N>      num_hits := num_hits + 1;<N>  end;<N><N>
Program Simple_Interest(input,output);<N>{*The program is to calculate the amount of interest on a given sum over a given period of time written by Clinton Ogada v.1 2/20/2023*}<N>const r = 8/100;<N>var<N>I,P,T: Real;<N>begin<N>  writeln ('Enter the principal:');<N>   Readln (P);<N>    writeln ('Enter the time in years:');<N>   Readln (T);<N>    I:= P*R*T;<N>   writeln('The interest is:', I :0:2);<N>  readln<N>end.<N>
Program BankAccount(input,output);<N>{*This program is meant to process deposits and withdrawals for a bank account*}<N>var<N>  balance, amount: real;<N>  transaction: char;<N>begin<N>  // Input the initial balance<N>  write('Enter initial balance: ');<N>  readln(balance);<N><N>
Program Interest(input,output);<N>{*The program is to calculate the amount of interest on a given sum over a given period of time written by Clinton Ogada v.1 2/20/2023*}<N>const r = 8/100;<N>var<N>I,P,T: Real;<N>begin<N>  writeln ('Enter the principal:');<N>   Readln (P);<N>    writeln ('Enter the time in years:');<N>   Readln (T);<N>    I:= P*R*T;<N>   writeln('The interest is:', I :0:2);<N>  readln<N>end.<N>
Program DataCards(input,output);<N>{*This program inputs data cards and output a list of surnames, each followed by initials*}<N>var<N>  input: text;<N>  line, surname, initials, name: string;<N>  i: integer;<N>begin<N>  // Open the input file<N>  assign(input, 'data_cards.txt');<N>  reset(input);<N><N>
unit UnitSplash;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects,<N>  FMX.Layouts, FMX.Controls.Presentation, FMX.StdCtrls;<N><N>
type<N>  TfrmSplash = class(TForm)<N>    Arc1: TArc;<N>    Layout1: TLayout;<N>    Image1: TImage;<N>    Circle1: TCircle;<N>    Label1: TLabel;<N>    Timer1: TTimer;<N>    procedure Timer1Timer(Sender: TObject);<N>    procedure FormShow(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  frmSplash: TfrmSplash;<N><N>implementation<N><N>{$R *.fmx}<N><N>uses UnitLogin, UnitPrincipal, UnitInicial;<N><N>procedure TfrmSplash.FormShow(Sender: TObject);<N>begin<N>    Arc1.StartAngle := 300;<N>    Arc1.EndAngle   := 0;<N>    Timer1.Enabled := true;<N>end;<N><N>
procedure TfrmSplash.Timer1Timer(Sender: TObject);<N>begin<N>    Arc1.EndAngle := Arc1.EndAngle + 50;<N>    if Arc1.EndAngle >= 400 then begin<N>//         if NOT Assigned(FrmPrincipal) then<N>//                Application.CreateForm(TFrmPrincipal, FrmPrincipal);<N>//            FrmPrincipal.id_usuario_global := id_usuario;<N>//            Timer1.Enabled := false;<N>//            FrmPrincipal.Show;<N>//            Application.MainForm := FrmPrincipal;<N>//            frmSplash.Close;<N><N>
         if NOT Assigned(FrmPrincipal) then<N>                Application.CreateForm(TFrmInicial, FrmInicial);<N><N>            Timer1.Enabled := false;<N>            FrmInicial.Show;<N>            Application.MainForm := FrmInicial;<N>            frmSplash.Close;<N><N>
unit UnitLogin;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.TabControl,<N>  FMX.Objects, FMX.Layouts, FMX.Controls.Presentation, FMX.StdCtrls, FMX.Edit,<N>  FMX.ListBox<N>  ,System.Notification,<N>  DateUtils<N>  ;<N><N>
// This software is Copyright (c) 2014 Embarcadero Technologies, Inc.<N>// You may only use this software if you are an authorized licensee<N>// of one of Embarcadero's developer tools products.<N>// This software is considered a Redistributable as defined under<N>// the software license agreement that comes with the Embarcadero Products<N>// and is subject to that software license agreement.<N><N>
{*******************************************************<N> Esta Unit foi copiada de https://github.com/CarlosHe/AndroidPermission<N> para suprir a necessidade de utilizacao da API 26 do Google<N><N> Vide docupento de produto de Software RnFImp03 para mais informacoes<N><N>
*******************************************************}<N><N>unit FMX.Permissions.Android;<N><N>interface<N><N>{$IFDEF ANDROID}<N><N>uses<N>  System.Classes, System.generics.collections, System.Messaging, System.TypInfo, FMX.Dialogs, Androidapi.JNI.App, System.SysUtils, Androidapi.JNI.Embarcadero,<N>  Androidapi.JNI.JavaTypes, FMX.Platform.Android, Androidapi.JNI.GraphicsContentViewText, Androidapi.JNIBridge, Androidapi.Helpers;<N><N>
unit uPermissions;<N><N>interface<N><N>uses<N>    System.Classes<N>    ,System.SysUtils<N>    ,System.StrUtils<N><N>    ,System.Permissions // Delphi Rio ou superior<N>    ,System.Generics.Collections<N><N><N>  {$IFDEF ANDROID}<N>  ,Androidapi.Helpers<N>  ,Androidapi.JNI.Os<N>  ,Androidapi.JNI.JavaTypes<N>  {$ENDIF}<N><N>
  ;<N><N>type<N>    TMyPermissions = class<N>        private<N>            class function GetCamera: string; static;<N>            class function GetWifiState: string; static;<N>            class function GetReadExternalStorage: string; static;<N>            class function GetWriteExternalStorage: string; static;<N>            class function GetReadPhoneState: string; static;<N><N>
{*******************************************************}<N>{                                                       }<N>{           CodeGear Delphi Runtime Library             }<N>{ Copyright(c) 2013-2017 Embarcadero Technologies, Inc. }<N>{              All rights reserved                      }<N>{                                                       }<N>{*******************************************************}<N><N>
{*******************************************************<N> Esta Unit foi copiada de https://github.com/CarlosHe/AndroidPermission<N> para suprir a necessidade de utilizacao da API 26 do Google<N><N> Vide docupento de produto de Software RnFImp03 para mais informacoes<N><N>
*******************************************************}<N><N>unit Androidapi.Helpers;<N><N>interface<N><N>{$IFDEF ANDROID}<N><N>uses<N>  System.Messaging, System.SysUtils,<N>  Androidapi.JNIBridge, Androidapi.JNI.App, Androidapi.JNI.GraphicsContentViewText,<N>  Androidapi.JNI.JavaTypes, Androidapi.JNI.Net, Androidapi.JNI.Util;<N><N>
function JObjectToID(const AObject: JObject): Pointer; inline;<N><N>{ TBytes conversions }<N><N>/// <summary>Copy a TBytes into a new TJavaArray&ltByte&gt</summary><N>function TBytesToTJavaArray(const ABytes: TBytes): TJavaArray<Byte>; inline;<N>/// <summary>Copy a TJavaArray&ltByte&gt into a new TBytes</summary><N>function TJavaArrayToTBytes(const AJArray: TJavaArray<Byte>): TBytes; inline;<N><N>
{ Integer conversions }<N><N>function Int64ToJLong(const AValue: Int64): JLong;<N><N>{ String conversions }<N><N>/// <summary>Convert a JString into a string</summary><N>function JStringToString(const JStr: JString): string; inline;<N>/// <summary>Convert a string into a JString</summary><N>function StringToJString(const Str: string): JString; inline;<N><N>
/// <summary>Convert a string into a JCharSequence</summary><N>function StrToJCharSequence(const ASource: string): JCharSequence; inline;<N>/// <summary>Convert a JCharSequence into a string</summary><N>function JCharSequenceToStr(const ASource: JCharSequence): string; inline;<N><N>
unit uFrmMensagem;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects,<N>  FMX.Layouts, FMX.Controls.Presentation, FMX.StdCtrls, FMX.Effects, FMX.Ani;<N><N>
unit UnitSplash;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects,<N>  FMX.Layouts, FMX.Controls.Presentation, FMX.StdCtrls;<N><N>
type<N>  TfrmSplash = class(TForm)<N>    Timer1: TTimer;<N>    lytBase: TLayout;<N>    imgBackground: TImage;<N>    Arc1: TArc;<N>    Image1: TImage;<N>    procedure Timer1Timer(Sender: TObject);<N>    procedure FormShow(Sender: TObject);<N>    procedure FormClose(Sender: TObject; var Action: TCloseAction);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  frmSplash: TfrmSplash;<N><N>implementation<N><N>{$R *.fmx}<N><N>uses UnitLogin, UnitPrincipal;<N><N>procedure TfrmSplash.FormClose(Sender: TObject; var Action: TCloseAction);<N>begin<N>    Action := TCloseAction.caFree;<N>    frmSplash := nil;<N>end;<N><N>
procedure TfrmSplash.FormShow(Sender: TObject);<N>begin<N>    Arc1.StartAngle := 300;<N>    Arc1.EndAngle   := 0;<N>    Timer1.Enabled := true;<N>end;<N><N>procedure TfrmSplash.Timer1Timer(Sender: TObject);<N>begin<N>    Arc1.EndAngle := Arc1.EndAngle + 50;<N>    if Arc1.EndAngle >= 400 then begin<N>         if NOT Assigned(FrmLogin) then<N>                Application.CreateForm(TFrmLogin, FrmLogin);<N><N>
﻿unit Globais;<N><N>interface<N><N>var<N>    CurCodigo: Integer;<N>    V_USUARIO: String;<N>    V_SENHA: String;<N><N><N>const<N>    C_COR_PADRAO = $FF174672;<N><N>    C_COR_PRIMARY = $FFA1A390;<N>    C_COR_PRIMARY_LIGHT = $FFD2D4C0;<N>    C_COR_PRIMARY_DARK = $FF727463;<N><N>
unit uTela02;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs,<N>  System.Math.Vectors, FMX.Controls3D, FMX.Layers3D, FMX.Layouts,<N>  FMX.Controls.Presentation, FMX.StdCtrls, FMX.Objects, System.Actions,<N>  FMX.ActnList;<N><N>
unit uEscolhaTelas;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects,<N>  FMX.Controls.Presentation, FMX.StdCtrls, FMX.Layouts;<N><N>
unit Unit1;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs;<N><N>type<N>  TForm1 = class(TForm)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form1: TForm1;<N><N>implementation<N><N>{$R *.fmx}<N><N>end.<N>
unit uInicial;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects,<N>  FMX.Layouts, FMX.Controls.Presentation, FMX.StdCtrls;<N><N>
﻿unit uPedidos.Constantes;<N><N>interface<N><N>const<N>//  C_COR_PADRAO = $FF049A04;<N>//  C_COR_PADRAO = $FD7F6664;<N>    C_COR_PADRAO = $FFA1A390;<N><N>    C_COR_PRIMARY = $FFA1A390;<N>    C_COR_PRIMARY_LIGHT = $FFD2D4C0;<N>    C_COR_PRIMARY_DARK = $FF727463;<N><N>
{*******************************************************<N> Esta Unit foi copiada de https://github.com/CarlosHe/AndroidPermission<N> para suprir a necessidade de utilizacao da API 26 do Google<N><N> Vide docupento de produto de Software RnFImp03 para mais informacoes<N><N>
*******************************************************}<N><N>unit FMX.Permissions.Android;<N><N>interface<N><N>{$IFDEF ANDROID}<N><N>uses<N>  System.Classes, System.generics.collections, System.Messaging, System.TypInfo, FMX.Dialogs, Androidapi.JNI.App, System.SysUtils, Androidapi.JNI.Embarcadero,<N>  Androidapi.JNI.JavaTypes, FMX.Platform.Android, Androidapi.JNI.GraphicsContentViewText, Androidapi.JNIBridge, Androidapi.Helpers;<N><N>
﻿unit Globais;<N><N>interface<N><N>var<N>    StatusBarColor : Cardinal;<N>    StatusBarTransparent : Boolean;<N>    ModoDark : boolean;<N>    DesabilitaAudio : boolean;<N><N>    V_USERID: Integer;<N>    V_USUARIO: String;<N>    V_SENHA: String;<N>    V_STRTOKEN: String;<N>    V_CONECTADO : boolean;<N>    V_UltimaSincronia : TDateTime;<N>    V_ItemCadastrado : boolean;<N>    V_Estabelecimento : String;<N>    V_Cultura : String;<N><N>
    // DADOS DO APARELHO<N>    codename : String;<N>    strPlataforma : String;<N>    strModeloAparelho : String;<N>    strVersaoSO : String;<N>    strVersaoApp  : String;<N>    NomeApp : String;<N>    strDeviceToken : String; // tOKEN DO APARELHO<N><N><N>const<N>    C_COR_PADRAO        = $FFA1A390;<N>    C_COR_PADRAO_BOTAO  = $FF769C25;<N><N>
unit uPermissions;<N><N>interface<N><N>uses<N>    System.Classes<N>    ,System.SysUtils<N>    ,System.StrUtils<N><N>    ,System.Permissions // Delphi Rio ou superior<N>    ,System.Generics.Collections<N><N><N>  {$IFDEF ANDROID}<N>  ,Androidapi.Helpers<N>  ,Androidapi.JNI.Os<N>  ,Androidapi.JNI.JavaTypes<N>  {$ENDIF}<N><N>
  ;<N><N>type<N>    TMyPermissions = class<N>        private<N>            class function GetCamera: string; static;<N>            class function GetWifiState: string; static;<N>            class function GetReadExternalStorage: string; static;<N>            class function GetWriteExternalStorage: string; static;<N>            class function GetReadPhoneState: string; static;<N><N>
unit uSobre;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, jpeg, ExtCtrls, RXCtrls;<N><N>type<N>  TFrmSobre = class(TForm)<N>    RxLabel1: TRxLabel;<N>    Label1: TLabel;<N>    Panel1: TPanel;<N>    SP: TSecretPanel;<N>    Image1: TImage;<N>    procedure FormCreate(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit Rate.DAO;<N><N>interface<N><N>uses<N>  System.SysUtils,<N>  System.Classes,<N>  System.Generics.Collections,<N>  Uni,<N>  Data.Connection,<N>  Rate.Entity;<N><N>type<N>  TRateDao = class<N>    FDataStream: TDataStream;<N>  public<N>    constructor Create(ADataStream: TDataStream); overload;<N>    procedure Insert(ADog: TRateEntity);<N>    function GetByDogId(ADogId: Integer): TArray<TRateEntity>;<N>  end;<N><N>
implementation<N><N>constructor TRateDao.Create(ADataStream: TDataStream);<N>begin<N>  FDataStream := ADataStream;<N>end;<N><N>procedure TRateDao.Insert(ADog: TRateEntity);<N>var<N>  LSQLQuery: TUniQuery;<N>begin<N>  try<N>    LSQLQuery            := TUniQuery.Create(nil);<N>    LSQLQuery.Connection := FDataStream.con;<N><N>
    LSQLQuery.SQL.Add('INSERT INTO rate(rate, dog_id) ' + //<N>      'VALUES (:rate, :dog_id)');<N>    LSQLQuery.ParamByName('rate').AsInteger   := ADog.Rate;<N>    LSQLQuery.ParamByName('dog_id').AsInteger := ADog.DogId;<N><N>    LSQLQuery.Execute;<N>  finally<N>    LSQLQuery.Free;<N>  end;<N>end;<N><N>
unit Data.Connection;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, Data.DB, DBAccess, Uni, MemDS, UniProvider,<N>  MySQLUniProvider;<N><N>type<N>  TDataStream = class(TDataModule)<N>    con: TUniConnection;<N>    query: TUniQuery;<N>    sql: TUniSQL;<N>    dataSource: TUniDataSource;<N>    mysqlnprvdr: TMySQLUniProvider;<N>  end;<N><N>var<N>  DataStream: TDataStream;<N><N>implementation<N><N>{%CLASSGROUP 'Vcl.Controls.TControl'}<N><N>{$R *.dfm}<N><N>end.<N>
﻿unit Dog.Controller;<N><N>interface<N><N>uses<N>  MVCFramework,<N>  MVCFramework.Commons,<N>  MVCFramework.Serializer.Commons;<N><N>type<N><N>  [MVCPath('/api')]<N>  TDogs = class(TMVCController)<N><N>  public<N>    [MVCPath]<N>    [MVCHTTPMethod([httpGET])]<N>    procedure Index;<N><N>
  public<N>    [MVCPath('/dogs')]<N>    [MVCHTTPMethod([httpGET])]<N>    procedure GetDogs;<N><N>    [MVCPath('/dogs/($id)')]<N>    [MVCHTTPMethod([httpGET])]<N>    procedure getDog(id: String);<N><N>    [MVCPath('/dogs/rate/($id)')]<N>    [MVCHTTPMethod([httpPOST])]<N>    procedure RateDog(id: String);<N><N>
  end;<N><N>implementation<N><N>uses<N>  System.SysUtils,<N>  MVCFramework.Logger,<N>  System.StrUtils,<N>  MVCFramework.RESTClient,<N>  MVCFramework.RESTClient.Intf,<N>  System.JSON,<N>  REST.JSON,<N>  Data.Connection,<N>  Dog.DAO,<N>  Dog.Entity;<N><N>procedure TDogs.Index;<N>begin<N>  render(200, '{"message":"Dog Rating API. =)"}')<N>end;<N><N>
// Sample CRUD Actions for a "Customer" entity<N>procedure TDogs.GetDogs;<N>var<N>  LAPIClient     : IMVCRESTClient;<N>  LAPIResponse   : TJSONObject;<N>  LDogDAO        : TDogDAO;<N>  LDogEntity     : TDogEntity;<N>  LJsonResponse  : TJSONArray;<N>  LDataConnection: TDataStream;<N>  ArrayElement   : TJSonValue;<N>  LAPISource     : IMVCRESTResponse;<N>  LDogSerialized : TJSONObject;<N><N>
begin<N>  LAPIClient      := nil;<N>  LJsonResponse   := nil;<N>  LDataConnection := nil;<N>  LDogDAO         := nil;<N>  LAPIResponse    := nil;<N>  LAPISource      := nil;<N>  LDogEntity      := nil;<N>  ArrayElement    := nil;<N><N>  try<N>    LDataConnection := TDataStream.Create(nil);<N>    LDogEntity      := TDogEntity.Create;<N>    LDogDAO         := TDogDAO.Create(LDataConnection);<N><N>
unit Main.WebModule;<N><N>interface<N><N>uses<N>  System.SysUtils,<N>  System.Classes,<N>  Web.HTTPApp,<N>  MVCFramework;<N><N>type<N>  TDogRating = class(TWebModule)<N>    procedure WebModuleCreate(Sender: TObject);<N>    procedure WebModuleDestroy(Sender: TObject);<N>  private<N>    FMVC: TMVCEngine;<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  WebModuleClass: TComponentClass = TDogRating;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  System.IOUtils,<N>  MVCFramework.Commons,<N>  MVCFramework.Middleware.ActiveRecord,<N>  MVCFramework.Middleware.StaticFiles,<N>  MVCFramework.Middleware.Analytics,<N>  MVCFramework.Middleware.Trace,<N>  MVCFramework.Middleware.CORS,<N>  MVCFramework.Middleware.ETag,<N>  MVCFramework.Middleware.Compression,<N>  Dog.Controller;<N><N>
unit Rate.entity;<N><N>interface<N>uses<N>  MVCFramework.Serializer.Commons;<N>type TRateEntity = class<N>  private<N>    FIdRate: Integer;<N>    FRate: Integer;<N>    FDogId: Integer;<N><N>  public<N>    [MVCDoNotSerialize]<N>    property IdRate: Integer read FIdRate write FIdRate;<N>    property Rate: Integer read FRate write FRate;<N>    property DogId: Integer read FDogId write FDogId;<N>end;<N><N>implementation<N><N>end.<N>
program PASAPI;<N><N>{$IFNDEF PASAPI}<N>const PASAPI = 0;<N>{$ENDIF}<N>const PASAPIVERSION = 1;<N>const PASAPINAMESPACE = 'pasapi';<N><N>{$PACKRECORDS 1}<N><N>{$IFDEF PASAPI_EXPORT}<N>exports GetBase, GetAPIVersion;<N>{$ENDIF}<N><N>function GetBase: Longword;<N>begin<N>  Result := GetBase();<N>end;<N><N>
function GetAPIVersion: Longword;<N>begin<N>  Result := GetAPIVersion();<N>end;<N><N>function GetAddress(Offset: Longint): Longword;<N>begin<N>  Result := GetBase() + Offset;<N>end;<N><N>type<N>  GTAREF = Integer;<N>  ID = Word;<N>  NUMBER = Byte;<N>  CMDPROC = procedure(const Str: String);<N><N>
var<N>  D3DCOLOR: Longword;<N>  TICK: Longword;<N>  BOOL: Integer;<N>  ID3DXFont: Pointer;<N>  ID3DXSprite: Pointer;<N>  ID3DXRenderToSurface: Pointer;<N>  IDirect3DSurface9: Pointer;<N>  IDirect3DTexture9: Pointer;<N>  IDirect3DDevice9: Pointer;<N>  IDirect3DStateBlock9: Pointer;<N>  CDXUTDialog: Pointer;<N>  CDXUTListBox: Pointer;<N>  CDXUTEditBox: Pointer;<N>  CDXUTScrollBar: Pointer;<N>  CDXUTIMEEditBox: Pointer;<N><N>
{$APPTYPE CONSOLE}<N>uses pasapi;<N>uses Windows;<N><N>function GetBase: Cardinal;<N>begin<N>  Result := Cardinal(GetModuleHandleA('samp.dll'));<N>end;<N><N>function GetAPIVersion: Cardinal;<N>begin<N>  Result := PASAPI_VERSION;<N>end;<N><N>begin<N>end.<N>
program PASAPI;<N><N>{$IFNDEF PASAPI}<N>const PASAPI = 0;<N>{$ENDIF}<N>const PASAPIVERSION = 1;<N>const PASAPINAMESPACE = 'pasapi';<N><N>{$PACKRECORDS 1}<N><N>{$IFDEF PASAPI_EXPORT}<N>exports GetBase, GetAPIVersion;<N>{$ENDIF}<N><N>function GetBase: Longword;<N>begin<N>  Result := GetBase();<N>end;<N><N>
function GetAPIVersion: Longword;<N>begin<N>  Result := GetAPIVersion();<N>end;<N><N>function GetAddress(Offset: Longint): Longword;<N>begin<N>  Result := GetBase() + Offset;<N>end;<N><N>type<N>  GTAREF = Integer;<N>  ID = Word;<N>  NUMBER = Byte;<N>  CMDPROC = procedure(const Str: String);<N><N>
var<N>  D3DCOLOR: Longword;<N>  TICK: Longword;<N>  BOOL: Integer;<N>  ID3DXFont: Pointer;<N>  ID3DXSprite: Pointer;<N>  ID3DXRenderToSurface: Pointer;<N>  IDirect3DSurface9: Pointer;<N>  IDirect3DTexture9: Pointer;<N>  IDirect3DDevice9: Pointer;<N>  IDirect3DStateBlock9: Pointer;<N>  CDXUTDialog: Pointer;<N>  CDXUTListBox: Pointer;<N>  CDXUTEditBox: Pointer;<N>  CDXUTScrollBar: Pointer;<N>  CDXUTIMEEditBox: Pointer;<N><N>
<N>{$CVector}<N><N>unit pasapi;<N><N>interface<N><N>uses<N>  PasAPI.Common;<N><N>type<N>  VectorCompressed = record<N>    x, y, z: Word;<N>  end;<N><N>  TCVector = class<N>  public<N>    x, y, z: Single;<N><N>    constructor Create; overload;<N>    constructor Create(A_X, A_Y, A_Z: Single); overload;<N><N>
    procedure Set(A_X, A_Y, A_Z: Single);<N>    function GetLength: Single;<N>    function GetLengthSquared: Single;<N>    procedure Normalize;<N>    function Dot(const A_Vec: TCVector): Single;<N>    function Cross(const A_Vec: TCVector): TCVector;<N>    procedure ZeroNearZero;<N>  end;<N><N>
implementation<N><N>{ TCVector }<N><N>constructor TCVector.Create;<N>begin<N>  x := 0;<N>  y := 0;<N>  z := 0;<N>end;<N><N>constructor TCVector.Create(A_X, A_Y, A_Z: Single);<N>begin<N>  x := A_X;<N>  y := A_Y;<N>  z := A_Z;<N>end;<N><N>procedure TCVector.Set(A_X, A_Y, A_Z: Single);<N>begin<N>  x := A_X;<N>  y := A_Y;<N>  z := A_Z;<N>end;<N><N>
function TCVector.GetLength: Single;<N>begin<N>  Result := Sqrt(x * x + y * y + z * z);<N>end;<N><N>function TCVector.GetLengthSquared: Single;<N>begin<N>  Result := x * x + y * y + z * z;<N>end;<N><N>procedure TCVector.Normalize;<N>var<N>  Len: Single;<N>begin<N>  Len := GetLength;<N>  if Len > 0 then<N>  begin<N>    x := x / Len;<N>    y := y / Len;<N>    z := z / Len;<N>  end;<N>end;<N><N>
function TCVector.Dot(const A_Vec: TCVector): Single;<N>begin<N>  Result := x * A_Vec.x + y * A_Vec.y + z * A_Vec.z;<N>end;<N><N>function TCVector.Cross(const A_Vec: TCVector): TCVector;<N>begin<N>  Result := TCVector.Create(<N>    y * A_Vec.z - z * A_Vec.y,<N>    z * A_Vec.x - x * A_Vec.z,<N>    x * A_Vec.y - y * A_Vec.x<N>  );<N>end;<N><N>
function RefLocalPlayerCameraExtZoom: float;<N>begin<N>  Result := PFloat(GetAddress(0x143D20))^;<N>end;<N><N>function RefLocalPlayerAspectRatio: float;<N>begin<N>  Result := PFloat(GetAddress(0x1468D8))^;<N>end;<N><N>function RefInternalCameraExtZoom: PFloat;<N>begin<N>  Result := PPointer(GetAddress(0x1039BC))^;<N>end;<N><N>
function RefInternalAspectRatio: PFloat;<N>begin<N>  Result := PPointer(GetAddress(0x1039B8))^;<N>end;<N><N>function ArrayCameraExtZoom: PFloat;<N>begin<N>  Result := PFloat(GetAddress(0x143E00));<N>end;<N><N>function ArrayAspectRatio: PFloat;<N>begin<N>  Result := PFloat(GetAddress(0x146908));<N>end;<N><N>
function ArrayCameraMode: PChar;<N>begin<N>  Result := PChar(GetAddress(0x143D28));<N>end;<N><N>function RefInternalCameraMode: PChar;<N>begin<N>  Result := PPointer(GetAddress(0x11395C))^;<N>end;<N><N>function RefLocalPlayerAim: AimStuff.Aim;<N>begin<N>  Result := PAimStuff.Aim(GetAddress(0x144148))^;<N>end;<N><N>
function ArrayPlayerAim: PAimStuff.Aim;<N>begin<N>  Result := PAimStuff.Aim(GetAddress(0x144178));<N>end;<N><N>var AimStuff.Aim*& AimStuff.RefInternalAim: Pointer;<N>Begin<N>  AimStuff.RefInternalAim := GetAddress(0x1039B0);<N>End;<N><N>Procedure AimStuff.UpdateCameraExtZoomAndAspectRatio;<N>Begin<N>  GetAddress(0x9C0B0);<N>End;<N><N>
Procedure AimStuff.ApplyCameraExtZoomAndAspectRatio;<N>Begin<N>  GetAddress(0x9C0D0);<N>End;<N><N>Procedure AimStuff.SetCameraExtZoomAndAspectRatio(nPlayer: NUMBER; fCameraExtZoom: Float; fAspectRatio: Float);<N>Begin<N>  GetAddress(0x9C0F0)(nPlayer, fCameraExtZoom, fAspectRatio);<N>End;<N><N>
Function AimStuff.GetAspectRatio: Float;<N>Begin<N>  Result := GetAddress(0x9C110);<N>End;<N><N>Function AimStuff.GetCameraExtZoom: Float;<N>Begin<N>  Result := GetAddress(0x9C120);<N>End;<N><N>Procedure AimStuff.ApplyCameraExtZoomAndAspectRatio(nPlayer: NUMBER);<N>Begin<N>  GetAddress(0x9C140)(nPlayer);<N>End;<N><N>
Procedure AimStuff.SetCameraMode(nMode: Char; nPlayer: NUMBER);<N>Begin<N>  GetAddress(0x9C180)(nMode, nPlayer);<N>End;<N><N>Function AimStuff.GetCameraMode(nPlayer: NUMBER): Char;<N>Begin<N>  Result := GetAddress(0x9C1A0)(nPlayer);<N>End;<N><N>Function AimStuff.GetCameraMode: Char;<N>Begin<N>  Result := GetAddress(0x9C1B0);<N>End;<N><N>
Procedure AimStuff.Initialize;<N>Begin<N>  GetAddress(0x9C1C0);<N>End;<N><N>Procedure AimStuff.UpdateAim;<N>Begin<N>  GetAddress(0x9C230);<N>End;<N><N>Procedure AimStuff.ApplyAim;<N>Begin<N>  GetAddress(0x9C250);<N>End;<N><N>Function AimStuff.GetAim: AimStuff.Aim*;<N>Begin<N>  Result := GetAddress(0x9C270);<N>End;<N><N>
Procedure AimStuff.SetAim(nPlayer: Integer; pAim: ^AimStuff.Aim);<N>Begin<N>  GetAddress(0x9C280)(nPlayer, pAim);<N>End;<N><N>Procedure AimStuff.ApplyAim(nPlayer: Integer);<N>Begin<N>  GetAddress(0x9C2B0)(nPlayer);<N>End;<N><N>Function AimStuff.GetAim(nPlayer: Integer): AimStuff.Aim*;<N>Begin<N>  Result := GetAddress(0x9C2E0)(nPlayer);<N>End;<N><N><N>
{Copyright (c) 2023 Stephan Breer<N><N>This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.<N><N>Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:<N><N>
    1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.<N><N>    2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.<N><N>
    3. This notice may not be removed or altered from any source distribution.<N>}<N><N>unit DisplayConst;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N>        <N>const<N>  HMARGIN = 16;<N>  VMARGIN = 16;<N>  PORTRAITWIDTH = 250;<N>  PORTRAITHEIGHT = 250;<N>  INITIATIVEWIDTH = 200;<N>  INITIATIVEHEIGHT = 200;<N>  FRAMESIZE = 7;<N><N>
  SQRT2 = 1.4142135623;<N>  SQRT05 = 0.7071067811;<N><N>  PICFILEFILTER = '*.jpg;*.jpeg;*.png;*.bmp;*.webp';<N><N>  SAVESECTIONMAP = 'Map';<N>  SAVESECTIONGRID = 'Grid';<N>  SAVESECTIONPORTRAIT = 'Portrait';<N>  SAVESECTIONINITIATIVE = 'Initiative';<N>  SAVESECTIONTOKENS = 'Tokens';<N><N>
{Copyright (c) 2023 Stephan Breer<N><N>This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.<N><N>Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:<N><N>
    1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.<N><N>    2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.<N><N>
    3. This notice may not be removed or altered from any source distribution.<N>}<N><N>unit LibraryForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, XMLConf, Forms, Controls, Graphics, Dialogs, ExtCtrls,<N>  Grids, ComCtrls, StdCtrls, Types;<N><N>
{Copyright (c) 2023 Stephan Breer<N><N>This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.<N><N>Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:<N><N>
    1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.<N><N>    2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.<N><N>
    3. This notice may not be removed or altered from any source distribution.<N>}<N><N>unit RPGTypes;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRABitmap;<N>  <N> const<N>  MAXTOKENANIMSTEPS = 20;<N><N>function Map(Val, InValStart, InValEnd, OutValStart, OutValEnd: Double): Double;<N><N>
{Copyright (c) 2023 Stephan Breer<N><N>This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.<N><N>Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:<N><N>
    1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.<N><N>    2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.<N><N>
    3. This notice may not be removed or altered from any source distribution.<N>}<N><N>unit InitiativeForm;<N><N>{$mode ObjFPC}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, ComCtrls,<N>  Buttons;<N><N>
{Copyright (c) 2023 Stephan Breer<N><N>This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.<N><N>Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:<N><N>
    1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.<N><N>    2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.<N><N>
    3. This notice may not be removed or altered from any source distribution.<N>}<N><N>unit DisplayForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  {$IFDEF DEBUG}Windows,{$ENDIF}<N>  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, ExtCtrls,<N>  BGRABitmapTypes, BGRABitmap, RPGTypes;<N><N>
{Copyright (c) 2023 Stephan Breer<N><N>This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.<N><N>Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:<N><N>
    1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.<N><N>    2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.<N><N>
    3. This notice may not be removed or altered from any source distribution.<N>}<N><N>unit SettingsForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, Buttons;<N><N>type<N><N>  { TfmSettings }<N><N>
{Copyright (c) 2023 Stephan Breer<N><N>This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.<N><N>Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:<N><N>
    1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.<N><N>    2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.<N><N>
    3. This notice may not be removed or altered from any source distribution.<N>}<N><N>unit LangStrings;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>function GetString(Lang, StrID: string): string;<N>function GetLanguages: TStrings;<N><N>
var<N>  LanguageID: string;<N><N>implementation<N><N>uses<N>  IniFiles;<N><N>var<N>  FLangFile: TIniFile;<N><N>function GetString(Lang, StrID: string): string;<N>begin<N>  Result := StrID;<N>  if Assigned(FLangFile) then<N>    Result := FLangFile.ReadString(Lang, StrID, StrID);<N>end;<N><N>
function GetLanguages: TStrings;<N>begin<N>  Result := TStringList.Create;<N>  FLangFile.ReadSections(Result);<N>end;<N><N>initialization<N>  LanguageID := 'English';<N>  FLangFile := TIniFile.Create('LangStrings.ini');<N><N>finalization<N>  FLangFile.Free;<N><N>
{Copyright (c) 2023 Stephan Breer<N><N>This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.<N><N>Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:<N><N>
    1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.<N><N>    2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.<N><N>
    3. This notice may not be removed or altered from any source distribution.<N>}<N><N>unit TokenSettingsForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, ComCtrls,<N>  Spin, RPGTypes;<N><N>
{Copyright (c) 2023 Stephan Breer<N><N>This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.<N><N>Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:<N><N>
    1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.<N><N>    2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.<N><N>
    3. This notice may not be removed or altered from any source distribution.<N>}<N><N>unit GridSettingsForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, ComCtrls,<N>  ExtCtrls, SpinEx;<N><N>
{Copyright (c) 2023 Stephan Breer<N><N>This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.<N><N>Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:<N><N>
    1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.<N><N>    2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.<N><N>
    3. This notice may not be removed or altered from any source distribution.<N>}<N><N>unit ControllerForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, ComCtrls,<N>  ExtCtrls, Menus, IniFiles, BGRABitmap, RPGTypes;<N><N>
program bai2;<N>uses crt;<N>var t:string;<N>Begin<N>     clrscr;<N>     writeln('Nhap vao xau t'); readln(t);<N>     writeln(t[1]=' ') do delete(t,1,1);<N>     while (t[length(t)]=' ') do delete(t,length(t),1);<N>     while (pos(' ',t) > 0) do delete(t,pos(' ',t),1);<N>     writeln('Xau sau khi chuan hoa: ',t);<N>     readln();<N>end.<N>     <N>
unit TDocumentEngine;<N><N>{$mode ObjFPC}{$H+}<N><N>interface<N><N>uses<N>  Classes, Forms, Controls, Graphics, Dialogs, Menus, StdCtrls, ExtCtrls, SysUtils;<N><N>type<N><N> //-------------------------          TYPE and MARKER ENUMS ----------------------//<N><N>
unit Unit1;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, ExtCtrls, ComCtrls,<N>  Menus, StdCtrls, BCLabel, BCPanel, RichMemo, kmemo, TAdvancedMenu, Themes,<N>  TDocumentEngine, TRenderEngine, TAdvancedDropDown, math,<N>  ColorBox, ActnList, LCLProc, Spin, EditBtn, BCTypes, BCListBox, BCComboBox, Types;<N><N>
unit TRenderEngine;<N><N>{$mode ObjFPC}{$H+}<N><N>interface<N><N>uses<N>  Classes, Forms, Controls, Graphics, Dialogs, Menus, StdCtrls, ExtCtrls, dataTypes,BCLabel, bgraControls,BCTypes, BCPanel, SysUtils;<N><N>type<N><N>  { RendeEngine }<N><N>  { RenderEngine }<N><N>
  RenderEngine = Class<N>    public<N>     margins       : Array of Integer;<N><N>     constructor Create();<N>     procedure RenderMargin(Sender : TObject);<N><N>  end;<N><N><N><N><N>implementation<N><N>{ RenderEngine }<N><N>constructor RenderEngine.Create;<N>begin<N><N>
end;<N><N>procedure RenderEngine.RenderMargin(Sender: TObject);<N>var<N>  targetPanel : TBCPanel;<N>  x1          : Integer;<N>  y1          : Integer;<N>  x2          : Integer;<N>  y2          : Integer;<N>begin<N>  targetPanel := (Sender as TBCPanel);<N>  targetPanel.Canvas.Pen.Color := clGrayText;<N><N>
  // TOP<N><N>  x1          := margins[1];<N>  x2          := targetPanel.Width- margins[3];<N>  y1          := margins[0];<N>  y2          := margins[0];<N><N>  targetPanel.Canvas.Line(x1,y1,x2,y2);<N><N><N>  // Left<N><N>  x1          := margins[1];<N>  x2          := margins[1];<N>  y1          := margins[0];<N>  y2          := targetPanel.Height - margins[2];<N><N>
  targetPanel.Canvas.Line(x1,y1,x2,y2);<N><N>  // Bottom<N><N>  x1          := margins[1];<N>  x2          := targetPanel.Width- margins[3];<N>  y1          := targetPanel.Height - margins[2];<N>  y2          := targetPanel.Height - margins[2];<N><N>  targetPanel.Canvas.Line(x1,y1,x2,y2);<N><N>
  // right<N><N>  x1          := targetPanel.Width- margins[3];<N>  x2          := targetPanel.Width- margins[3];<N>  y1          := targetPanel.Height - margins[2];<N>  y2          := margins[0];<N><N>  targetPanel.Canvas.Line(x1,y1,x2,y2);<N><N>end;<N><N>
unit TAdvancedDropDown;<N><N>{$mode ObjFPC}{$H+}{$modeswitch advancedrecords}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, Menus, StdCtrls, ExtCtrls,BCLabel, bgraControls,BCTypes, math, BCPanel;<N><N>type<N><N>  TProc          = procedure(AParm: TObject) of object;<N>  TStringArray = Array of String;<N><N>
  { TAdvancedDropDownList }<N><N>  TAdvancedDropDownList = Class<N><N>    public<N>      currPos   : Integer;<N>      items     : TStringArray;<N><N>      renderContainer : TBCPanel;<N>      dropDown        : TBCPanel;<N>      itemView        : TListBox ;<N><N>
      containerHeight : Integer;<N>      containerWidth  : Integer;<N>      containerColor  : TColor;<N>      containerBorderColor : TColor;<N>      containerFontColors : Array of TColor;<N>      containerBorderWidth : Integer;<N>      containerFontNames   : Array of String;<N>      containerFontSizes   : Array of Integer;<N>      containerFontStyles   : Array of Integer;<N>      containerFontBackGrounds : Array of TColor;<N><N>
      cpanels       : Array of TBCPanel;<N>      sBarH         : TScrollbar;<N>      sBarV         : TScrollBar;<N><N>      selectedItem : Integer;<N><N>      dropDownOn   : Boolean;<N>      dropDownWidth: Integer;<N>      dropDownHeight:Integer;<N>      setFullWidth : Boolean;<N><N>
      totalWidth   : Integer;<N><N>      bottom_ofAll  : Integer;<N>      top_ofAll     : Integer;<N>      bottomPadding : Integer;<N><N>      debugLabel    : TBCLabel;<N>      allowOverFlow : Boolean;<N>      overFlowCounter: Integer;<N><N>      constructor Create();<N><N>
      procedure Initialize(entryItems: TStringArray);<N>      procedure Render(pPanel : TBCPanel);<N>      procedure toggleDropDown(Sender : TObject) ;<N>      procedure selectItem(Sender: TObject; User: boolean);<N><N><N><N>  end;<N><N>implementation<N><N>
{ TAdvancedDropDownList }<N><N>constructor TAdvancedDropDownList.Create;<N><N>begin<N><N><N><N><N>  // containerHeight := Floor(0.5 * Length(items)) * 1;<N><N><N>end;<N><N>procedure TAdvancedDropDownList.Initialize(entryItems: TStringArray);<N>var<N><N>  i             : Integer;<N>  totalHeight   : Integer;<N>  maxWidth      : Integer;<N>  fnt           : TFont;<N>  currWidth     : Integer;<N><N>
  c             : TBitmap;<N>begin<N><N>  renderContainer := TBCPanel.Create(Nil);<N>  renderContainer.Parent := Nil;<N><N>  itemView := TListBox.Create(Nil);<N>  itemView.Parent := Nil;<N><N>  setLength(items, 0);<N>  items         := entryitems;<N><N>  selectedItem := 0;<N><N>
  containerColor  := clForm;<N>  containerBorderColor := clGrayText;<N><N>  SetLength( containerFontColors, 0);<N>  for i := 0 to Length(items) - 1 do<N>  begin<N>    SetLength( containerFontColors, Length(containerFontColors) + 1);<N>    containerFontColors[Length(containerFontColors) - 1] := clWindowText;<N>  end;<N><N>
<N>  containerBorderColor := clGrayText;<N>  containerBorderWidth := 1;<N><N><N>  SetLength( containerFontNames, 0);<N>  for i := 0 to Length(items) - 1 do<N>  begin<N>    SetLength( containerFontNames, Length(containerFontNames) + 1);<N>    containerFontNames[Length(containerFontNames) - 1] := Screen.SystemFont.Name;<N>  end;<N><N>
<N><N>  SetLength( containerFontSizes, 0);<N>  for i := 0 to Length(items) - 1 do<N>  begin<N>    SetLength( containerFontSizes, Length(containerFontSizes) + 1);<N>    containerFontSizes[Length(containerFontSizes) - 1] := 0;<N>  end;<N><N><N>  SetLength( containerFontStyles, 0);<N>  for i := 0 to Length(items) - 1 do<N>  begin<N>    SetLength( containerFontStyles, Length(containerFontStyles) + 1);<N>    containerFontStyles[Length(containerFontStyles) - 1] := 0;<N>  end;<N><N>
<N>  SetLength( containerFontBackGrounds, 0);<N>  for i := 0 to Length(items) - 1 do<N>  begin<N>    SetLength( containerFontBackGrounds, Length(containerFontBackGrounds) + 1);<N>    containerFontBackGrounds[Length(containerFontBackGrounds) - 1] := clForm;<N>  end;<N><N>
  dropDownOn    := False;<N><N>  dropDownWidth := -1;<N>  dropDownHeight:= -1;<N><N>  setFullWidth  := False;<N><N>  maxWidth    := 0;<N><N><N><N><N><N>  totalHeight := 0;<N><N>  for i := 0 to Length(items) - 1 do<N>  begin<N><N>   fnt       := TFont.Create;<N>   fnt.Name  := containerFontNames[i];<N><N>
   c := TBitmap.Create;<N>   c.Canvas.Font.Assign(fnt);<N>   currWidth  := c.Canvas.TextWidth(items[i]) + 4; //-----------------------// Label width<N><N>   c.Free;<N><N>   itemView.Items.Add(items[i]);<N><N>   if maxWidth < currWidth then<N>   begin<N>    maxWidth := currWidth;<N>   end;<N><N>
   totalHeight:= totalHeight + fnt.GetTextHeight('AyTg') + 4 + 2;<N><N>  end;<N><N>  itemView.Height:=totalHeight+2;<N>  itemView.Width:= maxWidth+4;<N><N>  itemView.ScrollWidth := 10;<N><N>  totalWidth    := maxWidth + 5;<N><N><N>  if (dropDownWidth <> -1) then<N>  begin<N>  itemView.Width:=dropDownWidth;<N>  end;<N><N>
  if (dropDownHeight <> -1) then<N>  begin<N>  itemView.Height:=dropDownHeight;<N>  end;<N><N>  if not setFullWidth then<N>  begin<N>    itemView.Height := Floor(itemView.Height div 2)  ;<N>  end;<N><N><N><N>  itemView.OnSelectionChange:=@selectItem;<N><N>
  allowOverFlow := False;<N>  overFlowCounter:= 1;<N>  {TODO : Implement bevel controls}<N>end;<N><N><N><N>procedure TAdvancedDropDownList.Render(pPanel: TBCPanel);<N>var<N>  mPanel          : TBCPanel;<N>begin<N><N><N>  //---------------   Attach the top Panel to the container    -------------------//<N><N>
  // mPanel        := TBCPanel.Create(Nil);<N>  renderContainer.Parent := pPanel;<N><N><N><N>  renderContainer.Caption:= items[selectedItem];<N><N>  renderContainer.FontEx.Color:= containerFontColors[selectedItem] ;<N><N>  renderContainer.Height := pPanel.Height;<N>  renderContainer.Width  := pPanel.Width ;<N><N>
  renderContainer.BevelOuter:=bvNone;<N><N>  renderContainer.Color:= containerColor;<N><N>  renderContainer.Border.Color:= containerBorderColor;<N>  renderContainer.Border.Width:= containerBorderWidth;<N><N>  renderContainer.Border.Style:=bboSolid;<N>  renderContainer.BorderBCStyle:= bpsBorder;<N><N>
unit Unit1;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Forms, Controls, Graphics, Dialogs,<N>  Menus, StdCtrls, ExtCtrls,BCLabel, bgraControls,BCTypes,<N>  TAdvancedDropDown,<N>  BCPanel, Types;<N><N>type<N><N>  { TForm1 }<N><N>
unit TAdvancedDropDown;<N><N>{$mode ObjFPC}{$H+}{$modeswitch advancedrecords}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, Menus, StdCtrls, ExtCtrls,BCLabel, bgraControls,BCTypes, math, BCPanel;<N><N>type<N><N>  TProc          = procedure(AParm: TObject) of object;<N>  TStringArray = Array of String;<N><N>
  { TAdvancedDropDownList }<N><N>  TAdvancedDropDownList = Class<N><N>    public<N>      currPos   : Integer;<N>      items     : TStringArray;<N><N>      renderContainer : TBCPanel;<N>      dropDown        : TBCPanel;<N>      itemView        : TListBox ;<N><N>
      containerHeight : Integer;<N>      containerWidth  : Integer;<N>      containerColor  : TColor;<N>      containerBorderColor : TColor;<N>      containerFontColors : Array of TColor;<N>      containerBorderWidth : Integer;<N>      containerFontNames   : Array of String;<N>      containerFontSizes   : Array of Integer;<N>      containerFontStyles   : Array of Integer;<N>      containerFontBackGrounds : Array of TColor;<N><N>
      cpanels       : Array of TBCPanel;<N>      sBarH         : TScrollbar;<N>      sBarV         : TScrollBar;<N><N>      selectedItem : Integer;<N><N>      dropDownOn   : Boolean;<N>      dropDownWidth: Integer;<N>      dropDownHeight:Integer;<N>      setFullWidth : Boolean;<N><N>
      totalWidth   : Integer;<N><N>      bottom_ofAll  : Integer;<N>      top_ofAll     : Integer;<N>      bottomPadding : Integer;<N><N>      debugLabel    : TBCLabel;<N>      allowOverFlow : Boolean;<N>      overFlowCounter: Integer;<N><N>      constructor Create();<N><N>
      procedure Initialize(entryItems: TStringArray);<N>      procedure Render(pPanel : TBCPanel);<N>      procedure toggleDropDown(Sender : TObject) ;<N>      procedure selectItem(Sender: TObject; User: boolean);<N><N><N><N>  end;<N><N>implementation<N><N>
{ TAdvancedDropDownList }<N><N>constructor TAdvancedDropDownList.Create;<N><N>begin<N><N><N><N><N>  // containerHeight := Floor(0.5 * Length(items)) * 1;<N><N><N>end;<N><N>procedure TAdvancedDropDownList.Initialize(entryItems: TStringArray);<N>var<N><N>  i             : Integer;<N>  totalHeight   : Integer;<N>  maxWidth      : Integer;<N>  fnt           : TFont;<N>  currWidth     : Integer;<N><N>
  c             : TBitmap;<N>begin<N><N>  renderContainer := TBCPanel.Create(Nil);<N>  renderContainer.Parent := Nil;<N><N>  itemView := TListBox.Create(Nil);<N>  itemView.Parent := Nil;<N><N>  setLength(items, 0);<N>  items         := entryitems;<N><N>  selectedItem := 0;<N><N>
  containerColor  := clForm;<N>  containerBorderColor := clGrayText;<N><N>  SetLength( containerFontColors, 0);<N>  for i := 0 to Length(items) - 1 do<N>  begin<N>    SetLength( containerFontColors, Length(containerFontColors) + 1);<N>    containerFontColors[Length(containerFontColors) - 1] := clWindowText;<N>  end;<N><N>
<N>  containerBorderColor := clGrayText;<N>  containerBorderWidth := 1;<N><N><N>  SetLength( containerFontNames, 0);<N>  for i := 0 to Length(items) - 1 do<N>  begin<N>    SetLength( containerFontNames, Length(containerFontNames) + 1);<N>    containerFontNames[Length(containerFontNames) - 1] := Screen.SystemFont.Name;<N>  end;<N><N>
<N><N>  SetLength( containerFontSizes, 0);<N>  for i := 0 to Length(items) - 1 do<N>  begin<N>    SetLength( containerFontSizes, Length(containerFontSizes) + 1);<N>    containerFontSizes[Length(containerFontSizes) - 1] := 0;<N>  end;<N><N><N>  SetLength( containerFontStyles, 0);<N>  for i := 0 to Length(items) - 1 do<N>  begin<N>    SetLength( containerFontStyles, Length(containerFontStyles) + 1);<N>    containerFontStyles[Length(containerFontStyles) - 1] := 0;<N>  end;<N><N>
<N>  SetLength( containerFontBackGrounds, 0);<N>  for i := 0 to Length(items) - 1 do<N>  begin<N>    SetLength( containerFontBackGrounds, Length(containerFontBackGrounds) + 1);<N>    containerFontBackGrounds[Length(containerFontBackGrounds) - 1] := clForm;<N>  end;<N><N>
  dropDownOn    := False;<N><N>  dropDownWidth := -1;<N>  dropDownHeight:= -1;<N><N>  setFullWidth  := False;<N><N>  maxWidth    := 0;<N><N><N><N><N><N>  totalHeight := 0;<N><N>  for i := 0 to Length(items) - 1 do<N>  begin<N><N>   fnt       := TFont.Create;<N>   fnt.Name  := containerFontNames[i];<N><N>
   c := TBitmap.Create;<N>   c.Canvas.Font.Assign(fnt);<N>   currWidth  := c.Canvas.TextWidth(items[i]) + 4; //-----------------------// Label width<N><N>   c.Free;<N><N>   itemView.Items.Add(items[i]);<N><N>   if maxWidth < currWidth then<N>   begin<N>    maxWidth := currWidth;<N>   end;<N><N>
   totalHeight:= totalHeight + fnt.GetTextHeight('AyTg') + 4 + 2;<N><N>  end;<N><N>  itemView.Height:=totalHeight+2;<N>  itemView.Width:= maxWidth+4;<N><N>  itemView.ScrollWidth := 10;<N><N>  totalWidth    := maxWidth + 5;<N><N><N>  if (dropDownWidth <> -1) then<N>  begin<N>  itemView.Width:=dropDownWidth;<N>  end;<N><N>
  if (dropDownHeight <> -1) then<N>  begin<N>  itemView.Height:=dropDownHeight;<N>  end;<N><N>  if not setFullWidth then<N>  begin<N>    itemView.Height := Floor(itemView.Height div 2)  ;<N>  end;<N><N><N><N>  itemView.OnSelectionChange:=@selectItem;<N><N>
  allowOverFlow := False;<N>  overFlowCounter:= 1;<N>  {TODO : Implement bevel controls}<N>end;<N><N><N><N>procedure TAdvancedDropDownList.Render(pPanel: TBCPanel);<N>var<N>  mPanel          : TBCPanel;<N>begin<N><N><N>  //---------------   Attach the top Panel to the container    -------------------//<N><N>
  // mPanel        := TBCPanel.Create(Nil);<N>  renderContainer.Parent := pPanel;<N><N><N><N>  renderContainer.Caption:= items[selectedItem];<N><N>  renderContainer.FontEx.Color:= containerFontColors[selectedItem] ;<N><N>  renderContainer.Height := pPanel.Height;<N>  renderContainer.Width  := pPanel.Width ;<N><N>
  renderContainer.BevelOuter:=bvNone;<N><N>  renderContainer.Color:= containerColor;<N><N>  renderContainer.Border.Color:= containerBorderColor;<N>  renderContainer.Border.Width:= containerBorderWidth;<N><N>  renderContainer.Border.Style:=bboSolid;<N>  renderContainer.BorderBCStyle:= bpsBorder;<N><N>
(******************************************************************************<N> Delphi import unit for OpenSSL libeay, version 0.7m, 2010-11-05<N><N> For OpenSSL libeay32.dll version 0.9.6b, DLL compiled by GnuWin32.<N> Tested with Borland Delphi 6, 7 Personal<N><N>
 Copyright (C) 2002-2010, Marco Ferrante.<N> 2002-2006, CSITA - Universit� di Genova (IT).<N>     http://www.csita.unige.it/.<N> 2007-2009, DISI - Universit� di Genova (IT).<N>     http://www.disi.unige.it/.<N> 2010, CSITA - Universit� di Genova (IT).<N>     http://www.csita.unige.it/.<N> Thanks to:<N>   - Michal Hlavac (Slovakia)<N>   - Risto Tamme (Estonia)<N>   - Simon Sun (probably USA)<N><N>
   - Luis Carrasco, Bambu Code (Mexico)<N> for contributes and fix<N><N> A small part of this work is inspired on MySSL, interface to OpenSSL for<N> Delphi written by Jan Tomasek.<N><N> This product is related to cryptographic software written by Eric<N> Young (eay@cryptsoft.com). This product is related to software written<N> by Tim Hudson (tjh@cryptsoft.com)<N><N>
 == Changelog =======================================================<N><N> Version 0.7n, 2010-12-27<N> - typo corrected<N><N> Version 0.7m, 2010-11-05<N> - added support for PCKS#8 functions (contributed by Luis Carrasco - Bambu Code, Mexico),<N> - redefinition of PChar as PCharacter to handle PChar and PAnsiChar types<N> - basic AES support<N><N>
 Version 0.7h, 2009-02-25<N> - added X509_sign(),<N><N> Version 0.7g, 2007-02-20<N> - Bugfix: PKCS12_parse function uses a by-reference parameter<N> - Bugfix: BIO_get_mem_data(). Thanks to Andrei<N> - Removed redundant declarations<N><N> Version 0.7f, 2007-02-20<N> - Bugfix: PEM_read_* function uses a by-reference parameter<N><N>
 Version 0.7e, 2007-02-11<N> - Bugfix<N> - Replace BN_mod import with a wrapper to BN_div, see man BN_mul(3)<N><N> Version 0.7d, 2006-12-15<N> - Typos<N> - Removed EVP_MD_size and EVP_MD_CTX_size: these functions are not defined in<N>   DLL and handle their parameter in a non-opaque way.<N><N>
 Version 0.7c, 2006-11-14<N> - Add BIGNUM functions<N> - Defined RSA record<N> - Add missing EVP_VerifyFinal<N><N> Version 0.7b, 2006-11-05<N> - Between 0.9.6h and 0.9.7, OpenSSL split OpenSSL_add_all_algorithms<N>   in two new functions. Some versions of libeay32.dll use old name,<N>   some use new one. See http://www.openssl.org/news/changelog.html<N>   In this unit, OpenSSL_add_all_algorithms is now a wrapper that<N>   dynamically loads appropriate function from DLL.<N><N>
 Version 0.7a, 2006-09-14<N> - Bug fixes<N> - Defined wrapper for OpenSSL memory management function<N><N> == License =========================================================<N> Redistribution and use in source and binary forms, with or without<N> modification, are permitted provided that the following conditions<N> are met:<N><N>
 1. Redistributions of source code must retain the above copyright<N>    notice, this list of conditions and the following disclaimer.<N><N> 2. Redistributions in binary form must reproduce the above copyright<N>    notice, this list of conditions and the following disclaimer in<N>    the documentation and/or other materials provided with the<N>    distribution.<N><N>
 3. All advertising materials mentioning features or use of this<N>    software must display the following acknowledgment:<N>    "This product includes software developed by CSITA - University<N>    of Genoa (Italy) (http://www.unige.it/)"<N><N> 4. Redistributions of any form whatsoever must retain the following<N>    acknowledgment:<N>    "This product includes software developed by the University<N>    of Genoa (Italy) (http://www.unige.it/) and its contributors"<N><N>
unit utils;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>procedure log(msg:string;level:byte=0);<N><N>var<N>  debug:boolean=false;<N><N>implementation<N><N>procedure log(msg:string;level:byte=0);<N>begin<N>if (level=0) and (debug=false) then exit;<N>writeln(msg);<N>end;<N><N>end.<N><N>
procedure row(n:integer);<N>begin<N>     if n >=0 then begin<N>        write (n, ' ');<N>        row(n-2)<N>     end;<N>end;<N>begin<N>    row(25);<N>end.
procedure fib (count,v,v0:integer);<N>  begin<N>       if count=0 then Exit;<N>       write(v, ' ');<N>           fib(count-1,v+v0,v);<N>  end;<N>begin<N>  fib(10,1,0);<N>end.
var a,b:longint;<N>    f1,f2:Text;<N>function Nod(x,y:longint):longint;<N>begin<N>  if x<>0 then Nod:=Nod(y mod x,x) else Nod:=y;<N>end;<N>begin<N>read(a,b);<N>writeln(Nod(a,b));<N>end.
unit Unit1;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs,shellapi, StrUtils, VclTee.TeeGDIPlus,<N>  VCLTee.TeEngine, VCLTee.Series, Vcl.ExtCtrls, VCLTee.TeeProcs, VCLTee.Chart,<N>  Vcl.StdCtrls,IOUtils, Vcl.ComCtrls, Vcl.FileCtrl, FlCtrlEx;<N><N>
unit form_inserir_preferencias;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, Buttons, StdCtrls, DBCtrls, DB, IBCustomDataSet, IBQuery,<N>  RxLookup, CheckLst;<N><N>type TPreferencia = record<N>  Codigo: Integer;<N>  Nome: String;<N>  Selecionado: Boolean;<N>end;<N><N>
unit untConfigSincronismo;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, dxGDIPlusClasses, ExtCtrls, Buttons, DB, IBCustomDataSet,<N>  Grids, Wwdbigrd, Wwdbgrid, Mask, wwdbedit, DBCtrls, Wwdotdot, Wwdbcomb;<N><N>
unit form_inserir_manequim;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, Buttons, StdCtrls, DBCtrls, DB, IBCustomDataSet, IBQuery,<N>  RxLookup, CheckLst, Grids, Wwdbigrd, Wwdbgrid, RxMemDS, wwdblook;<N><N>
unit untaniversariante;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, RxGIF, ExtCtrls, rxAnimate, rxGIFCtrl;<N><N>type<N>  TfrmAniversariante = class(TForm)<N>    RxGIFAnimator1: TRxGIFAnimator;<N>    procedure RxGIFAnimator1Click(Sender: TObject);<N>    procedure FormActivate(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  frmAniversariante: TfrmAniversariante;<N><N>implementation<N><N>{$R *.dfm}<N><N>procedure TfrmAniversariante.FormActivate(Sender: TObject);<N>begin<N>  top := 105;<N>  left := 218;<N>end;<N><N>procedure TfrmAniversariante.RxGIFAnimator1Click(Sender: TObject);<N>begin<N>  frmAniversariante.Close;<N>end;<N><N>
unit form_aniversariantes;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, Buttons, StdCtrls, DBCtrls, DB, IBCustomDataSet, IBQuery,<N>  RxLookup, untDados, Grids, DBGrids;<N><N>type<N>  TAniversariantesDia = class(TForm)<N>    lblPergunta: TLabel;<N>    DBGrid1: TDBGrid;<N>    procedure FormShow(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit CardDAV;<N><N>interface<N><N>{.$DEFINE DEMO}<N><N>uses<N>  Classes,<N>  Contnrs,<N>  IdHTTP,<N>  IdSSLOpenSSL,<N>  IdSSL,<N>  IdSocks,<N>  XMLDoc,<N>  IdWebDAV,<N>  SyncObjs,<N>  IdComponent,<N>  IdLogFile;<N><N>// Definition for compiling demo version of component<N><N>
{$IFDEF VER210}<N>  {$DEFINE 2010ANDLATER}<N>{$ENDIF}<N><N>{$IFDEF VER220}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>{$ENDIF}<N><N>{$IFDEF VER230}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>{$ENDIF}<N><N>{$IFDEF VER240}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>  {$DEFINE XE3ANDLATER}<N>{$ENDIF}<N><N>
{$IFDEF VER250}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>  {$DEFINE XE3ANDLATER}<N>  {$DEFINE XE4ANDLATER}<N>{$ENDIF}<N><N>{$IFDEF VER260}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>  {$DEFINE XE3ANDLATER}<N>  {$DEFINE XE4ANDLATER}<N>  {$DEFINE XE5ANDLATER}<N>{$ENDIF}<N><N>
{$IFDEF VER270}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>  {$DEFINE XE3ANDLATER}<N>  {$DEFINE XE4ANDLATER}<N>  {$DEFINE XE5ANDLATER}<N>  {$DEFINE XE6ANDLATER}<N>{$ENDIF}<N><N>{$IFDEF VER280}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>  {$DEFINE XE3ANDLATER}<N>  {$DEFINE XE4ANDLATER}<N>  {$DEFINE XE5ANDLATER}<N>  {$DEFINE XE6ANDLATER}<N>  {$DEFINE XE7ANDLATER}<N>{$ENDIF}<N><N>
type<N>  // Some fixing workaround on Indy WebDAV class<N>  TIdWebDAV = class(IdWebDAV.TIdWebDAV)<N>  protected<N>    procedure DoRequest(const AMethod: TIdHTTPMethod; AURL: string; ASource, AResponseContent: TStream;<N>      AIgnoreReplies: array of SmallInt); override;<N>  end;<N><N>
  TCardDavProxyType = (ptNone, ptHTTP, ptSocks4, ptSocks5);<N><N>  TCDAddressbook = class;<N>  TCDContact = class;<N><N>  TCardDAVStoreProgressEvent = procedure(Sender: TCDAddressbook; Current, Total: Cardinal; var Cancel: Boolean) of object;<N>  TCardDAVStoreErrorEvent = procedure(Sender: TCDContact; ErrorMessage: String) of object;<N><N>
unit CalDAV;<N><N>interface<N><N>{.$DEFINE DEMO}<N><N>uses<N>  Classes,<N>  Contnrs,<N>  Windows,<N>  IdHTTP,<N>  IdSSLOpenSSL,<N>  IdSSLOpenSSLHeaders,<N>  IdCoderQuotedPrintable,<N>  IdCTypes,<N>  IdSSL,<N>  IdComponent,<N>  IdSocks,<N>  XMLDoc,<N>  TZDB,<N>  IdWebDAV,<N>  SyncObjs,<N>  IdLogFile;<N><N>
{$IF DECLARED(RTLVersion)}<N>  {$IF RTLVersion >= 22}<N>    {$DEFINE SUPPORTS_TTIMEZONE}<N>  {$IFEND}<N>{$IFEND}<N><N>{$IFDEF VER210}<N>  {$DEFINE 2010ANDLATER}<N>{$ENDIF}<N><N>{$IFDEF VER220}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>{$ENDIF}<N><N>
{$IFDEF VER230}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>{$ENDIF}<N><N>{$IFDEF VER240}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>  {$DEFINE XE3ANDLATER}<N>{$ENDIF}<N><N>{$IFDEF VER250}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>  {$DEFINE XE3ANDLATER}<N>  {$DEFINE XE4ANDLATER}<N>{$ENDIF}<N><N>
{$IFDEF VER260}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>  {$DEFINE XE3ANDLATER}<N>  {$DEFINE XE4ANDLATER}<N>  {$DEFINE XE5ANDLATER}<N>{$ENDIF}<N><N>{$IFDEF VER270}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>  {$DEFINE XE3ANDLATER}<N>  {$DEFINE XE4ANDLATER}<N>  {$DEFINE XE5ANDLATER}<N>  {$DEFINE XE6ANDLATER}<N>{$ENDIF}<N><N>
{***************************************************************<N> *<N> * Unit Name: CPortMonitor<N> * Purpose  : Addition to ComPort 2.60 Communication Library<N> *						TMemo to monitor incoming and outgoing data<N> * Author   :	Roelof Y. Ensing (ensingroel@msn.com)<N> * History  : June 2000, first edition<N> *<N> ****************************************************************}<N><N>
unit CPortMonitor;<N>{$I CPort.inc}<N><N>interface<N><N>uses<N>	Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>	StdCtrls, Math, CPortCtl, CPort;<N><N>type<N><N>	TMonitorStyle = (msAscii,msHex,msHexC,msHexVB,msHexPascal,msDecimal,msBinary);<N>	TMonitorEvent = procedure (var DisplayValue:string;const Data:string; ComPort: TComPort) of object;<N>	TMonitorInfo = (miCommPort, miDate, miTime, miDirection);<N>	TMonitorInfoSet = set of TMonitorInfo;<N><N>
(******************************************************<N> * ComPort Library ver. 4.11                          *<N> *   for Delphi 5, 6, 7, 2007-2010,XE  and            *<N> *   C++ Builder 3, 4, 5, 6                           *<N> * written by Dejan Crnila, 1998 - 2002               *<N> * maintained by Lars B. Dybdahl, 2003                *<N> * Homepage: http://comport.sf.net/                   *<N> *****************************************************)<N><N>
(******************************************************<N> * ComPort Library ver. 4.11                          *<N> *   for Delphi 5, 6, 7, 2007-2010,XE  and            *<N> *   C++ Builder 3, 4, 5, 6                           *<N> * written by Dejan Crnila, 1998 - 2002               *<N> * maintained by Lars B. Dybdahl, 2003                *<N> * Homepage: http://comport.sf.net/                   *<N> *****************************************************)<N><N>
(******************************************************<N> * ComPort Library ver. 4.11                          *<N> *   for Delphi 5, 6, 7, 2007-2010,XE  and            *<N> *   C++ Builder 3, 4, 5, 6                           *<N> * written by Dejan Crnila, 1998 - 2002               *<N> * maintained by Lars B. Dybdahl, 2003                *<N> * Homepage: http://comport.sf.net/                   *<N> *****************************************************)<N><N>
(******************************************************<N> * ComPort Library ver. 4.11                          *<N> *   for Delphi 5, 6, 7, 2007-2010,XE  and            *<N> *   C++ Builder 3, 4, 5, 6                           *<N> * written by Dejan Crnila, 1998 - 2002               *<N> * maintained by Lars B. Dybdahl, 2003                *<N> * Homepage: http://comport.sf.net/                   *<N> *****************************************************)<N><N>
unit CardDAV;<N><N>interface<N><N>{.$DEFINE DEMO}<N><N>uses<N>  Classes,<N>  Contnrs,<N>  IdHTTP,<N>  IdSSLOpenSSL,<N>  IdSSL,<N>  IdSocks,<N>  XMLDoc,<N>  IdWebDAV,<N>  SyncObjs,<N>  IdComponent,<N>  IdLogFile;<N><N>// Definition for compiling demo version of component<N><N>
{$IFDEF VER210}<N>  {$DEFINE 2010ANDLATER}<N>{$ENDIF}<N><N>{$IFDEF VER220}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>{$ENDIF}<N><N>{$IFDEF VER230}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>{$ENDIF}<N><N>{$IFDEF VER240}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>  {$DEFINE XE3ANDLATER}<N>{$ENDIF}<N><N>
{$IFDEF VER250}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>  {$DEFINE XE3ANDLATER}<N>  {$DEFINE XE4ANDLATER}<N>{$ENDIF}<N><N>{$IFDEF VER260}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>  {$DEFINE XE3ANDLATER}<N>  {$DEFINE XE4ANDLATER}<N>  {$DEFINE XE5ANDLATER}<N>{$ENDIF}<N><N>
{$IFDEF VER270}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>  {$DEFINE XE3ANDLATER}<N>  {$DEFINE XE4ANDLATER}<N>  {$DEFINE XE5ANDLATER}<N>  {$DEFINE XE6ANDLATER}<N>{$ENDIF}<N><N>{$IFDEF VER280}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>  {$DEFINE XE3ANDLATER}<N>  {$DEFINE XE4ANDLATER}<N>  {$DEFINE XE5ANDLATER}<N>  {$DEFINE XE6ANDLATER}<N>  {$DEFINE XE7ANDLATER}<N>{$ENDIF}<N><N>
type<N>  // Some fixing workaround on Indy WebDAV class<N>  TIdWebDAV = class(IdWebDAV.TIdWebDAV)<N>  protected<N>    procedure DoRequest(const AMethod: TIdHTTPMethod; AURL: string; ASource, AResponseContent: TStream;<N>      AIgnoreReplies: array of SmallInt); override;<N>  end;<N><N>
  TCardDavProxyType = (ptNone, ptHTTP, ptSocks4, ptSocks5);<N><N>  TCDAddressbook = class;<N>  TCDContact = class;<N><N>  TCardDAVStoreProgressEvent = procedure(Sender: TCDAddressbook; Current, Total: Cardinal; var Cancel: Boolean) of object;<N>  TCardDAVStoreErrorEvent = procedure(Sender: TCDContact; ErrorMessage: String) of object;<N><N>
unit CalDAV;<N><N>interface<N><N>{.$DEFINE DEMO}<N><N>uses<N>  Classes,<N>  Contnrs,<N>  Windows,<N>  IdHTTP,<N>  IdSSLOpenSSL,<N>  IdSSLOpenSSLHeaders,<N>  IdCoderQuotedPrintable,<N>  IdCTypes,<N>  IdSSL,<N>  IdComponent,<N>  IdSocks,<N>  XMLDoc,<N>  TZDB,<N>  IdWebDAV,<N>  SyncObjs,<N>  IdLogFile;<N><N>
{$IF DECLARED(RTLVersion)}<N>  {$IF RTLVersion >= 22}<N>    {$DEFINE SUPPORTS_TTIMEZONE}<N>  {$IFEND}<N>{$IFEND}<N><N>{$IFDEF VER210}<N>  {$DEFINE 2010ANDLATER}<N>{$ENDIF}<N><N>{$IFDEF VER220}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>{$ENDIF}<N><N>
{$IFDEF VER230}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>{$ENDIF}<N><N>{$IFDEF VER240}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>  {$DEFINE XE3ANDLATER}<N>{$ENDIF}<N><N>{$IFDEF VER250}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>  {$DEFINE XE3ANDLATER}<N>  {$DEFINE XE4ANDLATER}<N>{$ENDIF}<N><N>
{$IFDEF VER260}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>  {$DEFINE XE3ANDLATER}<N>  {$DEFINE XE4ANDLATER}<N>  {$DEFINE XE5ANDLATER}<N>{$ENDIF}<N><N>{$IFDEF VER270}<N>  {$DEFINE 2010ANDLATER}<N>  {$DEFINE XEANDLATER}<N>  {$DEFINE XE2ANDLATER}<N>  {$DEFINE XE3ANDLATER}<N>  {$DEFINE XE4ANDLATER}<N>  {$DEFINE XE5ANDLATER}<N>  {$DEFINE XE6ANDLATER}<N>{$ENDIF}<N><N>
unit untService;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.SvcMgr, Vcl.Dialogs;<N><N>type<N>  TService1 = class(TService)<N>  private<N>    { Private declarations }<N>  public<N>    function GetServiceController: TServiceController; override;<N>    { Public declarations }<N>  end;<N><N>
var<N>  Service1: TService1;<N><N>implementation<N><N>{$R *.dfm}<N><N>procedure ServiceController(CtrlCode: DWord); stdcall;<N>begin<N>  Service1.Controller(CtrlCode);<N>end;<N><N>function TService1.GetServiceController: TServiceController;<N>begin<N>  Result := ServiceController;<N>end;<N><N>
unit server.model.dao.interfaces;<N><N>interface<N><N>uses<N>  server.model.entity.pessoa,<N>  server.model.entity.endereco,<N>  server.model.entity.endereco.integracao,<N>  System.Generics.Collections,<N>  server.model.resource.interfaces,<N>  server.utils.generic.iterator;<N>type<N><N>
  iDAOPessoa = interface<N>    ['{1B2A6E29-0718-48A5-BBC5-61BD5CD04E34}']<N>    function ListarTodos : iDaoPessoa;<N>    function ListarPorID(aPessoa : TModelPessoa) : iDAOPessoa;<N>    function Inserir(aPessoa : TModelPessoa) : iDaoPessoa;<N>    function Excluir(ID : Int64) : iDaoPessoa;<N>    function Alterar(aPessoa : TModelPessoa) : iDaoPessoa;<N>    function List : TObjectList<TModelPessoa>;<N>    function IsEmpty : Boolean;<N>  end;<N><N>
unit server.model.resource.interfaces;<N><N>interface<N><N>uses<N>  Data.DB,<N>  System.Classes;<N><N>type<N>  iRestParams = interface;<N>  iConexao = interface<N>    ['{DB069014-7641-47C0-903C-19C1F70E37ED}']<N>    function Connect : TCustomConnection;<N>    procedure Disconnect;<N>    procedure StartTransaction;<N>    procedure Commit;<N>    procedure Rollback;<N><N>
unit server.model.resource.config;<N><N>interface<N><N>uses<N>  server.model.resource.interfaces;<N>type<N>  TResourceConfig = class<N>  private<N>    class var FDatabaseConfig : iDataBaseConfig;<N>  public<N>    class constructor Create;<N>    class function Database : iDataBaseConfig;<N>  end;<N>implementation<N><N>
uses<N>  server.model.resource.conexao.databaseconfig;<N><N>{ TResourceConfig }<N><N>class function TResourceConfig.Database: iDataBaseConfig;<N>begin<N>  Result := FDatabaseConfig;<N>end;<N><N>class constructor TResourceConfig.Create;<N>begin<N>  FDatabaseConfig := TDatabaseConfig.New;<N>end;<N><N>
unit server.model.service.factory;<N><N>interface<N><N>uses<N>  server.model.service.interfaces;<N>type<N>  TServiceFactory = class(TInterfacedObject, iServiceFactory)<N>  private<N>  public<N>    class function New : iServiceFactory;<N>    function CEP : iServiceCEP;<N>    function Endereco : iServiceEndereco;<N>    function Pessoa : iServicePessoa;<N>  end;<N>implementation<N><N>
uses<N>  server.model.service.cep.viacep,<N>  server.model.service.endereco,<N>  server.model.service.pessoa;<N><N>{ TServiceFactory }<N><N>function TServiceFactory.CEP: iServiceCEP;<N>begin<N>  Result := TServiceCEPViaCEP.New;<N>end;<N><N>function TServiceFactory.Endereco: iServiceEndereco;<N>begin<N>  Result := TServiceEndereco.New;<N>end;<N><N>
unit server.model.service.endereco;<N><N>interface<N><N>uses<N>  server.model.service.interfaces,<N>  server.model.dao.interfaces,<N>  server.model.entity.endereco.integracao, server.model.entity.endereco;<N>type<N>  TServiceEndereco = class(TInterfacedObject, iServiceEndereco)<N>  private<N>    FDAOEndereco : IDAOEndereco;<N>    procedure AtualizarEndereco(aEndereco : TModelEndereco);<N>  public<N>    constructor Create;<N>    class function New : iServiceEndereco;<N>    procedure AtualizarEnderecos;<N><N>
unit server.model.service.endereco.thread;<N><N>interface<N><N>uses<N>  server.utils.thread.timer;<N>type<N>  TThreadAutalizaEnderecos = class<N>  private<N>    class var FThreadTimer : TThreadTimer;<N>  public<N>    class constructor Create;<N>    class destructor Finish;<N>    class procedure Start;<N>    class procedure Interval(aValue : Integer);<N>  end;<N>implementation<N><N>
uses<N>  server.model.service.factory;<N><N>{ TThreadAutalizaEnderecos }<N><N>class constructor TThreadAutalizaEnderecos.Create;<N>begin<N>  FThreadTimer := TThreadTimer.Create(true);<N>  FThreadTimer.Interval(30000);<N>  FThreadTimer.OnTimer(<N>    procedure<N>    begin<N>      TServiceFactory.New.Endereco.AtualizarEnderecos;<N>    end);<N>end;<N><N>
class destructor TThreadAutalizaEnderecos.Finish;<N>begin<N>  FThreadTimer.ForceTerminate;<N>  FThreadTimer.Free;<N>end;<N><N>class procedure TThreadAutalizaEnderecos.Interval(aValue: Integer);<N>begin<N>  FThreadTimer.Interval(aValue);<N>end;<N><N>class procedure TThreadAutalizaEnderecos.Start;<N>begin<N>  FThreadTimer.Start;<N>end;<N><N>
unit server.model.entity.consultacep;<N><N>interface<N>type<N>  TModelConsultaCEP = class<N>  private<N>    FComplemento: String;<N>    FLogradouro: String;<N>    FCEP: String;<N>    FBairro: String;<N>    FUf: String;<N>    FLocalidade: String;<N>    FErro: Boolean;<N><N>
unit server.provider.request;<N><N>interface<N>type<N>  TProviderRequest = class<N>  private<N>    FBody : String;<N>    FParams : Tarray<string>;<N>  public<N>    constructor Create(aBody: String; aParams: TArray<String>);<N>    function Params : Tarray<string>;<N>    function Body : String;<N>  end;<N>implementation<N><N>
{ TProviderRequest }<N><N>function TProviderRequest.Body: String;<N>begin<N>  Result := FBody;<N>end;<N><N>constructor TProviderRequest.Create(aBody: String; aParams: TArray<String>);<N>begin<N>  FBody := aBody;<N>  FParams := aParams;<N>end;<N><N>function TProviderRequest.Params: Tarray<string>;<N>begin<N>  Result := FParams;<N>end;<N><N>
unit server.provider.action;<N><N>interface<N>uses<N>  server.provider.response,<N>  server.provider.request;<N>type<N>   TProviderActionRequestResponse = procedure(AReq: TProviderRequest; ARes: TProviderResponse);<N><N>implementation<N><N>end.<N>
unit server.controller.factory;<N><N>interface<N><N>uses<N>  server.controller.interfaces;<N>type<N>  TController = class(TInterfacedObject, iController)<N>  private<N>    FPessoa : iPessoa;<N>  public<N>    class function New : iController;<N>    function Pessoa : iPessoa;<N>  end;<N>implementation<N><N>
uses<N>  server.controller.pessoa;<N><N>{ TController }<N><N>class function TController.New: iController;<N>begin<N>  Result := Self.Create;<N>end;<N><N>function TController.Pessoa: iPessoa;<N>begin<N>  if not Assigned(FPessoa) then<N>    FPessoa := TPessoa.New;<N>  Result := FPessoa;<N>end;<N><N>
unit server.controller.interfaces;<N><N>interface<N><N>uses<N>  System.JSON,<N>  server.model.service.interfaces;<N><N>type<N>  iPessoa = interface<N>    ['{AB6D2D3D-A617-4A8E-B356-A94433B084BB}']<N>    function Services : iServicePessoa;<N>    function JsonStringToObject(Value : String) : iPessoa;<N>    function JsonArrayStringToList(Value : String) : iPessoa;<N>  end;<N><N>  iController = interface<N>    ['{9602C436-30AD-414D-B325-74DADB6131BD}']<N>    function Pessoa : iPessoa;<N>  end;<N>implementation<N><N>end.<N>
unit server.utils.thread.timer;<N><N>interface<N><N>uses<N>  System.Classes, System.SyncObjs, System.SysUtils;<N><N>type<N>  TThreadTimer = class(TThread)<N>  private<N>    FEvent : TEvent;<N>    FOnTimer: TProc;<N>    FInterval: Integer;<N>  protected<N>    procedure Execute; override;<N>    procedure DoTimer;<N>  public<N>    procedure AfterConstruction; override;<N>    procedure BeforeDestruction; override;<N>    procedure ForceTerminate;<N><N>
    function Interval(aValue : Integer) : TThreadTimer;<N>    function OnTimer(aValue : TProc) : TThreadTimer;<N>  end;<N>implementation<N><N>{ TThreadTimer }<N><N>procedure TThreadTimer.AfterConstruction;<N>begin<N>  inherited;<N>  FInterval := 1000;<N>  FEvent := TEvent.Create;<N>end;<N><N>
procedure TThreadTimer.BeforeDestruction;<N>begin<N>  inherited;<N>  FEvent.Free;<N>end;<N><N>procedure TThreadTimer.DoTimer;<N>begin<N>  if Assigned(FOnTimer) then<N>    FOnTimer;<N><N>end;<N><N>procedure TThreadTimer.Execute;<N>var<N>  LWaitResult : TWaitResult;<N>begin<N>  inherited;<N>  while not Self.Terminated do<N>  begin<N>    LWaitResult := FEvent.WaitFor(FInterval);<N>    if LWaitResult <> TWaitResult.wrTimeout then<N>      Exit;<N>    DoTimer;<N>  end;<N>end;<N><N>
procedure TThreadTimer.ForceTerminate;<N>begin<N>  FEvent.SetEvent;<N>end;<N><N>function TThreadTimer.Interval(aValue: Integer): TThreadTimer;<N>begin<N>  Result := Self;<N>  FInterval := aValue;<N>end;<N><N>function TThreadTimer.OnTimer(aValue: TProc): TThreadTimer;<N>begin<N>  Result := Self;<N>  FOnTimer := aValue;<N>end;<N><N>
unit server.utils;<N><N>interface<N>uses<N>  Data.DB;<N>type<N>  TServerUtils = class<N>    class function DecodeURI(URI : String) : String;<N>    class function GetParamsFromURI(URI : String) : TArray<String>;<N>    class procedure SetEmptyParamsToNull(aParams : TParams);<N>    class procedure SetEmptyParamToNull(aParam : TParam);<N>    class function ApenasNumeros(valor : String) : String;<N>  end;<N>implementation<N><N>
uses<N>  System.SysUtils,<N>  System.Classes;<N><N>{ TServerUtils }<N><N>class function TServerUtils.ApenasNumeros(valor: String): String;<N>var<N>  i: Integer;<N>begin<N>  for i := 0 to Length(valor) - 1 do<N>    if not CharInSet(valor[i], ['0' .. '9']) then<N>      delete(valor, i, 1);<N><N>
  valor := StringReplace(valor, ' ', '', [rfReplaceAll]);<N>  Result := valor;<N>end;<N><N>class function TServerUtils.DecodeURI(URI: String): String;<N>var<N>  LURIParts : TArray<String>;<N>begin<N>  LURIParts := URI.Split(['/']);<N>  Result := '/' + LURIParts[1] + StringOfChar('/', Length(LURIParts) - 2);<N>end;<N><N>
class function TServerUtils.GetParamsFromURI(URI: String): TArray<String>;<N>begin<N>  Result := URI.Split(['/']);<N>  Delete(Result,0, 2);<N>end;<N><N>class procedure TServerUtils.SetEmptyParamToNull(aParam: TParam);<N>begin<N>  case aParam.DataType of<N>    ftString,<N>    ftWideString :<N>      if aParam.AsString.IsEmpty then<N>        aParam.Clear;<N>  end;<N>end;<N><N>
unit server.utils.generic.iterator;<N><N>interface<N><N>uses<N>  System.Generics.Collections;<N>type<N>  iGenericIterator<T> = interface<N>    ['{61625260-A81A-42FD-8C96-A985F189A63E}']<N>    function HasNext : boolean;<N>    function Next : T;<N>  end;<N><N>
  TGenericIterator<T: class, constructor> = class(TInterfacedObject, iGenericIterator<T>)<N>  private<N>    FList : TObjectList<T>;<N>    FCount : Integer;<N>  public<N>    constructor Create(AList : TObjectList<T>);<N>    class function New(AList : TObjectList<T>) : iGenericIterator<T>;<N>    function HasNext : boolean;<N>    function Next : T;<N><N>
  end;<N>implementation<N><N>{ TGenericIterator<T> }<N><N>constructor TGenericIterator<T>.Create(AList : TObjectList<T>);<N>begin<N>  FList := AList;<N>  FCount := 0;<N>end;<N><N>function TGenericIterator<T>.HasNext: boolean;<N>begin<N>  Result := not (FCount = FList.Count);<N>end;<N><N>
class function TGenericIterator<T>.New(AList : TObjectList<T>): iGenericIterator<T>;<N>begin<N>  Result := Self.Create(AList);<N>end;<N><N>function TGenericIterator<T>.Next: T;<N>begin<N>  Result := FList[FCount];<N>  Inc(FCount);<N>end;<N><N>end.<N><N><N>
unit client.model.principal;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, REST.Types, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS,<N>  FireDAC.Phys.Intf, FireDAC.DApt.Intf, Data.DB, FireDAC.Comp.DataSet,<N>  FireDAC.Comp.Client, REST.Response.Adapter, REST.Client, Data.Bind.Components,<N>  Data.Bind.ObjectScope;<N><N>
unit client.model.dao.factory;<N><N>interface<N><N>uses<N>  client.model.dao.Interfaces,<N>  client.model.entity.pessoa,<N>  System.Generics.Collections;<N>type<N>  TDAOFactory = class(TInterfacedObject, iDAOFactory)<N>  private<N>  public<N>    class function New : iDAOFactory;<N>    function Pessoa : IDAOPessoa;<N>  end;<N>implementation<N><N>
uses<N>  client.model.dao.pessoa;<N><N>{ TDAOFactory }<N><N>class function TDAOFactory.New : iDAOFactory;<N>begin<N>  Result := Self.Create;<N>end;<N><N>function TDAOFactory.Pessoa : IDAOPessoa;<N>begin<N>  Result := TDAOPessoa.New;<N>end;<N><N>end.<N><N><N>
unit client.model.resource.factory;<N><N>interface<N><N>uses<N>  client.model.resource.interfaces;<N>type<N>  TResourceFactory = class(TInterfacedObject, iServiceFactory)<N>  private<N>  public<N>    class function New : iServiceFactory;<N>    function Rest : iRest;<N>  end;<N>implementation<N><N>
uses<N>  client.model.resource.rest.delphirestclient,<N>  client.model.principal;<N><N>{ TResourceFactory }<N><N>class function TResourceFactory.New: iServiceFactory;<N>begin<N>  Result := Self.Create;<N>end;<N><N>function TResourceFactory.Rest: iRest;<N>begin<N>  Result := TDelphiRestClient.New.Params.BaseURL(dmPrincipal.ServerURL).&End;<N>end;<N><N>
unit client.model.resource.interfaces;<N><N>interface<N><N>type<N>  iRestParams = interface;<N><N>  iRest = interface<N>    ['{5CA7C6F6-39D1-4313-BAEA-15AEEF25C5D8}']<N>    function Content : string;<N>    function Delete : iRest;<N>    function Get : iRest;<N>    function Params : iRestParams;<N>    function Post : iRest; overload;<N>    function Put : iRest;<N>  end;<N><N>
unit client.view.pessoas.lote;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Data.DB, Vcl.StdCtrls, Vcl.WinXPanels,<N>  Vcl.Grids, Vcl.DBGrids, Vcl.Buttons, Vcl.ExtCtrls, Vcl.ComCtrls,<N>  client.controller.interfaces;<N><N>
unit client.view.pessoas;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Data.DB, Vcl.StdCtrls, Vcl.WinXPanels,<N>  Vcl.Grids, Vcl.DBGrids, Vcl.Buttons, Vcl.ExtCtrls, client.controller.interfaces;<N><N>
unit client.view.Style;<N><N>interface<N>const<N>  COR_FUNDO = $00ffffff;<N>  COR_TEMA = $00AFA856;<N>  COR_FUNDO_MENU =$00f8f2ed;<N>  COR_TOPO_CADASTRO = $00CFCA99;<N><N>implementation<N><N>end.<N>
unit client.controller.factory;<N><N>interface<N><N>uses<N>  client.controller.interfaces;<N>type<N>  TController = class(TInterfacedObject, iController)<N>  private<N>    FPessoa : iPessoa;<N>  public<N>    class function New : iController;<N>    function Pessoa : iPessoa;<N>  end;<N>implementation<N><N>
uses<N>  client.controller.pessoa;<N><N>{ TController }<N><N>class function TController.New: iController;<N>begin<N>  Result := Self.Create;<N>end;<N><N>function TController.Pessoa: iPessoa;<N>begin<N>  if not Assigned(FPessoa) then<N>    FPessoa := TPessoa.New;<N>  Result := FPessoa;<N>end;<N><N>
unit client.utils;<N><N>interface<N>type<N>  TClientUtils = class<N>    class function ApenasNumeros(valor : String) : String;<N>  end;<N><N>implementation<N><N>uses<N>  System.SysUtils;<N><N>{ TClientUtils }<N><N>class function TClientUtils.ApenasNumeros(valor: String): String;<N>var<N>  i: Integer;<N>begin<N>  for i := 0 to Length(valor) - 1 do<N>    if not CharInSet(valor[i], ['0' .. '9']) then<N>      delete(valor, i, 1);<N><N>  valor := StringReplace(valor, ' ', '', [rfReplaceAll]);<N>  Result := valor;<N>end;<N><N>end.<N>
program TableOfPrimes;<N>label P2, P3, P4, P5, P6, P9, P10, P11, P12;<N><N>const<N>  L = 500; {The number of primes to find}<N>  PRINTER = 18; {Unit number of the line printer}<N>  BUF0 = 2000; {Memory area for BUFFER[0]}<N>  BUF1 = BUF0 + 25; {Memory area for BUFFER[1]}<N>type<N>  A = array[-1..L] of integer; {Memory area for table of primes}<N><N>
var<N>  J, N, K, M: integer;<N>  PRIME: A;<N><N>begin<N>  {Start table}<N>  J := 1;<N>  N := 3;<N><N>P2:<N>  {N is prime}<N>  J := J + 1;<N>  PRIME[J] := N;<N><N>P3:<N>  {500 found?}<N>  if J = L then<N>    goto P9;<N><N>P4:<N>  {Advance N}<N>  N := N + 2;<N><N>
P5:<N>  {K := 2}<N>  K := 2;<N><N>P6:<N>  {PRIME[K]\N?}<N>  while PRIME[K] * PRIME[K] <= N do<N>  begin<N>    if (N mod PRIME[K]) = 0 then<N>      goto P4;<N>    K := K + 1;<N>  end;<N><N>  {Otherwise N is prime}<N>  goto P2;<N><N>P9:<N>  {Print title}<N>  writeln('FIRST FIVE HUNDRED PRIMES');<N>  writeln;<N>  M := 0;<N><N>
P10:<N>  {Set up line (right to left)}<N>  for K := 1 to 10 do<N>  begin<N>    M := M + 1;<N>    write(PRIME[M]:10);<N>    if M = J then<N>      goto P12;<N>  end;<N><N>P11:<N>  {Switch buffers}<N>  writeln;<N>  for K := 1 to 25 do<N>  begin<N>    PRIME[K] := PRIME[K] + 10000;<N>    PRIME[K] := PRIME[K] - 10000;<N>  end;<N><N>
unit login;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs;<N><N>type<N>  TForm10 = class(TForm)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form10: TForm10;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit Unit6;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls;<N><N>type<N>  TForm6 = class(TForm)<N>    Button1: TButton;<N>    procedure Button1Click(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form6: TForm6;<N><N>implementation<N><N>uses Unit1;<N>{$R *.dfm}<N><N>procedure TForm6.Button1Click(Sender: TObject);<N>begin<N>  Form6.Close;<N>  Form1.Show;<N>end;<N><N>end.<N>
unit Unit5;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls;<N><N>type<N>  TForm5 = class(TForm)<N>    Button1: TButton;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form5: TForm5;<N><N>implementation<N>uses Unit1;<N><N>{$R *.dfm}<N><N>end.<N>
unit Unit8;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms, <N>  Dialogs;<N><N>type<N>  TFrame8 = class(TFrame)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
﻿{<N>  ======================================<N>  Language:<N>  Object Pascal<N>  Name:<N>  DataChest<N>  数据存储柜<N>  Description:<N>  使用动态index存储数据<N>  Writer:<N>  黄锐( vowstar@gmail.com )<N>  Date:<N>  2010-4-8 12:54:43<N>  36816<N>  ======================================<N>}<N>unit DataChest;<N><N>
interface<N><N>uses<N>  Classes, SysUtils, xmldom, XMLDoc, XMLIntf, EncdDecd;<N><N>const<N>  ChestTypeEmpty = 0;<N>  ChestTypeInteger = 1;<N>  ChestTypeReal = 2;<N>  ChestTypeBoolean = 3;<N>  ChestTypeString = 4;<N>  ChestTypePointer = 5;<N><N>type<N>  {<N>    ======================================<N>    TChestElement<N>    不建副本到内存<N>    ======================================<N>    }<N>  TChestElement = class(TObject)<N>    ChestType: Word;<N>    Value: Pointer;<N>    Name: String;<N>  end;<N><N>
  TChestString = class(TObject)<N>    Value: string;<N>  end;<N><N>  {<N>    ======================================<N>    TChest<N>    不建副本到内存<N>    ======================================<N>    }<N>  TChest = class(TObject)<N>  const<N>    Version = '1.0.0.0';<N>  private<N><N>
unit uCadUsuario;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,<N>  System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs,<N>  Vcl.StdCtrls, DM.Main, Vcl.ExtCtrls, Vcl.Buttons, Fnc_Utils, uMessage,<N>  DTO.Usuario, Controle.Caixa.Controller.Manager.Interfaces,<N>  Controle.Caixa.Controller.Manager;<N><N>
unit uMain;<N><N>interface<N><N>uses<N>{(*}<N>  Winapi.Windows,<N>  Winapi.Messages,<N>  System.SysUtils,<N>  System.Variants,<N>  System.Classes,<N>  Vcl.Graphics,<N>  Vcl.Controls,<N>  Vcl.Forms,<N>  Vcl.Dialogs,<N>  Vcl.Menus,<N>  Vcl.ExtCtrls,<N>  Vcl.StdCtrls,<N>  uGridUsers,<N>  uMessage,<N>  Fnc_Utils,<N>  Vcl.Buttons,<N>  Controle.Caixa.Controller.Manager,<N>  Controle.Caixa.Controller.Manager.Interfaces,<N>  Manager.Types;<N>{*)}<N><N>
unit uMessage;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,<N>  System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.Buttons, Vcl.StdCtrls,<N>  System.ImageList, Vcl.ImgList, Vcl.Imaging.pngimage;<N><N>
unit Manager.Caixa;<N><N>interface<N><N>uses<N>  Data.DB, DTO.Caixa, Manager.Types, Manager.Interfaces,<N>  System.Generics.Collections, FireDAC.Comp.Client, FireDAC.Stan.Param,<N>  Vcl.Dialogs, System.TypInfo, System.Variants, System.SysUtils,<N>  Controle.Caixa.Model.Connection.Interfaces, Controle.Caixa.Model.Connection,<N>  DTO.Usuario;<N><N>
unit Manager.Usuario;<N><N>interface<N><N>uses<N>  Manager.Interfaces, DTO.Usuario, FireDAC.Comp.Client, FireDAC.Stan.Param,<N>  Manager.Types, System.TypInfo, System.SysUtils, Vcl.Dialogs,<N>  Controle.Caixa.Model.Connection, Controle.Caixa.Model.Connection.Interfaces,<N>  Data.DB, System.Generics.Collections, Bcrypt;<N><N>
unit Manager.Types;<N><N>interface<N><N>type<N>  tpFilterOperator = (Eq, GreaterThan, GreaterOrEqual, LessThan, LessOrEqual,<N>    Like, Different, Between);<N><N>  tpOrderDirection = (Asc, Desc);<N><N>implementation<N><N>end.<N>
unit Controle.Caixa.Controller.Manager.Interfaces;<N><N>interface<N><N>uses<N>  Manager.Interfaces,<N>  DTO.Caixa,<N>  DTO.Usuario;<N><N>type<N>  iControllerManager = Interface<N>    ['{B240267A-72C8-42F0-9A76-E0C88EA8743C}']<N>    function Caixa: iManager<TCaixa>;<N>    function Usuario: iManager<TUsuario>;<N>  End;<N><N>implementation<N><N>end.<N>
unit Controle.Caixa.Model.Connection.Interfaces;<N><N>interface<N><N>uses<N>  Data.DB,<N>  FireDAC.Comp.Client;<N><N>type<N>  iConnection = interface<N>    ['{42864D76-D1E7-4698-A0AA-40FCF17D60FC}']<N>    function Connection: TFDConnection;<N>  end;<N><N>implementation<N><N>end.<N>
unit DM_Atualiza;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, Data.Win.ADODB, Datasnap.Provider, Data.DB,<N>  Datasnap.DBClient;<N><N>type<N>  TDM_DATASET = class(TDataModule)<N>    Local: TADOConnection;<N>    ado_nuvens: TADOConnection;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  DM_DATASET: TDM_DATASET;<N><N>implementation<N><N>{%CLASSGROUP 'Vcl.Controls.TControl'}<N><N>{$R *.dfm}<N><N>end.<N>
unit uMensagem;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.Buttons,DateUtils,<N>  Vcl.Imaging.jpeg, Vcl.ExtCtrls;<N><N>
﻿unit dlAsyncProcList;<N><N>interface<N><N>uses SysUtils, Classes, Messages, Windows;<N><N>type<N>  IAsyncResult = interface<N>    ['{F9491DFA-3EBD-4395-BA87-D78BC15AC136}']<N>    function GetError: String;<N>  end;<N><N>  TAsyncResult = class(TInterfacedObject, IAsyncResult)<N>    strict private<N>      FError: String;<N>    public<N>      constructor Create(AError: String = '');<N>    public<N>      function GetError: String;<N>  end;<N><N>
  IAsyncObject = interface<N>    ['{047D5C4D-E4F4-4024-B1DC-7659625096A5}']<N>    procedure Run;<N>    procedure CallBack;<N>    function Data: Pointer;<N>  end;<N><N>  TAsyncProcRef         = reference to procedure(out AData: Pointer);<N>  TAsyncProcRefCallBack = reference to procedure(Sender: IAsyncObject);<N><N>
unit Web.Module;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, Web.HTTPApp, Datasnap.DSHTTPCommon,<N>  Datasnap.DSHTTPWebBroker, Datasnap.DSServer,<N>  Web.WebFileDispatcher, Web.HTTPProd,<N>  DataSnap.DSAuth,<N>  Datasnap.DSProxyJavaScript, IPPeerServer, Datasnap.DSMetadata,<N>  Datasnap.DSServerMetadata, Datasnap.DSClientMetadata, Datasnap.DSCommonServer,<N>  Datasnap.DSHTTP;<N><N>
unit Controller.Entidades;<N><N>interface<N><N>uses<N>  Controller, DAO.Conexao, DAO.EntidadeFactory;<N><N>type<N>  TController = class(TInterfacedObject,IController)<N>  private<N>    FEntidades: IEntidadeFactory;<N>  public<N>    constructor Create;<N>    destructor Destroy; override;<N>    class function New : iController;<N>    function Entidades : IEntidadeFactory;<N>  end;<N><N>
implementation<N><N>{ TController }<N><N>constructor TController.Create;<N>begin<N>  FEntidades := TEntidadesFactory.New;<N>end;<N><N>destructor TController.Destroy;<N>begin<N>  inherited;<N>end;<N><N>function TController.Entidades: IEntidadeFactory;<N>begin<N>  Result := FEntidades;<N>end;<N><N>
unit DAO.Query;<N><N>interface<N><N>uses<N>  DAO.Conexao, Data.DB, FireDAC.Stan.Intf, FireDAC.Stan.Option, FireDAC.Stan.Error,<N>  FireDAC.UI.Intf, FireDAC.Phys.Intf, FireDAC.Stan.Def, FireDAC.Stan.Pool,<N>  FireDAC.Stan.Async, FireDAC.Phys, FireDAC.VCLUI.Wait, FireDAC.Comp.Client;<N><N>
type<N>  TFireDacQuery = class(TInterfacedObject,IQuery)<N>  private<N>    FQuery: TFDQuery;<N>    FConexao: IConexao;<N>  public<N>    constructor Create(aValue: IConexao);<N>    destructor Destroy; override;<N>    class function New(aValue: IConexao): IQuery;<N>    function Query: TObject;<N>    function Open(aSQL: String): IQuery;<N>    function ExecSQL(aSQL: String): IQuery;<N>  end;<N><N>
implementation<N><N>uses<N>  System.SysUtils;<N><N>{ IFireDacQuery }<N><N>constructor TFireDacQuery.Create(aValue: IConexao);<N>begin<N>  FConexao := aValue;<N>  FQuery := TFDQuery.Create(Nil);<N>  FQuery.Connection := TFDConnection(FConexao.Connection);<N>end;<N><N>
destructor TFireDacQuery.Destroy;<N>begin<N>  FreeAndNil(FQuery);<N>  inherited;<N>end;<N><N>function TFireDacQuery.ExecSQL(aSQL: String): IQuery;<N>begin<N>  Result := Self;<N>  FQuery.ExecSQL(aSQL);<N>end;<N><N>class function TFireDacQuery.New(aValue: IConexao): IQuery;<N>begin<N>  Result := Self.Create(aValue);<N>end;<N><N>
unit DAO.EntidadeFactory;<N><N>interface<N><N>uses<N>  DAO.Conexao, DAO.Entidade;<N><N>type<N>  TEntidadesFactory = class(TInterfacedObject,IEntidadeFactory)<N>  private<N>    FPessoa: IEntidade;<N>  public<N>    constructor Create;<N>    destructor Destroy; override;<N>    class function New: IEntidadeFactory;<N>    function Pessoa: IEntidade;<N>  end;<N><N>
<N>implementation<N><N>{ TEntidadesFactory }<N><N>constructor TEntidadesFactory.Create;<N>begin<N><N>end;<N><N>destructor TEntidadesFactory.Destroy;<N>begin<N>  inherited;<N>end;<N><N>class function TEntidadesFactory.New: iEntidadeFactory;<N>begin<N>  Result := Self.Create;<N>end;<N><N>
unit DAO.ConexaoFactory;<N><N>interface<N><N>uses<N>  DAO.Conexao, DAO.ConFiredDAC, DAO.Query;<N><N>type<N>  TConexaoFactory = class(TInterfacedObject,IConexaoFactory)<N>  private<N>  public<N>    constructor Create;<N>    destructor Destroy; override;<N>    class function New: IConexaoFactory;<N>    function Conexao: IConexao;<N>    function Query: IQuery;<N>  end;<N><N>
implementation<N><N>{ TConexaoFactory }<N><N>function TConexaoFactory.Conexao: IConexao;<N>begin<N>  Result := TFireDacConexao.New;<N>end;<N><N>constructor TConexaoFactory.Create;<N>begin<N><N>end;<N><N>destructor TConexaoFactory.Destroy;<N>begin<N>  inherited;<N>end;<N><N>
unit DAO.Conexao;<N><N>interface<N><N>uses<N>  Data.DB;<N><N>type<N>  IQuery = interface;<N><N>  IConexao = interface<N>    function Connection: TObject;<N>  end;<N><N>  IConexaoFactory = interface<N>    function Conexao: IConexao;<N>    function Query: IQuery;<N>  end;<N><N>
  IQuery = interface<N>    function Query: TObject;<N>    function Open(aSQL: String): IQuery;<N>    function ExecSQL(aSQL: String): IQuery;<N>  end;<N><N>  IEntidade = interface<N>    function DataSet(aValue: TDataSource): IEntidade;<N>    procedure Open;<N>    procedure ExecSQL(aSQL: String);<N>  end;<N><N>
unit DAO.Entidade;<N><N>interface<N><N>uses<N>  Data.DB, DAO.Conexao, DAO.ConexaoFactory;<N><N>type<N>  TEntidadePessoa = class(TInterfacedObject,IEntidade)<N>  private<N>    FQuery: IQuery;<N>  public<N>    constructor Create;<N>    destructor Destroy; override;<N>    class function New: IEntidade;<N>    function DataSet(aValue: TDataSource): IEntidade;<N>    procedure Open;<N>    procedure ExecSQL(aSQL: String);<N>  end;<N><N>
implementation<N><N>uses<N>  System.Classes, System.SysUtils;<N><N>{ TEntidadeProduto }<N><N>constructor TEntidadePessoa.Create;<N>begin<N>  FQuery := TConexaoFactory.New.Query;<N>end;<N><N>function TEntidadePessoa.DataSet(aValue: TDataSource): IEntidade;<N>begin<N>  Result := Self;<N>  aValue.DataSet := TDataSet(FQuery.Query);<N>end;<N><N>
destructor TEntidadePessoa.Destroy;<N>begin<N>  inherited;<N>end;<N><N>procedure TEntidadePessoa.ExecSQL(aSQL: String);<N>begin<N>  FQuery.ExecSQL(aSQL);<N>end;<N><N>class function TEntidadePessoa.New: IEntidade;<N>begin<N>  Result := Self.Create;<N>end;<N><N>
unit DAO.ConFiredDAC;<N><N>interface<N><N>uses<N>  DAO.Conexao, Data.DB, FireDAC.Stan.Intf, FireDAC.Stan.Option, FireDAC.Stan.Error,<N>  FireDAC.UI.Intf, FireDAC.Phys.Intf, FireDAC.Stan.Def, FireDAC.Stan.Pool,<N>  FireDAC.Stan.Async, FireDAC.Phys, FireDAC.VCLUI.Wait, FireDAC.Comp.Client,<N>  FireDAC.Phys.PGDef, FireDAC.Phys.PG, FireDAC.DApt;<N><N>
<N>type<N>  TFireDacConexao = class(TInterfacedObject,IConexao)<N>  private<N>    FConexao: TFDConnection;<N>    FPhysPG: TFDPhysPgDriverLink;<N>  public<N>    constructor Create;<N>    destructor Destroy; override;<N>    class function New: IConexao;<N>    function Connection: TObject;<N>  end;<N><N>
unit View.Manutencao;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Dm.Dados, Vcl.ComCtrls,<N>  Vcl.ToolWin, Vcl.StdCtrls, Vcl.Mask, Vcl.DBCtrls;<N><N>
unit View.Principal;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,<N>  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ToolWin, Vcl.ComCtrls,<N>  System.Actions, Vcl.ActnList, Data.DB, Vcl.Grids, Vcl.DBGrids, Vcl.ExtCtrls,<N>  Datasnap.DBClient, Datasnap.Provider, MidasLib, Dm.Dados;<N><N>
unit Dm.Imagens;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, System.ImageList, Vcl.ImgList, Vcl.Controls;<N><N>type<N>  TdmImagens = class(TDataModule)<N>    img32: TImageList;<N>    img48: TImageList;<N>    img32d: TImageList;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  dmImagens: TdmImagens;<N><N>implementation<N><N>{%CLASSGROUP 'Vcl.Controls.TControl'}<N><N>{$R *.dfm}<N><N>end.<N>
unit Pkg.Json.DTO;<N><N>interface<N><N>uses System.Classes, System.Json, Rest.Json, System.Generics.Collections, Rest.JsonReflect;<N><N>type<N>  TArrayMapper = class<N>  protected<N>    procedure RefreshArray<T>(aSource: TList<T>; var aDestination: TArray<T>);<N>    function List<T>(var aList: TList<T>; aSource: TArray<T>): TList<T>;<N>    function ObjectList<T: class>(var aList: TObjectList<T>; aSource: TArray<T>): TObjectList<T>;<N>  public<N>    constructor Create; virtual;<N>  end;<N><N>
unit Evaluador;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>implementation<N><N>end.<N><N>
unit Edit;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ComCtrls, sRichEdit, Buttons, sBitBtn, sMemo;<N><N>type<N>  TEditForm = class(TForm)<N>    sBitBtn21: TsBitBtn;<N>    sRichEdit1: TsMemo;<N>    procedure FormShow(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit Unit2;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, Buttons, sBitBtn;<N><N>type<N>  TPreStartMentalTest = class(TForm)<N>    sBitBtn3: TsBitBtn;<N>    sBitBtn1: TsBitBtn;<N>    Label1: TLabel;<N>    procedure sBitBtn1Click(Sender: TObject);<N>    procedure sBitBtn3Click(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit Prowerka;<N><N>interface<N><N>uses<N>  SysUtils, Classes;<N><N>type<N>  TDataModule1 = class(TDataModule)<N>    //procedure DataModuleCreate(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  DataModule1: TDataModule1;<N><N>implementation<N> // uses Key, Entry;<N>{$R *.dfm}<N><N><N><N>end.<N>
unit CompleXityEditor;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, Buttons, sBitBtn, Grids, DBGrids, acDBGrid, sSpinEdit,<N>  sLabel, sButton, sEdit, sGroupBox, Data.DB;<N><N>
unit EditStudents;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, Buttons, sBitBtn, Grids, DBGrids, acDBGrid, sComboBox,<N>  sLabel, sEdit, sGroupBox, sButton, EncdDecd, Data.DB, Vcl.Mask, sMaskEdit,<N>  sCustomComboEdit;<N><N>
unit Mercado.Libre.View;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms,<N>  Vcl.Dialogs, Vcl.StdCtrls;<N><N>type<N>  TFrmMercadoLibre = class(TForm)<N>    btnGetUserInfo: TButton;<N>    memoResponse: TMemo;<N>    editUserID: TEdit;<N>    editAccess_Token: TEdit;<N>    procedure btnGetUserInfoClick(Sender: TObject);<N>  end;<N><N>
var<N>  FrmMercadoLibre: TFrmMercadoLibre;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses REST.Types, RESTRequest4D, Mercado.Libre.Consts;<N><N>procedure TFrmMercadoLibre.btnGetUserInfoClick(Sender: TObject);<N>var<N>  LResponse: RESTRequest4D.IResponse;<N>begin<N>  if Trim(editUserID.Text) = EmptyStr then<N>    Exit;<N>  if Trim(editAccess_Token.Text) = EmptyStr then<N>    Exit;<N><N>
  LResponse := RESTRequest4D.TRequest.New<N>    .BaseURL(ML_APIBASE)<N>    .Resource(ML_GET_USR_INF_REGEX)<N>    .AddUrlSegment('cust_id', editUserID.Text)<N>    .Token('Bearer ' + editAccess_Token.Text)<N>    .Accept(REST.Types.CONTENTTYPE_APPLICATION_JSON)<N>    .RaiseExceptionOn500(True)<N>    .Get;<N><N>
  memoResponse.Lines.Clear;<N>  memoResponse.Lines.Add(Format('Http status: %d', [LResponse.StatusCode]));<N>  memoResponse.Lines.Add(Format('Http text: %s', [LResponse.StatusText]));<N>  memoResponse.Lines.Add(Format('Response content: %s', [LResponse.Content]));<N>end;<N><N>
unit Samples.Main;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms,<N>  Vcl.Dialogs, Vcl.StdCtrls, FireDAC.Stan.Intf, FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS,<N>  FireDAC.Phys.Intf, FireDAC.DApt.Intf, Data.DB, FireDAC.Comp.DataSet, FireDAC.Comp.Client, Vcl.ExtCtrls, Vcl.ComCtrls,<N>  Vcl.Imaging.pngimage;<N><N>
unit RESTRequest4D.Request.NetHTTP;<N><N>interface<N><N>uses System.Net.Mime, System.Net.HttpClientComponent, System.Net.HttpClient, RESTRequest4D.Request.Contract, System.Classes,<N>  Data.DB, System.JSON, System.SysUtils, REST.Json, IdURI, System.NetEncoding, RESTRequest4D.Utils, DataSet.Serialize,<N>  RESTRequest4D.Response.NetHTTP, RESTRequest4D.Response.Contract, System.Net.URLClient;<N><N>
unit RESTRequest4D.Request.Indy;<N><N>{$IFDEF FPC}<N>  {$mode delphi}<N>{$ENDIF}<N><N>interface<N><N>uses RESTRequest4D.Request.Contract, RESTRequest4D.Response.Contract, IdHTTP, IdSSLOpenSSL, IdCTypes, IdSSLOpenSSLHeaders,<N>  RESTRequest4D.Utils,<N>  {$IFDEF FPC}<N>    DB, Classes, fpjson, jsonparser, fpjsonrtti, SysUtils;<N>  {$ELSE}<N>    Data.DB, System.Classes, System.JSON, System.SysUtils, REST.Json;<N>  {$ENDIF}<N><N>
unit RESTRequest4D.Response.Indy;<N><N>{$IFDEF FPC}<N>  {$mode delphi}<N>{$ENDIF}<N><N>interface<N><N>uses RESTRequest4D.Response.Contract, IdHTTP,<N>  {$IFDEF FPC}<N>    SysUtils, fpjson, Classes, jsonparser;<N>  {$ELSE}<N>    System.SysUtils, System.JSON, System.Classes;<N>  {$ENDIF}<N><N>
unit RESTRequest4D;<N><N>interface<N><N>uses<N>{$IF NOT (DEFINED(RR4D_INDY) or DEFINED(FPC) or DEFINED(RR4D_NETHTTP))}<N>  REST.Types,<N>{$ENDIF}<N>  RESTRequest4D.Request.Contract, RESTRequest4D.Response.Contract;<N><N>type<N>  IRequest = RESTRequest4D.Request.Contract.IRequest;<N>  IResponse = RESTRequest4D.Response.Contract.IResponse;<N><N>
  TRequest = class<N>  public<N>    class function New: IRequest;<N>  end;<N><N>{$IF NOT (DEFINED(RR4D_INDY) or DEFINED(FPC) or DEFINED(RR4D_NETHTTP))}<N>const<N>  poDoNotEncode = REST.Types.poDoNotEncode;<N>  poTransient = REST.Types.poTransient;<N>  poAutoCreated = REST.Types.poAutoCreated;<N>  {$IF COMPILERVERSION >= 33}<N>  poFlatArray = REST.Types.poFlatArray;<N>  poPHPArray = REST.Types.poPHPArray;<N>  poListArray = REST.Types.poListArray;<N>  {$ENDIF}<N><N>
  pkCOOKIE = REST.Types.pkCOOKIE;<N>  pkGETorPOST = REST.Types.pkGETorPOST;<N>  pkURLSEGMENT = REST.Types.pkURLSEGMENT;<N>  pkHTTPHEADER = REST.Types.pkHTTPHEADER;<N>  pkREQUESTBODY = REST.Types.pkREQUESTBODY;<N>  {$IF COMPILERVERSION >= 32}<N>  pkFILE = REST.Types.pkFILE;<N>  {$ENDIF}<N>  {$IF COMPILERVERSION >= 33}<N>  pkQUERY = REST.Types.pkQUERY;<N>  {$ENDIF}<N>{$ENDIF}<N><N>
implementation<N><N>uses<N>{$IF DEFINED(RR4D_INDY) or DEFINED(FPC)}<N>  RESTRequest4D.Request.Indy;<N>{$ELSEIF DEFINED(RR4D_NETHTTP)}<N>  RESTRequest4D.Request.NetHTTP;<N>{$ELSE}<N>  RESTRequest4D.Request.Client;<N>{$ENDIF}<N><N>class function TRequest.New: IRequest;<N>begin<N>{$IF DEFINED(RR4D_INDY) or DEFINED(FPC)}<N>  Result := TRequestIndy.Create;<N>{$ELSEIF DEFINED(RR4D_NETHTTP)}<N>  Result := TRequestNetHTTP.Create;<N>{$ELSE}<N>  Result := TRequestClient.Create;<N>{$ENDIF}<N>end;<N><N>
unit RESTRequest4D.Request.Client;<N><N>interface<N><N>uses RESTRequest4D.Request.Contract, Data.DB, REST.Client, REST.Response.Adapter, REST.Types, System.SysUtils, System.Classes,<N>  RESTRequest4D.Response.Contract, System.JSON, {$IF COMPILERVERSION >= 33}System.Net.HttpClient{$ENDIF}, REST.Authenticator.Basic<N>  {$if CompilerVersion <= 32.0}, IPPeerClient{$endif};<N><N>
unit RESTRequest4D.Utils;<N><N>interface<N><N>{$IFNDEF FPC}<N>uses DB;<N>{$ENDIF}<N><N>type<N>  TMethodRequest = (mrGET, mrPOST, mrPUT, mrPATCH, mrDELETE);<N><N>  TRESTRequest4DelphiUtils = class<N>  public<N>    {$IFNDEF FPC}<N>    class procedure ActiveCachedUpdates(const ADataSet: TDataSet; const AActive: Boolean = True);<N>    {$ENDIF}<N>  end;<N><N>
unit RESTRequest4D.Request.Contract;<N><N>interface<N><N>uses RESTRequest4D.Response.Contract,<N>  {$IF NOT (DEFINED(RR4D_INDY) or DEFINED(FPC) or DEFINED(RR4D_NETHTTP))}<N>    REST.Types,<N>  {$ENDIF}<N>  {$IFDEF FPC}<N>    SysUtils, fpjson, Classes, DB;<N>  {$ELSE}<N>    System.SysUtils, System.JSON, System.Classes, Data.DB;<N>  {$ENDIF}<N><N>
Library Apache;<N><N>{$DEFINE Apache2_4}<N>{$DEFINE FPCAPACHE_2_4}<N>{$MODE DELPHI}{$H+}<N><N>Uses<N>{$ifdef unix}<N>  cthreads,<N>{$endif}<N>  Horse, httpd24, fpApache24, custapache24;<N><N>const<N>  ModuleName = 'apache_horse_module';<N><N>var<N>  ApacheModuleData : module; {$ifdef unix} public name ModuleName;{$endif unix}<N><N>
exports ApacheModuleData name ModuleName;<N><N>procedure GetPing(Req: THorseRequest; Res: THorseResponse; Next: TNextProc);<N>begin<N>  Res.Send('pong');<N>end;<N><N>begin<N><N>  THorse.Get('/ping', GetPing);<N><N>  THorse.DefaultModule := @ApacheModuleData;<N>  THorse.HandlerName := 'apache_horse_module-handle';<N>  THorse.ModuleName := ModuleName;<N><N>
unit DaemonManager;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, DaemonApp;<N><N>type<N><N>  { TDaemon_Manager }<N><N>  TDaemon_Manager = class(TDaemonMapper)<N>    procedure Daemon_ManagerCreate(Sender: TObject);<N>  private<N><N>
  public<N><N>  end;<N><N>var<N>  Daemon_Manager: TDaemon_Manager;<N><N>implementation<N><N>procedure RegisterMapper;<N>begin<N>  RegisterDaemonMapper(TDaemon_Manager)<N>end;<N><N>{$R *.lfm}<N><N>{ TDaemon_Manager }<N><N>procedure TDaemon_Manager.Daemon_ManagerCreate(Sender: TObject);<N>begin<N><N>
unit DaemonMain;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, DaemonApp;<N><N>type<N><N>  { TDaemon_Main }<N><N>  TDaemon_Main = class(TDaemon)<N>    procedure DataModuleCreate(Sender: TObject);<N>    procedure DataModuleShutDown(Sender: TCustomDaemon);<N>    procedure DataModuleStart(Sender: TCustomDaemon; var OK: Boolean);<N>  private<N><N>
  public<N>  end;<N><N>var<N>  Daemon_Main: TDaemon_Main;<N><N>implementation<N><N>uses<N>  Horse;<N><N>procedure RegisterDaemon;<N>begin<N>  RegisterDaemonClass(TDaemon_Main)<N>end;<N><N>procedure RunHorse;<N>begin<N>  THorse.Listen(9000);<N>end;<N><N>procedure Ping(Req: THorseRequest; Res: THorseResponse; Next: TNextProc);<N>begin<N>  Res.Send('pong');<N>end;<N><N>
{$R *.lfm}<N><N>{ TDaemon_Main }<N><N>procedure TDaemon_Main.DataModuleCreate(Sender: TObject);<N>begin<N>  THorse.Get('ping', @Ping);<N>end;<N><N>procedure TDaemon_Main.DataModuleShutDown(Sender: TCustomDaemon);<N>begin<N>  THorse.StopListen;<N>end;<N><N>
unit Main.Service;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.SvcMgr, Vcl.Dialogs;<N><N>type<N>  TMainService = class(TService)<N>    procedure ServiceCreate(Sender: TObject);<N>    procedure ServiceStart(Sender: TService; var Started: Boolean);<N>    procedure ServiceStop(Sender: TService; var Stopped: Boolean);<N>  public<N>    function GetServiceController: TServiceController; override;<N>  end;<N><N>
var<N>  MainService: TMainService;<N><N>implementation<N><N>uses<N>  Horse;<N><N>{$R *.dfm}<N><N>procedure ServiceController(CtrlCode: DWord); stdcall;<N>begin<N>  MainService.Controller(CtrlCode);<N>end;<N><N>function TMainService.GetServiceController: TServiceController;<N>begin<N>  Result := ServiceController;<N>end;<N><N>
procedure TMainService.ServiceCreate(Sender: TObject);<N>begin<N>  THorse.Get('ping',<N>    procedure(Req: THorseRequest; Res: THorseResponse; Next: TProc)<N>    begin<N>      Res.Send('pong');<N>    end);<N>end;<N><N>procedure TMainService.ServiceStart(Sender: TService; var Started: Boolean);<N>begin<N>  THorse.Listen(9000);<N>  Started := True;<N>end;<N><N>
unit Tests.Commons;<N><N>interface<N><N>uses<N>  DUnitX.TestFramework, Horse.Commons;<N><N>type<N>  [TestFixture]<N>  TCommonsTest = class(TObject)<N>  public<N>    [Test]<N>    procedure TestMimeTypesToString;<N>  end;<N><N>implementation<N><N>{ TCommonsTest }<N><N>
unit Controllers.Api;<N><N>interface<N><N>uses<N>  Horse, System.JSON, Horse.Commons;<N><N>procedure Registry;<N>procedure DoGetApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>procedure DoPostApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>procedure DoPutApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>procedure DoDeleteApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N><N>
implementation<N><N>procedure Registry;<N>begin<N>  THorse<N>    .Group<N>      .Prefix('/Api')<N>        .Delete('/Test/:id', DoDeleteApi)<N>        .Route('/Test')<N>          .Get(DoGetApi)<N>          .Post(DoPostApi)<N>          .Put(DoPutApi)<N>end;<N><N>
procedure DoGetApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LList: TJSONArray;<N>  LObject01: TJSONObject;<N>  LObject02: TJSONObject;<N>  LObject03: TJSONObject;<N>begin<N>  LList := TJSONArray.Create;<N><N>  LObject01 := TJSONObject.Create;<N>  LObject01.AddPair(TJSONPair.Create('value', 'test01'));<N>  LList.AddElement(LObject01);<N><N>
  LObject02 := TJSONObject.Create;<N>  LObject02.AddPair(TJSONPair.Create('value', 'test02'));<N>  LList.AddElement(LObject02);<N><N>  LObject03 := TJSONObject.Create;<N>  LObject03.AddPair(TJSONPair.Create('value', 'test03'));<N>  LList.AddElement(LObject03);<N><N>
  Res.Send(LList.ToString);<N>end;<N><N>procedure DoPostApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LValue: string;<N>  LRequest: TJSONObject;<N>  LResponse: TJSONObject;<N>begin<N>  LValue := '';<N>  LRequest := TJSONObject.ParseJSONValue(Req.Body) as TJSONObject;<N><N>
  if (not LRequest.GetValue('value').Null) then<N>    LValue := LRequest.GetValue('value').value;<N><N>  LResponse := TJSONObject.Create;<N>  LResponse.AddPair(TJSONPair.Create('value', LValue));<N><N>  Res.Send(LResponse.ToString).Status(THTTPStatus.Created);<N>end;<N><N>
procedure DoPutApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LValue: string;<N>  LRequest: TJSONObject;<N>  LResponse: TJSONObject;<N>begin<N>  LValue := '';<N>  LRequest := TJSONObject.ParseJSONValue(Req.Body) as TJSONObject;<N><N>  if (not LRequest.GetValue('value').Null) then<N>    LValue := LRequest.GetValue('value').value;<N><N>
  LResponse := TJSONObject.Create;<N>  LResponse.AddPair(TJSONPair.Create('value', LValue));<N><N>  Res.Send(LResponse.ToString);<N>end;<N><N>procedure DoDeleteApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LValue: string;<N>  LResponse: TJSONObject;<N>begin<N>  LValue := Req.Params['id'];<N><N>
﻿unit Web.WebConst;<N><N>interface<N><N>resourcestring<N>  sDuplicateActionName = 'Duplicate action name';<N>  sOnlyOneDispatcher = 'Only one WebDispatcher per form/data module';<N>  sHTTPItemName = 'Name';<N>  sHTTPItemURI = 'PathInfo';<N>  sHTTPItemEnabled = 'Enabled';<N>  sHTTPItemDefault = 'Default';<N>  sHTTPItemProducer = 'Producer';<N>  sHTTPItemMethod = 'Method';<N><N>
unit Horse.Proc;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF NOT DEFINED(FPC)}<N>uses<N>  System.SysUtils;<N>{$ENDIF}<N><N>type<N>  TNextProc = {$IF DEFINED(FPC)} procedure of object {$ELSE} System.SysUtils.TProc {$ENDIF};<N>  TProc = {$IF DEFINED(FPC)} procedure {$ELSE} System.SysUtils.TProc {$ENDIF};<N>{$IF DEFINED(FPC)}<N>  TProc<T> = procedure(Arg1: T);<N>{$ENDIF}<N><N>implementation<N><N>end.<N>
unit Horse.HTTP;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, Generics.Collections, fpHTTP, HTTPDefs,<N>{$ELSE}<N>  System.SysUtils, System.Classes, Web.HTTPApp, System.Generics.Collections,<N>  {$IF CompilerVersion > 32.0}<N>  Web.ReqMulti,<N>  {$ENDIF}<N>{$ENDIF}<N>  Horse.Commons;<N><N>
unit Horse.Provider.FPC.Apache;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_APACHE) AND DEFINED(FPC)}<N><N>uses<N>{$IFDEF unix}<N>  cthreads,<N>{$ENDIF}<N>  fphttp, httpdefs, httpd24, fpApache24, custapache24, SysUtils, Classes,<N>  Horse.Provider.Abstract, Horse.Constants, Horse.Proc;<N><N>
unit Horse.Exception;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>  {$IF DEFINED(FPC)}<N>  SysUtils,<N>  {$ELSE}<N>  System.SysUtils,<N>  {$ENDIF}<N>  Horse.Commons;<N><N>type<N>  EHorseCallbackInterrupted = class(Exception)<N>    constructor Create; reintroduce;<N>  end;<N><N>
unit Horse.Provider.FPC.Daemon;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_DAEMON)}<N><N>uses<N>  SysUtils, Classes, httpdefs, fpHTTP, fphttpserver, Horse.HTTP, HOrse.Core,<N>  Horse.Provider.Abstract, Horse.Constants, Horse.Proc, Horse.Commons,<N>  Horse.Exception;<N><N>
{ ****************************************************************************** }<N>{ }<N>{ Linux Daemon with Delphi }<N>{ }<N>{ Author: Paolo Rossi (2017) }<N>{ }<N>{ http://www.paolorossi.net }<N>{ http://blog.paolorossi.net }<N>{ https://github.com/paolo-rossi }<N>{ }<N>{ ****************************************************************************** }<N>unit ThirdParty.Posix.Syslog;<N><N>
unit Horse.Core.Group.Contract;<N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N>interface<N><N>uses<N>  Horse.Core.Route.Contract, Horse.Core.RouterTree;<N><N>type<N>   IHorseCoreGroup<T: class> = interface<N>    ['{5EB734D6-6944-473E-9C79-506647E2F5E8}']<N>    function Prefix(APrefix: string): IHorseCoreGroup<T>;<N>    function Route(APath: string): IHorseCoreRoute<T>;<N><N>
    function Use(ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Use(AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Use(ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Use(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    function Get(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Get(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Get(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Get(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    function Put(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Put(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Put(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Put(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    {$IF (defined(fpc) or (CompilerVersion > 27.0))}<N>    function Patch(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Patch(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Patch(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Patch(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    {$IFEND}<N><N>
    function Head(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Head(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Head(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Head(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    function Post(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Post(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Post(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Post(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
unit Horse.WebModule;<N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, httpdefs, fpHTTP, fpWeb,<N>{$ELSE}<N>  System.SysUtils, System.Classes, Web.HTTPApp,<N>{$ENDIF}<N>  Horse.Core, Horse.Commons;<N><N>
unit Horse.Provider.FPC.HTTPApplication;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(FPC)}<N><N>uses<N>  SysUtils, Classes, httpdefs, fpHTTP, fphttpapp,<N>  Horse.Provider.Abstract, Horse.Constants, Horse.Proc;<N><N>
unit Horse.Provider.FPC.FastCGI;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(FPC) AND DEFINED(HORSE_FCGI)}<N><N>uses<N>  SysUtils, Classes, fpFCGI, httpdefs, fpHTTP,<N>  Horse.Provider.Abstract, Horse.Constants, Horse.Proc;<N><N>
unit Horse.Provider.FPC.CGI;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_CGI) AND DEFINED(FPC)}<N><N>uses<N>  SysUtils, Classes, fpCGI, fphttp, httpdefs,<N>  Horse.Provider.Abstract, Horse.Proc;<N><N>type<N><N>
unit Horse.Core.Group;<N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils,<N>{$ELSE}<N>  System.SysUtils,<N>{$ENDIF}<N>  Horse.Core.Group.Contract, Horse.Core.Route.Contract, Horse.Core.RouterTree;<N><N>
type<N>  THorseCoreGroup<T: class> = class(TInterfacedObject, IHorseCoreGroup<T>)<N>  private<N>    FHorseCore: TObject;<N>    FPrefix: string;<N>    function NormalizePath(APath: string): string;<N>  public<N>    constructor Create;<N><N>    function Prefix(APrefix: string): IHorseCoreGroup<T>;<N>    function Route(APath: string): IHorseCoreRoute<T>;<N><N>
    function Use(ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Use(AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Use(ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Use(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    function Get(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Get(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Get(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Get(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    function Put(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Put(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Put(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Put(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    {$IF (defined(fpc) or (CompilerVersion > 27.0))}<N>    function Patch(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Patch(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Patch(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Patch(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    {$IFEND}<N><N>
    function Head(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Head(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Head(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Head(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    function Post(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Post(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Post(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Post(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
unit Horse.Provider.VCL;<N><N>interface<N><N>{$IF DEFINED(HORSE_VCL)}<N>uses<N>  Horse.Provider.Abstract, Horse.Constants, IdHTTPWebBrokerBridge, IdSSLOpenSSL,<N>  IdContext, System.Classes, System.SyncObjs, System.SysUtils;<N><N>type<N>  THorseProviderIOHandleSSL = class;<N>  THorseProvider<T: class> = class;<N><N>
unit Horse.Provider.Daemon;<N><N>interface<N><N>{$IF DEFINED(HORSE_DAEMON) AND NOT DEFINED(FPC)}<N><N><N>uses<N><N>  Horse.Provider.Abstract, Horse.Constants, IdHTTPWebBrokerBridge, IdSSLOpenSSL, IdContext,<N>  System.SyncObjs, System.SysUtils, Posix.SysTypes;<N><N>
unit Horse.Constants;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>const<N>  DEFAULT_HOST = '0.0.0.0';<N>  DEFAULT_PORT = 9000;<N>  HORSE_ENV = 'HORSE_ENV';<N>  ENV_D = 'd';<N>  ENV_DEV = 'dev';<N>  ENV_DEVELOPMENT = 'development';<N>  START_RUNNING = 'Server is runing on %s:%d';<N><N>implementation<N><N>end.<N>
unit Horse.Commons;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$MODESWITCH TypeHelpers}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(FPC)}<N>uses Classes, SysUtils;<N>{$ENDIF}<N><N>type<N>{$IF DEFINED(FPC)}<N>  TMethodType = (mtAny, mtGet, mtPut, mtPost, mtHead, mtDelete, mtPatch);<N>{$ENDIF}<N><N>
unit Horse.Core.RouterTree;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections, fpHTTP, httpprotocol,<N>{$ELSE}<N>  System.SysUtils, System.NetEncoding, Web.HTTPApp, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.HTTP, Horse.Proc, Horse.Commons;<N><N>
unit Horse.Provider.Console;<N><N>interface<N><N>{$IF NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, Horse.Constants, IdHTTPWebBrokerBridge, IdSSLOpenSSL, IdContext, System.Classes, System.SyncObjs,<N>  System.SysUtils;<N><N>type<N>  THorseProviderIOHandleSSL = class;<N>  THorseProvider<T: class> = class;<N><N>
unit Horse.Core;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils,<N>{$ELSE}<N>  System.SysUtils, Web.HTTPApp,<N>{$ENDIF}<N>  Horse.Core.RouterTree, Horse.Commons,<N>  Horse.Core.Group.Contract, Horse.Core.Route.Contract;<N><N>
unit Horse.Core.Route;<N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N>interface<N><N>uses<N>  {$IF DEFINED(FPC)}<N>    SysUtils,<N>  {$ELSE}<N>    System.SysUtils,<N>  {$ENDIF}<N>  Horse.Core.Route.Contract, Horse.Core.RouterTree;<N><N>type<N>  THorseCoreRoute<T: class> = class(TInterfacedObject, IHorseCoreRoute<T>)<N>  private<N>    FPath: string;<N>    FHorseCore: TObject;<N>  public<N>    constructor Create(APath: string);<N><N>
    function This: IHorseCoreRoute<T>;<N><N>    function All(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    function Get(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Get(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Get(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Get(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    function Put(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Put(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Put(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Put(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    {$IF (defined(fpc) or (CompilerVersion > 27.0))}<N>    function Patch(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Patch(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Patch(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Patch(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Head(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Head(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Head(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Head(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    function Post(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Post(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Post(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Post(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    {$IF (defined(fpc) or (CompilerVersion > 27.0))}<N>    function Delete(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Delete(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Delete(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Delete(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function &End: T;<N>  end;<N><N>implementation<N><N>uses<N>  Horse.Core;<N><N>{ THorseCoreRoute }<N><N>constructor THorseCoreRoute<T>.Create(APath: string);<N>begin<N>  FPath := APath;<N>  FHorseCore := THorseCore.GetInstance;<N>end;<N><N>function THorseCoreRoute<T>.This: IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>end;<N><N>
function THorseCoreRoute<T>.All(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Use(FPath, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.All(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Use(FPath, [AMiddleware, ACallback]);<N>end;<N><N>
function THorseCoreRoute<T>.All(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Use(FPath, ACallbacks);<N>end;<N><N>function THorseCoreRoute<T>.&End: T;<N>begin<N>  Result := FHorseCore as T;<N>end;<N><N>
function THorseCoreRoute<T>.All(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Use(FPath, ACallbacks);<N>  THorseCore(FHorseCore).Use(FPath, [ACallback]);<N>end;<N><N>
{$IF (defined(fpc) or (CompilerVersion > 27.0))}<N>function THorseCoreRoute<T>.Delete(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Delete(FPath, ACallbacks);<N>end;<N><N>function THorseCoreRoute<T>.Delete(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Delete(FPath, AMiddleware, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Delete(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Delete(FPath, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.Delete(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Delete(FPath, ACallbacks, ACallback);<N>end;<N>{$IFEND}<N><N>
function THorseCoreRoute<T>.Get(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Get(FPath, AMiddleware, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.Get(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Get(FPath, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Get(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Get(FPath, ACallbacks);<N>end;<N><N>function THorseCoreRoute<T>.Get(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Get(FPath, ACallbacks, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Head(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Head(FPath, ACallbacks);<N>end;<N><N>function THorseCoreRoute<T>.Head(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Head(FPath, ACallbacks, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Head(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Head(FPath, AMiddleware, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.Head(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Head(FPath, ACallback);<N>end;<N><N>
{$IF (defined(fpc) or (CompilerVersion > 27.0))}<N>function THorseCoreRoute<T>.Patch(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Patch(FPath, ACallbacks, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Patch(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Patch(FPath, ACallbacks);<N>end;<N><N>function THorseCoreRoute<T>.Patch(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Patch(FPath, AMiddleware, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Patch(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Patch(FPath, ACallback);<N>end;<N>{$IFEND}<N><N>function THorseCoreRoute<T>.Post(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Post(FPath, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Post(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Post(FPath, AMiddleware, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.Post(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Post(FPath, ACallbacks);<N>end;<N><N>
function THorseCoreRoute<T>.Post(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Post(FPath, ACallbacks, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.Put(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Put(FPath, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Put(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Put(FPath, AMiddleware, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.Put(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Put(FPath, ACallbacks, ACallback);<N>end;<N><N>
unit DataSet.Serialize.Samples.Basic;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses Classes, SysUtils, memds, DB, Forms, Controls, Graphics, Dialogs, ComCtrls,<N>  ExtCtrls, StdCtrls, DBGrids, fpjson, DataSet.Serialize, TypInfo;<N><N>type<N><N>  { TFrmBasic }<N><N>
unit DataSet.Serialize.Samples.Basic;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics, System.JSON, Vcl.Controls,<N>  Vcl.Forms, Vcl.Dialogs, Vcl.ComCtrls, Vcl.ExtCtrls, Vcl.StdCtrls, Data.DB, Vcl.Grids, Vcl.DBGrids, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, DataSet.Serialize;<N><N>
unit DataSet.Serialize.Samples.Master.Detail;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.ComCtrls, Vcl.StdCtrls, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf, Data.DB, FireDAC.Comp.DataSet,<N>  FireDAC.Comp.Client, Vcl.Grids, Vcl.DBGrids, DataSet.Serialize, System.JSON;<N><N>
unit DataSet.Serialize.Utils;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson, SysUtils, Classes;<N>{$ELSE}<N>  {$IF CompilerVersion >= 20}System.Character,{$ENDIF} System.DateUtils, System.JSON, Data.DB, System.SysUtils, System.Classes;<N>{$ENDIF}<N><N>
type<N>  /// <summary><N>  ///   API error class (default).<N>  /// </summary><N>  EDataSetSerializeException = class(Exception);<N><N>  /// <summary><N>  ///   Type to get key values of an dataset.<N>  /// </summary><N>  TKeyValues = array of Variant;<N><N>
  /// <summary><N>  ///   Record representing the structure of a dataset field.<N>  /// </summary><N>  TFieldStructure = record<N>    Alignment: TAlignment;<N>    FieldType: TFieldType;<N>    Size: Integer;<N>    Precision: Integer;<N>    FieldName: string;<N>    Origin: string;<N>    DisplayLabel: string;<N>    Key: Boolean;<N>    Required: Boolean;<N>    Visible: Boolean;<N>    ReadOnly: Boolean;<N>    {$IF NOT DEFINED(FPC)}<N>    AutoGenerateValue: TAutoRefreshFlag;<N>    {$ENDIF}<N>  end;<N><N>
unit DataSet.Serialize.Language;<N><N>interface<N><N>type<N>  /// <summary><N>  ///   Languages handled by helper Validate (JSON).<N>  /// </summary><N>  TLanguageType = (ptBR, enUS);<N><N>implementation<N><N>end.<N>
unit DataSet.Serialize;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson,<N>{$ELSE}<N>  System.JSON, Data.DB,<N>{$ENDIF}<N>  DataSet.Serialize.Language, DataSet.Serialize.Config;<N><N>type<N>  TLanguageType = DataSet.Serialize.Language.TLanguageType;<N>  TDataSetSerializeConfig = DataSet.Serialize.Config.TDataSetSerializeConfig;<N>  TCaseNameDefinition = DataSet.Serialize.Config.TCaseNameDefinition;<N><N>
unit DataSet.Serialize.UpdatedStatus;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB;<N>{$ELSE}<N>  Data.DB;<N>{$ENDIF}<N><N>type<N>  TUpdateStatusHelper = record helper for TUpdateStatus<N>    function ToString: string;<N>  end;<N><N>
implementation<N><N>function TUpdateStatusHelper.ToString: string;<N>begin<N>  case Self of<N>    usModified:<N>      Result := 'MODIFIED';<N>    usInserted:<N>      Result := 'INSERTED';<N>    usDeleted:<N>      Result := 'DELETED';<N>  else<N>    Result := 'UNMODIFIED';<N>  end;<N>end;<N><N>
﻿unit DataSet.Serialize.Import;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson,<N>{$ELSE}<N>  System.JSON, Data.DB, System.StrUtils, System.SysUtils, System.Rtti,<N>  {$IF CompilerVersion >= 20}<N>    System.Character,<N>  {$ENDIF}<N>{$ENDIF}<N>  DataSet.Serialize.Language, DataSet.Serialize.Utils;<N><N>
unit Mercado.Libre.View;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms,<N>  Vcl.Dialogs, Vcl.StdCtrls;<N><N>type<N>  TFrmMercadoLibre = class(TForm)<N>    btnGetUserInfo: TButton;<N>    memoResponse: TMemo;<N>    editUserID: TEdit;<N>    editAccess_Token: TEdit;<N>    procedure btnGetUserInfoClick(Sender: TObject);<N>  end;<N><N>
var<N>  FrmMercadoLibre: TFrmMercadoLibre;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses REST.Types, RESTRequest4D, Mercado.Libre.Consts;<N><N>procedure TFrmMercadoLibre.btnGetUserInfoClick(Sender: TObject);<N>var<N>  LResponse: RESTRequest4D.IResponse;<N>begin<N>  if Trim(editUserID.Text) = EmptyStr then<N>    Exit;<N>  if Trim(editAccess_Token.Text) = EmptyStr then<N>    Exit;<N><N>
  LResponse := RESTRequest4D.TRequest.New<N>    .BaseURL(ML_APIBASE)<N>    .Resource(ML_GET_USR_INF_REGEX)<N>    .AddUrlSegment('cust_id', editUserID.Text)<N>    .Token('Bearer ' + editAccess_Token.Text)<N>    .Accept(REST.Types.CONTENTTYPE_APPLICATION_JSON)<N>    .RaiseExceptionOn500(True)<N>    .Get;<N><N>
  memoResponse.Lines.Clear;<N>  memoResponse.Lines.Add(Format('Http status: %d', [LResponse.StatusCode]));<N>  memoResponse.Lines.Add(Format('Http text: %s', [LResponse.StatusText]));<N>  memoResponse.Lines.Add(Format('Response content: %s', [LResponse.Content]));<N>end;<N><N>
unit Samples.Main;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms,<N>  Vcl.Dialogs, Vcl.StdCtrls, FireDAC.Stan.Intf, FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS,<N>  FireDAC.Phys.Intf, FireDAC.DApt.Intf, Data.DB, FireDAC.Comp.DataSet, FireDAC.Comp.Client, Vcl.ExtCtrls, Vcl.ComCtrls,<N>  Vcl.Imaging.pngimage;<N><N>
unit RESTRequest4D.Request.NetHTTP;<N><N>interface<N><N>uses System.Net.Mime, System.Net.HttpClientComponent, System.Net.HttpClient, RESTRequest4D.Request.Contract, System.Classes,<N>  Data.DB, System.JSON, System.SysUtils, REST.Json, IdURI, System.NetEncoding, RESTRequest4D.Utils, DataSet.Serialize,<N>  RESTRequest4D.Response.NetHTTP, RESTRequest4D.Response.Contract, System.Net.URLClient;<N><N>
unit RESTRequest4D.Request.Indy;<N><N>{$IFDEF FPC}<N>  {$mode delphi}<N>{$ENDIF}<N><N>interface<N><N>uses RESTRequest4D.Request.Contract, RESTRequest4D.Response.Contract, IdHTTP, IdSSLOpenSSL, IdCTypes, IdSSLOpenSSLHeaders,<N>  RESTRequest4D.Utils,<N>  {$IFDEF FPC}<N>    DB, Classes, fpjson, jsonparser, fpjsonrtti, SysUtils;<N>  {$ELSE}<N>    Data.DB, System.Classes, System.JSON, System.SysUtils, REST.Json;<N>  {$ENDIF}<N><N>
unit RESTRequest4D.Response.Indy;<N><N>{$IFDEF FPC}<N>  {$mode delphi}<N>{$ENDIF}<N><N>interface<N><N>uses RESTRequest4D.Response.Contract, IdHTTP,<N>  {$IFDEF FPC}<N>    SysUtils, fpjson, Classes, jsonparser;<N>  {$ELSE}<N>    System.SysUtils, System.JSON, System.Classes;<N>  {$ENDIF}<N><N>
unit RESTRequest4D;<N><N>interface<N><N>uses<N>{$IF NOT (DEFINED(RR4D_INDY) or DEFINED(FPC) or DEFINED(RR4D_NETHTTP))}<N>  REST.Types,<N>{$ENDIF}<N>  RESTRequest4D.Request.Contract, RESTRequest4D.Response.Contract;<N><N>type<N>  IRequest = RESTRequest4D.Request.Contract.IRequest;<N>  IResponse = RESTRequest4D.Response.Contract.IResponse;<N><N>
  TRequest = class<N>  public<N>    class function New: IRequest;<N>  end;<N><N>{$IF NOT (DEFINED(RR4D_INDY) or DEFINED(FPC) or DEFINED(RR4D_NETHTTP))}<N>const<N>  poDoNotEncode = REST.Types.poDoNotEncode;<N>  poTransient = REST.Types.poTransient;<N>  poAutoCreated = REST.Types.poAutoCreated;<N>  {$IF COMPILERVERSION >= 33}<N>  poFlatArray = REST.Types.poFlatArray;<N>  poPHPArray = REST.Types.poPHPArray;<N>  poListArray = REST.Types.poListArray;<N>  {$ENDIF}<N><N>
  pkCOOKIE = REST.Types.pkCOOKIE;<N>  pkGETorPOST = REST.Types.pkGETorPOST;<N>  pkURLSEGMENT = REST.Types.pkURLSEGMENT;<N>  pkHTTPHEADER = REST.Types.pkHTTPHEADER;<N>  pkREQUESTBODY = REST.Types.pkREQUESTBODY;<N>  {$IF COMPILERVERSION >= 32}<N>  pkFILE = REST.Types.pkFILE;<N>  {$ENDIF}<N>  {$IF COMPILERVERSION >= 33}<N>  pkQUERY = REST.Types.pkQUERY;<N>  {$ENDIF}<N>{$ENDIF}<N><N>
implementation<N><N>uses<N>{$IF DEFINED(RR4D_INDY) or DEFINED(FPC)}<N>  RESTRequest4D.Request.Indy;<N>{$ELSEIF DEFINED(RR4D_NETHTTP)}<N>  RESTRequest4D.Request.NetHTTP;<N>{$ELSE}<N>  RESTRequest4D.Request.Client;<N>{$ENDIF}<N><N>class function TRequest.New: IRequest;<N>begin<N>{$IF DEFINED(RR4D_INDY) or DEFINED(FPC)}<N>  Result := TRequestIndy.Create;<N>{$ELSEIF DEFINED(RR4D_NETHTTP)}<N>  Result := TRequestNetHTTP.Create;<N>{$ELSE}<N>  Result := TRequestClient.Create;<N>{$ENDIF}<N>end;<N><N>
unit RESTRequest4D.Request.Client;<N><N>interface<N><N>uses RESTRequest4D.Request.Contract, Data.DB, REST.Client, REST.Response.Adapter, REST.Types, System.SysUtils, System.Classes,<N>  RESTRequest4D.Response.Contract, System.JSON, {$IF COMPILERVERSION >= 33}System.Net.HttpClient{$ENDIF}, REST.Authenticator.Basic<N>  {$if CompilerVersion <= 32.0}, IPPeerClient{$endif};<N><N>
unit RESTRequest4D.Utils;<N><N>interface<N><N>{$IFNDEF FPC}<N>uses DB;<N>{$ENDIF}<N><N>type<N>  TMethodRequest = (mrGET, mrPOST, mrPUT, mrPATCH, mrDELETE);<N><N>  TRESTRequest4DelphiUtils = class<N>  public<N>    {$IFNDEF FPC}<N>    class procedure ActiveCachedUpdates(const ADataSet: TDataSet; const AActive: Boolean = True);<N>    {$ENDIF}<N>  end;<N><N>
unit RESTRequest4D.Request.Contract;<N><N>interface<N><N>uses RESTRequest4D.Response.Contract,<N>  {$IF NOT (DEFINED(RR4D_INDY) or DEFINED(FPC) or DEFINED(RR4D_NETHTTP))}<N>    REST.Types,<N>  {$ENDIF}<N>  {$IFDEF FPC}<N>    SysUtils, fpjson, Classes, DB;<N>  {$ELSE}<N>    System.SysUtils, System.JSON, System.Classes, Data.DB;<N>  {$ENDIF}<N><N>
Library Apache;<N><N>{$DEFINE Apache2_4}<N>{$DEFINE FPCAPACHE_2_4}<N>{$MODE DELPHI}{$H+}<N><N>Uses<N>{$ifdef unix}<N>  cthreads,<N>{$endif}<N>  Horse, httpd24, fpApache24, custapache24;<N><N>const<N>  ModuleName = 'apache_horse_module';<N><N>var<N>  ApacheModuleData : module; {$ifdef unix} public name ModuleName;{$endif unix}<N><N>
exports ApacheModuleData name ModuleName;<N><N>procedure GetPing(Req: THorseRequest; Res: THorseResponse; Next: TNextProc);<N>begin<N>  Res.Send('pong');<N>end;<N><N>begin<N><N>  THorse.Get('/ping', GetPing);<N><N>  THorse.DefaultModule := @ApacheModuleData;<N>  THorse.HandlerName := 'apache_horse_module-handle';<N>  THorse.ModuleName := ModuleName;<N><N>
unit DaemonManager;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, DaemonApp;<N><N>type<N><N>  { TDaemon_Manager }<N><N>  TDaemon_Manager = class(TDaemonMapper)<N>    procedure Daemon_ManagerCreate(Sender: TObject);<N>  private<N><N>
  public<N><N>  end;<N><N>var<N>  Daemon_Manager: TDaemon_Manager;<N><N>implementation<N><N>procedure RegisterMapper;<N>begin<N>  RegisterDaemonMapper(TDaemon_Manager)<N>end;<N><N>{$R *.lfm}<N><N>{ TDaemon_Manager }<N><N>procedure TDaemon_Manager.Daemon_ManagerCreate(Sender: TObject);<N>begin<N><N>
unit DaemonMain;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, DaemonApp;<N><N>type<N><N>  { TDaemon_Main }<N><N>  TDaemon_Main = class(TDaemon)<N>    procedure DataModuleCreate(Sender: TObject);<N>    procedure DataModuleShutDown(Sender: TCustomDaemon);<N>    procedure DataModuleStart(Sender: TCustomDaemon; var OK: Boolean);<N>  private<N><N>
  public<N>  end;<N><N>var<N>  Daemon_Main: TDaemon_Main;<N><N>implementation<N><N>uses<N>  Horse;<N><N>procedure RegisterDaemon;<N>begin<N>  RegisterDaemonClass(TDaemon_Main)<N>end;<N><N>procedure RunHorse;<N>begin<N>  THorse.Listen(9000);<N>end;<N><N>procedure Ping(Req: THorseRequest; Res: THorseResponse; Next: TNextProc);<N>begin<N>  Res.Send('pong');<N>end;<N><N>
{$R *.lfm}<N><N>{ TDaemon_Main }<N><N>procedure TDaemon_Main.DataModuleCreate(Sender: TObject);<N>begin<N>  THorse.Get('ping', @Ping);<N>end;<N><N>procedure TDaemon_Main.DataModuleShutDown(Sender: TCustomDaemon);<N>begin<N>  THorse.StopListen;<N>end;<N><N>
unit Main.Service;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.SvcMgr, Vcl.Dialogs;<N><N>type<N>  TMainService = class(TService)<N>    procedure ServiceCreate(Sender: TObject);<N>    procedure ServiceStart(Sender: TService; var Started: Boolean);<N>    procedure ServiceStop(Sender: TService; var Stopped: Boolean);<N>  public<N>    function GetServiceController: TServiceController; override;<N>  end;<N><N>
var<N>  MainService: TMainService;<N><N>implementation<N><N>uses<N>  Horse;<N><N>{$R *.dfm}<N><N>procedure ServiceController(CtrlCode: DWord); stdcall;<N>begin<N>  MainService.Controller(CtrlCode);<N>end;<N><N>function TMainService.GetServiceController: TServiceController;<N>begin<N>  Result := ServiceController;<N>end;<N><N>
procedure TMainService.ServiceCreate(Sender: TObject);<N>begin<N>  THorse.Get('ping',<N>    procedure(Req: THorseRequest; Res: THorseResponse; Next: TProc)<N>    begin<N>      Res.Send('pong');<N>    end);<N>end;<N><N>procedure TMainService.ServiceStart(Sender: TService; var Started: Boolean);<N>begin<N>  THorse.Listen(9000);<N>  Started := True;<N>end;<N><N>
unit Tests.Commons;<N><N>interface<N><N>uses<N>  DUnitX.TestFramework, Horse.Commons;<N><N>type<N>  [TestFixture]<N>  TCommonsTest = class(TObject)<N>  public<N>    [Test]<N>    procedure TestMimeTypesToString;<N>  end;<N><N>implementation<N><N>{ TCommonsTest }<N><N>
unit Controllers.Api;<N><N>interface<N><N>uses<N>  Horse, System.JSON, Horse.Commons;<N><N>procedure Registry;<N>procedure DoGetApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>procedure DoPostApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>procedure DoPutApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>procedure DoDeleteApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N><N>
implementation<N><N>procedure Registry;<N>begin<N>  THorse<N>    .Group<N>      .Prefix('/Api')<N>        .Delete('/Test/:id', DoDeleteApi)<N>        .Route('/Test')<N>          .Get(DoGetApi)<N>          .Post(DoPostApi)<N>          .Put(DoPutApi)<N>end;<N><N>
procedure DoGetApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LList: TJSONArray;<N>  LObject01: TJSONObject;<N>  LObject02: TJSONObject;<N>  LObject03: TJSONObject;<N>begin<N>  LList := TJSONArray.Create;<N><N>  LObject01 := TJSONObject.Create;<N>  LObject01.AddPair(TJSONPair.Create('value', 'test01'));<N>  LList.AddElement(LObject01);<N><N>
  LObject02 := TJSONObject.Create;<N>  LObject02.AddPair(TJSONPair.Create('value', 'test02'));<N>  LList.AddElement(LObject02);<N><N>  LObject03 := TJSONObject.Create;<N>  LObject03.AddPair(TJSONPair.Create('value', 'test03'));<N>  LList.AddElement(LObject03);<N><N>
  Res.Send(LList.ToString);<N>end;<N><N>procedure DoPostApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LValue: string;<N>  LRequest: TJSONObject;<N>  LResponse: TJSONObject;<N>begin<N>  LValue := '';<N>  LRequest := TJSONObject.ParseJSONValue(Req.Body) as TJSONObject;<N><N>
  if (not LRequest.GetValue('value').Null) then<N>    LValue := LRequest.GetValue('value').value;<N><N>  LResponse := TJSONObject.Create;<N>  LResponse.AddPair(TJSONPair.Create('value', LValue));<N><N>  Res.Send(LResponse.ToString).Status(THTTPStatus.Created);<N>end;<N><N>
procedure DoPutApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LValue: string;<N>  LRequest: TJSONObject;<N>  LResponse: TJSONObject;<N>begin<N>  LValue := '';<N>  LRequest := TJSONObject.ParseJSONValue(Req.Body) as TJSONObject;<N><N>  if (not LRequest.GetValue('value').Null) then<N>    LValue := LRequest.GetValue('value').value;<N><N>
  LResponse := TJSONObject.Create;<N>  LResponse.AddPair(TJSONPair.Create('value', LValue));<N><N>  Res.Send(LResponse.ToString);<N>end;<N><N>procedure DoDeleteApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LValue: string;<N>  LResponse: TJSONObject;<N>begin<N>  LValue := Req.Params['id'];<N><N>
﻿unit Web.WebConst;<N><N>interface<N><N>resourcestring<N>  sDuplicateActionName = 'Duplicate action name';<N>  sOnlyOneDispatcher = 'Only one WebDispatcher per form/data module';<N>  sHTTPItemName = 'Name';<N>  sHTTPItemURI = 'PathInfo';<N>  sHTTPItemEnabled = 'Enabled';<N>  sHTTPItemDefault = 'Default';<N>  sHTTPItemProducer = 'Producer';<N>  sHTTPItemMethod = 'Method';<N><N>
unit Horse.Proc;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF NOT DEFINED(FPC)}<N>uses<N>  System.SysUtils;<N>{$ENDIF}<N><N>type<N>  TNextProc = {$IF DEFINED(FPC)} procedure of object {$ELSE} System.SysUtils.TProc {$ENDIF};<N>  TProc = {$IF DEFINED(FPC)} procedure {$ELSE} System.SysUtils.TProc {$ENDIF};<N>{$IF DEFINED(FPC)}<N>  TProc<T> = procedure(Arg1: T);<N>{$ENDIF}<N><N>implementation<N><N>end.<N>
unit Horse.HTTP;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, Generics.Collections, fpHTTP, HTTPDefs,<N>{$ELSE}<N>  System.SysUtils, System.Classes, Web.HTTPApp, System.Generics.Collections,<N>  {$IF CompilerVersion > 32.0}<N>  Web.ReqMulti,<N>  {$ENDIF}<N>{$ENDIF}<N>  Horse.Commons;<N><N>
unit Horse.Provider.FPC.Apache;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_APACHE) AND DEFINED(FPC)}<N><N>uses<N>{$IFDEF unix}<N>  cthreads,<N>{$ENDIF}<N>  fphttp, httpdefs, httpd24, fpApache24, custapache24, SysUtils, Classes,<N>  Horse.Provider.Abstract, Horse.Constants, Horse.Proc;<N><N>
unit Horse.Exception;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>  {$IF DEFINED(FPC)}<N>  SysUtils,<N>  {$ELSE}<N>  System.SysUtils,<N>  {$ENDIF}<N>  Horse.Commons;<N><N>type<N>  EHorseCallbackInterrupted = class(Exception)<N>    constructor Create; reintroduce;<N>  end;<N><N>
unit Horse.Provider.FPC.Daemon;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_DAEMON)}<N><N>uses<N>  SysUtils, Classes, httpdefs, fpHTTP, fphttpserver, Horse.HTTP, HOrse.Core,<N>  Horse.Provider.Abstract, Horse.Constants, Horse.Proc, Horse.Commons,<N>  Horse.Exception;<N><N>
{ ****************************************************************************** }<N>{ }<N>{ Linux Daemon with Delphi }<N>{ }<N>{ Author: Paolo Rossi (2017) }<N>{ }<N>{ http://www.paolorossi.net }<N>{ http://blog.paolorossi.net }<N>{ https://github.com/paolo-rossi }<N>{ }<N>{ ****************************************************************************** }<N>unit ThirdParty.Posix.Syslog;<N><N>
unit Horse.Core.Group.Contract;<N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N>interface<N><N>uses<N>  Horse.Core.Route.Contract, Horse.Core.RouterTree;<N><N>type<N>   IHorseCoreGroup<T: class> = interface<N>    ['{5EB734D6-6944-473E-9C79-506647E2F5E8}']<N>    function Prefix(APrefix: string): IHorseCoreGroup<T>;<N>    function Route(APath: string): IHorseCoreRoute<T>;<N><N>
    function Use(ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Use(AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Use(ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Use(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    function Get(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Get(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Get(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Get(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    function Put(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Put(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Put(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Put(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    {$IF (defined(fpc) or (CompilerVersion > 27.0))}<N>    function Patch(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Patch(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Patch(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Patch(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    {$IFEND}<N><N>
    function Head(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Head(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Head(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Head(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    function Post(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Post(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Post(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Post(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
unit Horse.WebModule;<N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, httpdefs, fpHTTP, fpWeb,<N>{$ELSE}<N>  System.SysUtils, System.Classes, Web.HTTPApp,<N>{$ENDIF}<N>  Horse.Core, Horse.Commons;<N><N>
unit Horse.Provider.FPC.HTTPApplication;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(FPC)}<N><N>uses<N>  SysUtils, Classes, httpdefs, fpHTTP, fphttpapp,<N>  Horse.Provider.Abstract, Horse.Constants, Horse.Proc;<N><N>
unit Horse.Provider.FPC.FastCGI;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(FPC) AND DEFINED(HORSE_FCGI)}<N><N>uses<N>  SysUtils, Classes, fpFCGI, httpdefs, fpHTTP,<N>  Horse.Provider.Abstract, Horse.Constants, Horse.Proc;<N><N>
unit Horse.Provider.FPC.CGI;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_CGI) AND DEFINED(FPC)}<N><N>uses<N>  SysUtils, Classes, fpCGI, fphttp, httpdefs,<N>  Horse.Provider.Abstract, Horse.Proc;<N><N>type<N><N>
unit Horse.Core.Group;<N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils,<N>{$ELSE}<N>  System.SysUtils,<N>{$ENDIF}<N>  Horse.Core.Group.Contract, Horse.Core.Route.Contract, Horse.Core.RouterTree;<N><N>
type<N>  THorseCoreGroup<T: class> = class(TInterfacedObject, IHorseCoreGroup<T>)<N>  private<N>    FHorseCore: TObject;<N>    FPrefix: string;<N>    function NormalizePath(APath: string): string;<N>  public<N>    constructor Create;<N><N>    function Prefix(APrefix: string): IHorseCoreGroup<T>;<N>    function Route(APath: string): IHorseCoreRoute<T>;<N><N>
    function Use(ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Use(AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Use(ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Use(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    function Get(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Get(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Get(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Get(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    function Put(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Put(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Put(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Put(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    {$IF (defined(fpc) or (CompilerVersion > 27.0))}<N>    function Patch(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Patch(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Patch(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Patch(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    {$IFEND}<N><N>
    function Head(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Head(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Head(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Head(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    function Post(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Post(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Post(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Post(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
unit Horse.Provider.VCL;<N><N>interface<N><N>{$IF DEFINED(HORSE_VCL)}<N>uses<N>  Horse.Provider.Abstract, Horse.Constants, IdHTTPWebBrokerBridge, IdSSLOpenSSL,<N>  IdContext, System.Classes, System.SyncObjs, System.SysUtils;<N><N>type<N>  THorseProviderIOHandleSSL = class;<N>  THorseProvider<T: class> = class;<N><N>
unit Horse.Provider.Daemon;<N><N>interface<N><N>{$IF DEFINED(HORSE_DAEMON) AND NOT DEFINED(FPC)}<N><N><N>uses<N><N>  Horse.Provider.Abstract, Horse.Constants, IdHTTPWebBrokerBridge, IdSSLOpenSSL, IdContext,<N>  System.SyncObjs, System.SysUtils, Posix.SysTypes;<N><N>
unit Horse.Constants;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>const<N>  DEFAULT_HOST = '0.0.0.0';<N>  DEFAULT_PORT = 9000;<N>  HORSE_ENV = 'HORSE_ENV';<N>  ENV_D = 'd';<N>  ENV_DEV = 'dev';<N>  ENV_DEVELOPMENT = 'development';<N>  START_RUNNING = 'Server is runing on %s:%d';<N><N>implementation<N><N>end.<N>
unit Horse.Commons;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$MODESWITCH TypeHelpers}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(FPC)}<N>uses Classes, SysUtils;<N>{$ENDIF}<N><N>type<N>{$IF DEFINED(FPC)}<N>  TMethodType = (mtAny, mtGet, mtPut, mtPost, mtHead, mtDelete, mtPatch);<N>{$ENDIF}<N><N>
unit Horse.Core.RouterTree;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections, fpHTTP, httpprotocol,<N>{$ELSE}<N>  System.SysUtils, System.NetEncoding, Web.HTTPApp, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.HTTP, Horse.Proc, Horse.Commons;<N><N>
unit Horse.Provider.Console;<N><N>interface<N><N>{$IF NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, Horse.Constants, IdHTTPWebBrokerBridge, IdSSLOpenSSL, IdContext, System.Classes, System.SyncObjs,<N>  System.SysUtils;<N><N>type<N>  THorseProviderIOHandleSSL = class;<N>  THorseProvider<T: class> = class;<N><N>
unit Horse.Core;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils,<N>{$ELSE}<N>  System.SysUtils, Web.HTTPApp,<N>{$ENDIF}<N>  Horse.Core.RouterTree, Horse.Commons,<N>  Horse.Core.Group.Contract, Horse.Core.Route.Contract;<N><N>
unit Horse.Core.Route;<N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N>interface<N><N>uses<N>  {$IF DEFINED(FPC)}<N>    SysUtils,<N>  {$ELSE}<N>    System.SysUtils,<N>  {$ENDIF}<N>  Horse.Core.Route.Contract, Horse.Core.RouterTree;<N><N>type<N>  THorseCoreRoute<T: class> = class(TInterfacedObject, IHorseCoreRoute<T>)<N>  private<N>    FPath: string;<N>    FHorseCore: TObject;<N>  public<N>    constructor Create(APath: string);<N><N>
    function This: IHorseCoreRoute<T>;<N><N>    function All(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    function Get(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Get(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Get(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Get(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    function Put(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Put(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Put(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Put(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    {$IF (defined(fpc) or (CompilerVersion > 27.0))}<N>    function Patch(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Patch(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Patch(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Patch(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Head(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Head(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Head(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Head(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    function Post(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Post(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Post(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Post(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    {$IF (defined(fpc) or (CompilerVersion > 27.0))}<N>    function Delete(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Delete(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Delete(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Delete(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function &End: T;<N>  end;<N><N>implementation<N><N>uses<N>  Horse.Core;<N><N>{ THorseCoreRoute }<N><N>constructor THorseCoreRoute<T>.Create(APath: string);<N>begin<N>  FPath := APath;<N>  FHorseCore := THorseCore.GetInstance;<N>end;<N><N>function THorseCoreRoute<T>.This: IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>end;<N><N>
function THorseCoreRoute<T>.All(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Use(FPath, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.All(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Use(FPath, [AMiddleware, ACallback]);<N>end;<N><N>
function THorseCoreRoute<T>.All(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Use(FPath, ACallbacks);<N>end;<N><N>function THorseCoreRoute<T>.&End: T;<N>begin<N>  Result := FHorseCore as T;<N>end;<N><N>
function THorseCoreRoute<T>.All(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Use(FPath, ACallbacks);<N>  THorseCore(FHorseCore).Use(FPath, [ACallback]);<N>end;<N><N>
{$IF (defined(fpc) or (CompilerVersion > 27.0))}<N>function THorseCoreRoute<T>.Delete(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Delete(FPath, ACallbacks);<N>end;<N><N>function THorseCoreRoute<T>.Delete(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Delete(FPath, AMiddleware, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Delete(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Delete(FPath, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.Delete(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Delete(FPath, ACallbacks, ACallback);<N>end;<N>{$IFEND}<N><N>
function THorseCoreRoute<T>.Get(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Get(FPath, AMiddleware, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.Get(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Get(FPath, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Get(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Get(FPath, ACallbacks);<N>end;<N><N>function THorseCoreRoute<T>.Get(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Get(FPath, ACallbacks, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Head(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Head(FPath, ACallbacks);<N>end;<N><N>function THorseCoreRoute<T>.Head(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Head(FPath, ACallbacks, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Head(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Head(FPath, AMiddleware, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.Head(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Head(FPath, ACallback);<N>end;<N><N>
{$IF (defined(fpc) or (CompilerVersion > 27.0))}<N>function THorseCoreRoute<T>.Patch(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Patch(FPath, ACallbacks, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Patch(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Patch(FPath, ACallbacks);<N>end;<N><N>function THorseCoreRoute<T>.Patch(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Patch(FPath, AMiddleware, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Patch(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Patch(FPath, ACallback);<N>end;<N>{$IFEND}<N><N>function THorseCoreRoute<T>.Post(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Post(FPath, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Post(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Post(FPath, AMiddleware, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.Post(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Post(FPath, ACallbacks);<N>end;<N><N>
function THorseCoreRoute<T>.Post(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Post(FPath, ACallbacks, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.Put(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Put(FPath, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Put(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Put(FPath, AMiddleware, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.Put(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Put(FPath, ACallbacks, ACallback);<N>end;<N><N>
unit DataSet.Serialize.Samples.Basic;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses Classes, SysUtils, memds, DB, Forms, Controls, Graphics, Dialogs, ComCtrls,<N>  ExtCtrls, StdCtrls, DBGrids, fpjson, DataSet.Serialize, TypInfo;<N><N>type<N><N>  { TFrmBasic }<N><N>
unit DataSet.Serialize.Samples.Basic;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics, System.JSON, Vcl.Controls,<N>  Vcl.Forms, Vcl.Dialogs, Vcl.ComCtrls, Vcl.ExtCtrls, Vcl.StdCtrls, Data.DB, Vcl.Grids, Vcl.DBGrids, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, DataSet.Serialize;<N><N>
unit DataSet.Serialize.Samples.Master.Detail;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.ComCtrls, Vcl.StdCtrls, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf, Data.DB, FireDAC.Comp.DataSet,<N>  FireDAC.Comp.Client, Vcl.Grids, Vcl.DBGrids, DataSet.Serialize, System.JSON;<N><N>
unit DataSet.Serialize.Utils;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson, SysUtils, Classes;<N>{$ELSE}<N>  {$IF CompilerVersion >= 20}System.Character,{$ENDIF} System.DateUtils, System.JSON, Data.DB, System.SysUtils, System.Classes;<N>{$ENDIF}<N><N>
type<N>  /// <summary><N>  ///   API error class (default).<N>  /// </summary><N>  EDataSetSerializeException = class(Exception);<N><N>  /// <summary><N>  ///   Type to get key values of an dataset.<N>  /// </summary><N>  TKeyValues = array of Variant;<N><N>
  /// <summary><N>  ///   Record representing the structure of a dataset field.<N>  /// </summary><N>  TFieldStructure = record<N>    Alignment: TAlignment;<N>    FieldType: TFieldType;<N>    Size: Integer;<N>    Precision: Integer;<N>    FieldName: string;<N>    Origin: string;<N>    DisplayLabel: string;<N>    Key: Boolean;<N>    Required: Boolean;<N>    Visible: Boolean;<N>    ReadOnly: Boolean;<N>    {$IF NOT DEFINED(FPC)}<N>    AutoGenerateValue: TAutoRefreshFlag;<N>    {$ENDIF}<N>  end;<N><N>
unit DataSet.Serialize.Language;<N><N>interface<N><N>type<N>  /// <summary><N>  ///   Languages handled by helper Validate (JSON).<N>  /// </summary><N>  TLanguageType = (ptBR, enUS);<N><N>implementation<N><N>end.<N>
unit DataSet.Serialize;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson,<N>{$ELSE}<N>  System.JSON, Data.DB,<N>{$ENDIF}<N>  DataSet.Serialize.Language, DataSet.Serialize.Config;<N><N>type<N>  TLanguageType = DataSet.Serialize.Language.TLanguageType;<N>  TDataSetSerializeConfig = DataSet.Serialize.Config.TDataSetSerializeConfig;<N>  TCaseNameDefinition = DataSet.Serialize.Config.TCaseNameDefinition;<N><N>
unit DataSet.Serialize.UpdatedStatus;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB;<N>{$ELSE}<N>  Data.DB;<N>{$ENDIF}<N><N>type<N>  TUpdateStatusHelper = record helper for TUpdateStatus<N>    function ToString: string;<N>  end;<N><N>
implementation<N><N>function TUpdateStatusHelper.ToString: string;<N>begin<N>  case Self of<N>    usModified:<N>      Result := 'MODIFIED';<N>    usInserted:<N>      Result := 'INSERTED';<N>    usDeleted:<N>      Result := 'DELETED';<N>  else<N>    Result := 'UNMODIFIED';<N>  end;<N>end;<N><N>
﻿unit DataSet.Serialize.Import;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson,<N>{$ELSE}<N>  System.JSON, Data.DB, System.StrUtils, System.SysUtils, System.Rtti,<N>  {$IF CompilerVersion >= 20}<N>    System.Character,<N>  {$ENDIF}<N>{$ENDIF}<N>  DataSet.Serialize.Language, DataSet.Serialize.Utils;<N><N>
unit prv.arqNFeXML;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, ACBrBase, ACBrDFe, ACBrNFe, XMLDoc, XMLIntf,<N>  Winapi.Activex, IniFiles;<N><N>type<N>  TProviderArquivoNFeXML = class(TDataModule)<N>    ACBrNFeAPI: TACBrNFe;<N>  private<N>    function RetornaArquivo(XChave: string): string;<N>    { Private declarations }<N>  public<N>    function RetornaNFeXML(XChave: string): TFileStream;<N>    { Public declarations }<N>  end;<N><N>
var<N>  ProviderArquivoNFeXML: TProviderArquivoNFeXML;<N><N>implementation<N><N>{%CLASSGROUP 'System.Classes.TPersistent'}<N><N>{$R *.dfm}<N><N>{ TProviderArquivoNFeXML }<N><N>function TProviderArquivoNFeXML.RetornaNFeXML(XChave: string): TFileStream;<N>var wret: TFileStream;<N>    warquivo: string;<N>begin<N>  try<N>    warquivo := RetornaArquivo(XChave);<N>    wret     := TFileStream.Create(warquivo,fmOpenRead);<N>  finally<N>    Result := wret;<N>  end;<N>end;<N><N>
function TProviderArquivoNFeXML.RetornaArquivo(XChave: string): string;<N>var wret,wano,wmes,wcaminho,warquivo: string;<N>    wdata: tdate;<N>    warqini: TIniFile;<N>begin<N>  warqini  := TIniFile.Create(GetCurrentDir+'\Autorizador.ini');<N>  wcaminho := warqini.ReadString('Geral','CaminhoSalvar','');<N><N>
  wano  := '20'+Copy(XChave,3,2);<N>  wmes  := Copy(XChave,5,2);<N>  wdata := StrToDate('01/'+wmes+'/'+wano);<N>  wmes  := FormatDateTime('mmmm',wdata);<N><N>  warquivo := wcaminho + '\'+wano+'\'+wmes+'\'+XChave+'-nfe.xml';<N>  if FileExists(warquivo) then<N>     wret := warquivo<N>  else<N>     wret := '';<N><N>
unit prv.fotoProduto;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.Imaging.jpeg, Vcl.ExtCtrls;<N><N>type<N>  TProviderFotoProduto = class(TForm)<N>    Image1: TImage;<N>  private<N>    { Private declarations }<N>  public<N>    function SaveToStream: TStringStream;<N>    { Public declarations }<N>  end;<N><N>
var<N>  ProviderFotoProduto: TProviderFotoProduto;<N><N>implementation<N><N>{$R *.dfm}<N><N>function TProviderFotoProduto.SaveToStream: TStringStream;<N>var input: TStringStream;<N>    j: TJPEGImage;<N>begin<N>  input  := TStringStream.Create;<N>  j := TJPEGImage.Create;<N>  j.Assign(Image1.Picture.Graphic);<N>  j.SaveToStream(input);<N>  Result := input;<N>end;<N><N>
unit models.cadAtividades;<N><N>interface<N><N>type<N>  TAtividades = class<N>    private<N>      Fid: integer;<N>      Fnome: string;<N>    public<N>      property id: integer read Fid write Fid;<N>      property nome: string read Fnome write Fnome;<N>  end;<N><N>implementation<N><N>end.<N>
unit models.cadCobrancas;<N><N>interface<N><N>type<N>  TCobrancas = class<N>    private<N>    Fid: integer;<N>    Fnome: string;<N>    Ftipo: string;<N>    public<N>      property id: integer read Fid write Fid;<N>      property nome: string read Fnome write Fnome;<N>      property tipo: string read Ftipo write Ftipo;<N>  end;<N><N>implementation<N><N>end.<N>
unit models.seqUltimoPedidoVenda;<N><N>interface<N><N>type<N>  TSequenceUltimoPedidoVenda = class<N>    private<N>      FultPed: integer;<N>    public<N>      property ultped: integer read FultPed write FultPed;<N>  end;<N><N>implementation<N><N>end.<N>
unit models.cadCondicoes;<N><N>interface<N><N>type<N>  TCondicoes = class<N>    private<N>    Fdescricao: string;<N>    Fid: integer;<N>    Fnumpag: integer;<N>    Ftipo: string;<N>    public<N>      property id: integer read Fid write Fid;<N>      property descricao: string read Fdescricao write Fdescricao;<N>      property tipo: string read Ftipo write Ftipo;<N>      property numpag: integer read Fnumpag write Fnumpag;<N>  end;<N><N>implementation<N><N>end.<N>
unit models.cadLocalidades;<N><N>interface<N><N>type<N>  TLocalidades = class<N>    private<N>      Fid: integer;<N>      Fnome: string;<N>      Fuf: string;<N>      Fregiao: string;<N>      Fcodibge: integer;<N>    public<N>      property id: integer read Fid write Fid;<N>      property nome: string read Fnome write Fnome;<N>      property uf: string read Fuf write Fuf;<N>      property regiao: string read Fregiao write Fregiao;<N>      property codibge: integer read Fcodibge write Fcodibge;<N>  end;<N><N>implementation<N><N>end.<N>
unit models.cadAliquotasICM;<N><N>interface<N><N>type<N>  TAliquotas = class<N>    private<N>      Fid: integer;<N>      Fcodigo: string;<N>      Fdescricao: string;<N>      Fpercentual: double;<N>      Fpercentualsc: double;<N>      Fpercentualsp: double;<N>      Fbasecalculo: double;<N>      Fsomaisentos: boolean;<N>      Fsomaoutros: boolean;<N><N>
unit Horse.Jhonson;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, HTTPDefs, fpjson, jsonparser,<N>{$ELSE}<N>  System.Classes, System.JSON, System.SysUtils, Web.HTTPApp,<N>{$ENDIF}<N>  Horse, Horse.Commons;<N><N>
function Jhonson: THorseCallback; overload;<N>function Jhonson(const ACharset: string): THorseCallback; overload;<N><N>procedure Middleware(Req: THorseRequest; Res: THorseResponse; Next: {$IF DEFINED(FPC)}TNextProc{$ELSE}TProc{$ENDIF});<N><N>implementation<N><N>
var<N>  Charset: string;<N><N>function Jhonson: THorseCallback; overload;<N>begin<N>  Result := Jhonson('UTF-8');<N>end;<N><N>function Jhonson(const ACharset: string): THorseCallback; overload;<N>begin<N>  Charset := ACharset;<N>  Result := Middleware;<N>end;<N><N>
unit Horse.Compression.Types;<N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N>interface<N><N>type<N>{$SCOPEDENUMS ON}<N>  THorseCompressionType = (DEFLATE, GZIP);<N>{$SCOPEDENUMS OFF}<N><N>  THorseCompressionTypeHelper = record helper for THorseCompressionType<N>    function ToString: string;<N>    function WindowsBits: Integer;<N>  end;<N><N>
implementation<N><N>function THorseCompressionTypeHelper.ToString: string;<N>begin<N>  case Self of<N>    THorseCompressionType.DEFLATE:<N>      Result := 'deflate';<N>    THorseCompressionType.GZIP:<N>      Result := 'gzip';<N>  end;<N>end;<N><N>function THorseCompressionTypeHelper.WindowsBits: Integer;<N>begin<N>  case Self of<N>    THorseCompressionType.DEFLATE:<N>      Result := -15;<N>  else<N>    Result := 31;<N>  end;<N>end;<N><N>
unit Horse.Compression;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, zstream, HTTPDefs, fpjson,<N>{$ELSE}<N>  System.Classes, System.ZLib, System.SysUtils, Web.HTTPApp, System.JSON,<N>{$ENDIF}<N>  Horse.Compression.Types, Horse;<N><N>
const<N>  COMPRESSION_THRESHOLD = 1024;<N><N>procedure Middleware(Req: THorseRequest; Res: THorseResponse; Next: {$IF DEFINED(FPC)}TNextProc{$ELSE}TProc{$ENDIF});<N>function Compression(const ACompressionThreshold: Integer = COMPRESSION_THRESHOLD): THorseCallback;<N><N>
implementation<N><N>var<N>  CompressionThreshold: Integer;<N><N>function Compression(const ACompressionThreshold: Integer = COMPRESSION_THRESHOLD): THorseCallback;<N>begin<N>  CompressionThreshold := ACompressionThreshold;<N>  Result := {$IF DEFINED(FPC)}@Middleware{$ELSE}Middleware{$ENDIF};<N>end;<N><N>
unit Horse.BasicAuthentication;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>  {$IF DEFINED(FPC)}<N>    SysUtils, StrUtils, base64, Classes,<N>  {$ELSE}<N>    System.SysUtils, System.NetEncoding, System.Classes, System.StrUtils,<N>  {$ENDIF}<N>  Horse, Horse.Commons;<N><N>
Library Apache;<N><N>{$DEFINE Apache2_4}<N>{$DEFINE FPCAPACHE_2_4}<N>{$MODE DELPHI}{$H+}<N><N>Uses<N>{$ifdef unix}<N>  cthreads,<N>{$endif}<N>  Horse, httpd24, fpApache24, custapache24;<N><N>const<N>  ModuleName = 'apache_horse_module';<N><N>var<N>  ApacheModuleData : module; {$ifdef unix} public name ModuleName;{$endif unix}<N><N>
exports ApacheModuleData name ModuleName;<N><N>procedure GetPing(Req: THorseRequest; Res: THorseResponse; Next: TNextProc);<N>begin<N>  Res.Send('pong');<N>end;<N><N>begin<N><N>  THorse.Get('/ping', GetPing);<N><N>  THorse.DefaultModule := @ApacheModuleData;<N>  THorse.HandlerName := 'apache_horse_module-handle';<N>  THorse.ModuleName := ModuleName;<N><N>
unit DaemonManager;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, DaemonApp;<N><N>type<N><N>  { TDaemon_Manager }<N><N>  TDaemon_Manager = class(TDaemonMapper)<N>    procedure Daemon_ManagerCreate(Sender: TObject);<N>  private<N><N>
  public<N><N>  end;<N><N>var<N>  Daemon_Manager: TDaemon_Manager;<N><N>implementation<N><N>procedure RegisterMapper;<N>begin<N>  RegisterDaemonMapper(TDaemon_Manager)<N>end;<N><N>{$R *.lfm}<N><N>{ TDaemon_Manager }<N><N>procedure TDaemon_Manager.Daemon_ManagerCreate(Sender: TObject);<N>begin<N><N>
unit DaemonMain;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, DaemonApp;<N><N>type<N><N>  { TDaemon_Main }<N><N>  TDaemon_Main = class(TDaemon)<N>    procedure DataModuleCreate(Sender: TObject);<N>    procedure DataModuleShutDown(Sender: TCustomDaemon);<N>    procedure DataModuleStart(Sender: TCustomDaemon; var OK: Boolean);<N>  private<N><N>
  public<N>  end;<N><N>var<N>  Daemon_Main: TDaemon_Main;<N><N>implementation<N><N>uses<N>  Horse;<N><N>procedure RegisterDaemon;<N>begin<N>  RegisterDaemonClass(TDaemon_Main)<N>end;<N><N>procedure RunHorse;<N>begin<N>  THorse.Listen(9000);<N>end;<N><N>procedure Ping(Req: THorseRequest; Res: THorseResponse; Next: TNextProc);<N>begin<N>  Res.Send('pong');<N>end;<N><N>
{$R *.lfm}<N><N>{ TDaemon_Main }<N><N>procedure TDaemon_Main.DataModuleCreate(Sender: TObject);<N>begin<N>  THorse.Get('ping', @Ping);<N>end;<N><N>procedure TDaemon_Main.DataModuleShutDown(Sender: TCustomDaemon);<N>begin<N>  THorse.StopListen;<N>end;<N><N>
unit Main.Service;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.SvcMgr, Vcl.Dialogs;<N><N>type<N>  TMainService = class(TService)<N>    procedure ServiceCreate(Sender: TObject);<N>    procedure ServiceStart(Sender: TService; var Started: Boolean);<N>    procedure ServiceStop(Sender: TService; var Stopped: Boolean);<N>  public<N>    function GetServiceController: TServiceController; override;<N>  end;<N><N>
var<N>  MainService: TMainService;<N><N>implementation<N><N>uses<N>  Horse;<N><N>{$R *.dfm}<N><N>procedure ServiceController(CtrlCode: DWord); stdcall;<N>begin<N>  MainService.Controller(CtrlCode);<N>end;<N><N>function TMainService.GetServiceController: TServiceController;<N>begin<N>  Result := ServiceController;<N>end;<N><N>
procedure TMainService.ServiceCreate(Sender: TObject);<N>begin<N>  THorse.Get('ping',<N>    procedure(Req: THorseRequest; Res: THorseResponse; Next: TProc)<N>    begin<N>      Res.Send('pong');<N>    end);<N>end;<N><N>procedure TMainService.ServiceStart(Sender: TService; var Started: Boolean);<N>begin<N>  THorse.Listen(9000);<N>  Started := True;<N>end;<N><N>
unit Tests.Commons;<N><N>interface<N><N>uses<N>  DUnitX.TestFramework, Horse.Commons;<N><N>type<N>  [TestFixture]<N>  TCommonsTest = class(TObject)<N>  public<N>    [Test]<N>    procedure TestMimeTypesToString;<N>  end;<N><N>implementation<N><N>{ TCommonsTest }<N><N>
unit Controllers.Api;<N><N>interface<N><N>uses<N>  Horse, System.JSON, Horse.Commons;<N><N>procedure Registry;<N>procedure DoGetApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>procedure DoPostApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>procedure DoPutApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>procedure DoDeleteApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N><N>
implementation<N><N>procedure Registry;<N>begin<N>  THorse<N>    .Group<N>      .Prefix('/Api')<N>        .Delete('/Test/:id', DoDeleteApi)<N>        .Route('/Test')<N>          .Get(DoGetApi)<N>          .Post(DoPostApi)<N>          .Put(DoPutApi)<N>end;<N><N>
procedure DoGetApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LList: TJSONArray;<N>  LObject01: TJSONObject;<N>  LObject02: TJSONObject;<N>  LObject03: TJSONObject;<N>begin<N>  LList := TJSONArray.Create;<N><N>  LObject01 := TJSONObject.Create;<N>  LObject01.AddPair(TJSONPair.Create('value', 'test01'));<N>  LList.AddElement(LObject01);<N><N>
  LObject02 := TJSONObject.Create;<N>  LObject02.AddPair(TJSONPair.Create('value', 'test02'));<N>  LList.AddElement(LObject02);<N><N>  LObject03 := TJSONObject.Create;<N>  LObject03.AddPair(TJSONPair.Create('value', 'test03'));<N>  LList.AddElement(LObject03);<N><N>
  Res.Send(LList.ToString);<N>end;<N><N>procedure DoPostApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LValue: string;<N>  LRequest: TJSONObject;<N>  LResponse: TJSONObject;<N>begin<N>  LValue := '';<N>  LRequest := TJSONObject.ParseJSONValue(Req.Body) as TJSONObject;<N><N>
  if (not LRequest.GetValue('value').Null) then<N>    LValue := LRequest.GetValue('value').value;<N><N>  LResponse := TJSONObject.Create;<N>  LResponse.AddPair(TJSONPair.Create('value', LValue));<N><N>  Res.Send(LResponse.ToString).Status(THTTPStatus.Created);<N>end;<N><N>
procedure DoPutApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LValue: string;<N>  LRequest: TJSONObject;<N>  LResponse: TJSONObject;<N>begin<N>  LValue := '';<N>  LRequest := TJSONObject.ParseJSONValue(Req.Body) as TJSONObject;<N><N>  if (not LRequest.GetValue('value').Null) then<N>    LValue := LRequest.GetValue('value').value;<N><N>
  LResponse := TJSONObject.Create;<N>  LResponse.AddPair(TJSONPair.Create('value', LValue));<N><N>  Res.Send(LResponse.ToString);<N>end;<N><N>procedure DoDeleteApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LValue: string;<N>  LResponse: TJSONObject;<N>begin<N>  LValue := Req.Params['id'];<N><N>
﻿unit Web.WebConst;<N><N>interface<N><N>resourcestring<N>  sDuplicateActionName = 'Duplicate action name';<N>  sOnlyOneDispatcher = 'Only one WebDispatcher per form/data module';<N>  sHTTPItemName = 'Name';<N>  sHTTPItemURI = 'PathInfo';<N>  sHTTPItemEnabled = 'Enabled';<N>  sHTTPItemDefault = 'Default';<N>  sHTTPItemProducer = 'Producer';<N>  sHTTPItemMethod = 'Method';<N><N>
unit Horse.Proc;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF NOT DEFINED(FPC)}<N>uses<N>  System.SysUtils;<N>{$ENDIF}<N><N>type<N>  TNextProc = {$IF DEFINED(FPC)} procedure of object {$ELSE} System.SysUtils.TProc {$ENDIF};<N>  TProc = {$IF DEFINED(FPC)} procedure {$ELSE} System.SysUtils.TProc {$ENDIF};<N>{$IF DEFINED(FPC)}<N>  TProc<T> = procedure(Arg1: T);<N>{$ENDIF}<N><N>implementation<N><N>end.<N>
unit Horse.HTTP;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, Generics.Collections, fpHTTP, HTTPDefs,<N>{$ELSE}<N>  System.SysUtils, System.Classes, Web.HTTPApp, System.Generics.Collections,<N>  {$IF CompilerVersion > 32.0}<N>  Web.ReqMulti,<N>  {$ENDIF}<N>{$ENDIF}<N>  Horse.Commons;<N><N>
unit Horse.Provider.FPC.Apache;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_APACHE) AND DEFINED(FPC)}<N><N>uses<N>{$IFDEF unix}<N>  cthreads,<N>{$ENDIF}<N>  fphttp, httpdefs, httpd24, fpApache24, custapache24, SysUtils, Classes,<N>  Horse.Provider.Abstract, Horse.Constants, Horse.Proc;<N><N>
unit Horse.Exception;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>  {$IF DEFINED(FPC)}<N>  SysUtils,<N>  {$ELSE}<N>  System.SysUtils,<N>  {$ENDIF}<N>  Horse.Commons;<N><N>type<N>  EHorseCallbackInterrupted = class(Exception)<N>    constructor Create; reintroduce;<N>  end;<N><N>
unit Horse.Provider.FPC.Daemon;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_DAEMON)}<N><N>uses<N>  SysUtils, Classes, httpdefs, fpHTTP, fphttpserver, Horse.HTTP, HOrse.Core,<N>  Horse.Provider.Abstract, Horse.Constants, Horse.Proc, Horse.Commons,<N>  Horse.Exception;<N><N>
{ ****************************************************************************** }<N>{ }<N>{ Linux Daemon with Delphi }<N>{ }<N>{ Author: Paolo Rossi (2017) }<N>{ }<N>{ http://www.paolorossi.net }<N>{ http://blog.paolorossi.net }<N>{ https://github.com/paolo-rossi }<N>{ }<N>{ ****************************************************************************** }<N>unit ThirdParty.Posix.Syslog;<N><N>
unit Horse.Core.Group.Contract;<N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N>interface<N><N>uses<N>  Horse.Core.Route.Contract, Horse.Core.RouterTree;<N><N>type<N>   IHorseCoreGroup<T: class> = interface<N>    ['{5EB734D6-6944-473E-9C79-506647E2F5E8}']<N>    function Prefix(APrefix: string): IHorseCoreGroup<T>;<N>    function Route(APath: string): IHorseCoreRoute<T>;<N><N>
    function Use(ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Use(AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Use(ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Use(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    function Get(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Get(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Get(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Get(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    function Put(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Put(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Put(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Put(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    {$IF (defined(fpc) or (CompilerVersion > 27.0))}<N>    function Patch(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Patch(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Patch(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Patch(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    {$IFEND}<N><N>
    function Head(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Head(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Head(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Head(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    function Post(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Post(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Post(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Post(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
unit Horse.WebModule;<N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, httpdefs, fpHTTP, fpWeb,<N>{$ELSE}<N>  System.SysUtils, System.Classes, Web.HTTPApp,<N>{$ENDIF}<N>  Horse.Core, Horse.Commons;<N><N>
unit Horse.Provider.FPC.HTTPApplication;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(FPC)}<N><N>uses<N>  SysUtils, Classes, httpdefs, fpHTTP, fphttpapp,<N>  Horse.Provider.Abstract, Horse.Constants, Horse.Proc;<N><N>
unit Horse.Provider.FPC.FastCGI;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(FPC) AND DEFINED(HORSE_FCGI)}<N><N>uses<N>  SysUtils, Classes, fpFCGI, httpdefs, fpHTTP,<N>  Horse.Provider.Abstract, Horse.Constants, Horse.Proc;<N><N>
unit Horse.Provider.FPC.CGI;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_CGI) AND DEFINED(FPC)}<N><N>uses<N>  SysUtils, Classes, fpCGI, fphttp, httpdefs,<N>  Horse.Provider.Abstract, Horse.Proc;<N><N>type<N><N>
unit Horse.Core.Group;<N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils,<N>{$ELSE}<N>  System.SysUtils,<N>{$ENDIF}<N>  Horse.Core.Group.Contract, Horse.Core.Route.Contract, Horse.Core.RouterTree;<N><N>
type<N>  THorseCoreGroup<T: class> = class(TInterfacedObject, IHorseCoreGroup<T>)<N>  private<N>    FHorseCore: TObject;<N>    FPrefix: string;<N>    function NormalizePath(APath: string): string;<N>  public<N>    constructor Create;<N><N>    function Prefix(APrefix: string): IHorseCoreGroup<T>;<N>    function Route(APath: string): IHorseCoreRoute<T>;<N><N>
    function Use(ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Use(AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Use(ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Use(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    function Get(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Get(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Get(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Get(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    function Put(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Put(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Put(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Put(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    {$IF (defined(fpc) or (CompilerVersion > 27.0))}<N>    function Patch(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Patch(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Patch(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Patch(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    {$IFEND}<N><N>
    function Head(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Head(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Head(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Head(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
    function Post(APath: string; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Post(APath: string; AMiddleware, ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Post(APath: string; ACallbacks: array of THorseCallback): IHorseCoreGroup<T>; overload;<N>    function Post(APath: string; ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreGroup<T>; overload;<N><N>
unit Horse.Provider.VCL;<N><N>interface<N><N>{$IF DEFINED(HORSE_VCL)}<N>uses<N>  Horse.Provider.Abstract, Horse.Constants, IdHTTPWebBrokerBridge, IdSSLOpenSSL,<N>  IdContext, System.Classes, System.SyncObjs, System.SysUtils;<N><N>type<N>  THorseProviderIOHandleSSL = class;<N>  THorseProvider<T: class> = class;<N><N>
unit Horse.Provider.Daemon;<N><N>interface<N><N>{$IF DEFINED(HORSE_DAEMON) AND NOT DEFINED(FPC)}<N><N><N>uses<N><N>  Horse.Provider.Abstract, Horse.Constants, IdHTTPWebBrokerBridge, IdSSLOpenSSL, IdContext,<N>  System.SyncObjs, System.SysUtils, Posix.SysTypes;<N><N>
unit Horse.Constants;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>const<N>  DEFAULT_HOST = '0.0.0.0';<N>  DEFAULT_PORT = 9000;<N>  HORSE_ENV = 'HORSE_ENV';<N>  ENV_D = 'd';<N>  ENV_DEV = 'dev';<N>  ENV_DEVELOPMENT = 'development';<N>  START_RUNNING = 'Server is runing on %s:%d';<N><N>implementation<N><N>end.<N>
unit Horse.Commons;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$MODESWITCH TypeHelpers}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(FPC)}<N>uses Classes, SysUtils;<N>{$ENDIF}<N><N>type<N>{$IF DEFINED(FPC)}<N>  TMethodType = (mtAny, mtGet, mtPut, mtPost, mtHead, mtDelete, mtPatch);<N>{$ENDIF}<N><N>
unit Horse.Core.RouterTree;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections, fpHTTP, httpprotocol,<N>{$ELSE}<N>  System.SysUtils, System.NetEncoding, Web.HTTPApp, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.HTTP, Horse.Proc, Horse.Commons;<N><N>
unit Horse.Provider.Console;<N><N>interface<N><N>{$IF NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, Horse.Constants, IdHTTPWebBrokerBridge, IdSSLOpenSSL, IdContext, System.Classes, System.SyncObjs,<N>  System.SysUtils;<N><N>type<N>  THorseProviderIOHandleSSL = class;<N>  THorseProvider<T: class> = class;<N><N>
unit Horse.Core;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils,<N>{$ELSE}<N>  System.SysUtils, Web.HTTPApp,<N>{$ENDIF}<N>  Horse.Core.RouterTree, Horse.Commons,<N>  Horse.Core.Group.Contract, Horse.Core.Route.Contract;<N><N>
unit Horse.Core.Route;<N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N>interface<N><N>uses<N>  {$IF DEFINED(FPC)}<N>    SysUtils,<N>  {$ELSE}<N>    System.SysUtils,<N>  {$ENDIF}<N>  Horse.Core.Route.Contract, Horse.Core.RouterTree;<N><N>type<N>  THorseCoreRoute<T: class> = class(TInterfacedObject, IHorseCoreRoute<T>)<N>  private<N>    FPath: string;<N>    FHorseCore: TObject;<N>  public<N>    constructor Create(APath: string);<N><N>
    function This: IHorseCoreRoute<T>;<N><N>    function All(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    function Get(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Get(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Get(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Get(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    function Put(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Put(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Put(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Put(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    {$IF (defined(fpc) or (CompilerVersion > 27.0))}<N>    function Patch(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Patch(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Patch(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Patch(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Head(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Head(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Head(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Head(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    function Post(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Post(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Post(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Post(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    {$IF (defined(fpc) or (CompilerVersion > 27.0))}<N>    function Delete(ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Delete(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Delete(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Delete(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function &End: T;<N>  end;<N><N>implementation<N><N>uses<N>  Horse.Core;<N><N>{ THorseCoreRoute }<N><N>constructor THorseCoreRoute<T>.Create(APath: string);<N>begin<N>  FPath := APath;<N>  FHorseCore := THorseCore.GetInstance;<N>end;<N><N>function THorseCoreRoute<T>.This: IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>end;<N><N>
function THorseCoreRoute<T>.All(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Use(FPath, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.All(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Use(FPath, [AMiddleware, ACallback]);<N>end;<N><N>
function THorseCoreRoute<T>.All(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Use(FPath, ACallbacks);<N>end;<N><N>function THorseCoreRoute<T>.&End: T;<N>begin<N>  Result := FHorseCore as T;<N>end;<N><N>
function THorseCoreRoute<T>.All(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Use(FPath, ACallbacks);<N>  THorseCore(FHorseCore).Use(FPath, [ACallback]);<N>end;<N><N>
{$IF (defined(fpc) or (CompilerVersion > 27.0))}<N>function THorseCoreRoute<T>.Delete(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Delete(FPath, ACallbacks);<N>end;<N><N>function THorseCoreRoute<T>.Delete(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Delete(FPath, AMiddleware, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Delete(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Delete(FPath, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.Delete(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Delete(FPath, ACallbacks, ACallback);<N>end;<N>{$IFEND}<N><N>
function THorseCoreRoute<T>.Get(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Get(FPath, AMiddleware, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.Get(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Get(FPath, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Get(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Get(FPath, ACallbacks);<N>end;<N><N>function THorseCoreRoute<T>.Get(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Get(FPath, ACallbacks, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Head(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Head(FPath, ACallbacks);<N>end;<N><N>function THorseCoreRoute<T>.Head(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Head(FPath, ACallbacks, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Head(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Head(FPath, AMiddleware, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.Head(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Head(FPath, ACallback);<N>end;<N><N>
{$IF (defined(fpc) or (CompilerVersion > 27.0))}<N>function THorseCoreRoute<T>.Patch(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Patch(FPath, ACallbacks, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Patch(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Patch(FPath, ACallbacks);<N>end;<N><N>function THorseCoreRoute<T>.Patch(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Patch(FPath, AMiddleware, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Patch(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Patch(FPath, ACallback);<N>end;<N>{$IFEND}<N><N>function THorseCoreRoute<T>.Post(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Post(FPath, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Post(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Post(FPath, AMiddleware, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.Post(ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Post(FPath, ACallbacks);<N>end;<N><N>
function THorseCoreRoute<T>.Post(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Post(FPath, ACallbacks, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.Put(ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Put(FPath, ACallback);<N>end;<N><N>
function THorseCoreRoute<T>.Put(AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Put(FPath, AMiddleware, ACallback);<N>end;<N><N>function THorseCoreRoute<T>.Put(ACallbacks: array of THorseCallback; ACallback: THorseCallback): IHorseCoreRoute<T>;<N>begin<N>  Result := Self;<N>  THorseCore(FHorseCore).Put(FPath, ACallbacks, ACallback);<N>end;<N><N>
unit Annotation.Classes;<N><N>interface<N><N>uses<N>  GBSwagger.Model.Attributes;<N><N>type<N>  TUser = class<N>  private<N>    Fid: Double;<N>    Fname: String;<N>    FlastName: string;<N>    FbirthdayDate: TDateTime;<N>    FlastUpdate: TDateTime;<N>  public<N>    [SwagProp('user id', True)]<N>    property id: Double read Fid write Fid;<N><N>
    [SwagProp('User Description', True)]<N>    property name: String read Fname write Fname;<N><N>    [SwagString(100)]<N>    property lastName: string read FlastName write FlastName;<N>    property birthdayDate: TDateTime read FbirthdayDate write FbirthdayDate;<N><N>
    [SwagIgnore]<N>    property lastUpdate: TDateTime read FlastUpdate write FlastUpdate;<N>  end;<N><N>  TAPIError = class<N>  private<N>    Ferror: string;<N>  public<N>    property error: string read Ferror write Ferror;<N>  end;<N><N>implementation<N><N>
unit Annotation.Controller.User;<N><N>interface<N><N>uses<N>  Horse,<N>  GBSwagger.Path.Attributes,<N>  Annotation.Classes,<N>  System.JSON;<N><N>type<N>  [SwagPath('user', 'Users')]<N>  TUserController = class<N>  private<N>    FRequest: THorseRequest;<N>    FResponse: THorseResponse;<N><N>
  public<N>    [SwagGET('List Users')]<N>    [SwagParamQuery('id', 'user id')]<N>    [SwagResponse(200, TUser, 'Users data', True)]<N>    procedure GetUsers;<N><N>    [SwagGET('{id}', 'Find User')]<N>    [SwagParamPath('id', 'user id')]<N>    [SwagResponse(200, TUser, 'User data')]<N>    [SwagResponse(404)]<N>    procedure FindUser;<N><N>
    [SwagPOST('Insert a new user')]<N>    [SwagParamBody('UserData', TUser)]<N>    [SwagResponse(201, TUser)]<N>    [SwagResponse(400)]<N>    procedure InsertUser;<N><N>    [SwagPUT('{id}', 'Update user')]<N>    [SwagParamPath('id', 'user id')]<N>    [SwagParamBody('User Data', TUser)]<N>    [SwagResponse(204)]<N>    [SwagResponse(400)]<N>    [SwagResponse(404)]<N>    procedure UpdateUser;<N><N>
    [SwagDELETE('{id}', 'Delete user')]<N>    [SwagParamPath('id', 'user id')]<N>    [SwagResponse(204)]<N>    [SwagResponse(400)]<N>    [SwagResponse(404)]<N>    procedure DeleteUser;<N><N>    constructor create(Req: THorseRequest; Res: THorseResponse);<N>    destructor Destroy; override;<N>end;<N><N>
implementation<N><N>{ TUserController }<N><N>constructor TUserController.create(Req: THorseRequest; Res: THorseResponse);<N>begin<N>  FRequest := Req;<N>  FResponse:= Res;<N>end;<N><N>procedure TUserController.DeleteUser;<N>begin<N>  FResponse.Status(204);<N>end;<N><N>
destructor TUserController.Destroy;<N>begin<N><N>  inherited;<N>end;<N><N>procedure TUserController.UpdateUser;<N>begin<N>  FResponse.Status(204);<N>end;<N><N>procedure TUserController.FindUser;<N>begin<N>  FResponse.Send('{"id": 1, "name": "user 1"}');<N>end;<N><N>
unit Annotation.JWT.Controller.User;<N><N>interface<N><N>uses<N>  Horse,<N>  GBSwagger.Path.Attributes,<N>  Annotation.JWT.Classes,<N>  System.JSON;<N><N>type<N>  [SwagPath('company/{companyId}/user', 'Users')]<N>  [SwagParamPath('companyId', 'Company Id')]<N>  [SwagParamHeader('TestHeader', 'Header Default')]<N>  [SwagParamQuery('TestQuery', 'Query Default')]<N>  TUserController = class<N>  private<N>    FRequest: THorseRequest;<N>    FResponse: THorseResponse;<N><N>
  public<N>    [SwagGET('List Users', True)]<N>    [SwagParamQuery('id', 'user id')]<N>    [SwagResponse(200, TUser, 'Users data', True)]<N>    procedure GetUsers;<N><N>    [SwagGET('{id}', 'Find User')]<N>    [SwagParamPath('id', 'user id')]<N>    [SwagResponse(200, TUser, 'User data')]<N>    [SwagResponse(404)]<N>    procedure FindUser;<N><N>
    [SwagPOST('Insert a new user')]<N>    [SwagParamBody('UserData', TUser)]<N>    [SwagResponse(201, TUser)]<N>    [SwagResponse(400)]<N>    procedure InsertUser;<N><N>    [SwagPUT('{id}', 'Update user')]<N>    [SwagParamPath('id', 'user id')]<N>    [SwagParamBody('User Data', TUser)]<N>    [SwagResponse(204)]<N>    [SwagResponse(400)]<N>    [SwagResponse(404)]<N>    procedure UpdateUser;<N><N>
    [SwagDELETE('{id}', 'Delete user')]<N>    [SwagParamPath('id', 'user id')]<N>    [SwagResponse(204)]<N>    [SwagResponse(400)]<N>    [SwagResponse(404)]<N>    procedure DeleteUser;<N><N>    constructor create(Req: THorseRequest; Res: THorseResponse);<N>    destructor Destroy; override;<N>end;<N><N>
implementation<N><N>{ TUserController }<N><N>constructor TUserController.create(Req: THorseRequest; Res: THorseResponse);<N>begin<N>  FRequest := Req;<N>  FResponse:= Res;<N>end;<N><N>procedure TUserController.DeleteUser;<N>begin<N>  FResponse.Status(204);<N>end;<N><N>
destructor TUserController.Destroy;<N>begin<N><N>  inherited;<N>end;<N><N>procedure TUserController.UpdateUser;<N>begin<N>  FResponse.Status(204);<N>end;<N><N>procedure TUserController.FindUser;<N>begin<N>  FResponse.Send('{"id": 1, "name": "user 1"}');<N>end;<N><N>
unit Annotation.JWT.Classes;<N><N>interface<N><N>uses<N>  GBSwagger.Model.Attributes;<N><N>type<N>  TUser = class<N>  private<N>    Fid: Double;<N>    Fname: String;<N>    FlastName: string;<N>    FbirthdayDate: TDateTime;<N>    FlastUpdate: TDateTime;<N>  public<N>    [SwagProp('user id', True)]<N>    property id: Double read Fid write Fid;<N><N>
    [SwagProp('User Description', True)]<N>    property name: String read Fname write Fname;<N><N>    [SwagString(100)]<N>    property lastName: string read FlastName write FlastName;<N>    property birthdayDate: TDateTime read FbirthdayDate write FbirthdayDate;<N><N>
    [SwagIgnore]<N>    property lastUpdate: TDateTime read FlastUpdate write FlastUpdate;<N>  end;<N><N>  TAPIError = class<N>  private<N>    Ferror: string;<N>  public<N>    property error: string read Ferror write Ferror;<N>  end;<N><N>implementation<N><N>
unit PetStore.Order;<N><N>interface<N><N>uses<N>  Horse,<N>  Horse.GBSwagger,<N>  PetStore.Models;<N><N>procedure addOrder    (Req: THorseRequest; Resp: THorseResponse; Next: TProc);<N>procedure findOrder   (Req: THorseRequest; Resp: THorseResponse; Next: TProc);<N>procedure deleteOrder (Req: THorseRequest; Resp: THorseResponse; Next: TProc);<N>procedure inventory    (Req: THorseRequest; Resp: THorseResponse; Next: TProc);<N><N>
implementation<N><N>procedure addOrder(Req: THorseRequest; Resp: THorseResponse; Next: TProc);<N>begin<N>end;<N><N>procedure findOrder(Req: THorseRequest; Resp: THorseResponse; Next: TProc);<N>begin<N>end;<N><N>procedure deleteOrder(Req: THorseRequest; Resp: THorseResponse; Next: TProc);<N>begin<N>end;<N><N>
unit PetStore.Models;<N><N>interface<N><N>uses<N>  GBSwagger.Model.Attributes,<N>  System.Variants,<N>  System.Generics.Collections;<N><N>type<N>  TStatus = (sAvailable, sPending, sSold);<N>  TOrderStatus = (osPlaced, osApproved, odDelivered);<N><N>  TTag = class;<N><N>
unit Validation.Controller.User;<N><N>interface<N><N>uses<N>  Horse,<N>  GBSwagger.Path.Attributes,<N>  GBSwagger.Validator.Interfaces,<N>  Validation.Classes,<N>  REST.Json,<N>  System.JSON;<N><N>type<N>  [SwagPath('user', 'Users')]<N>  TUserController = class<N>  private<N>    FRequest: THorseRequest;<N>    FResponse: THorseResponse;<N><N>
  public<N>    [SwagGET('List Users')]<N>    [SwagParamQuery('id', 'user id')]<N>    [SwagResponse(200, TUser, 'Users data', True)]<N>    procedure GetUsers;<N><N>    [SwagGET('{id}', 'Find User')]<N>    [SwagParamPath('id', 'user id')]<N>    [SwagResponse(200, TUser, 'User data')]<N>    [SwagResponse(404)]<N>    procedure FindUser;<N><N>
    [SwagPOST('Insert a new user')]<N>    [SwagParamBody('UserData', TUser)]<N>    [SwagResponse(201, TUser)]<N>    [SwagResponse(400)]<N>    procedure InsertUser;<N><N>    [SwagPUT('{id}', 'Update user')]<N>    [SwagParamPath('id', 'user id')]<N>    [SwagParamBody('User Data', TUser)]<N>    [SwagResponse(204)]<N>    [SwagResponse(400)]<N>    [SwagResponse(404)]<N>    procedure UpdateUser;<N><N>
    [SwagDELETE('{id}', 'Delete user')]<N>    [SwagParamPath('id', 'user id')]<N>    [SwagResponse(204)]<N>    [SwagResponse(400)]<N>    [SwagResponse(404)]<N>    procedure DeleteUser;<N><N>    constructor create(Req: THorseRequest; Res: THorseResponse);<N>    destructor Destroy; override;<N>end;<N><N>
implementation<N><N>{ TUserController }<N><N>constructor TUserController.create(Req: THorseRequest; Res: THorseResponse);<N>begin<N>  FRequest := Req;<N>  FResponse:= Res;<N>end;<N><N>procedure TUserController.DeleteUser;<N>begin<N>  FResponse.Status(204);<N>end;<N><N>
destructor TUserController.Destroy;<N>begin<N><N>  inherited;<N>end;<N><N>procedure TUserController.UpdateUser;<N>begin<N>  FResponse.Status(204);<N>end;<N><N>procedure TUserController.FindUser;<N>begin<N>  FResponse.Send('{"id": 1, "name": "user 1"}');<N>end;<N><N>
procedure TUserController.GetUsers;<N>begin<N>  FResponse.Send('[{"id": 1, "name": "user 1"}]');<N>end;<N><N>procedure TUserController.InsertUser;<N>var<N>  user : TUser;<N>begin<N>  user := TJson.JsonToObject<TUser>(FRequest.Body);<N>  try<N>    SwaggerValidator.validate(user);<N>    FResponse.Send(FRequest.Body).Status(201);<N>  finally<N>    user.Free;<N>  end;<N>end;<N><N>
unit Validation.Classes;<N><N>interface<N><N>uses<N>  GBSwagger.Model.Attributes;<N><N>type<N>  TUser = class<N>  private<N>    Fid: Double;<N>    Fname: String;<N>    FlastName: string;<N>    FbirthdayDate: TDateTime;<N>    FlastUpdate: TDateTime;<N>  public<N>    [SwagProp('id', 'user id')]<N>    property id: Double read Fid write Fid;<N><N>
    [SwagRequired]<N>    [SwagString(30, 3)]<N>    property name: String read Fname write Fname;<N><N>    [SwagString(100)]<N>    [SwagProp('', '', True)]<N>    property lastName: string read FlastName write FlastName;<N><N>    property birthdayDate: TDateTime read FbirthdayDate write FbirthdayDate;<N>    property lastUpdate: TDateTime read FlastUpdate write FlastUpdate;<N>  end;<N><N>
unit FMain;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls,<N>  PetStore.Models,<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Model.JSON.Interfaces,<N>  GBSwagger.Model.Types,<N>  System.TypInfo;<N><N>
type<N>  TForm1 = class(TForm)<N>    Memo1: TMemo;<N>    procedure FormCreate(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form1: TForm1;<N><N>implementation<N><N>{$R *.dfm}<N><N>
unit PetStore.Models;<N><N>interface<N><N>uses<N>  GBSwagger.Model.Attributes,<N>  System.Variants,<N>  System.Generics.Collections;<N><N>type<N>  TStatus = (sAvailable, sPending, sSold);<N>  TOrderStatus = (osPlaced, osApproved, odDelivered);<N><N>  TTag = class;<N><N>
unit FMain;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs,<N>  Validator.Model, Vcl.StdCtrls,<N>  GBSwagger.Validator.Interfaces;<N><N>
type<N>  TfrmMain = class(TForm)<N>    btnValidate: TButton;<N>    procedure btnValidateClick(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  frmMain: TfrmMain;<N><N>implementation<N><N>
{$R *.dfm}<N><N>procedure TfrmMain.btnValidateClick(Sender: TObject);<N>var<N>  person : TPerson;<N>begin<N>  person := TPerson.Create;<N>  try<N>    person.id := 2;<N>    person.name := '1';<N>    person.birthday := Now;<N>    person.address.street := 'Street 1';<N>    person.address.state := 'RJaaa';<N>    person.phones.Add(TPhone.Create);<N>    SwaggerValidator.validate(person);<N>  finally<N>    person.Free;<N>  end;<N>end;<N><N>
unit Validator.Model;<N><N>interface<N><N>uses<N>  GBSwagger.Model.Attributes,<N>  GBSwagger.Validator.Attributes,<N>  System.Generics.Collections;<N><N>type<N>  TStatus = (active, inactive);<N><N>  TAddress = class;<N>  TPhone = class;<N><N>  TPerson = class<N>  private<N>    Fid: Double;<N>    Fname: String;<N>    Fbirthday: TDateTime;<N>    Fstatus: TStatus;<N>    Faddress: TAddress;<N>    Fphones: TObjectList<TPhone>;<N><N>
  public<N>    [SwagRequired]<N>    [SwagNumber(0, 2)]<N>    property id: Double read Fid write Fid;<N><N>    [SwagRequired]<N>    property name: String read Fname write Fname;<N>    [SwagRequired]<N>    property birthday: TDateTime read Fbirthday write Fbirthday;<N><N>
    [SwagValidateProperties('street')]<N>    property address: TAddress read Faddress write Faddress;<N>    property phones: TObjectList<TPhone> read Fphones write Fphones;<N><N>    property status: TStatus read Fstatus write Fstatus;<N><N>    constructor create;<N>    destructor  Destroy; override;<N>  end;<N><N>
  TAddress = class<N>  private<N>    Fstreet: string;<N>    Fstate: String;<N><N>  public<N>    [SwagRequired]<N>    property street: string read Fstreet write Fstreet;<N>    [SwagRequired]<N>    [SwagString(2, 2)]<N>    property state: String read Fstate write Fstate;<N>  end;<N><N>
  TPhone = class<N>  private<N>    FphoneNumber: string;<N><N>  public<N>    [SwagRequired]<N>    property phoneNumber: string read FphoneNumber write FphoneNumber;<N>  end;<N><N>implementation<N><N>{ TPerson }<N><N>constructor TPerson.create;<N>begin<N>  Faddress := TAddress.Create;<N>  Fphones  := TObjectList<TPhone>.create;<N>end;<N><N>
unit WebModuleUnit1;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, Web.HTTPApp, Datasnap.DSHTTPCommon,<N>  Datasnap.DSHTTPWebBroker, Datasnap.DSServer,<N>  Web.WebFileDispatcher, Web.HTTPProd,<N>  DataSnap.DSAuth,<N>  Datasnap.DSProxyJavaScript, IPPeerServer, Datasnap.DSMetadata,<N>  Datasnap.DSServerMetadata, Datasnap.DSClientMetadata,<N>  Datasnap.DSCommonServer, Datasnap.DSHTTP, System.JSON, Data.DBXCommon,<N>  Datasnap.GBSwagger, Datasnap.Classes;<N><N>
unit ServerMethodsUnit1;<N><N>interface<N><N>uses<N>  Web.HTTPApp, Datasnap.DSHTTPWebBroker,<N>  System.SysUtils, System.Classes, System.Json,<N>  Datasnap.DSServer, Datasnap.DSAuth,<N>  Datasnap.Classes,<N>  Datasnap.GBSwagger,<N>  GBSwagger.Validator.Interfaces;<N><N>
type<N>{$METHODINFO ON}<N>  [SwagPath('TServerMethods1/usuario', 'Usuarios')]<N>  TServerMethods1 = class(TDataModule)<N>  public<N>    [SwagGET('{id}', 'Consulta Usuario')]<N>    [SwagParamPath('id', 'id do Usuario')]<N>    [SwagResponse(200, TUser, 'Dados do Usuario')]<N>    [SwagResponse(400)]<N>    [SwagResponse(404)]<N>    function swagUsuario: TJSONValue; virtual; abstract;<N><N>
    [SwagGET('Lista Usuarios')]<N>    [SwagResponse(200, TUser, 'Lista de Usuarios', True)]<N>    [SwagResponse(400)]<N>    function usuario: TJSONValue;<N><N>    [SwagPOST('Insere um usuario')]<N>    [SwagParamBody('usuario', TUser, '')]<N>    [SwagResponse(201, TUser, 'Created')]<N>    [SwagResponse(400)]<N>    [SwagResponse(500)]<N>    function updateUsuario: TJSONValue;<N><N>
    [SwagPUT('{id}', 'Altera Usuario')]<N>    [SwagParamPath('id', 'id do usuario')]<N>    [SwagParamBody('usuario', TUser, '')]<N>    [SwagResponse(204)]<N>    [SwagResponse(400)]<N>    [SwagResponse(500)]<N>    function acceptUsuario(IdUsuario: Integer): TJSONValue;<N><N>
    [SwagDELETE('{id}', 'Excluir Usuario')]<N>    [SwagParamPath('id', 'id do usuario')]<N>    [SwagResponse(204)]<N>    [SwagResponse(400)]<N>    [SwagResponse(500)]<N>    function cancelUsuario: TJSONValue;<N><N>  end;<N>{$METHODINFO OFF}<N><N>implementation<N><N>
{$R *.dfm}<N><N>{ TServerMethods1 }<N><N>function TServerMethods1.acceptUsuario(IdUsuario: Integer): TJSONValue;<N>begin<N><N>end;<N><N>function TServerMethods1.cancelUsuario: TJSONValue;<N>begin<N><N>end;<N><N>function TServerMethods1.updateUsuario: TJSONValue;<N>var<N>  user : TUser;<N>begin<N>  user := TUser.Create;<N>  SwaggerValidator.validate(user);<N>end;<N><N>
unit Datasnap.Classes;<N><N>interface<N><N>uses<N>  GBSwagger.Model.Attributes;<N><N>type<N>  TUser = class<N>  private<N>    Fid: Double;<N>    Fname: String;<N>    FlastName: string;<N>  public<N>    property id: Double read Fid write Fid;<N>    [SwagRequired]<N>    property name: String read Fname write Fname;<N>    property lastName: string read FlastName write FlastName;<N>  end;<N><N>  TAPIError = class<N>  private<N>    Ferror: string;<N>  public<N>    property error: string read Ferror write Ferror;<N>  end;<N><N>implementation<N><N>end.<N>
unit Horse.GBSwagger.Controller;<N><N>interface<N><N>uses<N>  Horse;<N><N>type THorseGBSwagger = class<N><N>  protected<N>    FRequest: THorseRequest;<N>    FResponse: THorseResponse;<N><N>  public<N>    constructor create(Req: THorseRequest; Res: THorseResponse);<N>end;<N><N>implementation<N><N>{ THorseGBSwagger }<N><N>constructor THorseGBSwagger.create(Req: THorseRequest; Res: THorseResponse);<N>begin<N>  FRequest := Req;<N>  FResponse:= Res;<N>end;<N><N>end.<N>
unit Horse.GBSwagger;<N><N>interface<N><N>uses<N>  Horse,<N>  Horse.GBSwagger.Register,<N>  Horse.GBSwagger.Controller,<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Model.JSON.Interfaces,<N>  GBSwagger.Model.Types,<N>  GBSwagger.Web.HTML,<N>  System.JSON,<N>  System.Classes,<N>  System.StrUtils,<N>  System.SysUtils,<N>  Web.HTTPApp;<N><N>
unit GBSwagger.Model.JSON.Security;<N><N>interface<N><N>uses<N>  GBSwagger.Model.JSON.Interfaces,<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Model.Types,<N>  System.SysUtils,<N>  System.JSON;<N><N>type TGBSwaggerModelJSONSecurity = class(TInterfacedObject, IGBSwaggerModelJSON)<N><N>
  private<N>    FSwaggerSecurity: IGBSwaggerSecurity;<N><N>    function JSONBasicAuth: TJSONObject;<N>    function JSONAPIKey   : TJSONObject;<N>    function JSONOAuth    : TJSONObject;<N>  public<N>    constructor create(SwaggerSecurity: IGBSwaggerSecurity);<N>    class function New(SwaggerSecurity: IGBSwaggerSecurity): IGBSwaggerModelJSON;<N><N>
unit GBSwagger.Model.Info;<N><N>interface<N><N>uses<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Model.Contact;<N><N>type TGBSwaggerModelInfo = class(TInterfacedObject, IGBSwaggerInfo)<N><N>  private<N>    [Weak]<N>    FParent  : IGBSwagger;<N>    FContact : IGBSwaggerContact;<N>    FLicense : IGBSwaggerContact;<N><N>
    FTitle          : string;<N>    FDescription    : String;<N>    FTermsOfService : string;<N>    FVersion        : string;<N><N>  protected<N>    function &End: IGBSwagger;<N><N>    function Title          (Value: String): IGBSwaggerInfo; overload;<N>    function TermsOfService (Value: String): IGBSwaggerInfo; overload;<N>    function Description    (Value: String): IGBSwaggerInfo; overload;<N>    function Version        (Value: String): IGBSwaggerInfo; overload;<N><N>
    function Title          : string; overload;<N>    function Description    : String; overload;<N>    function TermsOfService : string; overload;<N>    function Version        : string; overload;<N><N>    function Contact: IGBSwaggerContact;<N>    function License: IGBSwaggerContact;<N><N>
  public<N>    class function New(Parent: IGBSwagger): IGBSwaggerInfo;<N>    constructor create(Parent: IGBSwagger);<N>    destructor  Destroy; override;<N><N>end;<N><N>implementation<N><N>{ TGBSwaggerModelInfo }<N><N>function TGBSwaggerModelInfo.Contact: IGBSwaggerContact;<N>begin<N>  if not Assigned(FContact) then<N>    FContact := TGBSwaggerModelContact.New(Self);<N>  result := FContact;<N>end;<N><N>
constructor TGBSwaggerModelInfo.create(Parent: IGBSwagger);<N>begin<N>  FParent         := Parent;<N>  FVersion        := '1.0.0';<N>  FTermsOfService := 'http://www.apache.org/licenses/LICENSE-2.0.txt';<N><N>  License<N>    .Name('Apache License - Version 2.0, January 2004')<N>    .URL('http://www.apache.org/licenses/LICENSE-2.0');<N>end;<N><N>
function TGBSwaggerModelInfo.Description: String;<N>begin<N>  result := FDescription;<N>end;<N><N>destructor TGBSwaggerModelInfo.Destroy;<N>begin<N><N>  inherited;<N>end;<N><N>function TGBSwaggerModelInfo.License: IGBSwaggerContact;<N>begin<N>  if not Assigned(FLicense) then<N>    FLicense := TGBSwaggerModelContact.New(Self);<N>  result := FLicense;<N>end;<N><N>
function TGBSwaggerModelInfo.Description(Value: String): IGBSwaggerInfo;<N>begin<N>  result := Self;<N>  FDescription := Value;<N>end;<N><N>class function TGBSwaggerModelInfo.New(Parent: IGBSwagger): IGBSwaggerInfo;<N>begin<N>  Result := Self.Create(Parent);<N>end;<N><N>
function TGBSwaggerModelInfo.&End: IGBSwagger;<N>begin<N>  result := FParent;<N>end;<N><N>function TGBSwaggerModelInfo.TermsOfService(Value: String): IGBSwaggerInfo;<N>begin<N>  Result := Self;<N>  FTermsOfService := Value;<N>end;<N><N>function TGBSwaggerModelInfo.TermsOfService: string;<N>begin<N>  result := FTermsOfService;<N>end;<N><N>
function TGBSwaggerModelInfo.Title: string;<N>begin<N>  result := FTitle;<N>end;<N><N>function TGBSwaggerModelInfo.Title(Value: String): IGBSwaggerInfo;<N>begin<N>  result := Self;<N>  FTitle := Value;<N>end;<N><N>function TGBSwaggerModelInfo.Version: string;<N>begin<N>  result := FVersion;<N>end;<N><N>
unit GBSwagger.Model.Security;<N><N>interface<N><N>uses<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Model.Types;<N><N>type TGBSwaggerModelSecurity = class(TInterfacedObject, IGBSwaggerSecurity)<N><N>  private<N>    [Weak]<N>    FParent: IGBSwagger;<N><N>
    FType             : TGBSwaggerSecurityType;<N>    FCallback         : TRouteCallback;<N>    FDescription      : String;<N>    FName             : String;<N>    FIn               : TGBSwaggerParamType;<N>    FFlow             : TGBSwaggerSecurityFlow;<N>    FAuthorizationURL : String;<N>    FTokenURL         : String;<N><N>
unit GBSwagger.Model.Path;<N><N>interface<N><N>uses<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Model.PathMethod,<N>  Web.HTTPApp,<N>  System.Generics.Collections;<N><N>type TGBSwaggerModelPath = class(TInterfacedObject, IGBSwaggerPath)<N><N>  private<N>    [Weak]<N>    FParent: IGBSwagger;<N><N>
    FName: string;<N>    FTags: TList<String>;<N>    FMethods: TList<IGBSwaggerPathMethod>;<N><N>    function AddMethod(Summary, Description: String): IGBSwaggerPathMethod;<N>  protected<N>    function Name(Value: String): IGBSwaggerPath; overload;<N>    function Name: string; overload;<N><N>
unit GBSwagger.Model.JSON.Parameter;<N><N>interface<N><N>uses<N>  GBSwagger.Model.JSON.Interfaces,<N>  GBSwagger.Model.JSON.Utils,<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Model.Types,<N>  System.SysUtils,<N>  System.StrUtils,<N>  System.Variants,<N>  System.JSON;<N><N>
type TGBSwaggerModelJSONParameter = class(TInterfacedObject, IGBSwaggerModelJSON)<N><N>  private<N>    FSwaggerParameter: IGBSwaggerParameter;<N><N>    procedure ParamEnum(AJsonObject: TJSONObject);<N>  public<N>    constructor create(SwaggerParameter: IGBSwaggerParameter);<N>    class function New(SwaggerParameter: IGBSwaggerParameter): IGBSwaggerModelJSON;<N><N>
    function ToJSON: TJSONValue;<N>end;<N><N>implementation<N><N>{ TGBSwaggerModelJSONParameter }<N><N>constructor TGBSwaggerModelJSONParameter.create(SwaggerParameter: IGBSwaggerParameter);<N>begin<N>  FSwaggerParameter := SwaggerParameter;<N>end;<N><N>class function TGBSwaggerModelJSONParameter.New(SwaggerParameter: IGBSwaggerParameter): IGBSwaggerModelJSON;<N>begin<N>  result := Self.create(SwaggerParameter);<N>end;<N><N>
procedure TGBSwaggerModelJSONParameter.ParamEnum(AJsonObject: TJSONObject);<N>var<N>  jsonArray: TJSONArray;<N>  i        : Integer;<N>begin<N>  jsonArray := TJSONArray.Create;<N>  for i := 0 to Pred(Length(FSwaggerParameter.EnumValues)) do<N>    jsonArray.Add(VarToStr( FSwaggerParameter.EnumValues[i]));<N><N>
  AJsonObject<N>    .AddPair('type', 'array')<N>    .AddPair('items', TJSONObject.Create<N>                        .AddPair('type', 'string')<N>                        .AddPair('enum', jsonArray))<N>                        .AddPair('default', VarToStr(FSwaggerParameter.EnumValues[0]));<N>end;<N><N>
function TGBSwaggerModelJSONParameter.ToJSON: TJSONValue;<N>var<N>  jsonObject: TJSONObject;<N>  schemaName: string;<N>begin<N>  jsonObject := TJSONObject.Create<N>                  .AddPair('in', FSwaggerParameter.ParamType.toString)<N>                  .AddPair('name', FSwaggerParameter.Name)<N>                  .AddPair('description', FSwaggerParameter.Description)<N>                  .AddPair('required', TJSONBool.Create(FSwaggerParameter.Required));<N><N>
unit GBSwagger.Model.JSON.PathResponse;<N><N>interface<N><N>uses<N>  GBSwagger.RTTI,<N>  GBSwagger.Model.JSON.Utils,<N>  GBSwagger.Model.JSON.Interfaces,<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Model.JSON.Header,<N>  GBSwagger.Model.Types,<N>  System.SysUtils,<N>  System.StrUtils,<N>  System.JSON;<N><N>
type TGBSwaggerModelJSONPathResponse = class(TInterfacedObject, IGBSwaggerModelJSON)<N><N>  private<N>    FSwaggerPathResponse: IGBSwaggerPathResponse;<N><N>    function JSONSchema   : TJSONObject;<N>    function JSONHeaders  : TJSONObject;<N>  public<N>    constructor create(SwaggerPathResponse: IGBSwaggerPathResponse);<N>    class function New(SwaggerPathResponse: IGBSwaggerPathResponse): IGBSwaggerModelJSON;<N><N>
    function ToJSON: TJSONValue;<N>end;<N><N>implementation<N><N>{ TGBSwaggerModelJSONPathResponse }<N><N>constructor TGBSwaggerModelJSONPathResponse.create(SwaggerPathResponse: IGBSwaggerPathResponse);<N>begin<N>  FSwaggerPathResponse := SwaggerPathResponse;<N>end;<N><N>
function TGBSwaggerModelJSONPathResponse.JSONHeaders: TJSONObject;<N>var<N>  header  : IGBSwaggerHeader;<N>  headers : TArray<IGBSwaggerHeader>;<N>begin<N>  result  := TJSONObject.Create;<N>  headers := FSwaggerPathResponse.Headers;<N><N>  if Length(headers) > 0 then<N>  begin<N>    for header in headers do<N>      result.AddPair(header.Name, TGBSwaggerModelJSONHeader.New(header).ToJSON);<N>  end;<N>end;<N><N>
function TGBSwaggerModelJSONPathResponse.JSONSchema: TJSONObject;<N>var<N>  schemaName: String;<N>begin<N>  schemaName := FSwaggerPathResponse.&End.&End.&End.SchemaName(FSwaggerPathResponse.Schema);<N>  if FSwaggerPathResponse.IsArray then<N>    result := TGBSwaggerModelJSONUtils.JSONSchemaArray(schemaName)<N>  else<N>    result := TGBSwaggerModelJSONUtils.JSONSchemaObject(schemaName);<N>end;<N><N>
class function TGBSwaggerModelJSONPathResponse.New(SwaggerPathResponse: IGBSwaggerPathResponse): IGBSwaggerModelJSON;<N>begin<N>  result := Self.create(SwaggerPathResponse);<N>end;<N><N>function TGBSwaggerModelJSONPathResponse.ToJSON: TJSONValue;<N>var<N>  json: TJSONObject;<N>begin<N>  json := TJSONObject.Create<N>              .AddPair('description', FSwaggerPathResponse.Description);<N><N>
  if Assigned(FSwaggerPathResponse.Schema) then<N>    json.AddPair('schema', JSONSchema)<N>  else<N>    json.AddPair('schema', TJSONObject.Create<N>                            .AddPair('type', FSwaggerPathResponse.&Type));<N><N>  json.AddPair('headers', JSONHeaders);<N>  result := json;<N>end;<N><N>
unit GBSwagger.Web.HTML;<N><N>interface<N><N>uses<N>  System.SysUtils,<N>  System.StrUtils,<N>  GBSwagger.Resources;<N><N>function SwaggerDocument(AResourcePath, AJsonPath: String): string; overload;<N><N>implementation<N><N>function SwaggerDocument(AResourcePath, AJsonPath: String): string;<N>begin<N>  result := GETSwagger_HTML(AJsonPath);<N>end;<N><N>end.<N>
unit GBSwagger.Model.JSON.Info;<N><N>interface<N><N>uses<N>  GBSwagger.Model.JSON.Interfaces,<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Model.Types,<N>  GBSwagger.Model.JSON.Contact,<N>  System.JSON,<N>  System.SysUtils;<N><N>type TGBSwaggerModelJSONInfo = class(TInterfacedObject, IGBSwaggerModelJSON)<N><N>
  private<N>    FSwaggerInfo: IGBSwaggerInfo;<N><N>  public<N>    constructor create(SwaggerInfo: IGBSwaggerInfo);<N>    class function New(SwaggerInfo: IGBSwaggerInfo): IGBSwaggerModelJSON;<N><N>    function ToJSON: TJSONValue;<N><N>end;<N><N>implementation<N><N>
{ TGBSwaggerModelJSONInfo }<N><N>constructor TGBSwaggerModelJSONInfo.create(SwaggerInfo: IGBSwaggerInfo);<N>begin<N>  FSwaggerInfo := SwaggerInfo;<N>end;<N><N>class function TGBSwaggerModelJSONInfo.New(SwaggerInfo: IGBSwaggerInfo): IGBSwaggerModelJSON;<N>begin<N>  Result := Self.create(SwaggerInfo);<N>end;<N><N>
function TGBSwaggerModelJSONInfo.ToJSON: TJSONValue;<N>var<N>  title: string;<N>  ext  : string;<N>begin<N>  title := FSwaggerInfo.Title;<N>  if title.IsEmpty then<N>  begin<N>    title := ExtractFileName(GetModuleName(HInstance));<N>    ext   := ExtractFileExt(title);<N>    title := title.Replace(ext, EmptyStr);<N>  end;<N><N>
  result := TJSONObject.Create<N>              .AddPair('description', FSwaggerInfo.Description)<N>              .AddPair('version', FSwaggerInfo.Version)<N>              .AddPair('title', title)<N>              .AddPair('termsOfService', FSwaggerInfo.TermsOfService)<N>              .AddPair('contact', TGBSwaggerModelJSONContact.New(FSwaggerInfo.Contact).ToJSON)<N>              .AddPair('license', TGBSwaggerModelJSONContact.New(FSwaggerInfo.License).ToJSON);<N>end;<N><N>
unit GBSwagger.Register;<N><N>interface<N><N>uses<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Register.Interfaces,<N>  System.Generics.Collections;<N><N>type TGBSwaggerRegister = class(TInterfacedObject, IGBSwaggerRegister)<N><N>  protected<N>    [Weak]<N>    FParent: IGBSwagger;<N>    FResponse: IGBSwaggerRegisterResponse;<N>    FSchemaOnError: TClass;<N>    FListResponses: TList<Integer>;<N><N>
    function ResponseExists(StatusCode: Integer): Boolean;<N>    function Response(StatusCode: Integer): IGBSwaggerRegisterResponse;<N>    function SchemaOnError (Value: TClass): IGBSwaggerRegister;<N><N>    function &End: IGBSwagger;<N>  public<N>    constructor create(Parent: IGBSwagger);<N>    class function New(Parent: IGBSwagger): IGBSwaggerRegister;<N>    destructor Destroy; override;<N>end;<N><N>
implementation<N><N>{ TGBSwaggerRegister }<N><N>uses<N>  GBSwagger.Register.Response;<N><N>destructor TGBSwaggerRegister.Destroy;<N>begin<N>  FListResponses.free;<N>  inherited;<N>end;<N><N>function TGBSwaggerRegister.&End: IGBSwagger;<N>begin<N>  result := FParent;<N>end;<N><N>
constructor TGBSwaggerRegister.create(Parent: IGBSwagger);<N>begin<N>  FParent       := Parent;<N>  FResponse     := TGBSwaggerRegisterResponse.New(Self);<N>  FListResponses:= TList<Integer>.create;<N>end;<N><N>class function TGBSwaggerRegister.New(Parent: IGBSwagger): IGBSwaggerRegister;<N>begin<N>  Result := Self.create(Parent);<N>end;<N><N>
function TGBSwaggerRegister.Response(StatusCode: Integer): IGBSwaggerRegisterResponse;<N>begin<N>  result := FResponse.Register(StatusCode);<N>  if not FListResponses.Contains(StatusCode) then<N>    FListResponses.Add(StatusCode);<N>end;<N><N>function TGBSwaggerRegister.ResponseExists(StatusCode: Integer): Boolean;<N>begin<N>  result := FListResponses.Contains(StatusCode);<N>end;<N><N>
function TGBSwaggerRegister.SchemaOnError(Value: TClass): IGBSwaggerRegister;<N>var<N>  i: Integer;<N>begin<N>  result := Self;<N>  FSchemaOnError := Value;<N><N>  for i := 0 to Pred(Self.FListResponses.Count) do<N>  begin<N>    if FListResponses.Items[i] >= 400 then<N>      Self.Response(FListResponses[i]).Schema(FSchemaOnError);<N>  end;<N>end;<N><N>
unit GBSwagger.Model.JSON.Header;<N><N>interface<N><N>uses<N>  GBSwagger.Model.JSON.Interfaces,<N>  GBSwagger.Model.Interfaces,<N>  System.SysUtils,<N>  System.StrUtils,<N>  System.JSON;<N><N>type TGBSwaggerModelJSONHeader = class(TInterfacedObject, IGBSwaggerModelJSON)<N><N>
  private<N>    FSwaggerHeader: IGBSwaggerHeader;<N><N>  public<N>    constructor create(SwaggerHeader: IGBSwaggerHeader);<N>    class function New(SwaggerHeader: IGBSwaggerHeader): IGBSwaggerModelJSON;<N><N>    function ToJSON: TJSONValue;<N>end;<N><N>implementation<N><N>
{ TGBSwaggerModelJSONHeader }<N><N>constructor TGBSwaggerModelJSONHeader.create(SwaggerHeader: IGBSwaggerHeader);<N>begin<N>  FSwaggerHeader := SwaggerHeader;<N>end;<N><N>class function TGBSwaggerModelJSONHeader.New(SwaggerHeader: IGBSwaggerHeader): IGBSwaggerModelJSON;<N>begin<N>  result := Self.create(SwaggerHeader);<N>end;<N><N>
function TGBSwaggerModelJSONHeader.ToJSON: TJSONValue;<N>begin<N>  result :=<N>    TJSONObject.Create<N>      .AddPair('type', FSwaggerHeader.&Type)<N>      .AddPair('format', FSwaggerHeader.Format)<N>      .AddPair('description', FSwaggerHeader.Description);<N><N>
unit GBSwagger.Model.PathMethod;<N><N>interface<N><N>uses<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Model.Types,<N>  GBSwagger.Model.Parameter,<N>  GBSwagger.Model.PathResponse,<N>  System.Generics.Collections,<N>  System.SysUtils,<N>  Web.HTTPApp;<N><N>
type TGBSwaggerModelPathMethod = class(TInterfacedObject, IGBSwaggerPathMethod)<N><N>  private<N>    [Weak]<N>    FParent: IGBSwaggerPath;<N><N>    FMethodType : TMethodType;<N>    FSummary    : String;<N>    FDescription: string;<N>    FOperationId: string;<N>    FIsPublic   : Boolean;<N><N>
unit GBSwagger.Path.Attributes;<N><N>interface<N><N>uses<N>  GBSwagger.Model.Types,<N>  System.SysUtils;<N><N>type<N>  SwagApp = class(TCustomAttribute)<N>  private<N>    FTitle: string;<N>    FVersion: String;<N>    FHost: string;<N><N>  public<N>    property title: String read FTitle;<N>    property version: string read FVersion;<N>    property host: string read FHost;<N><N>
    constructor create(ATitle, AVersion: string; AHost: String = ''); overload;<N>    constructor create(ATitle: String); overload;<N>  end;<N><N>  SwagContact = class(TCustomAttribute)<N>  private<N>    Fname: String;<N>    Femail: String;<N>    Fsite: String;<N><N>
  public<N>    property name: String read Fname;<N>    property email: String read Femail;<N>    property site: String read Fsite;<N><N>    constructor create(AName: string; AEmail: String = ''; ASite: string = '');<N>  end;<N><N>  SwagBasePath = class(TCustomAttribute)<N>  private<N>    FValue: string;<N>  public<N>    constructor create(Value: String);<N>    property value: String read FValue;<N>  end;<N><N>
  SwagAppDescription = class(TCustomAttribute)<N>  private<N>    FDescription: string;<N>  public<N>    constructor create(ADescription: String);<N>    property description: string read FDescription;<N>  end;<N><N>  SwagSecurityBearer = class(TCustomAttribute)<N>  end;<N><N>
  SwagSecurityBasic = class(TCustomAttribute)<N>  end;<N><N>  SwagPath = class(TCustomAttribute)<N>  private<N>    Fname: string;<N>    Ftag: String;<N>  public<N>    property name: string read Fname;<N>    property tag: String read Ftag write Ftag;<N><N>    constructor create(ATag: String); overload;<N>    constructor create(AName, ATag: string); overload;<N>  end;<N><N>
unit GBSwagger.Model.PathResponse;<N><N>interface<N><N>uses<N>  System.SysUtils,<N>  System.Generics.Collections,<N>  GBSwagger.Model.Types,<N>  GBSwagger.Model.Header,<N>  GBSwagger.Model.Interfaces;<N><N>type TGBSwaggerModelPathResponse = class(TInterfacedObject, IGBSwaggerPathResponse)<N><N>
  private<N>    [Weak]<N>    FParent: IGBSwaggerPathMethod;<N><N>    FHttpCode   : Integer;<N>    FDescription: String;<N>    FSchemaStr  : string;<N>    FSchema     : TClass;<N>    FIsArray    : Boolean;<N>    FHeaders    : TList<IGBSwaggerHeader>;<N><N>    function GetHeader(Name: String): IGBSwaggerHeader;<N><N>
  protected<N>    function HttpCode    (Value: Integer): IGBSwaggerPathResponse; overload;<N>    function Description (Value: String): IGBSwaggerPathResponse; overload;<N>    function Schema      (Value: String): IGBSwaggerPathResponse; overload;<N>    function Schema      (Value: TClass): IGBSwaggerPathResponse; overload;<N>    function IsArray     (Value: Boolean): IGBSwaggerPathResponse; overload;<N><N>
    function Header(Name: String = ''; Description: String = ''): IGBSwaggerHeader;<N>    function Headers: TArray<IGBSwaggerHeader>;<N><N>    function HttpCode   : Integer; overload;<N>    function Description: String; overload;<N>    function Schema     : TClass; overload;<N>    function IsArray    : Boolean; overload;<N>    function &Type      : string;<N><N>
    function &End: IGBSwaggerPathMethod;<N><N>  public<N>    constructor create(Parent: IGBSwaggerPathMethod);<N>    class function New(Parent: IGBSwaggerPathMethod): IGBSwaggerPathResponse;<N>    destructor Destroy; override;<N>end;<N><N>implementation<N><N>
{ TGBSwaggerModelPathResponse }<N><N>function TGBSwaggerModelPathResponse.Header(Name, Description: String): IGBSwaggerHeader;<N>begin<N>  result := GetHeader(Name);<N><N>  if not Assigned(Result) then<N>  begin<N>    result := TGBSwaggerModelHeader.New(Self)<N>                .Name(Name)<N>                .Description(Description);<N><N>
    FHeaders.Add(result);<N>  end;<N>end;<N><N>function TGBSwaggerModelPathResponse.Headers: TArray<IGBSwaggerHeader>;<N>begin<N>  result := FHeaders.ToArray;<N>end;<N><N>function TGBSwaggerModelPathResponse.&Type: string;<N>begin<N>  Result := FSchemaStr;<N>end;<N><N>
constructor TGBSwaggerModelPathResponse.create(Parent: IGBSwaggerPathMethod);<N>begin<N>  FParent  := Parent;<N>  FIsArray := False;<N>  FHeaders := TList<IGBSwaggerHeader>.create;<N>end;<N><N>function TGBSwaggerModelPathResponse.Description: String;<N>begin<N>  result := FDescription;<N>end;<N><N>
function TGBSwaggerModelPathResponse.Description(Value: String): IGBSwaggerPathResponse;<N>begin<N>  result := Self;<N>  FDescription := Value;<N>end;<N><N>destructor TGBSwaggerModelPathResponse.Destroy;<N>begin<N>  FHeaders.Free;<N>  inherited;<N>end;<N><N>
function TGBSwaggerModelPathResponse.&End: IGBSwaggerPathMethod;<N>begin<N>  Result := FParent;<N>end;<N><N>function TGBSwaggerModelPathResponse.GetHeader(Name: String): IGBSwaggerHeader;<N>var<N>  iHeader: IGBSwaggerHeader;<N>begin<N>  result := nil;<N>  for iHeader in FHeaders do<N>  begin<N>    if iHeader.Name.ToLower.Equals(Name.ToLower) then<N>      Exit(iHeader);<N>  end;<N>end;<N><N>
function TGBSwaggerModelPathResponse.HttpCode(Value: Integer): IGBSwaggerPathResponse;<N>begin<N>  result := Self;<N>  FHttpCode := Value;<N>end;<N><N>function TGBSwaggerModelPathResponse.HttpCode: Integer;<N>begin<N>  Result := FHttpCode;<N>end;<N><N>function TGBSwaggerModelPathResponse.IsArray(Value: Boolean): IGBSwaggerPathResponse;<N>begin<N>  result := Self;<N>  FIsArray := Value;<N>end;<N><N>
function TGBSwaggerModelPathResponse.IsArray: Boolean;<N>begin<N>  result := FIsArray;<N>end;<N><N>class function TGBSwaggerModelPathResponse.New(Parent: IGBSwaggerPathMethod): IGBSwaggerPathResponse;<N>begin<N>  result := Self.create(Parent);<N>end;<N><N>
function TGBSwaggerModelPathResponse.Schema(Value: String): IGBSwaggerPathResponse;<N>begin<N>  result := Self;<N>  FSchemaStr := Value;<N>end;<N><N>function TGBSwaggerModelPathResponse.Schema(Value: TClass): IGBSwaggerPathResponse;<N>begin<N>  result  := Self;<N>  FSchema := Value;<N><N>
  if (Assigned(FParent)) and (Assigned(FSchema)) then<N>  begin<N>    FParent.&End<N>      .&End<N>      .AddModel(FSchema);<N>  end;<N><N>end;<N><N>function TGBSwaggerModelPathResponse.Schema: TClass;<N>begin<N>  result := FSchema;<N>end;<N><N>end.<N><N><N>
unit GBSwagger.Model.Header;<N><N>interface<N><N>uses<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Model.Types;<N><N>type TGBSwaggerModelHeader = class(TInterfacedObject, IGBSwaggerHeader)<N><N>  private<N>    [Weak]<N>    FParent: IGBSwaggerPathResponse;<N><N>
    FName        : string;<N>    FDescription : string;<N>    FType        : string;<N>    FFormat      : string;<N><N>  protected<N>    function Name        : String; overload;<N>    function Description : String; overload;<N>    function &Type       : String; overload;<N>    function Format      : string; overload;<N><N>
    function Name        (Value: String): IGBSwaggerHeader; overload;<N>    function Description (Value: String): IGBSwaggerHeader; overload;<N>    function &Type       (Value: String): IGBSwaggerHeader; overload;<N>    function Format      (Value: String): IGBSwaggerHeader; overload;<N><N>
    function &End: IGBSwaggerPathResponse;<N><N>  public<N>    constructor create(Parent: IGBSwaggerPathResponse);<N>    class function New(Parent: IGBSwaggerPathResponse): IGBSwaggerHeader;<N>    destructor  Destroy; override;<N><N>end;<N><N>implementation<N><N>
{ TGBSwaggerModelHeader }<N><N>constructor TGBSwaggerModelHeader.create(Parent: IGBSwaggerPathResponse);<N>begin<N>  FParent := Parent;<N>  FType   := SWAG_STRING;<N>end;<N><N>function TGBSwaggerModelHeader.Description(Value: String): IGBSwaggerHeader;<N>begin<N>  result := Self;<N>  FDescription := Value;<N>end;<N><N>
function TGBSwaggerModelHeader.Description: String;<N>begin<N>  result := FDescription;<N>end;<N><N>destructor TGBSwaggerModelHeader.Destroy;<N>begin<N><N>  inherited;<N>end;<N><N>function TGBSwaggerModelHeader.&End: IGBSwaggerPathResponse;<N>begin<N>  result := FParent;<N>end;<N><N>
function TGBSwaggerModelHeader.Format(Value: String): IGBSwaggerHeader;<N>begin<N>  result := Self;<N>  FFormat := Value;<N>end;<N><N>function TGBSwaggerModelHeader.Format: string;<N>begin<N>  result := FFormat;<N>end;<N><N>function TGBSwaggerModelHeader.Name(Value: String): IGBSwaggerHeader;<N>begin<N>  result := Self;<N>  FName  := Value;<N>end;<N><N>
function TGBSwaggerModelHeader.Name: String;<N>begin<N>  result := FName;<N>end;<N><N>class function TGBSwaggerModelHeader.New(Parent: IGBSwaggerPathResponse): IGBSwaggerHeader;<N>begin<N>  Result := Self.create(Parent);<N>end;<N><N>function TGBSwaggerModelHeader.&Type: String;<N>begin<N>  result := FType;<N>end;<N><N>
unit GBSwagger.Model.Parameter;<N><N>interface<N><N>uses<N>  System.SysUtils,<N>  System.StrUtils,<N>  System.Rtti,<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.RTTI,<N>  GBSwagger.Model.Types;<N><N>type TGBSwaggerModelParameter = class(TInterfacedObject, IGBSwaggerParameter)<N><N>
  private<N>    [Weak]<N>    FParent: IGBSwaggerPathMethod;<N><N>    FParamType  : TGBSwaggerParamType;<N>    FName       : string;<N>    FDescription: String;<N>    FSchemaStr  : string;<N>    FSchema     : TClass;<N>    FRequired   : Boolean;<N>    FIsArray    : Boolean;<N>    FEnumValues : TArray<Variant>;<N><N>
unit GBSwagger.Model.JSON.Path;<N><N>interface<N><N>uses<N>  GBSwagger.Model.JSON.Interfaces,<N>  GBSwagger.Model.JSON.Utils,<N>  GBSwagger.Model.JSON.PathMethod,<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Model.Types,<N>  System.SysUtils,<N>  System.StrUtils,<N>  System.JSON;<N><N>
type TGBSwaggerModelJSONPath = class(TInterfacedObject, IGBSwaggerModelJSON)<N><N>  private<N>    FSwaggerPath: IGBSwaggerPath;<N><N>  public<N>    constructor create(SwaggerPath: IGBSwaggerPath);<N>    class function New(SwaggerPath: IGBSwaggerPath): IGBSwaggerModelJSON;<N><N>
    function ToJSON: TJSONValue;<N>end;<N><N>implementation<N><N>{ TGBSwaggerModelJSONPath }<N><N>constructor TGBSwaggerModelJSONPath.create(SwaggerPath: IGBSwaggerPath);<N>begin<N>  FSwaggerPath := SwaggerPath;<N>end;<N><N>class function TGBSwaggerModelJSONPath.New(SwaggerPath: IGBSwaggerPath): IGBSwaggerModelJSON;<N>begin<N>  result := Self.create(SwaggerPath);<N>end;<N><N>
function TGBSwaggerModelJSONPath.ToJSON: TJSONValue;<N>var<N>  jsonObject: TJSONObject;<N>  i         : Integer;<N>begin<N>  jsonObject := TJSONObject.Create;<N><N>  for i := 0 to Pred(Length(FSwaggerPath.Methods)) do<N>    jsonObject.AddPair(<N>        FSwaggerPath.Methods[i].MethodType.toString,<N>        TGBSwaggerModelJSONPathMethod.New(FSwaggerPath.Methods[i]).ToJSON<N>    );<N><N>
unit GBSwagger.Model.JSON.Interfaces;<N><N>interface<N><N>uses<N>  REST.Json,<N>  System.JSON,<N>  GBSwagger.Model.Interfaces;<N><N>type<N>  IGBSwaggerModelJSON = interface<N>    function ToJSON: TJSONValue;<N>  end;<N><N>function SwaggerJSON      (ASwagger: IGBSwagger): TJSONValue;<N>function SwaggerJSONString(ASwagger: IGBSwagger): String;<N><N>
unit GBSwagger.Model.JSON.Contact;<N><N>interface<N><N>uses<N>  GBSwagger.Model.JSON.Interfaces,<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Model.Types,<N>  System.JSON;<N><N>type TGBSwaggerModelJSONContact = class(TInterfacedObject, IGBSwaggerModelJSON)<N><N>
  private<N>    FSwaggerContact: IGBSwaggerContact;<N><N>  public<N>    constructor create(SwaggerContact: IGBSwaggerContact);<N>    class function New(SwaggerContact: IGBSwaggerContact): IGBSwaggerModelJSON;<N><N>    function ToJSON: TJSONValue;<N>end;<N><N>
implementation<N><N>{ TGBSwaggerModelJSONContact }<N><N>constructor TGBSwaggerModelJSONContact.create(SwaggerContact: IGBSwaggerContact);<N>begin<N>  FSwaggerContact := SwaggerContact;<N>end;<N><N>class function TGBSwaggerModelJSONContact.New(SwaggerContact: IGBSwaggerContact): IGBSwaggerModelJSON;<N>begin<N>  result := Self.create(SwaggerContact);<N>end;<N><N>
function TGBSwaggerModelJSONContact.ToJSON: TJSONValue;<N>begin<N>  Result := TJSONObject.Create<N>              .AddPair('name', FSwaggerContact.Name)<N>              .AddPair('email', FSwaggerContact.Email)<N>              .AddPair('url', FSwaggerContact.URL);<N>end;<N><N>
unit GBSwagger.Model.Types;<N><N>interface<N><N>uses<N>  {$IFNDEF DSNAP}<N>  Horse,<N>  {$ENDIF}<N>  System.SysUtils,<N>  Web.HTTPApp;<N><N>const<N>  SWAG_STRING  = 'string';<N>  SWAG_INTEGER = 'integer';<N><N>type<N>  TRouteCallback = {$IFNDEF HORSE} Horse.THorseCallback {$ELSE} TObject {$ENDIF};<N><N>
  TGBSwaggerContentType = (gbAppJSON, gbAppXML, gbTextHtml, gbPlainText, gbMultiPartFormData, gbAppOctetStream);<N>  TGBSwaggerProtocol    = (gbHttp, gbHttps);<N>  TGBSwaggerParamType   = (gbHeader, gbBody, gbQuery, gbPath, gbFormData);<N>  TGBSwaggerSecurityType = (gbBasic, gbApiKey, gbOAuth2);<N>  TGBSwaggerSecurityFlow = (gbImplicit, gbPassword, gbApplication, gbAccessCode);<N><N>
unit GBSwagger.Model.JSON;<N><N>interface<N><N>uses<N>  GBSwagger.Model.JSON.Interfaces,<N>  GBSwagger.Model.JSON.Info,<N>  GBSwagger.Model.JSON.Schema,<N>  GBSwagger.Model.JSON.Path,<N>  GBSwagger.Model.JSON.Security,<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Model.Types,<N>  GBSwagger.Model,<N>  GBSwagger.RTTI,<N>  System.SysUtils,<N>  System.Generics.Collections,<N>  System.Generics.Defaults,<N>  System.JSON;<N><N>
unit GBSwagger.Model;<N><N>interface<N><N>uses<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Model.Types,<N>  GBSwagger.Model.Info,<N>  GBSwagger.Model.Tag,<N>  GBSwagger.Model.Path,<N>  GBSwagger.Model.Schema,<N>  GBSwagger.Model.Config,<N>  GBSwagger.Model.Security,<N>  GBSwagger.RTTI,<N>  System.SysUtils,<N>  System.TypInfo,<N>  System.StrUtils,<N>  System.Generics.Collections,<N>  Web.HTTPApp;<N><N>
unit GBSwagger.Model.JSON.PathMethod;<N><N>interface<N><N>uses<N>  GBSwagger.Model.JSON.Interfaces,<N>  GBSwagger.Model.JSON.Utils,<N>  GBSwagger.Model.JSON.PathResponse,<N>  GBSwagger.Model.JSON.Parameter,<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Model.Types,<N>  System.SysUtils,<N>  System.StrUtils,<N>  System.JSON;<N><N>
unit GBSwagger.Model.Tag;<N><N>interface<N><N>uses<N>  GBSwagger.Model.Interfaces;<N><N>type TGBSwaggerModelTag = class(TInterfacedObject, IGBSwaggerTag)<N><N>  private<N>    [Weak]<N>    FParent: IGBSwagger;<N><N>    FName          : String;<N>    FDescription   : String;<N>    FDocDescription: String;<N>    FDocURL        : String;<N><N>
  protected<N>    function Name           (Value: String): IGBSwaggerTag; overload;<N>    function Description    (Value: String): IGBSwaggerTag; overload;<N>    function DocDescription (Value: String): IGBSwaggerTag; overload;<N>    function DocURL         (Value: String): IGBSwaggerTag; overload;<N><N>
    function Name          : String; overload;<N>    function Description   : String; overload;<N>    function DocDescription: String; overload;<N>    function DocURL        : String; overload;<N><N>    function &End: IGBSwagger;<N><N>  public<N>    constructor create(Parent: IGBSwagger);<N>    class function New(Parent: IGBSwagger): IGBSwaggerTag;<N>    destructor  Destroy; override;<N>end;<N><N>
implementation<N><N>{ TGBSwaggerModelTag }<N><N>constructor TGBSwaggerModelTag.create(Parent: IGBSwagger);<N>begin<N>  FParent := Parent;<N>end;<N><N>function TGBSwaggerModelTag.Description(Value: String): IGBSwaggerTag;<N>begin<N>  result := Self;<N>  FDescription := Value;<N>end;<N><N>
function TGBSwaggerModelTag.Description: String;<N>begin<N>  result := FDescription;<N>end;<N><N>destructor TGBSwaggerModelTag.Destroy;<N>begin<N><N>  inherited;<N>end;<N><N>function TGBSwaggerModelTag.DocDescription(Value: String): IGBSwaggerTag;<N>begin<N>  result := Self;<N>  FDocDescription := Value;<N>end;<N><N>
function TGBSwaggerModelTag.DocDescription: String;<N>begin<N>  result := FDocDescription;<N>end;<N><N>function TGBSwaggerModelTag.DocURL(Value: String): IGBSwaggerTag;<N>begin<N>  result  := Self;<N>  FDocURL := Value;<N>end;<N><N>function TGBSwaggerModelTag.DocURL: String;<N>begin<N>  Result := FDocURL;<N>end;<N><N>
function TGBSwaggerModelTag.Name(Value: String): IGBSwaggerTag;<N>begin<N>  result := Self;<N>  FName  := Value;<N>end;<N><N>function TGBSwaggerModelTag.Name: String;<N>begin<N>  result := FName;<N>end;<N><N>class function TGBSwaggerModelTag.New(Parent: IGBSwagger): IGBSwaggerTag;<N>begin<N>  result := Self.create(Parent);<N>end;<N><N>
unit GBSwagger.Model.Schema;<N><N>interface<N><N>uses<N>  GBSwagger.Model.Interfaces;<N><N>type TGBSwaggerModelSchema = class(TInterfacedObject, IGBSwaggerSchema)<N><N>  private<N>    [Weak]<N>    FParent: IGBSwagger;<N><N>    FName     : String;<N>    FClassType: TClass;<N>  protected<N>    function Name      (Value: String): IGBSwaggerSchema; overload;<N>    function ClassType (Value: TClass): IGBSwaggerSchema; overload;<N><N>
    function Name     : String; overload;<N>    function ClassType: TClass; overload;<N><N>    function &End: IGBSwagger;<N>  public<N>    constructor create(Parent: IGBSwagger);<N>    class function New(Parent: IGBSwagger): IGBSwaggerSchema;<N>    destructor  Destroy; override;<N><N>
end;<N><N>implementation<N><N>{ TGBSwaggerModelSchema }<N><N>function TGBSwaggerModelSchema.ClassType: TClass;<N>begin<N>  result := FClassType;<N>end;<N><N>function TGBSwaggerModelSchema.ClassType(Value: TClass): IGBSwaggerSchema;<N>begin<N>  result := Self;<N>  FClassType := Value;<N>end;<N><N>
constructor TGBSwaggerModelSchema.create(Parent: IGBSwagger);<N>begin<N>  FParent := Parent;<N>end;<N><N>destructor TGBSwaggerModelSchema.Destroy;<N>begin<N><N>  inherited;<N>end;<N><N>function TGBSwaggerModelSchema.Name(Value: String): IGBSwaggerSchema;<N>begin<N>  result := Self;<N>  FName  := Value;<N>end;<N><N>
function TGBSwaggerModelSchema.Name: String;<N>begin<N>  result := FName;<N>end;<N><N>class function TGBSwaggerModelSchema.New(Parent: IGBSwagger): IGBSwaggerSchema;<N>begin<N>  result := Self.create(Parent);<N>end;<N><N>function TGBSwaggerModelSchema.&End: IGBSwagger;<N>begin<N>  result := FParent;<N>end;<N><N>
unit GBSwagger.Resources;<N><N>interface<N><N>uses<N>  System.SysUtils,<N>  System.Classes,<N>  System.StrUtils,<N>  Web.HTTPApp,<N>  Web.HTTPProd,<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Model.Types;<N><N>type<N>  TGBSwaggerResources = class(TDataModule)<N>    swagger_html: TPageProducer;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit GBSwagger.Model.Attributes;<N><N>interface<N><N>uses<N>  System.SysUtils;<N><N>type<N>  SwagClass = class(TCustomAttribute)<N>  private<N>    Fdescription: String;<N>    public<N>      constructor create(ADescription: String); overload;<N><N>      property description: String read Fdescription;<N>  end;<N><N>
  SwagRequired = class(TCustomAttribute)<N>  end;<N><N>  SwagIgnore = class(TCustomAttribute)<N>  private<N>    FIgnoreProperties: TArray<String>;<N><N>  public<N>    property IgnoreProperties: TArray<String> read FIgnoreProperties write FIgnoreProperties;<N>    constructor create; overload;<N>    constructor create(AIgnoreProperties: String); overload;<N>  end;<N><N>
  SwagProp = class(TCustomAttribute)<N>  protected<N>    FName: string;<N>    FDescription: string;<N>    FReadOnly: Boolean;<N>    FRequired: Boolean;<N><N>  public<N>    property name: String read FName write FName;<N>    property description: String read FDescription write FDescription;<N>    property readOnly: Boolean read FReadOnly write FReadOnly;<N>    property required: Boolean read FRequired write FRequired;<N><N>
    constructor create(AName: String;<N>                       ADescription: string = '';<N>                       bRequired: Boolean = False;<N>                       bReadOnly: Boolean = False); overload;<N><N>    constructor create(ADescription: string;<N>                       bRequired: Boolean;<N>                       bReadOnly: Boolean = False;<N>                       AName: string = ''); overload;<N><N>
    constructor create(bRequired: Boolean;<N>                       bReadOnly: Boolean = False;<N>                       ADescription: String = '';<N>                       AName: String = ''); overload;<N>  end;<N><N>  SwagString = class(TCustomAttribute)<N>  private<N>    FmaxLength: Integer;<N>    FminLength: Integer;<N>  public<N>    property minLength: Integer read FminLength;<N>    property maxLength: Integer read FmaxLength;<N><N>
    constructor create(AMaxLength: Integer; AMinLength: Integer = 0); overload;<N><N>  end;<N><N>  SwagNumber = class(TCustomAttribute)<N>  private<N>    Fminimum: Double;<N>    Fmaximum: Double;<N><N>    public<N>      constructor create(AMinimum: Double; AMaximum: Double = 0); overload;<N><N>
      property minimum: Double read Fminimum write Fminimum;<N>      property maximum: Double read Fmaximum write Fmaximum;<N>  end;<N><N>  SwagDate = class(TCustomAttribute)<N>  private<N>    FDateFormat: string;<N>  public<N>    constructor create(DateFormat: string);<N>    property dateFormat: string read FdateFormat;<N>  end;<N><N>
implementation<N><N>{ SwagClass }<N><N>constructor SwagClass.create(ADescription: String);<N>begin<N>  Fdescription:= ADescription;<N>end;<N><N>{ SwagNumber }<N><N>constructor SwagNumber.create(AMinimum: Double; AMaximum: Double = 0);<N>begin<N>  Fminimum := AMinimum;<N>  Fmaximum := AMaximum;<N>end;<N><N>
{ SwagString }<N><N>constructor SwagString.create(AMaxLength: Integer; AMinLength: Integer = 0);<N>begin<N>  FminLength := AMinLength;<N>  FMaxLength := AMaxLength;<N>end;<N><N>{ SwagDate }<N><N>constructor SwagDate.create(DateFormat: string);<N>begin<N>  FDateFormat := DateFormat;<N>end;<N><N>
{ SwagProp }<N><N>constructor SwagProp.create(AName, ADescription: string; bRequired, bReadOnly: Boolean);<N>begin<N>  FName        := AName;<N>  FDescription := ADescription;<N>  FRequired    := bRequired;<N>  FReadOnly    := bReadOnly;<N>end;<N><N>constructor SwagProp.create(bRequired, bReadOnly: Boolean; ADescription, AName: String);<N>begin<N>  FName        := AName;<N>  FDescription := ADescription;<N>  FRequired    := bRequired;<N>  FReadOnly    := bReadOnly;<N>end;<N><N>
constructor SwagProp.create(ADescription: string; bRequired,  bReadOnly: Boolean; AName: string);<N>begin<N>  FName        := AName;<N>  FDescription := ADescription;<N>  FRequired    := bRequired;<N>  FReadOnly    := bReadOnly;<N>end;<N><N>{ SwagIgnore }<N><N>
unit GBSwagger.Model.JSON.Utils;<N><N>interface<N><N>uses<N>  System.JSON,<N>  GBSwagger.Model.Types;<N><N>type TGBSwaggerModelJSONUtils = class<N><N>  public<N>    class function JSONContentTypes(Value: TArray<String>): TJSONArray;<N>    class function JSONProtocols   (Value: TArray<TGBSwaggerProtocol>)   : TJSONArray;<N><N>
    class function JSONSchemaArray (SchemaName: string): TJSONObject;<N>    class function JSONSchemaObject(SchemaName: string): TJSONObject;<N><N>end;<N><N>implementation<N><N>{ TGBSwaggerModelJSONUtils }<N><N>class function TGBSwaggerModelJSONUtils.JSONContentTypes(Value: TArray<String>): TJSONArray;<N>var<N>  i: Integer;<N>begin<N>  result := TJSONArray.Create;<N>  for i := 0 to Pred(Length(Value)) do<N>    Result.Add(Value[i]);<N>end;<N><N>
unit Datasnap.GBSwagger;<N><N>interface<N><N>uses<N>  Web.HTTPApp,<N>  Datasnap.DSServer,<N>  Datasnap.DSHTTPWebBroker,<N>  GBSwagger.Model.Interfaces,<N>  GBSwagger.Model.JSON.Interfaces,<N>  GBSwagger.Model.Types,<N>  GBSwagger.Web.HTML,<N>  GBSwagger.RTTI,<N>  GBSwagger.Path.Register,<N>  GBSwagger.Path.Attributes,<N>  Datasnap.GBSwagger.Scripts,<N>  System.JSON,<N>  System.SysUtils,<N>  System.StrUtils,<N>  system.classes;<N><N>
unit Datasnap.GBSwagger.Scripts;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, Web.HTTPApp, Web.HTTPProd;<N><N>type<N>  TDataModule1 = class(TDataModule)<N>    swagger_ui_bundle: TPageProducer;<N>    swagger_ui_standalone_preset: TPageProducer;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit GBSwagger.Validator.Attributes;<N><N>interface<N><N>uses<N>  System.Classes;<N><N>type SwagValidateProperties = class(TCustomAttribute)<N>  private<N>    Fproperties: TArray<String>;<N><N>  public<N>    constructor create(AProperties: String);<N>    property properties: TArray<String> read Fproperties;<N>end;<N><N>
implementation<N><N>{ SwagValidateProperties }<N><N>constructor SwagValidateProperties.create(AProperties: String);<N>var<N>  split: TStrings;<N>  i: Integer;<N>begin<N>  split := TStringList.Create;<N>  try<N>    split.Delimiter       := ',';<N>    split.StrictDelimiter := True;<N>    split.DelimitedText   := AProperties;<N><N>
unit GBSwagger.Validator.Interfaces;<N><N>interface<N><N>type<N>  IGBSwaggerValidator = interface<N>    ['{132A6324-5991-49CA-8006-880C6C7CE789}']<N>    procedure validate(Value: TObject; AInstanceName: String = '');<N>  end;<N><N>function SwaggerValidator: IGBSwaggerValidator;<N><N>implementation<N><N>uses<N>  GBSwagger.Validator.Base;<N><N>function SwaggerValidator: IGBSwaggerValidator;<N>begin<N>  result := TGBSwaggerValidator.New;<N>end;<N><N>end.<N>
unit GBSwagger.Validator.Base;<N><N>interface<N><N>uses<N>  GBSwagger.Model.Attributes,<N>  GBSwagger.Validator.Attributes,<N>  GBSwagger.Validator.Interfaces,<N>  GBSwagger.RTTI,<N>  System.Rtti,<N>  System.SysUtils,<N>  System.TypInfo;<N><N>type TGBSwaggerValidator = class(TInterfacedObject, IGBSwaggerValidator)<N><N>
  private<N>    function GetPropertyName(AProp: TRttiProperty; AInstanceName: String): string;<N><N>    procedure validateRequiredProperty(Value: TObject; AProp: TRttiProperty; AInstanceName: string);<N>    procedure validateNumberProperty  (Value: TObject; AProp: TRttiProperty; AInstanceName: string);<N><N>
unit DataSet.Serialize.Samples.Basic;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses Classes, SysUtils, memds, DB, Forms, Controls, Graphics, Dialogs, ComCtrls,<N>  ExtCtrls, StdCtrls, DBGrids, fpjson, DataSet.Serialize, TypInfo;<N><N>type<N><N>  { TFrmBasic }<N><N>
unit DataSet.Serialize.Samples.Basic;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics, System.JSON, Vcl.Controls,<N>  Vcl.Forms, Vcl.Dialogs, Vcl.ComCtrls, Vcl.ExtCtrls, Vcl.StdCtrls, Data.DB, Vcl.Grids, Vcl.DBGrids, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, DataSet.Serialize;<N><N>
unit DataSet.Serialize.Samples.Master.Detail;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.ComCtrls, Vcl.StdCtrls, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf, Data.DB, FireDAC.Comp.DataSet,<N>  FireDAC.Comp.Client, Vcl.Grids, Vcl.DBGrids, DataSet.Serialize, System.JSON;<N><N>
unit DataSet.Serialize.Utils;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson, SysUtils, Classes;<N>{$ELSE}<N>  {$IF CompilerVersion >= 20}System.Character,{$ENDIF} System.DateUtils, System.JSON, Data.DB, System.SysUtils, System.Classes;<N>{$ENDIF}<N><N>
type<N>  /// <summary><N>  ///   API error class (default).<N>  /// </summary><N>  EDataSetSerializeException = class(Exception);<N><N>  /// <summary><N>  ///   Type to get key values of an dataset.<N>  /// </summary><N>  TKeyValues = array of Variant;<N><N>
  /// <summary><N>  ///   Record representing the structure of a dataset field.<N>  /// </summary><N>  TFieldStructure = record<N>    Alignment: TAlignment;<N>    FieldType: TFieldType;<N>    Size: Integer;<N>    Precision: Integer;<N>    FieldName: string;<N>    Origin: string;<N>    DisplayLabel: string;<N>    Key: Boolean;<N>    Required: Boolean;<N>    Visible: Boolean;<N>    ReadOnly: Boolean;<N>    {$IF NOT DEFINED(FPC)}<N>    AutoGenerateValue: TAutoRefreshFlag;<N>    {$ENDIF}<N>  end;<N><N>
unit DataSet.Serialize.Language;<N><N>interface<N><N>type<N>  /// <summary><N>  ///   Languages handled by helper Validate (JSON).<N>  /// </summary><N>  TLanguageType = (ptBR, enUS);<N><N>implementation<N><N>end.<N>
unit DataSet.Serialize;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson,<N>{$ELSE}<N>  System.JSON, Data.DB,<N>{$ENDIF}<N>  DataSet.Serialize.Language, DataSet.Serialize.Config;<N><N>type<N>  TLanguageType = DataSet.Serialize.Language.TLanguageType;<N>  TDataSetSerializeConfig = DataSet.Serialize.Config.TDataSetSerializeConfig;<N>  TCaseNameDefinition = DataSet.Serialize.Config.TCaseNameDefinition;<N><N>
unit DataSet.Serialize.UpdatedStatus;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB;<N>{$ELSE}<N>  Data.DB;<N>{$ENDIF}<N><N>type<N>  TUpdateStatusHelper = record helper for TUpdateStatus<N>    function ToString: string;<N>  end;<N><N>
implementation<N><N>function TUpdateStatusHelper.ToString: string;<N>begin<N>  case Self of<N>    usModified:<N>      Result := 'MODIFIED';<N>    usInserted:<N>      Result := 'INSERTED';<N>    usDeleted:<N>      Result := 'DELETED';<N>  else<N>    Result := 'UNMODIFIED';<N>  end;<N>end;<N><N>
﻿unit DataSet.Serialize.Import;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson,<N>{$ELSE}<N>  System.JSON, Data.DB, System.StrUtils, System.SysUtils, System.Rtti,<N>  {$IF CompilerVersion >= 20}<N>    System.Character,<N>  {$ENDIF}<N>{$ENDIF}<N>  DataSet.Serialize.Language, DataSet.Serialize.Utils;<N><N>
﻿procedure LoopFor(s:string; i:integer; n: integer);<N>begin<N>writeln(s);<N>if i<n then LoopFor(s,i+1,n);<N>end;<N>var i:integer;<N>begin<N>LoopFor('Привет',1,10);<N>end.
﻿procedure row(n:integer);<N>begin<N>     if n >=0 then begin<N>        write (n, ' ');<N>        row(n-2)<N>     end;<N>     if n <0 then write (0);<N>end;<N>begin<N>    row(25);<N>end.
﻿var x,y: integer;<N>function stepen (a,b: integer):integer;<N>var xx:real;<N>begin<N>  if y>=1 then begin<N>  xx:=x**y;<N>  y:=y-1;<N>  writeln(xx);<N>  stepen(x,y);<N>  end;<N>end;<N>begin<N>  writeln('число?');<N>  readln(x);<N>  writeln('степень?');<N>  readln(y);<N>  writeln(stepen(x,y));<N>end.
﻿var a,b,c:integer;<N>procedure row(n:integer);<N>begin<N>     if c >=1 then begin<N>       c:=a mod b;<N>        write (c, ' ');<N>        a:=b;<N>        b:=c;<N>        row(c)<N>     end;<N>     writeln('НОД равен ', a);<N>     readln<N>end;<N>begin<N>  readln(a,b);<N>  c:=1;<N>    row(c);<N>end.
﻿var k,c,l:integer;<N>procedure row(n:integer);<N>begin<N>     if k <=c then begin<N>       write (k, ' ');<N>       l:=l+1;<N>       K:=K+l;<N>        row(k)<N>     end;<N>end;<N>begin<N>  k:=1;<N>  l:=0;<N>  readln(c);<N>    row(c);<N>end.
﻿var f1,f2,f3,n:integer;<N>procedure fib (i,k: integer);<N>  begin<N>       writeln (f3,' ');<N>       if n<=10 then begin<N>         f3:=f2+f1;<N>         f1:=f2;<N>         f2:=f3;<N>       n:=n+1;<N>           fib(f1,f2);<N>           end;<N>  end;<N>begin<N>  f1:=0;<N>  f2:=1;<N>  f3:=1;<N>  n:=1;<N>  fib(f1,f2);<N>end.
﻿var pI: ^integer;<N>begin<N>  new(pI);<N>  pI^ := 2;<N>  writeln('Адрес  ='  , pI); <N>  writeln('Значение = ', pI^); <N>end.
unit magwmi;<N>{$WARN UNSAFE_TYPE off}<N>{$WARN UNSAFE_CAST off}<N>{$WARN UNSAFE_CODE off}<N>{$WARN SYMBOL_PLATFORM OFF}<N>{$WARN SYMBOL_LIBRARY OFF}<N>{$WARN SYMBOL_DEPRECATED OFF}<N><N>{<N>Magenta Systems WMI and SMART Component v5.5<N>Updated by Angus Robertson, Magenta Systems Ltd, England, 5th August 2013<N>delphi@magsys.co.uk, http://www.magsys.co.uk/delphi/<N>Copyright 2013, Magenta Systems Ltd<N><N>
partly based on articles in Delphi Developers Magazine by Craig Murphy and work by<N>Denis Blondeau (both needed the same bug fixes to read variant arrays properly)<N><N>note - WbemScripting_TLB was created by importing the Microsoft WMI Scripting type library<N><N>
unit uCMD;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,<N>  uLog, Vcl.Dialogs, Winapi.ShellAPI;<N><N>procedure RunCMD(cmdLine: string; WindowMode: integer);<N><N>implementation<N><N>procedure RunCMD(cmdLine: string; WindowMode: integer);<N><N>
  procedure ShowWindowsErrorMessage(r: integer);<N>  var<N>    sMsg: string;<N>  begin<N>    sMsg := SysErrorMessage(r);<N>    if (sMsg = '') and (r = ERROR_BAD_EXE_FORMAT) then<N>      sMsg := SysErrorMessage(ERROR_BAD_FORMAT);<N>    MessageDlg(sMsg, mtError, [mbOK], 0);<N>  end;<N><N>
unit uThreadCheckStatusMobilite;<N><N>interface<N><N>Uses Classes;<N><N>type<N>   TThreadSrvCheckStatusMobilite = class(TThread)<N>    private<N>      FStatus : integer;<N>      procedure Synchro;<N>    published<N>      constructor create;<N>      destructor Destroy();override;<N>      procedure Execute;override;<N>    public<N>    property Status : integer read FStatus write FStatus;<N>   end;<N><N>
implementation<N><N>Uses ServiceControler, uMainForm;<N><N>{ TThreadSrvCheckStatusMobilite }<N><N>constructor TThreadSrvCheckStatusMobilite.create;<N>begin<N>  inherited;<N>  FreeOnTerminate := false;<N>end;<N><N>destructor TThreadSrvCheckStatusMobilite.Destroy;<N>begin<N>  Terminate;<N>  Resume;<N>  WaitFor;<N>  inherited;<N>end;<N><N>
procedure TThreadSrvCheckStatusMobilite.Execute;<N>begin<N>  inherited;<N><N>  while not terminated do<N>  begin<N>    try<N>      FStatus := ServiceGetStatus('','GinkoiaMobiliteSvr');<N>      Synchronize(Synchro);<N>    except<N>    end;<N><N>    if not Terminated<N>      then sleep(5000);<N>  end;<N>end;<N><N>
unit ExeControler;<N><N>interface<N><N>USes Types, SysUtils, ShellAPI, Windows, TlHelp32, Vcl.Controls, Vcl.ComCtrls;<N><N><N>function ProcessExists(exeFileName: string): boolean;<N>function ExeStart(exeName: string; params:string = ''): boolean;<N>function ExeStop(exeName: string): boolean;<N><N>
unit ServiceControler;<N><N>interface<N><N>USes System.Win.Registry, WinSvc, Types, SysUtils, ShellAPI, Windows;<N><N>/// <summary>Verifie si le service existe</summary><N>/// <param name="sMachine">machine name, ie: \SERVER (empty = local machine)</param><N>/// <param name="sService">service name, ie: Alerter</param><N>/// <returns>return TRUE si le service est installer sur la machine</returns><N>function ServiceExist(sMachine, sService : string) : boolean;<N><N>
/// <summary>Installation d'un service</summary><N>/// <param name="servicePath">repertoire ou se trouve l'exe du service</param><N>/// <param name="serviceExe">nom de l'exe du service</param><N>/// <remarks>Cette fonction provoque l'apparition de boite de dialogue (installation reussit ou non).</remarks><N>procedure InstallService(servicePath, serviceExe : string);<N><N>
unit Poste_frm;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls, <N>  Buttons, ExtCtrls;<N><N>type<N>  Tfrm_poste = class(TForm)<N>    Bevel1: TBevel;<N>    BitBtn1: TBitBtn;<N>    BitBtn2: TBitBtn;<N>    Label1: TLabel;<N>    ed_Nom: TEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  frm_poste: Tfrm_poste;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit Societe_frm;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls, <N>  Buttons, ExtCtrls, ComCtrls;<N><N>type<N>  TFrm_Societe = class(TForm)<N>    Bevel1: TBevel;<N>    BitBtn1: TBitBtn;<N>    BitBtn2: TBitBtn;<N>    Label1: TLabel;<N>    Label2: TLabel;<N>    ed_Nom: TEdit;<N>    Edt_Date: TDateTimePicker;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Frm_Societe: TFrm_Societe;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit Ident_Frm;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls;<N><N>type<N>  Tfrm_Ident = class(TForm)<N>    Bevel1: TBevel;<N>    BitBtn1: TBitBtn;<N>    BitBtn2: TBitBtn;<N>    Label1: TLabel;<N>    Label2: TLabel;<N>    ed_Ident: TEdit;<N>    ed_Password: TEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit Magasin_frm;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls, <N>  Buttons, ExtCtrls;<N><N>type<N>  Tfrm_magasin = class(TForm)<N>    Bevel1: TBevel;<N>    BitBtn1: TBitBtn;<N>    BitBtn2: TBitBtn;<N>    Label1: TLabel;<N>    ed_Nom: TEdit;<N>    Label2: TLabel;<N>    ed_Ident: TEdit;<N>    Label3: TLabel;<N>    Lb_Soc: TComboBox;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  frm_magasin: Tfrm_magasin;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit UUtilMachine;<N><N>interface<N><N>uses<N>   registry, ShlObj, ComObj, ActiveX,<N>   Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>   StdCtrls, ComCtrls;<N><N>type<N>  TUtilMachine = class(TObject)<N>  public<N>    procedure CreerRaccourcie(Nom, Fichier, Description, Repertoire, Icon :<N>        String; Index:Integer=0);<N>    function NomPoste: string;<N>  end;<N><N>
unit ChxNomGroupe;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls;<N><N>type<N>  TFrm_Groupe = class(TForm)<N>    OKBtn: TButton;<N>    CancelBtn: TButton;<N>    Bevel1: TBevel;<N>    Edit1: TEdit;<N>    Commentaire: TLabel;<N>    Memo1: TMemo;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>{<N>var<N>  Frm_Groupe: TFrm_Groupe;<N>}<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit CMBDefs;<N><N>interface<N><N>const<N>  CVERSION = 'CMB v1.0';<N>  <N>var<N>  GAPPPATH : String;<N><N><N>implementation<N><N>end.<N>
// Translation of the C headers for Oracle's XML parser<N>// e-delos<N><N>unit OraXML;<N><N>interface<N><N>{$IFNDEF MSWINDOWS}<N>	{$IFDEF WIN32}<N>		{$DEFINE MSWINDOWS}<N>  {$ENDIF}<N>{$ENDIF}<N><N>uses<N>{$IFDEF MSWINDOWS}<N>  Windows;<N>{$ENDIF}<N>{$IFDEF LINUX}<N>	Libc;<N>{$ENDIF}<N><N>
//$Log:<N>// 1    Utilitaires1.0         19/09/2016 10:08:38    Ludovic MASSE   <N>//$<N>//$NoKeywords$<N>//<N>unit UCrePtcVersion;<N><N>interface<N><N>uses<N>   UsaisiePtch,<N>   filectrl,<N>   Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>   Buttons, ExtCtrls, Db, dxmdaset, MemDataX;<N><N>
type<N>   TCrePtcVersion = class(TForm)<N>      OKBtn: TButton;<N>      CancelBtn: TButton;<N>      Bevel1: TBevel;<N>      lb: TListBox;<N>      Label1: TLabel;<N>      DataX: TDataBaseX;<N>      Versions: TMemDataX;<N>      Versionsid: TIntegerField;<N>      Versionsversion: TStringField;<N>      Versionsnomversion: TStringField;<N>      VersionsPatch: TIntegerField;<N>   private<N>    { Private declarations }<N>   public<N>    { Public declarations }<N>      function execute: boolean;<N>   end;<N><N>
//$Log:<N>// 3    Utilitaires1.2         07/06/2019 14:44:47    St?phane MATHIS v2.3.0.27<N>//      <N>//      ajout numero de version<N>//      fenetre plus grande et redimensionnable<N>//      enlever les lignes vides<N>// 2    Utilitaires1.1         06/06/2019 17:58:51    St?phane MATHIS<N>//      gestionpantin - probleme liste client<N>// 1    Utilitaires1.0         19/09/2016 10:08:38    Ludovic MASSE   <N>//$<N>//$NoKeywords$<N>//<N>unit UChxClient;<N><N>
//$Log:<N>// 1    Utilitaires1.0         19/09/2016 10:08:38    Ludovic MASSE   <N>//$<N>//$NoKeywords$<N>//<N>unit UChxPlage;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls, wwdbdatetimepicker, wwDBDateTimePickerRv;<N><N>
type<N>  Tfrm_chxplage = class(TForm)<N>    OKBtn: TButton;<N>    CancelBtn: TButton;<N>    Bevel1: TBevel;<N>    Label1: TLabel;<N>    Label2: TLabel;<N>    Chp_Datedeb: TwwDBDateTimePickerRv;<N>    Chp_Datefin: TwwDBDateTimePickerRv;<N>    Cb_Version: TComboBox;<N>    procedure FormCreate(Sender: TObject);<N>    procedure OKBtnClick(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
//$Log:<N>// 1    Utilitaires1.0         19/09/2016 10:08:39    Ludovic MASSE   <N>//$<N>//$NoKeywords$<N>//<N>unit UsaisiePtch;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls;<N><N>type<N>  TsaisiePtch = class(TForm)<N>    OKBtn: TButton;<N>    CancelBtn: TButton;<N>    Bevel1: TBevel;<N>    mem: TMemo;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  saisiePtch: TsaisiePtch;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
//$Log:<N>// 1    Utilitaires1.0         19/09/2016 10:08:37    Ludovic MASSE   <N>//$<N>//$NoKeywords$<N>//<N>unit cregroupe_frm;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls;<N><N>type<N>  Tfrm_crergroupe = class(TForm)<N>    OKBtn: TButton;<N>    CancelBtn: TButton;<N>    Bevel1: TBevel;<N>    Label1: TLabel;<N>    Edit1: TEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit magwmi;<N>{$WARN UNSAFE_TYPE off}<N>{$WARN UNSAFE_CAST off}<N>{$WARN UNSAFE_CODE off}<N>{$WARN SYMBOL_PLATFORM OFF}<N>{$WARN SYMBOL_LIBRARY OFF}<N>{$WARN SYMBOL_DEPRECATED OFF}<N><N>{<N>Magenta Systems WMI and SMART Component v5.5<N>Updated by Angus Robertson, Magenta Systems Ltd, England, 5th August 2013<N>delphi@magsys.co.uk, http://www.magsys.co.uk/delphi/<N>Copyright 2013, Magenta Systems Ltd<N><N>
partly based on articles in Delphi Developers Magazine by Craig Murphy and work by<N>Denis Blondeau (both needed the same bug fixes to read variant arrays properly)<N><N>note - WbemScripting_TLB was created by importing the Microsoft WMI Scripting type library<N><N>
unit uCopythread;<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N>{<N>type<N>  TCopyThread = class(TThread)<N>  private<N>    FIn, FOut : string;<N>    procedure copyfile;<N>  public<N>    procedure Execute ; override;<N>    constructor create (const source, dest : string);<N>  end;<N>}<N>implementation<N>{<N>procedure TCopyThread.Execute;<N>begin<N> // CopyResult := CopyFileEx(CurrentName, NewName, CopyProgressRoutine, Self,<N>//    @Cancel, CopyFlags);<N>end;<N><N>}<N><N><N>end.<N>
unit ServiceControler;<N><N>interface<N><N>USes System.Win.Registry;<N><N>/// <summary>Verifie si le service existe</summary><N>/// <param name="sMachine">machine name, ie: \SERVER (empty = local machine)</param><N>/// <param name="sService">service name, ie: Alerter</param><N>/// <returns>return TRUE si le service est installer sur la machine</returns><N>function ServiceExist(sMachine, sService : string) : boolean;<N><N>
/// <summary>Installation d'un service</summary><N>/// <param name="servicePath">repertoire ou se trouve l'exe du service</param><N>/// <param name="serviceExe">nom de l'exe du service</param><N>/// <remarks>Cette fonction provoque l'apparition de boite de dialogue (installation reussit ou non).</remarks><N>procedure InstallService(servicePath, serviceExe : string);<N><N>
unit uFileUtils;<N><N>interface<N><N>function GetTempDirectory(Base : string = '') : String;<N>function GetFileSize(FileName : string) : Int64;<N>function GetDiskFreeSpace(Drive : char) : Int64;<N>function DelTree(DirName : string): Boolean;<N><N>implementation<N><N>
uses<N>  System.SysUtils,<N>  System.IOUtils,<N>  Winapi.ShellAPI;<N><N>function GetTempDirectory(Base : string) : String;<N>var<N>  tempFolder: string;<N>begin<N>  Randomize();<N>  if Trim(Base) = '' then<N>    tempFolder := TPath.GetTempPath()<N>  else<N>    tempFolder := IncludeTrailingPathDelimiter(Base);<N>  repeat<N>    result := IncludeTrailingPathDelimiter(IncludeTrailingPathDelimiter(tempFolder) + IntToStr(Random(999999999)));<N>  until not DirectoryExists(Result);<N>end;<N><N>
function GetFileSize(FileName : string) : Int64;<N>var<N>  FindStruc : TSearchRec;<N>begin<N>  Result := 0;<N>  try<N>    if FindFirst(FileName, faanyfile, FindStruc) = 0 THEN<N>      Result := FindStruc.Size;<N>  finally<N>    findClose(FindStruc);<N>  end;<N>end;<N><N>
unit uValideKeyNumber;<N><N>interface<N><N>uses<N>  Vcl.StdCtrls;<N><N>procedure ValideNumericKeyPress(Edit : TCustomEdit; var Key: Char; Negatif : boolean = true; Flotant : boolean = true); overload;<N>procedure ValideNumericKeyPress(Edit : TCustomEdit; var Key: Char; Decimal : integer; Negatif : boolean = true; Flotant : boolean = true); overload;<N><N>
function GetFloatFromEdit(Edit : TEdit) : Double;<N>procedure SetEditFromFloat(Edit : TEdit; Value : Double);<N>function GetCurrencyFromEdit(Edit : TEdit) : Currency;<N>procedure SetEditFromCurrency(Edit : TEdit; Value : Currency);<N><N>implementation<N><N>
uses<N>  System.SysUtils,<N>  Winapi.Windows;<N><N>var<N>  FormatSettings :  TFormatSettings;<N><N>procedure ValideNumericKeyPress(Edit : TCustomEdit; var Key: Char; Negatif : boolean; Flotant : boolean);<N>begin<N>  ValideNumericKeyPress(Edit, Key, 0, Negatif, Flotant);<N>end;<N><N>
unit uVersionInfo;<N><N>interface<N><N>uses<N>  System.Classes, // TStringList<N>  System.Types;   // TValueRelationship<N>  <N>const<N>  FileInfos : array [1..8] of string = ('FileDescription', 'CompanyName', 'FileVersion', 'InternalName',<N>                                        'LegalCopyRight', 'OriginalFileName', 'ProductName', 'ProductVersion');<N><N>
unit UInfosBase;<N><N>interface<N><N>function CanConnect(Server, FileName, UserName, Password : string; Port : integer; out error :string) : boolean;<N>function GetInfosBase(Server, FileName, UserName, Password : string; Port : integer; out Version, Nom, GUID, Sender : string; out DateVersion : TDateTime; out Generateur : integer; out Recalcul : boolean; out error :string) : boolean;<N><N>
implementation<N><N>uses<N>  Vcl.Dialogs,<N>  System.SysUtils,<N>  FireDAC.Comp.Client,<N>  uGestionBDD;<N><N>function CanConnect(Server, FileName, UserName, Password : string; Port : integer; out error :string) : boolean;<N>var<N>  Connexion : TMyConnection;<N>begin<N>  Result := false;<N>  error := '';<N><N>
  try<N>    try<N>      Connexion := GetNewConnexion(Server, FileName, UserName, Password, Port, false);<N>      Connexion.Open();<N>      if Connexion.Connected then<N>        Result := true;<N>    finally<N>      FreeAndNil(Connexion);<N>    end;<N>  except<N>    on e : exception do<N>    begin<N>      error := e.ClassName + ' - ' + e.Message;<N>      Result := false;<N>    end;<N>  end;<N>end;<N><N>
function GetInfosBase(Server, FileName, UserName, Password : string; Port : integer; out Version, Nom, GUID, Sender : string; out DateVersion : TDateTime; out Generateur : integer; out Recalcul : boolean; out error :string) : boolean;<N>var<N>  Connexion : TMyConnection;<N>  Query : TMyQuery;<N>begin<N>  Result := false;<N>  Version := '';<N>  Nom := '';<N>  GUID := '';<N>  DateVersion := 0;<N>  Generateur := -1;<N>  Recalcul := false;<N>  error := '';<N><N>
  try<N>    try<N>      Connexion := GetNewConnexion(Server, FileName, UserName, Password, Port, false);<N>      Connexion.Open();<N>      if Connexion.Connected then<N>      begin<N>        try<N>          // requete<N>          Query := GetNewQuery(Connexion);<N><N>
          // existance des tables ?<N>          try<N>            Query.SQL.Text := 'select rdb$relation_name from rdb$relations where upper(rdb$relation_name) in (''GENVERSION'', ''GENBASES'', ''K'', ''GENPARAMBASE'', ''GENTRIGGER'', ''GENTRIGGERDIFF'');';<N>            Query.Open();<N>            if Query.Eof then<N>              Exit<N>            else if not (Query.RecordCount in [5, 6]) then<N>              Exit;<N>          finally<N>            Query.Close();<N>          end;<N><N>
{<N>***************************************************<N>* A binary compatible SHA1 implementation         *<N>* written by Dave Barton (davebarton@bigfoot.com) *<N>***************************************************<N>* 160bit hash size                                *<N>***************************************************<N>}<N>unit SHA1;<N><N>
interface<N>uses<N>   Windows,<N>   Sysutils;<N><N>type<N>   TSHA1Digest = array[0..19] of byte;<N>   TSHA1Context = record<N>      Hash: array[0..4] of DWord;<N>      Hi, Lo: integer;<N>      Buffer: array[0..63] of byte;<N>      Index: integer;<N>   end;<N><N>
function SHA1SelfTest: boolean;<N>procedure SHA1Init(var Context: TSHA1Context);<N>procedure SHA1Update(var Context: TSHA1Context; Buffer: pointer; Len: integer);<N>procedure SHA1Final(var Context: TSHA1Context; var Digest: TSHA1Digest);<N>FUNCTION StrtoSha1 (S:String) : String ;<N>//******************************************************************************<N>implementation<N><N>
unit ReservationType_Defs;<N><N>interface<N>  uses Contnrs, SysUtils;<N><N>  type TCFGMAIL = record<N>    PBT_ADRPRINC  ,<N>    PBT_ADRARCH   ,<N>    PBT_PASSW     ,<N>    PBT_SERVEUR   : String;<N>    PBT_PORT      : integer;<N>    PBT_MTYID     : integer;<N>    PBT_ARCHIVAGE : integer;<N>    PBT_SMTP      : String;<N>    PBT_PORTSMTP  : Integer;<N>  end;<N><N>
﻿unit uLog;<N><N>interface<N><N>uses<N>{$IF CompilerVersion > 27}<N>  System.Classes,<N>  System.SysUtils,<N>  System.StrUtils,<N>  Winapi.Windows,<N>  Winapi.Winsock,<N>  System.Contnrs,<N>  System.SyncObjs,<N>  System.iniFiles,<N>  idTCPClient,<N>  System.Math ;<N>{$ELSE}<N>  Classes,<N>  SysUtils,<N>  StrUtils,<N>  Windows,<N>  Winsock,<N>  Contnrs,<N>  SyncObjs,<N>  iniFiles,<N>  idTCPClient,<N>  Math ;<N>{$IFEND}<N><N>
(*<N> * GExperts Debug Window Interface<N> * http://www.gexperts.org<N> *<N> * You are free to use this code in any application to send commands to the<N> * GExperts debug window.  This includes usage in commercial, shareware,<N> * freeware, public domain, and other applications.<N> *)<N><N>
unit ReservationType_Defs;<N><N>interface<N>  uses Contnrs, SysUtils;<N><N>  type TCFGMAIL = record<N>    PBT_ADRPRINC  ,<N>    PBT_ADRARCH   ,<N>    PBT_PASSW     ,<N>    PBT_SERVEUR   : String;<N>    PBT_PORT      : integer;<N>    PBT_MTYID     : integer;<N>    PBT_ARCHIVAGE : integer;<N>    PBT_SMTP      : String;<N>    PBT_PORTSMTP  : Integer;<N>  end;<N><N>
﻿unit uLog;<N><N>interface<N><N>uses<N>{$IF CompilerVersion > 27}<N>  System.Classes,<N>  System.SysUtils,<N>  System.StrUtils,<N>  Winapi.Windows,<N>  Winapi.Winsock,<N>  System.Contnrs,<N>  System.SyncObjs,<N>  System.iniFiles,<N>  idTCPClient,<N>  System.Math ;<N>{$ELSE}<N>  Classes,<N>  SysUtils,<N>  StrUtils,<N>  Windows,<N>  Winsock,<N>  Contnrs,<N>  SyncObjs,<N>  iniFiles,<N>  idTCPClient,<N>  Math ;<N>{$IFEND}<N><N>
unit ReservationType_Defs;<N><N>interface<N>  uses Contnrs, SysUtils;<N><N>  type TCFGMAIL = record<N>    PBT_ADRPRINC  ,<N>    PBT_ADRARCH   ,<N>    PBT_PASSW     ,<N>    PBT_SERVEUR   : String;<N>    PBT_PORT      : integer;<N>    PBT_MTYID     : integer;<N>    PBT_ARCHIVAGE : integer;<N>    PBT_SMTP      : String;<N>    PBT_PORTSMTP  : Integer;<N>  end;<N><N>
﻿unit uLog;<N><N>interface<N><N>uses<N>{$IF CompilerVersion > 27}<N>  System.Classes,<N>  System.SysUtils,<N>  System.StrUtils,<N>  Winapi.Windows,<N>  Winapi.Winsock,<N>  System.Contnrs,<N>  System.SyncObjs,<N>  System.iniFiles,<N>  idTCPClient,<N>  System.Math ;<N>{$ELSE}<N>  Classes,<N>  SysUtils,<N>  StrUtils,<N>  Windows,<N>  Winsock,<N>  Contnrs,<N>  SyncObjs,<N>  iniFiles,<N>  idTCPClient,<N>  Math ;<N>{$IFEND}<N><N>
(*<N> * GExperts Debug Window Interface<N> * http://www.gexperts.org<N> *<N> * You are free to use this code in any application to send commands to the<N> * GExperts debug window.  This includes usage in commercial, shareware,<N> * freeware, public domain, and other applications.<N> *)<N><N>
unit ReservationType_Defs;<N><N>interface<N>  uses Contnrs, SysUtils;<N><N>  type TCFGMAIL = record<N>    PBT_ADRPRINC  ,<N>    PBT_ADRARCH   ,<N>    PBT_PASSW     ,<N>    PBT_SERVEUR   : String;<N>    PBT_PORT      : integer;<N>    PBT_MTYID     : integer;<N>    PBT_ARCHIVAGE : integer;<N>    PBT_SMTP      : String;<N>    PBT_PORTSMTP  : Integer;<N>  end;<N><N>
﻿unit uLog;<N><N>interface<N><N>uses<N>{$IF CompilerVersion > 27}<N>  System.Classes,<N>  System.SysUtils,<N>  System.StrUtils,<N>  Winapi.Windows,<N>  Winapi.Winsock,<N>  System.Contnrs,<N>  System.SyncObjs,<N>  System.iniFiles,<N>  idTCPClient,<N>  System.Math ;<N>{$ELSE}<N>  Classes,<N>  SysUtils,<N>  StrUtils,<N>  Windows,<N>  Winsock,<N>  Contnrs,<N>  SyncObjs,<N>  iniFiles,<N>  idTCPClient,<N>  Math ;<N>{$IFEND}<N><N>
unit ReservationType_Defs;<N><N>interface<N>  uses Contnrs, SysUtils;<N><N>  type TCFGMAIL = record<N>    PBT_ADRPRINC  ,<N>    PBT_ADRARCH   ,<N>    PBT_PASSW     ,<N>    PBT_SERVEUR   : String;<N>    PBT_PORT      : integer;<N>    PBT_MTYID     : integer;<N>    PBT_ARCHIVAGE : integer;<N>    PBT_SMTP      : String;<N>    PBT_PORTSMTP  : Integer;<N>  end;<N><N>
{<N> MD5 Core - f0xi - 2006 - [www.delphifr.com]<N><N> DO NOT MODIFY !    NE PAS MODIFIER !<N>}<N>unit MD5Core;<N><N>interface<N><N>uses SysUtils;<N><N>{ ------------------------------------------------------------------------------------------------ }<N><N>
type<N>  TMD5Buffer = array[0..3]  of cardinal;<N>  TMD5DblWord= array[0..1]  of cardinal;<N>  TMD5Cvn    = array[0..15] of cardinal;<N>  TMD5Data   = array[0..15] of Byte;<N><N>  TMD5Context = record<N>    Buf   : TMD5Buffer;<N>    Bytes : TMD5DblWord;<N>    Cvn   : TMD5Cvn;<N>  end;<N><N>
{ ------------------------------------------------------------------------------------------------ }<N><N>procedure MD5CoreInitialize(var ctx: TMD5Context);<N>procedure MD5CoreUpdate(var ctx: TMD5Context; const buffer; len: Cardinal);<N>function  MD5CoreFinalize(var ctx: TMD5Context): TMD5Data;<N>procedure MD5CoreTransform(var buf: TMD5Buffer; const cvn: TMD5Cvn);<N><N>
{ ------------------------------------------------------------------------------------------------ }<N><N><N>implementation<N>{$R-}<N>{$Q-}<N><N>{ ------------------------------------------------------------------------------------------------ }<N><N>const<N>  MD5_INITBUF : TMD5Buffer  = (<N>     $67452301,$EFCDAB89,$98BADCFE,$10325476<N>  );<N><N>
{<N> MD5 Core - f0xi - 2006 - [www.delphifr.com]<N><N> DO NOT MODIFY !    NE PAS MODIFIER !<N>}<N>unit MD5Core;<N><N>interface<N><N>uses SysUtils;<N><N>{ ------------------------------------------------------------------------------------------------ }<N><N>
type<N>  TMD5Buffer = array[0..3]  of cardinal;<N>  TMD5DblWord= array[0..1]  of cardinal;<N>  TMD5Cvn    = array[0..15] of cardinal;<N>  TMD5Data   = array[0..15] of Byte;<N><N>  TMD5Context = record<N>    Buf   : TMD5Buffer;<N>    Bytes : TMD5DblWord;<N>    Cvn   : TMD5Cvn;<N>  end;<N><N>
{ ------------------------------------------------------------------------------------------------ }<N><N>procedure MD5CoreInitialize(var ctx: TMD5Context);<N>procedure MD5CoreUpdate(var ctx: TMD5Context; const buffer; len: Cardinal);<N>function  MD5CoreFinalize(var ctx: TMD5Context): TMD5Data;<N>procedure MD5CoreTransform(var buf: TMD5Buffer; const cvn: TMD5Cvn);<N><N>
{ ------------------------------------------------------------------------------------------------ }<N><N><N>implementation<N>{$R-}<N>{$Q-}<N><N>{ ------------------------------------------------------------------------------------------------ }<N><N>const<N>  MD5_INITBUF : TMD5Buffer  = (<N>     $67452301,$EFCDAB89,$98BADCFE,$10325476<N>  );<N><N>
{<N> MD5 Core - f0xi - 2006 - [www.delphifr.com]<N><N> DO NOT MODIFY !    NE PAS MODIFIER !<N>}<N>unit MD5Core;<N><N>interface<N><N>uses SysUtils;<N><N>{ ------------------------------------------------------------------------------------------------ }<N><N>
type<N>  TMD5Buffer = array[0..3]  of cardinal;<N>  TMD5DblWord= array[0..1]  of cardinal;<N>  TMD5Cvn    = array[0..15] of cardinal;<N>  TMD5Data   = array[0..15] of Byte;<N><N>  TMD5Context = record<N>    Buf   : TMD5Buffer;<N>    Bytes : TMD5DblWord;<N>    Cvn   : TMD5Cvn;<N>  end;<N><N>
{ ------------------------------------------------------------------------------------------------ }<N><N>procedure MD5CoreInitialize(var ctx: TMD5Context);<N>procedure MD5CoreUpdate(var ctx: TMD5Context; const buffer; len: Cardinal);<N>function  MD5CoreFinalize(var ctx: TMD5Context): TMD5Data;<N>procedure MD5CoreTransform(var buf: TMD5Buffer; const cvn: TMD5Cvn);<N><N>
{ ------------------------------------------------------------------------------------------------ }<N><N><N>implementation<N>{$R-}<N>{$Q-}<N><N>{ ------------------------------------------------------------------------------------------------ }<N><N>const<N>  MD5_INITBUF : TMD5Buffer  = (<N>     $67452301,$EFCDAB89,$98BADCFE,$10325476<N>  );<N><N>
unit Integration.Thread.CallStack;<N><N>interface<N><N>implementation<N><N>uses<N>  System.Classes,<N>  System.SysUtils,<N>  Winapi.Windows,<N>  JclDebug,<N>  JclHookExcept;<N><N>procedure HookGlobalException(ExceptObj: TObject; ExceptAddr: Pointer; OSException: Boolean);<N><N>
  function GetApplicationFileName(): string;<N>  begin<N>    SetLength(Result, MAX_PATH + 1);<N>    GetModuleFileName(HInstance, PChar(Result), MAX_PATH);<N>    SetLength(Result, Length(PChar(Result)));<N>  end;<N><N>  function ReadFileVersion(Fichier: string): string;<N>  var<N>    Dummy       : DWORD;<N>    Info        : Pointer;<N>    InfoSize    : Cardinal;<N>    VerValue    : PVSFixedFileInfo;<N>    InfoDataSize: Cardinal;<N>  begin<N>    Result := '';<N><N>
{<N> MD5 Core - f0xi - 2006 - [www.delphifr.com]<N><N> DO NOT MODIFY !    NE PAS MODIFIER !<N>}<N>unit MD5Core;<N><N>interface<N><N>uses SysUtils;<N><N>{ ------------------------------------------------------------------------------------------------ }<N><N>
type<N>  TMD5Buffer = array[0..3]  of cardinal;<N>  TMD5DblWord= array[0..1]  of cardinal;<N>  TMD5Cvn    = array[0..15] of cardinal;<N>  TMD5Data   = array[0..15] of Byte;<N><N>  TMD5Context = record<N>    Buf   : TMD5Buffer;<N>    Bytes : TMD5DblWord;<N>    Cvn   : TMD5Cvn;<N>  end;<N><N>
{ ------------------------------------------------------------------------------------------------ }<N><N>procedure MD5CoreInitialize(var ctx: TMD5Context);<N>procedure MD5CoreUpdate(var ctx: TMD5Context; const buffer; len: Cardinal);<N>function  MD5CoreFinalize(var ctx: TMD5Context): TMD5Data;<N>procedure MD5CoreTransform(var buf: TMD5Buffer; const cvn: TMD5Cvn);<N><N>
{ ------------------------------------------------------------------------------------------------ }<N><N><N>implementation<N>{$R-}<N>{$Q-}<N><N>{ ------------------------------------------------------------------------------------------------ }<N><N>const<N>  MD5_INITBUF : TMD5Buffer  = (<N>     $67452301,$EFCDAB89,$98BADCFE,$10325476<N>  );<N><N>
unit uWMSCBFile;<N><N>interface<N><N>uses<N>  uFTPFiles, uGestionBDD;<N><N>type<N><N>  TWMSCBFile = class(TCustomFTPSendFile)<N>  protected<N>    procedure LoadQueryParams(AQuery: TMyQuery); override;<N><N>    function getQuery: string; override;<N>    function getInitQuery: string; override;<N>  public<N><N>
unit uWMSPrixFile;<N><N>interface<N><N>uses<N>  uFTPFiles, uGestionBDD;<N><N>type<N><N>  TWMSPrixFile = class(TCustomFTPSendFile)<N>  protected<N>    procedure LoadQueryParams(AQuery: TMyQuery); override;<N><N>    function getQuery: string; override;<N>    function getInitQuery: string; override;<N>  public<N><N>
  end;<N><N>implementation<N><N>uses<N>  uCustomFTPManager, UCommon_Dm;<N><N>function TWMSPrixFile.getInitQuery: string;<N>begin<N>  Result :=<N>    'SELECT ' +<N>    '  CODE_EAN, ' +<N>    '  PXVTE, ' +<N>    '  PXVTE_N, ' +<N>    '  PXDESTOCK, ' +<N>    '  PUMP, ' +<N>    '  ETAT_DATA ' +<N>    'FROM WMS_PRIX(:MAGID, :INIT_MODE, :LAST_VERSION, :CURRENT_VERSION, ' +<N>    '  :LAST_VERSION_LAME, :CURRENT_VERSION_LAME, :DEBUT_PLAGE_BASE, ' +<N>    '  :FIN_PLAGE_BASE)';<N>end;<N><N>
unit uWMSMagasinFile;<N><N>interface<N><N>uses<N>  uFTPFiles, uGestionBDD;<N><N>type<N>  TWMSMagasinFile = class(TCustomFTPSendFile)<N>  protected<N>    procedure RefreshFileName; override;<N><N>    function getQuery: string; override;<N>    function getInitQuery: string; override;<N>  public<N>  end;<N><N>
unit uWMSArticleFile;<N><N>interface<N><N>uses<N>  uFTPFiles, uGestionBDD;<N><N>type<N>  TWMSArticleFile = class(TCustomFTPSendFile)<N>  protected<N>    procedure LoadQueryParams(AQuery: TMyQuery); override;<N><N>    function getQuery: string; override;<N>    function getInitQuery: string; override;<N><N>
unit uWMSInventaire;<N><N>interface<N><N>uses<N>  uFTPFiles, Classes, uLog;<N><N>type<N>  TWMSInventaireFile = class(TCustomFTPGetFile)<N>  private<N>    const FCopyDirectory: string = 'C:\Ginkoia\Data\';<N>  protected<N>    procedure DoUpdateBDD; override;<N><N>
    function CheckFileEntete: boolean; override;<N>  public<N>  end;<N><N>implementation<N><N>uses<N>  Windows, SysUtils, uCustomFTPManager;<N><N>{ TWMSInventaireFile }<N><N>function TWMSInventaireFile.CheckFileEntete: boolean;<N>begin<N><N>end;<N><N>procedure TWMSInventaireFile.DoUpdateBDD;<N>begin<N>  if ForceDirectories(FCopyDirectory) then<N>    MoveFile( PChar(getFilePath), PChar(FCopyDirectory) );<N>end;<N><N>
unit uWMSRALFile;<N><N>interface<N><N>uses<N>  uFTPFiles, uGestionBDD;<N><N>type<N><N>  TWMSRALFile = class(TCustomFTPSendFile)<N>  protected<N>    procedure RefreshFileName; override;<N><N>    function getQuery: string; override;<N>    function getInitQuery: string; override;<N>  public<N><N>
unit uFTPManager;<N><N>interface<N><N>uses<N>  uFTPSite, Generics.Collections, uGestionBDD, uCustomFTPManager, uFTPUtils,<N>  uMonitoring, uLog, Classes, uFTPCtrl;<N><N>type<N>  TFTPManager = class(TCustomFTPManager)<N>  private<N>    FFTPSites: TObjectList<TFTPSite>;<N><N>
    FOnLogEvent: TFTPLogEvent;<N>    FOnAddMonitoringEvent: TAddMonitoringEvent;<N>    FOnAfterStop: TNotifyEvent;<N>    FOnAfterStart: TNotifyEvent;<N>    FOnGetData: TNotifyEvent;<N><N>    FASS_TYPE: String;<N>    FGENPATH: String;<N>    FGENLOGPATH: String;<N><N>
unit uFTPCtrl;<N><N>interface<N><N>Type<N>  TFTPCtrl = Class(TObject)<N>  private<N>    FNameSite: String;<N>    FIsBusy: Boolean;<N>    procedure Reset;<N>  public<N>    constructor Create;<N><N>    procedure Start(Const ANameSite: String);<N>    procedure Finish(Const ANameSite: String);<N><N>
    property NameSite: String read FNameSite;<N>    property IsBusy: Boolean read FIsBusy;<N>  End;<N><N>implementation<N><N>{ TFTPCtrl }<N><N>constructor TFTPCtrl.Create;<N>begin<N>  Reset;<N>end;<N><N>procedure TFTPCtrl.Finish(const ANameSite: String);<N>begin<N>  if FNameSite = ANameSite then<N>    Reset;<N>end;<N><N>
{<N> MD5 Core - f0xi - 2006 - [www.delphifr.com]<N><N> DO NOT MODIFY !    NE PAS MODIFIER !<N>}<N>unit MD5Core;<N><N>interface<N><N>uses SysUtils;<N><N>{ ------------------------------------------------------------------------------------------------ }<N><N>
type<N>  TMD5Buffer = array[0..3]  of cardinal;<N>  TMD5DblWord= array[0..1]  of cardinal;<N>  TMD5Cvn    = array[0..15] of cardinal;<N>  TMD5Data   = array[0..15] of Byte;<N><N>  TMD5Context = record<N>    Buf   : TMD5Buffer;<N>    Bytes : TMD5DblWord;<N>    Cvn   : TMD5Cvn;<N>  end;<N><N>
{ ------------------------------------------------------------------------------------------------ }<N><N>procedure MD5CoreInitialize(var ctx: TMD5Context);<N>procedure MD5CoreUpdate(var ctx: TMD5Context; const buffer; len: Cardinal);<N>function  MD5CoreFinalize(var ctx: TMD5Context): TMD5Data;<N>procedure MD5CoreTransform(var buf: TMD5Buffer; const cvn: TMD5Cvn);<N><N>
{ ------------------------------------------------------------------------------------------------ }<N><N><N>implementation<N>{$R-}<N>{$Q-}<N><N>{ ------------------------------------------------------------------------------------------------ }<N><N>const<N>  MD5_INITBUF : TMD5Buffer  = (<N>     $67452301,$EFCDAB89,$98BADCFE,$10325476<N>  );<N><N>
unit uEventPanel;<N><N>interface<N><N>uses  Windows, Classes, SysUtils, Controls, StdCtrls, ExtCtrls, Graphics,<N>      uLog, menus ;<N><N><N>type<N>  TEventPanel = class(TCustomPanel)<N>  private<N>    lbTitle  : TLabel ;<N>    lbDetail : TLabel ;<N>    imgIcon  : TImage ;<N><N>
    FTitle: string;<N>    FLevel: TLogLevel;<N>    FDetail: string;<N>    FPopMenu : TPopupMenu;<N><N>    procedure SetTitle(const Value: string);<N>    procedure SetLevel(const Value: TLogLevel);<N>    procedure SetIcon(const Value: TBitMap);<N>    function getIcon: TIcon;<N>    procedure setDetail(const Value: string);<N><N>
  public<N>    constructor Create(AOwner: TComponent); override;<N>    destructor Destroy ; override ;<N>    procedure SetPopMenu(const Value: TPopupMenu);<N>  published<N>    property Title : string  read FTitle write SetTitle ;<N>    property Detail : string read FDetail write setDetail ;<N>    property Icon  : TIcon   read getIcon ;<N>    property Level : TLogLevel  read FLevel write SetLevel;<N>    property PopMenu : TPopupMenu read FPopMenu write SetPopMenu;<N>    property Align ;<N>  end;<N><N>
implementation<N>//==============================================================================<N>{ TEventPanel }<N>//==============================================================================<N>constructor TEventPanel.Create(AOwner: TComponent);<N>begin<N>  inherited;<N><N>
  Width  := 100 ;<N>  Height := 100 ;<N>  Padding.Left    := 5 ;<N>  Padding.Right   := 5 ;<N>  Padding.Top     := 5 ;<N>  Padding.Bottom  := 5 ;<N><N>  PopupMenu := nil;<N><N>  Margins.Right     := 5 ;<N>  AlignWithMargins  := true ;<N><N>  BevelOuter := bvNone ;<N>  ParentColor := false ;<N>  ParentBackground := false ;<N><N>
  lbTitle := TLabel.Create(Self) ;<N>  lbTitle.Align := alBottom ;<N>  lbTitle.Color := clWhite ;<N>  lbTitle.Font.Name := 'Arial' ;<N>  lbTitle.Font.Size := 8 ;<N>  lbTitle.Font.Style := [fsBold] ;<N>  lbTitle.Alignment  := taCenter ;<N>  lbTitle.Font.Color := clWhite ;<N>  lbTitle.ParentColor := true ;<N>  lbTitle.Transparent := true ;<N>  lbTitle.Parent := Self ;<N><N>
  lbDetail := TLabel.Create(Self);<N>  lbDetail.Align := alBottom ;<N>  lbDetail.Color := clWhite ;<N>  lbDetail.Font.Name := 'Arial' ;<N>  lbDetail.Font.Size := 7 ;<N>  lbDetail.Font.Style := [] ;<N>  lbDetail.Alignment  := taCenter ;<N>  lbDetail.Font.Color := clWhite ;<N>  lbDetail.ParentColor := true ;<N>  lbDetail.Transparent := true ;<N>  lbDetail.Parent := Self ;<N><N>
  imgIcon := TImage.Create(Self);<N>  imgIcon.Top := 15 ;<N>  imgIcon.Left := 34 ;<N>  imgIcon.Width := 32 ;<N>  imgIcon.Height := 32 ;<N>  imgIcon.Parent := self ;<N>  imgIcon.Transparent := true ;<N><N>  setTitle('') ;<N>  setDetail('') ;<N>  setLevel(logNone) ;<N>end;<N>//------------------------------------------------------------------------------<N>destructor TEventPanel.Destroy;<N>begin<N>  lbTitle.Free ;<N><N>
  inherited;<N>end;<N>function TEventPanel.getIcon: TIcon;<N>begin<N>  Result := imgIcon.Picture.Icon ;<N>end;<N><N>procedure TEventPanel.setDetail(const Value: string);<N>begin<N>  FDetail := Value;<N><N>  lbDetail.Visible := (FDetail <> '') ;<N>  lbDetail.Caption := FDetail ;<N>  lbDetail.Top := Height - lbDetail.Height ;<N>end;<N><N>
procedure TEventPanel.SetIcon(const Value: TBitMap);<N>begin<N>end;<N><N>procedure TEventPanel.SetLevel(const Value: TLogLevel);<N>begin<N>  FLevel := Value ;<N>  Color := LogLevelColor[Ord(FLevel)] ;<N>end;<N><N>procedure TEventPanel.SetPopMenu(const Value: TPopupMenu);<N>begin<N>  Self.PopupMenu := Value;<N>end;<N><N>
unit ImpDoc_Types;<N><N>interface<N><N>uses EuGen;<N><N>Type<N>  TTypFac = record<N>    Id : Integer;<N>    Lib : String;<N>  end;<N><N>  TGetIso = function (Mny: TMYTYP): STRING of object;<N>var<N>  GGKPATH  ,<N>  GIBPATH  ,<N>  GGKLOGS  ,<N>  GFACPATH : String;<N><N>  WorkInProgress : Boolean;<N><N>implementation<N><N>end.<N>
unit Gin.Com.ThreadProc;<N><N>interface<N><N>uses Classes, SysUtils ;<N><N>type<N>  TProcError = reference to procedure( aException : Exception ) ;<N><N>  TThreadProc = class(TThread)<N>  private<N>    FFinish     : TProc ;<N>    FError      : TProcError ;<N>    FException  : Exception ;<N>    procedure doError ;<N>    procedure doFinish ;<N>  protected<N>    FRun     : TProc ;<N>    procedure Execute ; override ;<N>  public<N>    constructor Create ; reintroduce ;<N><N>
    class function RunInThread(aProc: TProc) : TThreadProc ;<N>    function whenFinish(aProc: TProc) : TThreadProc ;<N>    function whenError(aProc : TProcError) : TThreadProc ;<N>    function Run : TThreadProc ;<N><N>    procedure SynchonizeProc(aProc : TThreadProcedure) ;<N>  published<N>    property Terminated ;<N>  end;<N><N>
implementation<N><N>{ TThreadProc }<N><N>constructor TThreadProc.Create;<N>begin<N>  inherited Create(true) ;<N>  FRun     := nil ;<N>  FError   := nil ;<N>  FFinish  := nil ;<N><N>  FreeOnTerminate := true ;<N>end;<N><N>procedure TThreadProc.doError;<N>begin<N>  if Assigned(FError) then<N>  begin<N>    try<N>      FError(FException) ;<N>    except<N>    end;<N>  end;<N>end;<N><N>
// Translation of the C headers for Oracle's XML parser<N>// e-delos<N><N>unit OraXML;<N><N>interface<N><N>{$IFNDEF MSWINDOWS}<N>	{$IFDEF WIN32}<N>		{$DEFINE MSWINDOWS}<N>  {$ENDIF}<N>{$ENDIF}<N><N>uses<N>{$IFDEF MSWINDOWS}<N>  Windows;<N>{$ENDIF}<N>{$IFDEF LINUX}<N>	Libc;<N>{$ENDIF}<N><N>
unit StdXML_TLB;<N><N>{ This file contains pascal declarations imported from a type library.<N>  This file will be written during each import or refresh of the type<N>  library editor.  Changes to this file will be discarded during the<N>  refresh process. }<N><N>
{ XMLComponents Framework Library }<N>{ Version 1.0 }<N><N>interface<N><N>{$IFNDEF MSWINDOWS}<N>	{$IFDEF WIN32}<N>		{$DEFINE MSWINDOWS}<N>  {$ENDIF}<N>{$ENDIF}<N><N>uses<N>	Classes,<N>{$IFDEF MSWINDOWS}<N>	Windows, ActiveX, Graphics, OleCtrls,<N>  StdVCL,<N>{$ENDIF}<N>  DAC_TLB;<N><N>
unit Probleme_frm;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls, RzLabel;<N><N>type<N>  TDial_Probleme = class(TForm)<N>    OKBtn: TButton;<N>    CancelBtn: TButton;<N>    Bevel1: TBevel;<N>    RzLabel1: TRzLabel;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Dial_Probleme: TDial_Probleme;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit magwmi;<N>{$WARN UNSAFE_TYPE off}<N>{$WARN UNSAFE_CAST off}<N>{$WARN UNSAFE_CODE off}<N>{$WARN SYMBOL_PLATFORM OFF}<N>{$WARN SYMBOL_LIBRARY OFF}<N>{$WARN SYMBOL_DEPRECATED OFF}<N><N>{<N>Magenta Systems WMI and SMART Component v5.5<N>Updated by Angus Robertson, Magenta Systems Ltd, England, 5th August 2013<N>delphi@magsys.co.uk, http://www.magsys.co.uk/delphi/<N>Copyright 2013, Magenta Systems Ltd<N><N>
partly based on articles in Delphi Developers Magazine by Craig Murphy and work by<N>Denis Blondeau (both needed the same bug fixes to read variant arrays properly)<N><N>note - WbemScripting_TLB was created by importing the Microsoft WMI Scripting type library<N><N>
unit ServiceControler;<N><N>interface<N><N>USes System.Win.Registry, WinSvc, Types, SysUtils, ShellAPI, Windows;<N><N>/// <summary>Verifie si le service existe</summary><N>/// <param name="sMachine">machine name, ie: \SERVER (empty = local machine)</param><N>/// <param name="sService">service name, ie: Alerter</param><N>/// <returns>return TRUE si le service est installer sur la machine</returns><N>function ServiceExist(sMachine, sService : string) : boolean;<N><N>
/// <summary>Installation d'un service</summary><N>/// <param name="servicePath">repertoire ou se trouve l'exe du service</param><N>/// <param name="serviceExe">nom de l'exe du service</param><N>/// <remarks>Cette fonction provoque l'apparition de boite de dialogue (installation reussit ou non).</remarks><N>procedure InstallService(servicePath, serviceExe : string);<N><N>
unit uManageCodeBarreType1;<N><N>interface<N><N>Type<N><N>  RArticleTaille = Record<N>    FTgfId: integer;<N>    FItemId: string;<N>    FTaille: string;<N>    FTavail: integer;<N>    FCodeTaille: string;<N>    procedure SetValues(ATgfId: integer; AItemId: string; ATaille: string;<N>      ATavail: integer; ACodeTaille: string);<N>  End;<N>  TArticleTailleArray = array of RArticleTaille;<N><N>
  RArticleCouleur = Record<N>    FCouId: integer;<N>    FColorisId: string;<N>    FColorisCode: string;<N>    FDescriptif: string;<N>    FItemId: string;<N>    FValide: integer;<N>    procedure SetValues(ACouId: integer; AColorisId: string; AColorisCode: string;<N>      ADescriptif: string; AItemId: string; AValide: integer);<N>  End;<N>  TArticleCouleurArray = array of RArticleCouleur;<N><N>
  RArticleCodeBarreType1 = Record<N>    ArfId: integer;<N>    TgfId: integer;<N>    CouId: Integer;<N>    CBType1Exist: boolean;<N>    CBType1: string;<N>    procedure SetValues(AArfId: integer; ATgfId: integer; ACouId: integer);<N>  End;<N>  TArticleCodeBarreType1Array = array of RArticleCodeBarreType1;<N><N>
  TArticle = Class<N>  private<N>    FArtId: integer;<N>    FArfId: integer;<N>    FTailleArray: TArticleTailleArray;<N>    FCouleurArray: TArticleCouleurArray;<N><N>    FCBType1Array: TArticleCodeBarreType1Array;<N><N>    procedure Init;<N>    procedure InitTaille;<N>    procedure InitCouleur;<N><N>
    procedure InitCBType1Array;<N>    procedure UpdateCBType1Values;<N><N>    function TailleExist(ATgfId: integer): boolean;<N>    function CouleurExist(ACouId: integer): boolean;<N>  public<N>    constructor Create(ArtId, ArfId: integer);<N>    destructor Destroy;<N><N>
    procedure AddTaille(TgfId: integer; ItemId: string; Taille: string;<N>      Tavail: integer; CodeTaille: string);<N><N>    procedure AddCouleur(CouId: integer; ColorisId: string; ColorisCode: string;<N>      Descriptif: string; ItemId: string; Valide: integer);<N><N>
unit DM_GINKOIA;<N><N>interface<N><N>uses<N>  SysUtils, Classes, DB, IBODataset, IB_Components, dxmdaset, UPost;<N><N>type<N>  TDMGinkoia = class(TDataModule)<N>    IBCNX_GINKOIA: TIB_Connection;<N>    QR_GENLAUNCH: TIBOQuery;<N>    TR_GINKOIA: TIB_Transaction;<N>    TBL_GENMAGASIN: TIBOTable;<N>    TBL_UILGRPGINKOIA: TIBOTable;<N>    TBL_UILGRPGINKOIAMAG: TIBOTable;<N>  private<N>  public<N>  end;<N><N>var<N>  DMGinkoia: TDMGinkoia;<N><N>implementation<N><N>{$R *.dfm}<N><N>{ TDMGinkoia }<N><N>end.<N>
unit Erreur_CBR;<N><N>interface<N><N>uses SysUtils, Controls, stdctrls, Contnrs;<N><N>Type<N><N>  TErreur = class(TObject)<N>   private<N>    FRefErreur   : String;<N>    FText        : String;<N>    FNumeroLigne : Integer;<N>    FDate        : TDateTime;<N>    FHeure       : TDateTime;<N>    FIdTable     : Integer;<N>    FNomTable    : String;<N><N>
unit Constante_CBR;<N><N>interface<N><N>uses Classes, Contnrs, IniFiles, SysUtils, Forms;<N><N>type<N><N>  // les provenances en MAJUSCULE viennent de CONSOMONITOR et en minuscule de YELLIS<N>  TTypeTableProvenance = (tpAucun, tpClients, tpEmetteur, tpFichiers, tpHisto, tpPlageMAJ, tpSpecifique,<N>                          tpVersion, tpSRV, tpGRP, tpDossier, tpHDB, tpRAISON);<N><N>
  TTypeMaTable = class(TObject)<N>    Libelle        : String;<N>    ATraiter       : Boolean;<N>    MAJAuto        : Boolean;<N>    Last_Id        : Integer;<N>    Last_IdSVG     : Integer;<N>    TableOrigine   : String;<N>    TypeProvenance : TTypeTableProvenance;<N>  end;<N><N>
var<N>  vgObjlTable : TObjectList;<N><N>  vgIniFile     : TIniFile;<N>  vgFichierIni  : string = '';<N>  vgRepertoire  : string = '';<N><N>const<N>  E1 : String = ' ';<N>  E2 : String = '  ';<N>  E3 : String = '   ';<N>  E4 : String = '    ';<N>  E5 : String = '     ';<N><N>
unit ThrdSynchronizeSvr;<N><N>interface<N><N>uses<N>  Classes, SysUtils, IdHTTP;<N><N>type<N>  TThrdSynchronizeSvr = class(TThread)<N>  private<N>    FTYPE_SYNC: String;<N>  protected<N>    procedure Execute; override;<N>  public<N>    property TYPE_SYNC: String read FTYPE_SYNC write FTYPE_SYNC;<N>  end;<N><N>
implementation<N><N>uses dmdClients;<N><N>procedure TThrdSynchronizeSvr.Execute;<N>var<N>  vIdHTTP: TIdHTTP;<N>begin<N>  try<N>    vIdHTTP:= dmClients.GetNewIdHTTP(nil);<N>    vIdHTTP.Get(GParams.Url + 'Synchronize?TYPESYNC=' + FTYPE_SYNC);<N>  finally<N>    FreeAndNil(vIdHTTP);<N>  end;<N>end;<N><N>
unit FrmDlgProvidersSubscribers;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, FrmCustomGinkoiaDlg, StdCtrls, Buttons, ExtCtrls, dmdClient, Mask,<N>  DBCtrls, DB, DBClient;<N><N>type<N>  TTypeProSub = (tpsPRO, tpsSUB);<N><N>
unit FramUpDown;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms, <N>  Dialogs, Buttons, ExtCtrls;<N><N>type<N>  TUpDownFram = class(TFrame)<N>    pnlUpDown: TPanel;<N>    SpdBtnUp: TSpeedButton;<N>    SpdBtnDown: TSpeedButton;<N>  private<N>  public<N>  end;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit uClassGinkoia;<N><N>interface<N><N>Uses<N>  Contnrs;<N><N>Type<N>  TGnk = Class(TObject)<N>  private<N>    FDOSS_ID: Integer;<N>    FK_ENABLED: Integer;<N>  published<N>    property DOSS_ID: Integer read FDOSS_ID write FDOSS_ID;<N>    property K_ENABLED: Integer read FK_ENABLED write FK_ENABLED;<N>  End;<N><N>
  TGnkGenProviders = Class(TGnk)<N>  private<N>    FPRO_ID: Integer;<N>    FPRO_NOM: string;<N>    FPRO_ORDRE: Integer;<N>    FPRO_LOOP: Integer;<N>  published<N>    property PRO_ID: Integer read FPRO_ID write FPRO_ID;<N>    property PRO_NOM: string read FPRO_NOM write FPRO_NOM;<N>    property PRO_ORDRE: Integer read FPRO_ORDRE write FPRO_ORDRE;<N>    property PRO_LOOP: Integer read FPRO_LOOP write FPRO_LOOP;<N>  End;<N><N>
  TGnkGenSubscribers = Class(TGnk)<N>  private<N>    FSUB_ID: Integer;<N>    FSUB_NOM: string;<N>    FSUB_ORDRE: Integer;<N>    FSUB_LOOP: Integer;<N>  published<N>    property SUB_ID: Integer read FSUB_ID write FSUB_ID;<N>    property SUB_NOM: string read FSUB_NOM write FSUB_NOM;<N>    property SUB_ORDRE: Integer read FSUB_ORDRE write FSUB_ORDRE;<N>    property SUB_LOOP: Integer read FSUB_LOOP write FSUB_LOOP;<N>  End;<N><N>
  TGnkGenLiaiRepli = Class(TGnk)<N>  private<N>    FGLR_ID: Integer;<N>    FGLR_PROSUBID: Integer;<N>    FGLR_REPID: Integer;<N>    FGLR_LASTVERSION: string;<N>  published<N>    property GLR_ID: Integer read FGLR_ID write FGLR_ID;<N>    property GLR_REPID: Integer read FGLR_REPID write FGLR_REPID;<N>    property GLR_PROSUBID: Integer read FGLR_PROSUBID write FGLR_PROSUBID;<N>    property GLR_LASTVERSION: string read FGLR_LASTVERSION write FGLR_LASTVERSION;<N>  End;<N><N>
unit uCommon;<N><N>interface<N><N>uses<N>  SysUtils, Classes, Windows, uMdlMaintenance;<N><N><N>function GetNowToStr: String;<N>function DOSS_CHEMINToUNC(Const ASRV_NOM, ADOSS_CHEMIN: String): String;<N>function DOSS_CHEMINToDirectory(Const ADOSS_CHEMIN: String): String;<N>function GetPathEmetteur(Const AEMETTEUR: TEmetteur; Const APath: String): String;<N><N>
implementation<N><N>uses uConst;<N><N><N>function DOSS_CHEMINToUNC(Const ASRV_NOM, ADOSS_CHEMIN: String): String;<N>begin<N>  Result:= '\\' + ASRV_NOM + DOSS_CHEMINToDirectory(ADOSS_CHEMIN);<N>end;<N><N>function DOSS_CHEMINToDirectory(Const ADOSS_CHEMIN: String): String;<N>var<N>  i, vIdx: integer;<N>  Buffer: String;<N>begin<N>  Result:= '';<N><N>
  if Pos('.', ADOSS_CHEMIN) <> 0 then<N>    Buffer:= ExtractFilePath(ADOSS_CHEMIN)<N>  else<N>    Buffer:= ADOSS_CHEMIN;<N><N>  if (Length(ADOSS_CHEMIN) in [1..3]) and (Pos(':', Buffer) <> 0) then<N>    begin<N>      Result:= '\' + Copy(Buffer, 1, Pos(':', Buffer)-1);<N>      Exit;<N>    end;<N><N>
  for i:= Length(Buffer) Downto 1 do<N>    begin<N>      if Buffer[i] = ':' then<N>        begin<N>          vIdx:= i;<N>          Break;<N>        end;<N>    end;<N><N>  Result:= ExcludeTrailingBackslash(Copy(Buffer, vIdx +1, Length(Buffer) - vIdx));<N>end;<N><N>
function GetPathEmetteur(Const AEMETTEUR: TEmetteur; Const APath: String): String;<N>var<N>  vIdx: integer;<N>begin<N>  Result:= APath;<N>  vIdx:= Pos(cDB_FileName_GINKOIA, Result);<N>  if vIdx <> 0 then<N>    Delete(Result, vIdx, 10);<N>  Result:= ExcludeTrailingBackslash(APath);<N>  Result:= Result + '\' + AEMETTEUR.ADossier.AGroupe.GROU_NOM + '\' + AEMETTEUR.ADossier.DOSS_DATABASE + '\' + AEMETTEUR.EMET_NOM;<N>end;<N><N>
unit ThrdSynchronizeSvr;<N><N>interface<N><N>uses<N>  Classes, SysUtils, IdHTTP;<N><N>type<N>  TThrdSynchronizeSvr = class(TThread)<N>  private<N>  protected<N>    procedure Execute; override;<N>  end;<N><N>implementation<N><N>uses dmdClients;<N><N>procedure TThrdSynchronizeSvr.Execute;<N>var<N>  vIdHTTP: TIdHTTP;<N>begin<N>  try<N>    vIdHTTP:= dmClients.GetNewIdHTTP(nil);<N>    vIdHTTP.Get(GParams.Url + 'SynchronizeSVR');<N>  finally<N>    FreeAndNil(vIdHTTP);<N>  end;<N>end;<N><N>end.<N>
unit FrmCustomGinkoiaForm;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, FrmCustomGinkoia, cxPropertiesStore;<N><N>type<N>  TCustomGinkoiaFormFrm = class(TCustomGinkoiaFrm)<N>    cxPropertiesStore: TcxPropertiesStore;<N>    procedure FormClose(Sender: TObject; var Action: TCloseAction);<N>    procedure FormCreate(Sender: TObject);<N>    procedure FormDestroy(Sender: TObject);<N>  private<N>  public<N>  end;<N><N>
var<N>  CustomGinkoiaFormFrm: TCustomGinkoiaFormFrm;<N><N>implementation<N><N>{$R *.dfm}<N><N>procedure TCustomGinkoiaFormFrm.FormClose(Sender: TObject;<N>  var Action: TCloseAction);<N>begin<N>  inherited;<N>  if cxPropertiesStore.Active then<N>    cxPropertiesStore.StoreTo(False);<N>end;<N><N>
procedure TCustomGinkoiaFormFrm.FormCreate(Sender: TObject);<N>begin<N>  inherited;<N>  cxPropertiesStore.StorageName:= 'Software\' + ChangeFileExt(ExtractFileName(Application.ExeName), '') + '\Storage\' + Self.Name;<N>  if cxPropertiesStore.Active then<N>    cxPropertiesStore.RestoreFrom;<N>end;<N><N>
unit uMdlGinkoia;<N><N>interface<N><N>uses<N>  Classes, SysUtils, DB,<N><N>{$IFDEF CLIENT}<N>  dmdGINKOIA,<N>{$ELSE}<N>  dmdGINKOIA_XE7,<N>  System.Types,<N>{$ENDIF}<N>  Contnrs;<N><N>Const<N>  cRC = #13#10;<N>  cSqlListFieldByTableName = 'SELECT Distinct(s.rdb$field_name) as Field_Name' + cRC + 'FROM rdb$relation_fields s' + cRC +<N>    'WHERE rdb$Relation_Name = ''%s''';<N><N>
unit uZipGinkoia;<N><N>interface<N><N>uses SysUtils, Classes, uSevenzip;<N><N><N>function ZipFile(Const AListFile: TStrings;<N>                 Const AZipName: String;<N>                 AZipFormat: String = '7z';<N>                 AZipPassWord : String = ''): Boolean;<N><N>
function ZipFileWithPath(Const Dir, Path, Willcards: String;<N>                         Const recurse: boolean;<N>                         Const AZipName: String;<N>                         AZipFormat: String = '7z';<N>                         AZipPassWord : String = ''): Boolean;<N><N>
unit FrmCustomGinkoia;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs;<N><N>type<N>  TCustomGinkoiaFrm = class(TForm)<N>  private<N>  public<N>  end;<N><N>var<N>  CustomGinkoiaFrm: TCustomGinkoiaFrm;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit GSData_TErreur;<N><N>interface<N><N>uses SysUtils, Controls, stdctrls, uLogFile;<N><N>Type<N>  TTypeErreur = (teNull, teArticle, teArticleInteg, teMarque, teNomenclature,<N>                 teOpeCom, teMultiColis, tePackage, tePrixDeVente, teFournisseur,<N>                 teReception, teCommande, teGetFtp, teGetFtpWarning);<N><N>
  TErreur = class(TObject)<N>   private<N>    FNomFichier  : String;<N>    FRefErreur   : String;<N>    FText        : String;<N>    FNumeroLigne : Integer;<N>    FTypeErreur  : TTypeErreur;<N>    FDate        : TDateTime;<N>    FHeure       : TDateTime;<N>    FIdTable     : Integer;<N>    FNomTable    : String;<N><N>
unit FrmMain;<N><N>interface<N><N>uses<N>  SysUtils, Classes, Forms, Controls, ExtCtrls, StdCtrls, Dialogs;<N><N>type<N>  TMainFrm = class(TForm)<N>    PnlMain: TPanel;<N>  private<N>  public<N>  end;<N><N>var<N>  MainFrm: TMainFrm;<N><N>implementation<N><N>uses SockApp,<N>uCtrlBaseClientNationale;<N><N>{$R *.dfm}<N><N>initialization<N>  TWebAppSockObjectFactory.Create('c_BaseClientNationale')<N><N>end.<N>
unit u_i_BaseClientNationaleIntf;<N><N>interface<N><N>uses InvokeRegistry, Types, XSBuiltIns;<N><N>type<N>  TRemotableGnk = class(TRemotable)<N>  private<N>    FMessage: String;<N>    FErreur: integer;<N>    FFilename: String;<N>  published<N>    property iErreur: integer read FErreur write FErreur;<N>    property sMessage: String read FMessage write FMessage;<N>    property sFilename: String read FFilename write FFilename;<N>  end;<N><N>
unit uThrdImport;<N><N>interface<N><N>uses<N>  Classes, Messages, SysUtils,windows;<N><N>const<N>  TH_MESSAGE  = WM_USER + 1; //Thread message<N>  TH_NEWLINE  = 1;           //Thread Submessage<N><N>type<N>  PThreadInfo = ^TThreadInfo;<N>  TThreadInfo = record<N>     ThreadId: Cardinal;<N>     MemoLine: string;<N>  end;<N><N>
  TThrdImport = class(TThread)<N>  private<N>    FMemoLine:string;<N>  protected<N>    procedure UpdateMemo;<N>    procedure Execute; override;<N>    procedure SetMemoLine(AValue:string);<N>  public<N>    property MemoLine: string read FMemoLine Write SetMemoLine;<N>  end;<N><N>
implementation<N><N>uses FrmMain;<N><N>{ TThrdImport }<N><N>procedure TThrdImport.Execute;<N>begin<N>  try<N>      MainFrm.SetImport;<N>  Except<N><N>  end;<N>end;<N><N>procedure TThrdImport.SetMemoLine(AValue:string);<N>begin<N>  FMemoLine:=AValue;<N>  Synchronize(UpdateMemo);<N>end;<N><N>
unit uThrdExport;<N><N>interface<N><N>uses<N>  Classes;<N><N>type<N>  TThrdExport = class(TThread)<N>  private<N>    FListHoraireExportNow: String;<N>  protected<N>    procedure Execute; override;<N>  public<N>    property ListHoraireExportNow: String read FListHoraireExportNow write FListHoraireExportNow;<N>  end;<N><N>implementation<N><N>uses FrmMain;<N><N>{ TThrdExport }<N><N>procedure TThrdExport.Execute;<N>begin<N>  MainFrm.SetExport(FListHoraireExportNow);<N>end;<N><N>end.<N>
unit uGetSQLServer;<N><N>interface<N><N>uses<N>  SysUtils, Windows, Classes;<N><N>type<N>  NET_API_STATUS = DWORD;<N><N>  PServerInfo100 = ^TServerInfo100;<N><N>  _SERVER_INFO_100 = record<N>    sv100_platform_id: DWORD;<N>    sv100_name: LPWSTR;<N>  end;<N><N>
  {$EXTERNALSYM _SERVER_INFO_100}<N><N>  TServerInfo100 = _SERVER_INFO_100;<N><N>  SERVER_INFO_100 = _SERVER_INFO_100;<N><N>  {$EXTERNALSYM SERVER_INFO_100}<N><N>const<N><N>  NERR_Success = 0;<N><N>  MAX_PREFERRED_LENGTH = DWORD(-1);<N><N>  SV_TYPE_SQLSERVER = $00000004;<N><N>
unit uCallStack;<N><N>interface<N><N>implementation<N><N>uses<N>  System.Classes,<N>  System.SysUtils,<N>  Winapi.Windows;<N>//  JclDebug,<N>//  JclHookExcept;<N><N>procedure HookGlobalException(ExceptObj: TObject; ExceptAddr: Pointer; OSException: Boolean);<N><N>
  function GetApplicationFileName(): string;<N>  begin<N>    SetLength(Result, MAX_PATH + 1);<N>    GetModuleFileName(HInstance, PChar(Result), MAX_PATH);<N>    SetLength(Result, Length(PChar(Result)));<N>  end;<N><N>  function ReadFileVersion(Fichier: string): string;<N>  var<N>    Dummy       : DWORD;<N>    Info        : Pointer;<N>    InfoSize    : Cardinal;<N>    VerValue    : PVSFixedFileInfo;<N>    InfoDataSize: Cardinal;<N>  begin<N>    Result := '';<N><N>
﻿unit uRepriseCCGlobalPOSUtils;<N><N>interface<N><N>uses<N>  Data.DB,<N>  uRepriseCCGlobalPOSDBUtils, WSCartesCadeauxGlobalPOS, ulog, System.Classes,<N>  IdSMTP, IdExplicitTLSClientServerBase, IdSSLOpenSSL, IdMessage, uRepriseCCGlobalPOSUtils_RS;<N><N>type<N>  TRCCCanContinueEvent = procedure(Sender: TObject; var ACanContinue: Boolean) of object;<N><N>
  TRepriseCCGlobalPOSUtils = class<N>  private<N>    FRCCDBUtils: TRepriseCCGlobalPOSDBUtils;<N>    FwsGlobalPOS: TwsGetGlobalPOS;<N>    FOnLog: TLogEvent;<N>    FOnCanContinue: TRCCCanContinueEvent;<N><N>    procedure CancelCKD(ACKDO: TDataSet; AMagId: Integer);<N><N>
    procedure AddLog(ALogMessage: string; ALogLevel: TLogLevel = logTrace; AMagId: integer = 0);<N>    function CanContinue: Boolean;<N>    procedure SetOnLog(const Value: TLogEvent);<N>    procedure SendMail(aMessage: string; AMagId: Integer);<N>    procedure MailFailedCKDO(ACKDO: TDataSet; AMagId: integer);<N>    procedure MailCKDOKO(ACKDO: TDataSet; AMagId: integer);<N>  public<N>    constructor Create(ADataBaseFile: string);<N>    destructor Destroy;<N><N>
    procedure closeConnection;<N><N>    procedure RecoverBaseCKDOs;<N>    procedure RecoverMagCKDOs(AMagId: integer);<N>    procedure RecoverCKDO(ACKDO: TDataSet; ABasCodeTiers: string; AMagId: integer);<N><N>    property OnLog: TLogEvent read FOnLog write SetOnLog;<N>    property OnCanContinue: TRCCCanContinueEvent read FOnCanContinue write FOnCanContinue;<N>  end;<N><N>
﻿unit uRepriseCCIllicadoUtils;<N><N>interface<N><N>uses<N>  Data.DB,<N>  uRepriseCCIllicadoDBUtils, WSCartesCadeauxGlobalPOS, ulog, System.Classes,<N>  IdSMTP, IdExplicitTLSClientServerBase, IdSSLOpenSSL, IdMessage, uRepriseCCIllicadoUtils_RS;<N><N>type<N>  TRCCCanContinueEvent = procedure(Sender: TObject; var ACanContinue: Boolean) of object;<N><N>
  TRepriseCCIllicadoUtils = class<N>  private<N>    FRCCDBUtils: TRepriseCCIllicadoDBUtils;<N>    FwsGlobalPOS: TwsGetGlobalPOS;<N>    FOnLog: TLogEvent;<N>    FOnCanContinue: TRCCCanContinueEvent;<N><N>    procedure CancelCKD(ACKDO: TDataSet; AMagId: Integer);<N><N>
    procedure AddLog(ALogMessage: string; ALogLevel: TLogLevel = logTrace; AMagId: integer = 0);<N>    function CanContinue: Boolean;<N>    procedure SetOnLog(const Value: TLogEvent);<N>    procedure SendMail(aMessage: string; AMagId: Integer);<N>    procedure MailFailedCKDO(ACKDO: TDataSet; AMagId: integer);<N>    procedure MailCKDOKO(ACKDO: TDataSet; AMagId: integer);<N>  public<N>    constructor Create(ADataBaseFile: string);<N>    destructor Destroy;<N><N>
    procedure closeConnection;<N><N>    procedure RecoverBaseCKDOs;<N>    procedure RecoverMagCKDOs(AMagId: integer);<N>    procedure RecoverCKDO(ACKDO: TDataSet; ABasCodeTiers: string; AMagId: integer);<N><N>    property OnLog: TLogEvent read FOnLog write SetOnLog;<N>    property OnCanContinue: TRCCCanContinueEvent read FOnCanContinue write FOnCanContinue;<N>  end;<N><N>
unit uRegistryUtils;<N><N>interface<N><N>uses<N>  System.Win.Registry,<N>  Winapi.Windows;<N><N>  function GetBaseFilePath: string;<N><N>implementation<N><N>function GetBaseFilePath: string;<N>var<N>  reg: TRegistry;<N>begin<N>  try<N>    reg := TRegistry.Create;<N>    reg.RootKey := HKEY_LOCAL_MACHINE;<N><N>
    if reg.KeyExists('\SOFTWARE\Algol\Ginkoia') then<N>    begin<N>      if reg.OpenKeyReadOnly('\SOFTWARE\Algol\Ginkoia') then<N>      begin<N>        result := reg.ReadString('Base0');<N>      end;<N>    end;<N>  finally<N>    reg.CloseKey;<N>    reg.Free;<N>  end;<N>end;<N><N>
// Translation of the C headers for Oracle's XML parser<N>// e-delos<N><N>unit OraXML;<N><N>interface<N><N>{$IFNDEF MSWINDOWS}<N>	{$IFDEF WIN32}<N>		{$DEFINE MSWINDOWS}<N>  {$ENDIF}<N>{$ENDIF}<N><N>uses<N>{$IFDEF MSWINDOWS}<N>  Windows;<N>{$ENDIF}<N>{$IFDEF LINUX}<N>	Libc;<N>{$ENDIF}<N><N>
//$Log:<N>// 1    Utilitaires1.0         01/10/2012 16:06:34    Loic G          <N>//$<N>//$NoKeywords$<N>//<N>unit UCrePtcVersion;<N><N>interface<N><N>uses<N>   UsaisiePtch,<N>   filectrl,<N>   Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>   Buttons, ExtCtrls, Db, dxmdaset, MemDataX;<N><N>
type<N>   TCrePtcVersion = class(TForm)<N>      OKBtn: TButton;<N>      CancelBtn: TButton;<N>      Bevel1: TBevel;<N>      lb: TListBox;<N>      Label1: TLabel;<N>      DataX: TDataBaseX;<N>      Versions: TMemDataX;<N>      Versionsid: TIntegerField;<N>      Versionsversion: TStringField;<N>      Versionsnomversion: TStringField;<N>      VersionsPatch: TIntegerField;<N>   private<N>    { Private declarations }<N>   public<N>    { Public declarations }<N>      function execute: boolean;<N>   end;<N><N>
//$Log:<N>// 1    Utilitaires1.0         01/10/2012 16:06:33    Loic G          <N>//$<N>//$NoKeywords$<N>//<N>unit UChxClient;<N><N>interface<N><N>uses<N>   UsaisiePtch,<N>   filectrl,<N>   Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>   Buttons, ExtCtrls, Db, dxmdaset, MemDataX, Dialogs;<N><N>
//$Log:<N>// 1    Utilitaires1.0         01/10/2012 16:06:33    Loic G          <N>//$<N>//$NoKeywords$<N>//<N>unit UChxPlage;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls, wwdbdatetimepicker, wwDBDateTimePickerRv;<N><N>
type<N>  Tfrm_chxplage = class(TForm)<N>    OKBtn: TButton;<N>    CancelBtn: TButton;<N>    Bevel1: TBevel;<N>    Label1: TLabel;<N>    Label2: TLabel;<N>    Chp_Datedeb: TwwDBDateTimePickerRv;<N>    Chp_Datefin: TwwDBDateTimePickerRv;<N>    Cb_Version: TComboBox;<N>    procedure FormCreate(Sender: TObject);<N>    procedure OKBtnClick(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
//$Log:<N>// 1    Utilitaires1.0         01/10/2012 16:06:38    Loic G          <N>//$<N>//$NoKeywords$<N>//<N>unit UsaisiePtch;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls;<N><N>type<N>  TsaisiePtch = class(TForm)<N>    OKBtn: TButton;<N>    CancelBtn: TButton;<N>    Bevel1: TBevel;<N>    mem: TMemo;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  saisiePtch: TsaisiePtch;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
//$Log:<N>// 1    Utilitaires1.0         01/10/2012 16:06:27    Loic G          <N>//$<N>//$NoKeywords$<N>//<N>unit cregroupe_frm;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls;<N><N>type<N>  Tfrm_crergroupe = class(TForm)<N>    OKBtn: TButton;<N>    CancelBtn: TButton;<N>    Bevel1: TBevel;<N>    Label1: TLabel;<N>    Edit1: TEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit BrowseForFolderU;<N><N>interface<N><N>function BrowseForFolder(const browseTitle: String; const initialFolder: String = ''; mayCreateNewFolder: Boolean = False): String;<N><N>implementation<N><N>uses<N>  Windows, Forms, shlobj;<N><N>var<N>  lg_StartFolder: String;<N><N>
unit magwmi;<N>{$WARN UNSAFE_TYPE off}<N>{$WARN UNSAFE_CAST off}<N>{$WARN UNSAFE_CODE off}<N>{$WARN SYMBOL_PLATFORM OFF}<N>{$WARN SYMBOL_LIBRARY OFF}<N>{$WARN SYMBOL_DEPRECATED OFF}<N><N>{<N>Magenta Systems WMI and SMART Component v5.5<N>Updated by Angus Robertson, Magenta Systems Ltd, England, 5th August 2013<N>delphi@magsys.co.uk, http://www.magsys.co.uk/delphi/<N>Copyright 2013, Magenta Systems Ltd<N><N>
partly based on articles in Delphi Developers Magazine by Craig Murphy and work by<N>Denis Blondeau (both needed the same bug fixes to read variant arrays properly)<N><N>note - WbemScripting_TLB was created by importing the Microsoft WMI Scripting type library<N><N>
﻿unit uLog;<N><N>{$WARN UNIT_PLATFORM OFF}<N>{$WARN SYMBOL_PLATFORM OFF}<N><N>interface<N><N>uses<N>{$IF CompilerVersion > 27}<N>  System.Classes,<N>  System.SysUtils,<N>  System.StrUtils,<N>  Winapi.Windows,<N>  Winapi.Winsock,<N>  System.Contnrs,<N>  System.SyncObjs,<N>  System.iniFiles,<N>  idTCPClient,<N>  System.Math ;<N>{$ELSE}<N>  Classes,<N>  SysUtils,<N>  StrUtils,<N>  Windows,<N>  Winsock,<N>  Contnrs,<N>  SyncObjs,<N>  iniFiles,<N>  idTCPClient,<N>  Math ;<N>{$IFEND}<N><N>
unit ServiceControler;<N><N>interface<N><N>USes System.Win.Registry, WinSvc, Types, SysUtils, ShellAPI, Windows;<N><N>/// <summary>Verifie si le service existe</summary><N>/// <param name="sMachine">machine name, ie: \SERVER (empty = local machine)</param><N>/// <param name="sService">service name, ie: Alerter</param><N>/// <returns>return TRUE si le service est installer sur la machine</returns><N>function ServiceExist(sMachine, sService : string) : boolean;<N><N>
/// <summary>Installation d'un service</summary><N>/// <param name="servicePath">repertoire ou se trouve l'exe du service</param><N>/// <param name="serviceExe">nom de l'exe du service</param><N>/// <remarks>Cette fonction provoque l'apparition de boite de dialogue (installation reussit ou non).</remarks><N>procedure InstallService(servicePath, serviceExe : string);<N><N>
unit uSynchroTypes;<N><N>interface<N><N>Uses  Windows, Messages, SysUtils, Variants, Classes, StdCtrls, magwmi, magsubs1, Registry,<N>      ShellAPi,inifiles,Tlhelp32, WinSvc,Forms, StrUtils, IOUtils,ServiceControler, Controls,<N>      FireDAC.Comp.Client,IdText, IdFTP, IdFTPCommon, IdExplicitTLSClientServerBase, IdAllFTPListParsers,<N>      IdBaseComponent, IdComponent, IdRawBase, IdRawClient, IdIcmpClient,Vcl.ComCtrls,<N>      IdHashMessageDigest, idHash,ShlObj;<N><N>
unit date_frm;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls;<N><N>type<N>  Tfrm_date = class(TForm)<N>    OKBtn: TButton;<N>    CancelBtn: TButton;<N>    Bevel1: TBevel;<N>    Edit1: TEdit;<N>    Date: TLabel;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit FSP2KTypes;<N><N>interface<N><N>uses Classes;<N><N>type<N>  TIniStruct = record<N>    IsDebugMode : Boolean;<N>    dbDebugMode : String;<N>    lgDebugMode : String;<N>    pwDebugMode : String;<N>    ctDebugMode : String;<N><N>    Database : String;<N>    LoginDb : String;<N>    PasswordDb : String;<N>    CatalogDb : String;<N><N>
    FedasFile : String;<N>    FedasRef  : Integer;<N>  end;<N><N>  TNomenclature = Record<N>    UNI_ID ,<N>    SEC_ID : Integer;<N>  End;<N><N>const<N>  CVERSION = '1.0';<N><N>var<N>  GAPPPATH : String;<N>  GLOGFILEPATH : String;<N>  GLOGFILENAME : String;<N>  IniStruct : TIniStruct;<N>  lstDbListDone : TStringList;<N>  bStopProg : Boolean;<N><N>
unit StdXML_TLB;<N><N>{ This file contains pascal declarations imported from a type library.<N>  This file will be written during each import or refresh of the type<N>  library editor.  Changes to this file will be discarded during the<N>  refresh process. }<N><N>
{ XMLComponents Framework Library }<N>{ Version 1.0 }<N><N>interface<N><N>{$IFNDEF MSWINDOWS}<N>	{$IFDEF WIN32}<N>		{$DEFINE MSWINDOWS}<N>  {$ENDIF}<N>{$ENDIF}<N><N>uses<N>	Classes,<N>{$IFDEF MSWINDOWS}<N>	Windows, ActiveX, Graphics, OleCtrls,<N>  StdVCL,<N>{$ENDIF}<N>  DAC_TLB;<N><N>
unit USendFTP;<N><N>interface<N><N>function DecryptPasswd(Value : string) : string;<N>function SendFileFTP(FileName : string) : boolean;<N><N>implementation<N><N>uses<N>  System.Classes,<N>  System.SysUtils,<N>  IdFTP,<N>  IdFTPCommon,<N>  IdException,<N>  ULectureIniFile,<N>  UResourceString;<N><N>
function DecryptPasswd(Value : string) : string;<N>var<N>  i : integer;<N>begin<N>  Result := '';<N>  for i := (Length(Value) - 1) downto 1 do<N>    Result := Result + Value[i];<N>end;<N><N>function SendFileFTP(FileName : string) : boolean;<N>var<N>  IdFTP : TIdFTP;<N>  Server, Username, Password, Directory : string;<N>  Port : integer;<N>  FileTest : string;<N>  tmpFile : TStringList;<N>begin<N>  Result := false;<N><N>
  try<N>    if not FileExists(FileName) then<N>      EXIT;<N>    // lecture des info de config<N>    if not ReadIniFTP(Server, Username, Password, Directory, Port) then<N>      Raise Exception.Create(rs_ExceptionReadIni);<N>    // fichier de verif<N>    FileTest := ChangeFileExt(FileName, '.txt');<N><N>
unit ULectureIniFile;<N><N>interface<N><N>uses<N>  System.Classes;<N><N>function ReadIniBaseConf(out Serveur, Base : string) : boolean;<N>function WriteIniBaseConf(Serveur, Base : string) : boolean;<N><N>function ReadIniShowMagasin(out ShowMagasin : boolean) : boolean;<N>function WriteIniShowMagasin(ShowMagasin : boolean) : boolean;<N><N>
unit uMessage;<N><N>interface<N><N>uses<N>  Winapi.Windows,<N>  Winapi.Messages;<N><N>const<N>  WM_START_TRT = WM_USER +1;<N>  WM_HIDE_WINDOW = WM_USER +2;<N>  WM_ASK_TO_KILL = WM_USER +3;<N>  WM_TERMINATED = WM_USER +4;<N><N>implementation<N><N>end.<N>
unit uConstHistoEvent;<N><N>interface<N><N>const<N>  CBIOK   = '3008';<N>  CLASTBI = '3009';<N>  CLASTRS = '3010';<N><N>implementation<N><N>end.<N>
unit uIntervalText;<N><N>interface<N><N>function GetIntervalText(Milliseconds : cardinal) : string; overload;<N>function GetIntervalText(Deb, Fin : TDateTime) : string; overload;<N><N>implementation<N><N>uses<N>  System.SysUtils,<N>  System.DateUtils;<N><N>
function GetIntervalText(Milliseconds : cardinal) : string;<N><N>  function GetDureeText(var Duree : Cardinal; Diviseur : cardinal) : string;<N>  var<N>    Reste : Cardinal;<N>  begin<N>    Result := '';<N>    try<N>      Reste := Duree mod Diviseur;<N>      Result := Format('%.' + IntToStr(Length(IntToStr(Diviseur -1))) + 'd', [Reste]);<N>      Duree := Duree div Diviseur;<N>    except<N><N>
unit Ginkoia.Srv.Class_MotPasse;<N><N>interface<N><N>uses<N>  System.Classes,<N>  System.SysUtils,<N>  System.StrUtils,<N>  System.Math,<N>  System.DateUtils,<N>  IdHashMessageDigest;<N><N>function GetPassword(Seed : string = ''; DateGen : TDateTime = 0) : string;<N>function IsValidPassword(Password : string) : boolean;<N><N>
unit IFC_Type;<N><N>interface<N><N>uses  SysUtils, Windows, Forms, Inifiles, Classes, StdCtrls,<N>      Dialogs, Graphics, Controls, Consts;<N><N>type<N>  TCFG = record<N>    Database : String;<N><N>  public<N>    Procedure LoadIni;<N>    Procedure SaveIni;<N>  end;<N><N>
<N>var<N>  GAPPPATH : String;<N>  IniCfg : TCFG;<N><N>  function DoCryptPass(APass : String) : String;<N>  function DoUnCryptPass(APass : String) : String;<N>implementation<N><N><N>function DoCryptPass(APass : String) : String;<N>var<N>  i : Integer;<N>begin<N>  Result := '';<N>  for i  := 1 to Length(APass) do<N>    Result := Result +IntToHex(Ord(APass[i]),2) + IntToHex(Random(255),2);<N>end;<N><N>
function DoUnCryptPass(APass : String) : String;<N>var<N>  i : Integer;<N>begin<N>  Result := '';<N>  for i  := 1 to (Length(APass) Div 4) do<N>    Result := Result + Chr(StrToInt('$' + APass[(i - 1)* 4 + 1] + APass[(i -1) * 4 + 2]));<N>end;<N><N>{ TCFG }<N><N>
procedure TCFG.LoadIni;<N>begin<N>  With TIniFile.Create(GAPPPATH + ChangeFileExt(ExtractFileName(Application.ExeName), '.ini')) do<N>  try<N>    Database := ReadString('DIR','DATABASE','');<N>  finally<N>    free;<N>  end;<N>end;<N><N>procedure TCFG.SaveIni;<N>begin<N>  With TIniFile.Create(GAPPPATH + ChangeFileExt(ExtractFileName(Application.ExeName), '.ini')) do<N>  try<N>    WriteString('DIR','DATABASE',Database);<N>  finally<N>    free;<N>  end;<N><N>
unit uVersion;<N><N>interface<N><N>uses<N>  System.SysUtils, Winapi.Windows;<N><N>type<N>  TVersionField = ( vfMajor, vfMinor, vfRelease, vfBuild );<N>  TVersionFields = set of TVersionField;<N><N>const<N>  DetailVersion = [ vfMajor, vfMinor, vfRelease, vfBuild ];<N>  CommonVersion = [ vfMajor, vfMinor ];<N><N>
// https://delphihaven.wordpress.com/2012/12/08/retrieving-the-applications-version-string/<N>function GetAppVersion(const VersionFields: TVersionFields = DetailVersion ): String;<N><N>implementation<N><N>procedure GetAppCommonVersion(out Major, Minor: Word);<N>var<N>  Rec: LongRec;<N>begin<N>  Rec := LongRec(GetFileVersion(ParamStr(0)));<N>  Major := Rec.Hi;<N>  Minor := Rec.Lo;<N>end;<N><N>
unit uVersion;<N><N>interface<N><N>uses<N>  System.SysUtils, Winapi.Windows;<N><N>type<N>  TVersionField = ( vfMajor, vfMinor, vfRelease, vfBuild );<N>  TVersionFields = set of TVersionField;<N><N>const<N>  DetailVersion = [ vfMajor, vfMinor, vfRelease, vfBuild ];<N>  CommonVersion = [ vfMajor, vfMinor ];<N><N>
// https://delphihaven.wordpress.com/2012/12/08/retrieving-the-applications-version-string/<N>function GetAppVersion(const VersionFields: TVersionFields = DetailVersion ): String;<N><N>implementation<N><N>procedure GetAppCommonVersion(out Major, Minor: Word);<N>var<N>  Rec: LongRec;<N>begin<N>  Rec := LongRec(GetFileVersion(ParamStr(0)));<N>  Major := Rec.Hi;<N>  Minor := Rec.Lo;<N>end;<N><N>
unit uDefs;<N><N>interface<N><N>type<N>  TIni = record<N>    defaultPath : String;<N><N>    smtpUsername : String;<N>    smtpPassword : String;<N>    smtpHost : String;<N>    smtpPort : Integer;<N>  end;<N><N>implementation<N><N>end.<N>
﻿unit Urechcltcent;<N><N>interface<N><N>uses<N>   inifiles, Xml_Unit, IcXMLParser, Windows, Messages, SysUtils, Classes,<N>   Graphics, Controls, Forms, Dialogs, Buttons, StdCtrls, Db, IBDatabase,<N>   IBCustomDataSet, IBQuery, XMLDoc, ExtCtrls, XMLIntf, filectrl, uGenerique,<N>   uDefs, IdMessage, IdSMTP, IdSSLOpenSSL, IdGlobal,<N>   IdExplicitTLSClientServerBase;<N><N>
unit uDefs;<N><N>interface<N><N>uses Windows, Messages, SysUtils,Classes,dxmdaset, StrUtils, ADODB, Contnrs, IdFTP, IdComponent;<N><N>const<N>  CTYPESTOCK = 1;<N>  CTYPEVENTE = 2;<N>  CTYPECMD   = 3;<N>  CETATOK    = 1;<N>  CETATKO    = 0;<N><N>  MODESTOCK = 1;<N>  MODEVENTE = 2;<N>  MODECMD   = 3;<N><N>
  CVERSION = '1.09 Avec Limitation CDE/mail sur champ MAG_CMDLEVIS';<N><N>type<N>  TKVersion = record<N>    IdKvTicket ,<N>    IdKvBL     ,<N>    IdKvFact   : Integer;<N>  end;<N><N>  TTVALignes = array of record<N>    CDE_TVAHT   ,<N>    CDE_TVATAUX ,<N>    CDE_TVA     : currency;<N>  end;<N><N>
  TCFG = record<N>    Debug : Boolean;<N>    DebugMagCode : String;<N>    DebugMagID   : Integer;<N>    DebugKIdCDE  : Integer;<N>    EMail : Record<N>      ExpMail  ,<N>      Password ,<N>      AdrSMTP  : String;<N>      Port : Integer;<N>    end;<N>    FTP : Record<N>      Host     ,<N>      UserName ,<N>      Password : String;<N>      Dir      : String;<N>    End;<N>    MntMiniCde : Double;<N>  end;<N><N>
  var<N>  GAPPPATH  : String;<N>  GPATHQRY  : String;<N>  GPATHSAVE : String;<N>  GPATHIMG  : String;<N>  GBASEPATHDEBUG : String;<N>  GPATHARCHIV : String;<N>  MainCFG   : TCFG;<N><N>  function CryptPW(sPW : String) : String;<N>  function DeCryptPW(sPW : String) : String;<N><N>
  function SendFileToFTP(sFileName : String) : Boolean;<N>  function ArchiveFile(sFileName : String) : Boolean;<N><N>implementation<N><N>function CryptPW(sPW : String) : String;<N>var<N>  i : Integer;<N>begin<N>  Result := '';<N>  if Trim(sPW) <> '' then<N>    for i := 1 to Length(sPW) do<N>      Result := Result + IntToHex(Ord(sPW[i]),2);<N>end;<N><N>
function DeCryptPW(sPW : String) : String;<N>var<N>  i : integer;<N>begin<N>  Result := '';<N>  if Trim(sPW) <> '' then<N>  begin<N><N>    i := 1;<N>    while i < Length(sPW) do<N>    begin<N>      Result := Result + Chr(StrToInt('$' + Copy(sPW,i,2)));<N>      inc(i,2);<N>    end;<N>  end;<N>end;<N><N>
function SendFileToFTP(sFileName : String) : Boolean;<N>var<N>  lst : TStringList;<N>  i : integer;<N>begin<N>  Result := False;<N><N>//  if MainCFG.Debug then<N>//    Exit;<N><N>  if Trim(MainCFG.FTP.Host) = '' then<N>    raise Exception.Create('Send FTP -> Configuration incorrecte');<N><N>
  With TIdFTP.Create(nil) do<N>  try<N>    Username := MainCFG.FTP.UserName;<N>    Password := MainCFG.FTP.Password;<N>    Host     := MainCFG.FTP.Host;<N>    Passive  := True;<N><N>//    TransferTimeout := 5000;<N><N>    try<N>      Connect;<N><N>      if Trim(MainCFG.FTP.Dir) <> '' then<N>      begin<N>        lst := TStringList.Create;<N><N>
        try<N>          lst.Text := StringReplace(MainCFG.FTP.Dir,'/',#13#10,[rfReplaceAll]);<N>          for i := 0 to Lst.Count - 1 do<N>          begin<N>            if Trim(lst[i]) <> '' then<N>              ChangeDir(Trim(lst[i]));<N>              Sleep(50);<N>          end;<N>        finally<N>          lst.free;<N>        end;<N>      end;<N><N>
      // Si le fichier existe deja on le supprime<N>      if Size(ExtractFileName(sFileName)) <> -1 then<N>        Delete(ExtractFileName(sFileName));<N><N>      Put(sFileName, ExtractFileName(sFileName));<N><N>      Result := True;<N>    Except on E:Exception do<N>      raise Exception.create('Send FTP -> ' + E.Message);<N>    end;<N>  finally<N>    Disconnect;<N>    Free;<N>  end;<N>end;<N><N>
function ArchiveFile(sFileName : String) : Boolean;<N>begin<N>  Try<N>    Result := CopyFile(PChar(sFileName),PChar(GPATHARCHIV + ExtractFileName(sFileName)),False);<N>    if Result then<N>      Result := DeleteFile(sFileName);<N>  Except on E:Exception do<N>    raise Exception.Create('ArchiveFile -> ' + E.Message);<N>  End;<N>end;<N><N>
unit UChxVersion;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls, <N>  Buttons, ExtCtrls;<N><N>type<N>  TDial_Versions = class(TForm)<N>    OKBtn: TButton;<N>    CancelBtn: TButton;<N>    Bevel1: TBevel;<N>    Depart: TEdit;<N>    Arrive: TEdit;<N>    Label1: TLabel;<N>    Label2: TLabel;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>{<N>var<N>  Dial_Versions: TDial_Versions;<N>}<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit UCltNom;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls;<N><N>type<N>  TDial_Cltnom = class(TForm)<N>    OKBtn: TButton;<N>    CancelBtn: TButton;<N>    Bevel1: TBevel;<N>    Edit1: TEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Dial_Cltnom: TDial_Cltnom;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit ULiveUpCst;<N><N>interface<N>Type<N>    TEnCours = (Ecrs_Rien, Ecrs_Identification, Ecrs_AttenteQuestion, ECRS_LastVersion, ECRS_QuelqueChose, ECRS_ApresRelease, ECRS_Fichiers,<N>                Ecrs_EnvoiACK);<N><N>implementation<N><N>end.<N>
unit ULaVersion;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls;<N><N>type<N>  TTLaVersion = class(TForm)<N>    OKBtn: TButton;<N>    CancelBtn: TButton;<N>    Bevel1: TBevel;<N>    Version: TLabel;<N>    Edit1: TEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  TLaVersion: TTLaVersion;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit magwmi;<N>{$WARN UNSAFE_TYPE off}<N>{$WARN UNSAFE_CAST off}<N>{$WARN UNSAFE_CODE off}<N>{$WARN SYMBOL_PLATFORM OFF}<N>{$WARN SYMBOL_LIBRARY OFF}<N>{$WARN SYMBOL_DEPRECATED OFF}<N><N>{<N>Magenta Systems WMI and SMART Component v5.5<N>Updated by Angus Robertson, Magenta Systems Ltd, England, 5th August 2013<N>delphi@magsys.co.uk, http://www.magsys.co.uk/delphi/<N>Copyright 2013, Magenta Systems Ltd<N><N>
partly based on articles in Delphi Developers Magazine by Craig Murphy and work by<N>Denis Blondeau (both needed the same bug fixes to read variant arrays properly)<N><N>note - WbemScripting_TLB was created by importing the Microsoft WMI Scripting type library<N><N>
unit Poste_frm;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls, <N>  Buttons, ExtCtrls;<N><N>type<N>  Tfrm_poste = class(TForm)<N>    Bevel1: TBevel;<N>    BitBtn1: TBitBtn;<N>    BitBtn2: TBitBtn;<N>    Label1: TLabel;<N>    ed_Nom: TEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  frm_poste: Tfrm_poste;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit UCst;<N><N>interface<N><N>const<N>   //URL = 'http://localHost/tech/AccesBase.dll/';<N>   URL = 'http://lame2.no-ip.com/tech/AccesBase.dll/';<N>   //URL = 'http://192.168.13.20/tech/AccesBase.dll/';<N>   LecteurLame='D';<N><N>FUNCTION traitechaine(S: string): string;<N><N>implementation<N><N>FUNCTION traitechaine(S: string): string;<N>var<N>   kk: Integer;<N>begin<N>   while pos(' ', S) > 0 do<N>   begin<N>      kk := pos(' ', S);<N>      delete(S, kk, 1);<N>      Insert('%20', S, kk);<N>   end;<N>   result := S;<N>end;<N><N><N>end.<N>
unit Societe_frm;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls, <N>  Buttons, ExtCtrls, ComCtrls;<N><N>type<N>  TFrm_Societe = class(TForm)<N>    Bevel1: TBevel;<N>    BitBtn1: TBitBtn;<N>    BitBtn2: TBitBtn;<N>    Label1: TLabel;<N>    Label2: TLabel;<N>    ed_Nom: TEdit;<N>    Edt_Date: TDateTimePicker;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Frm_Societe: TFrm_Societe;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit Ident_Frm;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls;<N><N>type<N>  Tfrm_Ident = class(TForm)<N>    Bevel1: TBevel;<N>    BitBtn1: TBitBtn;<N>    BitBtn2: TBitBtn;<N>    Label1: TLabel;<N>    Label2: TLabel;<N>    ed_Ident: TEdit;<N>    ed_Password: TEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit Magasin_frm;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls, <N>  Buttons, ExtCtrls;<N><N>type<N>  Tfrm_magasin = class(TForm)<N>    Bevel1: TBevel;<N>    BitBtn1: TBitBtn;<N>    BitBtn2: TBitBtn;<N>    Label1: TLabel;<N>    ed_Nom: TEdit;<N>    Label2: TLabel;<N>    ed_Ident: TEdit;<N>    Label3: TLabel;<N>    Lb_Soc: TComboBox;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  frm_magasin: Tfrm_magasin;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit UUtilMachine;<N><N>interface<N><N>uses<N>   registry, ShlObj, ComObj, ActiveX,<N>   Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,<N>   StdCtrls, ComCtrls;<N><N>type<N>  TUtilMachine = class(TObject)<N>  public<N>    procedure CreerRaccourcie(Nom, Fichier, Description, Repertoire, Icon :<N>        String; Index:Integer=0);<N>    function NomPoste: string;<N>  end;<N><N>
// Translation of the C headers for Oracle's XML parser<N>// e-delos<N><N>unit OraXML;<N><N>interface<N><N>{$IFNDEF MSWINDOWS}<N>	{$IFDEF WIN32}<N>		{$DEFINE MSWINDOWS}<N>  {$ENDIF}<N>{$ENDIF}<N><N>uses<N>{$IFDEF MSWINDOWS}<N>  Windows;<N>{$ENDIF}<N>{$IFDEF LINUX}<N>	Libc;<N>{$ENDIF}<N><N>
//$Log:<N>// 1    Utilitaires1.0         20/05/2005 11:22:25    pascal          <N>//$<N>//$NoKeywords$<N>//<N>unit UCrePtcVersion;<N><N>interface<N><N>uses<N>   UsaisiePtch,<N>   filectrl,<N>   Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>   Buttons, ExtCtrls, Db, dxmdaset, MemDataX;<N><N>
type<N>   TCrePtcVersion = class(TForm)<N>      OKBtn: TButton;<N>      CancelBtn: TButton;<N>      Bevel1: TBevel;<N>      lb: TListBox;<N>      Label1: TLabel;<N>      DataX: TDataBaseX;<N>      Versions: TMemDataX;<N>      Versionsid: TIntegerField;<N>      Versionsversion: TStringField;<N>      Versionsnomversion: TStringField;<N>      VersionsPatch: TIntegerField;<N>   private<N>    { Private declarations }<N>   public<N>    { Public declarations }<N>      function execute: boolean;<N>   end;<N><N>
//$Log:<N>// 2    Utilitaires1.1         08/08/2005 09:03:34    pascal          Divers<N>//      modifications suite aux demandes de st?phanes<N>// 1    Utilitaires1.0         04/07/2005 10:18:53    pascal          <N>//$<N>//$NoKeywords$<N>//<N>unit UChxPlage;<N><N>
//$Log:<N>// 1    Utilitaires1.0         20/05/2005 11:22:26    pascal          <N>//$<N>//$NoKeywords$<N>//<N>unit UsaisiePtch;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls;<N><N>type<N>  TsaisiePtch = class(TForm)<N>    OKBtn: TButton;<N>    CancelBtn: TButton;<N>    Bevel1: TBevel;<N>    mem: TMemo;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  saisiePtch: TsaisiePtch;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
//$Log:<N>// 1    Utilitaires1.0         20/05/2005 11:22:23    pascal          <N>//$<N>//$NoKeywords$<N>//<N>unit cregroupe_frm;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls;<N><N>type<N>  Tfrm_crergroupe = class(TForm)<N>    OKBtn: TButton;<N>    CancelBtn: TButton;<N>    Bevel1: TBevel;<N>    Label1: TLabel;<N>    Edit1: TEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit Gin.Com.ThreadProc;<N><N>interface<N><N>uses System.Classes, System.SysUtils ;<N><N>type<N>  TProcError = reference to procedure( aException : Exception ) ;<N><N>  TThreadProc = class(TThread)<N>  private<N>    FFinish     : TProc ;<N>    FError      : TProcError ;<N>    FException  : Exception ;<N>    procedure doError ;<N>    procedure doFinish ;<N>  protected<N>    FRun     : TProc ;<N>    procedure Execute ; override ;<N>  public<N>    constructor Create ; reintroduce ;<N><N>
    class function RunInThread(aProc: TProc) : TThreadProc ;<N>    function whenFinish(aProc: TProc) : TThreadProc ;<N>    function whenError(aProc : TProcError) : TThreadProc ;<N>    function Run : TThreadProc ;<N><N>    procedure SynchonizeProc(aProc : TThreadProcedure) ;<N>  published<N>    property Terminated ;<N>  end;<N><N>
implementation<N><N>{ TThreadProc }<N><N>constructor TThreadProc.Create;<N>begin<N>  inherited Create(true) ;<N>  FRun     := nil ;<N>  FError   := nil ;<N>  FFinish  := nil ;<N><N>  FreeOnTerminate := true ;<N>end;<N><N>procedure TThreadProc.doError;<N>begin<N>  if Assigned(FError) then<N>  begin<N>    try<N>      FError(FException) ;<N>    except<N>    end;<N>  end;<N>end;<N><N>
unit HotSyncDM;<N><N>interface<N><N>uses<N>  SysUtils, Classes, DB, IBDatabase, IBCustomDataSet, IBQuery;<N><N>type<N>  TDMHotSync = class(TDataModule)<N>    Database: TIBDatabase;<N>    Transaction: TIBTransaction;<N>    Query: TIBQuery;<N>    QueryTables: TIBQuery;<N><N>  private<N><N>  public<N><N>  end;<N><N>var<N>  DMHotSync: TDMHotSync;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit ChxMag_frm;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls;<N><N>type<N>  Tfrm_ChxMag = class(TForm)<N>    OKBtn: TButton;<N>    Bevel1: TBevel;<N>    Lb_Mag: TListBox;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  frm_ChxMag: Tfrm_ChxMag;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit ChxMag_frm;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls;<N><N>type<N>  Tfrm_ChxMag = class(TForm)<N>    OKBtn: TButton;<N>    Bevel1: TBevel;<N>    Lb_Mag: TListBox;<N>    procedure OKBtnClick(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  frm_ChxMag: Tfrm_ChxMag;<N><N>implementation<N><N>{$R *.DFM}<N><N>procedure Tfrm_ChxMag.OKBtnClick(Sender: TObject);<N>begin<N>  ModalResult := mrOk;<N>end;<N><N>end.<N>
unit UDynamicNKL;<N><N>interface<N><N>uses<N>  StdCtrls, Controls;<N><N>type<N>  TDynamicNKL = class<N>  strict private<N>    Fname : string;<N>    Fparent : TWinControl;<N>    Findex : Integer;<N><N>    FactID : Integer;<N>    FuniID : Integer;<N>    FssfID : Integer;<N><N>
    FaxeLabel : TLabel;<N>    FssfEdit : TEdit;<N>    FssfLabel : TLabel;<N><N>    function getSsfCodeFinal() : string;<N>  public<N>    constructor Create(aParent : TWinControl; aName : string; aIndex, aActID, aUniID : Integer; aSsfCodeFinal : string); overload;<N>    destructor Destroy(); override;<N><N>
    procedure SetLabel(aNom : string; aSsfID : Integer; aInRed : Boolean = False);<N>    procedure SetEnabled(aValue : Boolean);<N><N>    property UniID : Integer read FuniID;<N>    property ActID : Integer read FactID;<N>    property SsfID : Integer read FssfID;<N>    property SsfCodeFinal : string read getSsfCodeFinal;<N>    property Enabled : Boolean write SetEnabled;<N>    property Name : string read Fname; <N>  end;<N><N>
implementation<N><N>uses<N>    SysUtils, Messages, Forms, Graphics;<N><N><N>{ TDynamicNKL }<N><N>constructor TDynamicNKL.Create(aParent: TWinControl; aName: string; aIndex, aActID, aUniID : Integer; aSsfCodeFinal : string);<N>begin<N>  inherited Create();<N>  Fparent := aParent;<N>  Fname := aName;<N>  Findex := aIndex;<N><N>
  FuniID := aUniID;<N>  FactID := aActID;<N><N>  FaxeLabel := TLabel.Create(nil);<N>  FaxeLabel.Font.Size := 7;<N>  FaxeLabel.Font.Color := clNavy;<N>  FaxeLabel.Parent := Fparent;<N>  FaxeLabel.Left := 21;<N>  FaxeLabel.Top := 9 + ((Findex) * 30) - TScrollBox(aParent).vertscrollbar.position;<N>  FaxeLabel.Caption := UpperCase(Fname);<N><N>
/// <summary><N>/// Gestion de la journalisation des exceptions.<N>/// </summary><N>unit uCallStack;<N><N>interface<N><N>implementation<N><N>uses<N>  System.Classes,<N>  System.SysUtils,<N>  Winapi.Windows,<N>  JclDebug,<N>  JclHookExcept;<N><N>procedure HookGlobalException(ExceptObj: TObject; ExceptAddr: Pointer; OSException: Boolean);<N><N>
  function GetApplicationFileName(): string;<N>  begin<N>    SetLength(Result, MAX_PATH + 1);<N>    GetModuleFileName(HInstance, PChar(Result), MAX_PATH);<N>    SetLength(Result, Length(PChar(Result)));<N>  end;<N><N>  function ReadFileVersion(Fichier: string): string;<N>  var<N>    Dummy       : DWORD;<N>    Info        : Pointer;<N>    InfoSize    : Cardinal;<N>    VerValue    : PVSFixedFileInfo;<N>    InfoDataSize: Cardinal;<N>  begin<N>    Result := '';<N><N>
unit uEntropy.TSpeedButton.Colored;<N><N>interface<N><N>uses<N>  System.Classes,<N>  System.UITypes,<N>  FMX.StdCtrls;<N><N>type<N>  TSpeedButton = class(FMX.StdCtrls.TSpeedButton)<N>  private const<N>    cEnter: TAlphaColor = TAlphaColorRec.Black;<N>    cLeave: TAlphaColor = TAlphaColorRec.White;<N>  protected<N>    procedure DoMouseEnter; override;<N>    procedure DoMouseLeave; override;<N>  end;<N><N>
unit uApplicationVersion;<N>// http://delphihaven.wordpress.com/2012/12/08/retrieving-the-applications-version-string/<N><N>interface<N><N>function GetAppVersionStr: string;<N>function GetAppVersionStrFull: string;<N><N>implementation<N><N>uses<N>  System.SysUtils,<N>  Winapi.Windows;<N><N>
unit uReportMemoryLeaks;<N><N>interface<N><N>implementation<N><N>initialization<N><N>{$IFDEF DEBUG}<N>  ReportMemoryLeaksOnShutdown := True;<N>{$ENDIF}<N><N>end.<N>
unit UVersionUtils;<N><N>interface<N><N>uses<N>  System.Types;<N><N>function GetYellisVersion(Version : string) : string;<N>function CompareVersion(A, B : string) : TValueRelationship;<N><N>implementation<N><N>uses<N>  System.SysUtils,<N>  System.StrUtils,<N>  System.Classes,<N>  System.Math;<N><N>
function GetYellisVersion(Version : string) : string;<N>var<N>  IdxLast : integer;<N>begin<N>  IdxLast := Length(Version);<N>  while not (Version[IdxLast] = '.') do<N>    Dec(IdxLast);<N>  Result := 'V' + LeftStr(Version, IdxLast);<N>  if Copy(Version, IdxLast +1, 4) = '9999' then<N>    Result := Result + '1'<N>  else<N>    Result := Result + '0';<N>end;<N><N>
function CompareVersion(A, B : string) : TValueRelationship;<N>var<N>  ListValA, ListValB : TStringList;<N>  ValA, ValB, i, nb : integer;<N>begin<N>  Result := EqualsValue;<N>  try<N>    While (Length(A) > 0) and not CharInSet(A[1], ['0'..'9'])  do<N>      Delete(A, 1, 1);<N>    While (Length(B) > 0) and not CharInSet(B[1], ['0'..'9']) do<N>      Delete(B, 1, 1);<N><N>
    ListValA := TStringList.Create();<N>    ListValA.Delimiter := '.';<N>    ListValA.DelimitedText := Trim(A);<N>    ListValB := TStringList.Create();<N>    ListValB.Delimiter := '.';<N>    ListValB.DelimitedText := Trim(B);<N><N>    nb := Max(ListValA.Count, ListValB.Count);<N>    while ListValA.Count < nb do<N>      ListValA.Add('0');<N>    while ListValB.Count < nb do<N>      ListValB.Add('0');<N><N>
    for i := 0 to nb -1 do<N>    begin<N>      if TryStrToInt(ListValA[i], ValA) and TryStrToInt(ListValB[i], ValB) then<N>        Result := CompareValue(ValA, ValB)<N>      else<N>        Result := CompareStr(ListValA[i], ListValB[i]);<N>      if not (Result = EqualsValue) then<N>        Exit;<N>    end;<N>  finally<N>    FreeAndNil(ListValA);<N>    FreeAndNil(ListValB);<N>  end;<N>end;<N><N>
unit UMomentPassword;<N><N>interface<N><N>function GetPassword(Seed : string = ''; DateGen : TDateTime = 0) : string;<N>function IsValidPassword(Password : string; Seed : string = ''; DateGen : TDateTime = 0) : boolean;<N><N>implementation<N><N>uses<N>  System.Math,<N>  System.SysUtils,<N>  System.StrUtils,<N>  System.DateUtils,<N>  IdHashMessageDigest;<N><N>
unit UFileUtils;<N><N>interface<N><N>function GetTempDirectory(Base : string = '') : String;<N>function GetFileSize(FileName : string) : Int64;<N>function GetDiskFreeSpace(Drive : char) : Int64;<N>function DelTree(DirName : string): Boolean;<N><N>implementation<N><N>
uses<N>  System.SysUtils,<N>  System.IOUtils,<N>  Winapi.ShellAPI;<N><N>function GetTempDirectory(Base : string) : String;<N>var<N>  tempFolder: string;<N>begin<N>  Randomize();<N>  if Trim(Base) = '' then<N>    tempFolder := TPath.GetTempPath()<N>  else<N>    tempFolder := IncludeTrailingPathDelimiter(Base);<N>  repeat<N>    result := IncludeTrailingPathDelimiter(IncludeTrailingPathDelimiter(tempFolder) + IntToStr(Random(999999999)));<N>  until not DirectoryExists(Result);<N>end;<N><N>
function GetFileSize(FileName : string) : Int64;<N>var<N>  FindStruc : TSearchRec;<N>begin<N>  Result := 0;<N>  try<N>    if FindFirst(FileName, faanyfile, FindStruc) = 0 THEN<N>      Result := FindStruc.Size;<N>  finally<N>    findClose(FindStruc);<N>  end;<N>end;<N><N>
unit UValideKeyNumber;<N><N>interface<N><N>uses<N>  Vcl.StdCtrls;<N><N>procedure ValideNumericKeyPress(Edit : TCustomEdit; var Key: Char; Negatif : boolean = true; Flotant : boolean = true); overload;<N>procedure ValideNumericKeyPress(Edit : TCustomEdit; var Key: Char; Decimal : integer; Negatif : boolean = true; Flotant : boolean = true); overload;<N><N>
function GetFloatFromEdit(Edit : TEdit) : Double;<N>procedure SetEditFromFloat(Edit : TEdit; Value : Double);<N>function GetCurrencyFromEdit(Edit : TEdit) : Currency;<N>procedure SetEditFromCurrency(Edit : TEdit; Value : Currency);<N><N>implementation<N><N>
uses<N>  System.SysUtils,<N>  Winapi.Windows;<N><N>var<N>  FormatSettings :  TFormatSettings;<N><N>procedure ValideNumericKeyPress(Edit : TCustomEdit; var Key: Char; Negatif : boolean; Flotant : boolean);<N>begin<N>  ValideNumericKeyPress(Edit, Key, 0, Negatif, Flotant);<N>end;<N><N>
unit UConstantes;<N><N>interface<N><N>uses<N>  IdExplicitTLSClientServerBase, IdSSLOpenSSL, windows;<N><N>type<N>  TMessageEvent = procedure(Sender: TObject; Text: String) of object;<N>  TProgressEvent = procedure(Sender: TObject; Progress: integer) of object;<N><N>
  TParamMail = record<N>    FromAddress : string;<N>    SmtpPort    : integer;<N>    SmtpHost    : string;<N>    SmtpUsername: string;<N>    SmtpPassword: string;<N>    SmtpUseTLS  : TIdUseTLS;<N>    SSLVersion  : TIdSSLVersion;<N>  end;<N>  function GetCompName: string;<N><N>
<N><N>implementation<N>  function GetCompName: string;<N>  var<N>    dwLength: dword;<N>  begin<N>    dwLength := 253;<N>    SetLength(result, dwLength+1);<N>    if not Windows.GetComputerName(pchar(result), dwLength) then<N>      Result := '';<N>    result := pchar(result);<N>  end;<N>end.<N><N><N>
UNIT Question_Frm;<N><N>INTERFACE<N><N>USES Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>    Buttons, ExtCtrls;<N><N>TYPE<N>    TFrm_Question = CLASS(TForm)<N>        OKBtn: TButton;<N>        CancelBtn: TButton;<N>        Bevel1: TBevel;<N>        ed_Question: TEdit;<N>    PRIVATE<N>        { Private declarations }<N>    PUBLIC<N>        { Public declarations }<N>        FUNCTION execute(titre: STRING; VAR Valeur: STRING; Mdp: Boolean): Boolean;<N>    END;<N><N>
unit Mainform;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, ShellApi, IdBaseComponent,<N>  IdComponent, IdTCPConnection, IdTCPClient, IdHTTP, IniFiles, Vcl.ExtCtrls,<N>  Data.DB, FireDAC.Comp.DataSet,FireDAC.Comp.Client, Vcl.ComCtrls,<N>  Vcl.ButtonGroup, Vcl.Buttons, FireDAC.Stan.Intf, FireDAC.Phys,<N>  FireDAC.Phys.IBBase, FireDAC.Phys.IB,  FireDAC.Phys.IBWrapper;<N><N>
unit Uversion;<N><N>interface<N><N>uses<N>  Classes; // TStringList<N><N>const<N>  FileInfos : array [1..8] of string = ('FileDescription', 'CompanyName', 'FileVersion', 'InternalName',<N>                                        'LegalCopyRight', 'OriginalFileName', 'ProductName', 'ProductVersion');<N><N>
unit ServiceControler;<N><N>interface<N><N>/// <summary>Verifie si le service existe</summary><N>/// <param name="sMachine">machine name, ie: \SERVER (empty = local machine)</param><N>/// <param name="sService">service name, ie: Alerter</param><N>/// <returns>return TRUE si le service est installer sur la machine</returns><N>function ServiceExist(sMachine, sService : string) : boolean;<N><N>
/// <summary>Installation d'un service</summary><N>/// <param name="servicePath">repertoire ou se trouve l'exe du service</param><N>/// <param name="serviceExe">nom de l'exe du service</param><N>/// <remarks>Cette fonction provoque l'apparition de boite de dialogue (installation reussit ou non).</remarks><N>procedure InstallService(servicePath, serviceExe : string);<N><N>
unit UTools;<N><N>interface<N><N>uses<N>  SysUtils, Classes, StdCtrls, Variants, Windows, Registry, WinSvc;<N>function InterbaseRunning : boolean;<N>function ShutDownInterbase : boolean;<N>function StartInterbase : boolean;<N>function ShutDownWinUpdate : boolean;<N>function StartWinUpdate : boolean;<N><N>
unit uTools;<N><N>interface<N><N>uses<N>  SysUtils, Classes, Windows, WinSvc;<N><N>type<N>  TTools = class<N>    private<N>      function InterbaseRunning : boolean;<N>      function ServiceStart(sMachine, sService : string ) : boolean;<N>      function ServiceStop(sMachine, sService : string ) : boolean;<N>    public<N><N>
      constructor Create;<N>      destructor Destroy; OVERRIDE;<N>      function ShutDownInterbase : boolean;<N>      function StartInterbase : boolean;<N>      function ShutDownWinUpdate : boolean;<N>      function StartWinUpdate : boolean;<N>  end;<N><N>
unit uThreadProc;<N><N>interface<N><N>uses Classes, SysUtils, Forms;<N><N>type<N>  TProcError = reference to procedure( aException : Exception ) ;<N><N>  TThreadProc = class(TThread)<N>  private<N>    FFinish     : TProc ;<N>    FError      : TProcError ;<N>    FException  : Exception ;<N>    procedure doError ;<N>    procedure doFinish ;<N>  protected<N>    FRun     : TProc ;<N>    procedure Execute ; override ;<N>  public<N>    constructor Create ; reintroduce ;<N><N>
    class function RunInThread(aProc: TProc) : TThreadProc ;<N>    function whenFinish(aProc: TProc) : TThreadProc ;<N>    function whenError(aProc : TProcError) : TThreadProc ;<N>    function Run : TThreadProc ;<N>    function RunAndWait: TThreadProc;<N><N>
    procedure SynchonizeProc(aProc : TThreadProcedure) ;<N>  published<N>    property Terminated ;<N>  end;<N><N>implementation<N><N>{ TThreadProc }<N><N>constructor TThreadProc.Create;<N>begin<N>  inherited Create(true) ;<N>  FRun     := nil ;<N>  FError   := nil ;<N>  FFinish  := nil ;<N><N>
  FreeOnTerminate := true ;<N>end;<N><N>procedure TThreadProc.doError;<N>begin<N>  if Assigned(FError) then<N>  begin<N>    try<N>      FError(FException) ;<N>    except<N>    end;<N>  end;<N>end;<N><N>procedure TThreadProc.doFinish;<N>begin<N>  if Assigned(FFinish) then<N>  begin<N>    try<N>      FFinish() ;<N>    except<N>    end;<N>  end;<N>end;<N><N>
procedure TThreadProc.Execute;<N>begin<N>  inherited ;<N><N>  try<N>    FRun() ;<N><N>    if not Terminated then<N>    begin<N>      if Assigned(FFinish) then<N>        Synchronize(doFinish);<N>      Terminate;<N>    end ;<N>  except<N>    on E:Exception do<N>    begin<N>      FException := E ;<N>      if Assigned(FError) then<N>        Synchronize(doError);<N>      Terminate;<N>    end;<N>  end;<N>end;<N><N>
function TThreadProc.Run: TThreadProc;<N>begin<N>  if Assigned(FRun) then<N>    Start ;<N><N>  Result := Self ;<N>end;<N><N>function TThreadProc.RunAndWait: TThreadProc;<N>begin<N>  if Assigned(FRun) then<N>    Start;<N><N>  while not Terminated do<N>  begin<N>    Application.ProcessMessages;<N>    Sleep(20);<N>  end;<N><N>
  Result := Self;<N>end;<N><N>class function TThreadProc.RunInThread(aProc: TProc): TThreadProc;<N>begin<N>  Result := TThreadProc.Create ;<N>  Result.FRun := aProc ;<N>end;<N><N>procedure TThreadProc.SynchonizeProc(aProc: TThreadProcedure);<N>begin<N>  Synchronize(aProc);<N>end;<N><N>
function TThreadProc.whenError(aProc: TProcError): TThreadProc;<N>begin<N>  FError := aProc ;<N>  Result := Self ;<N>end;<N><N>function TThreadProc.whenFinish(aProc: TProc): TThreadProc;<N>begin<N>  FFinish := aProc ;<N>  Result := Self ;<N>end;<N><N>end.<N><N>
unit UnitLog;<N><N>interface<N><N>uses System.Classes, System.SysUtils, Winapi.Windows;<N><N>type<N>  TLog = class(TThread)<N>    private<N>      _sFichier, _sLigne: String;<N>      _bNouveau: Boolean;<N><N>    protected<N>      procedure Execute;   override;<N><N>
    public<N>      constructor Create(const sFichier, sLigne: String; const bNouveau: Boolean);<N>      procedure AjoutLog;<N>  end;<N><N>implementation<N><N>uses Unit1;<N><N>constructor TLog.Create(const sFichier, sLigne: String; const bNouveau: Boolean);<N>begin<N>  inherited Create(True);<N>  _sFichier := sFichier;<N>  _sLigne := sLigne;<N>  _bNouveau := bNouveau;<N>  FreeOnTerminate := True;<N>end;<N><N>
procedure TLog.Execute;<N>begin<N>  AjoutLog;<N>  Terminate;<N>end;<N><N>procedure TLog.AjoutLog;<N>var<N>  F: TextFile;<N>begin<N>  if(not _bNouveau) and (not FileExists(_sFichier)) then<N>    Exit;<N><N>  EnterCriticalSection(MainForm._SectionCritiqueLog);<N>  try<N>    AssignFile(F, _sFichier);<N>    try<N>      if _bNouveau then<N>        Rewrite(F)<N>      else<N>        Append(F);<N><N>
unit magwmi;<N>{$WARN UNSAFE_TYPE off}<N>{$WARN UNSAFE_CAST off}<N>{$WARN UNSAFE_CODE off}<N>{$WARN SYMBOL_PLATFORM OFF}<N>{$WARN SYMBOL_LIBRARY OFF}<N>{$WARN SYMBOL_DEPRECATED OFF}<N><N>{<N>Magenta Systems WMI and SMART Component v5.5<N>Updated by Angus Robertson, Magenta Systems Ltd, England, 5th August 2013<N>delphi@magsys.co.uk, http://www.magsys.co.uk/delphi/<N>Copyright 2013, Magenta Systems Ltd<N><N>
partly based on articles in Delphi Developers Magazine by Craig Murphy and work by<N>Denis Blondeau (both needed the same bug fixes to read variant arrays properly)<N><N>note - WbemScripting_TLB was created by importing the Microsoft WMI Scripting type library<N><N>
unit uHistorical;<N><N>interface<N><N>uses<N>  uTypes;<N><N>type<N>  THistorical = class;<N>  THistoricalDetail = class;<N>  THistoricalDetails = TArray< THistoricalDetail >;<N><N>  THistoricalDetail = class<N>    FDate: TDateString;<N>    FVal: TValue;<N>    FLvl: TLevel;<N>  end;<N><N>
unit uApplicationVersion;<N>//http://delphihaven.wordpress.com/2012/12/08/retrieving-the-applications-version-string/<N><N>interface<N><N>  function GetAppVersionStr: string;<N>  function GetAppVersionStrFull: string;<N><N>implementation<N><N>uses<N>  System.SysUtils, Winapi.Windows;<N><N>
unit uTile;<N><N>interface<N><N>uses<N>  Vcl.ExtCtrls, { TPanel }<N>  Vcl.Controls, { TWinControl }<N>  Vcl.StdCtrls, { TLabel }<N>  Vcl.ComCtrls, { TProgressBar, TListView }<N>  System.Classes, { TAlign }<N>  System.UITypes, { TColor }<N>  uTypes,<N>  uTileCustom,<N>  Entropy.TPanel.Paint, System.SysUtils;<N><N>
unit uUptime;<N><N>interface<N><N>type<N>  TUptimeRec = record<N>  strict private<N>    class function GetUptime: TDateTime; static;<N>  public<N>    class property Uptime: TDateTime read GetUptime;<N>    class var CreationTime: TDateTime;<N>  end;<N><N>implementation<N><N>
uses<N>  Winapi.Windows, System.SysUtils;<N><N>//Convert then FileTime to TDatetime format<N>function FileTime2DateTime(FileTime: TFileTime): TDateTime;<N>var<N>  LocalTime: TFileTime;<N>  DOSTime  : Integer;<N>begin<N>  FileTimeToLocalFileTime( FileTime, LocalTime );<N>  FileTimeToDosDateTime(<N>    LocalTime,<N>    LongRec( DOSTime ).Hi,<N>    LongRec( DOSTime ).Lo<N>  );<N>  Exit( FileDateToDateTime( DOSTime ) );<N>end;<N><N>
var<N>  lpCreationTime, lpExitTime, lpKernelTime, lpUserTime: TFileTime;<N><N>{ TTime }<N><N>class function TUptimeRec.GetUptime: TDateTime;<N>begin<N>  Exit( Now - TUptimeRec.CreationTime );<N>end;<N><N>initialization<N>  GetProcessTimes(<N>    GetCurrentProcess,<N>    lpCreationTime,<N>    lpExitTime,<N>    lpKernelTime,<N>    lpUserTime<N>  );<N>  TUptimeRec.CreationTime := FileTime2DateTime( lpCreationTime );<N><N>
unit uTile__;<N><N>interface<N><N>uses<N>  uTypes, System.SysUtils;<N><N>type<N>  TTile = class;<N>  TTileDetail = class;<N>  TTileDetails = TArray< TTileDetail >;<N><N>  //************************************************************************//<N><N>  TResponse = class( uTypes.TResponse );<N><N>
  TResponseColored = class( TResponse )<N>    FTag: TTag;<N>    FColor: TTileColorInt;<N>  end;<N><N>  TResponseProgressive = class( TResponseColored )<N>    FMin, FMax, FValue: TTileValueInt64;<N>  end;<N><N>  TResponseValued = class( TResponseColored )<N>    FValues: TTileValueStrings;<N>  end;<N><N>
unit uIso8601;<N><N>interface<N><N>type<N>  TUtc = class(TObject)<N>  public<N>    class function FromUtc(const Value: TDateTime): TDateTime; static;<N>    class function ToUtc(const Value: TDateTime): TDateTime; static;<N>    class function UtcNow: TDateTime; static;<N>  end;<N><N>
  TToTIso8601 = class(TUtc)<N>  public<N>    class function DateTimeToIso8601(const Value: TDateTime): string; static;<N>    class function DateToIso8601(const Value: TDate): string; static;<N>    class function TimeToIso8601(const Value: TTime): string; static;<N>    class function UtcTimeToIso8601(const Value: TTime): string; static;<N>  end;<N><N>
  TIso8601 = class(TToTIso8601)<N>  public<N>    class function DateFromIso8601(const Value: string): TDate; static;<N>    class function DateTimeFromIso8601(const Value: string): TDateTime; static;<N>    class function TimeFromIso8601(const Value: string): TTime; static;<N>    class function UtcDateTimeToIso8601(const Value: TDateTime): string; static;<N>  end;<N><N>
implementation<N><N>uses<N>  XSBuiltIns,<N>  SysUtils,<N>  IdGlobalProtocols;<N><N>class function TIso8601.DateFromIso8601(const Value: string): TDate;<N>begin<N>  with TXSDate.Create() do<N>  try<N>    XSToNative(value); // convert from WideString<N>    Result := AsDate; // convert to TDate<N>  finally<N>    Free();<N>  end;<N>end;<N><N>
class function TIso8601.DateTimeFromIso8601(const Value: string): TDateTime;<N>begin<N>  with TXSDateTime.Create() do<N>  try<N>    XSToNative(value); // convert from WideString<N>    Result := AsDateTime; // convert to TDateTime<N>  finally<N>    Free();<N>  end;<N>end;<N><N>
class function TIso8601.TimeFromIso8601(const Value: string): TTime;<N>begin<N>  with TXSTime.Create() do<N>  try<N>    XSToNative(value); // convert from WideString<N>    Result := AsTime; // convert to TTime<N>  finally<N>    Free();<N>  end;<N>end;<N><N>
class function TIso8601.UtcDateTimeToIso8601(const Value: TDateTime): string;<N>begin<N>  with TXSDateTime.Create() do<N>  try<N>    AsUTCDateTime := Value;<N>    Result := NativeToXS; // convert to WideString<N>  finally<N>    Free();<N>  end;<N>end;<N><N>
class function TUtc.FromUtc(const Value: TDateTime): TDateTime;<N>var<N>  Bias: TDateTime;<N>begin<N>  Bias := TimeZoneBias;<N>  Result := Value - TimeZoneBias;<N>end;<N><N>class function TUtc.ToUtc(const Value: TDateTime): TDateTime;<N>var<N>  Bias: TDateTime;<N>begin<N>  Bias := TimeZoneBias;<N>  Result := Value + TimeZoneBias;<N>end;<N><N>
class function TUtc.UtcNow: TDateTime;<N>begin<N>  Result := ToUtc(Now);<N>end;<N><N>class function TToTIso8601.DateTimeToIso8601(const Value: TDateTime): string;<N>begin<N>  with TXSDateTime.Create() do<N>  try<N>    AsDateTime := Value; // convert from TDateTime<N>    Result := NativeToXS; // convert to WideString<N>  finally<N>    Free();<N>  end;<N>end;<N><N>
class function TToTIso8601.DateToIso8601(const Value: TDate): string;<N>begin<N>  with TXSDate.Create() do<N>  try<N>    AsDate := Value; // convert from TDate<N>    Result := NativeToXS; // convert to WideString<N>  finally<N>    Free();<N>  end;<N>end;<N><N>
class function TToTIso8601.TimeToIso8601(const Value: TTime): string;<N>begin<N>  with TXSTime.Create() do<N>  try<N>    AsTime := Value; // convert from TTime<N>    Result := NativeToXS; // convert to WideString<N>  finally<N>    Free();<N>  end;<N>end;<N><N>
class function TToTIso8601.UtcTimeToIso8601(const Value: TTime): string;<N>begin<N>  with TXSTime.Create() do<N>  try<N>    AsTime := ToUtc(Value);<N>    Result := NativeToXS; // convert to WideString<N>  finally<N>    Free();<N>  end;<N>end;<N><N>end.<N><N><N>
unit uTileCustom;<N><N>interface<N><N>uses<N>  uTypes, System.SysUtils, uHttp, REST.Json, System.Classes;<N><N>type<N>  TTileCustom = class;<N>  TTileDetail = class;<N><N>  {$REGION 'Declaration: TResponse[|Colored|Progressive|Valued|Detail]'}<N>  TResponse = class<N>  end;<N><N>
  TResponseColored = class( TResponse )<N>  private<N>    function GetColor: TTileColor;<N>  public<N>    FTag: TTag;<N>    FColor: TTileColorIndex;<N>    property Color: TTileColor read GetColor;<N>  end;<N><N>  TResponseProgressive = class( TResponseColored )<N>    FMin, FMax, FValue: TTileValueInt64;<N>  end;<N><N>
  TResponseValued = class( TResponseColored )<N>    FValues: TTileValueStrings;<N>  end;<N><N>  TResponseDetail = class( TResponse )<N>    FValues: TArray< TTileDetail >;<N>    destructor Destroy; override;<N>  end;<N>  {$ENDREGION 'Declaration: TResponse[|Colored|Progressive|Valued|Detail]'}<N><N>
unit uReportMemoryLeaks;<N>interface<N>implementation<N>initialization<N>  {$IFDEF DEBUG}<N>  ReportMemoryLeaksOnShutdown := True;<N>  {$ENDIF}<N>end.<N>
unit uUptimeUI;<N><N>interface<N><N>uses<N>  System.Classes, uUptime;<N><N>type<N>  TUptimeEvent = procedure(const Creation, Uptime: TDateTime) of object;<N><N>  TUptime = class( TThread )<N>  private const<N>    cSleepTime = 25;<N>  private<N>    FOnUpdate: TUptimeEvent;<N>  protected<N>    procedure Execute; override;<N>  public<N>    constructor Create; reintroduce;<N>    destructor Destroy; override;<N>    property OnUpdate: TUptimeEvent read FOnUpdate write FOnUpdate;<N>  end;<N><N>
implementation<N><N>{ TUptime }<N><N>constructor TUptime.Create;<N>begin<N>  inherited Create( True );<N>  FreeOnTerminate := False;<N>//  Start;<N>end;<N><N>destructor TUptime.Destroy;<N>begin<N>  Terminate;<N>  WaitFor;<N>  inherited;<N>end;<N><N>procedure TUptime.Execute;<N>begin<N>  inherited;<N>  while not Terminated do begin<N>    if Assigned( FOnUpdate ) then<N>      FOnUpdate( uUptime.TUptimeRec.CreationTime, uUptime.TUptimeRec.Uptime );<N>    Sleep( cSleepTime );<N>  end;<N>end;<N><N>
unit uAuthentication;<N><N>interface<N><N>uses<N>  uHttp, uTypes;<N><N>type<N>  TAuthenticationAccount = class<N>  private<N>    FLogin: TLogin;<N>    FPassword: TPassword;<N>  public<N>    constructor Create(const Login: TLogin;<N>      const Password: TPassword); reintroduce;<N>    property Login: TLogin read FLogin write FLogin;<N>    property Password: TPassword read FPassword write FPassword;<N>  end;<N><N>
unit uHttp;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes;<N><N>type<N>  TUrl = type String;<N>  TJsonString = type String;<N><N>  EHttpUriException = class( Exception );<N>  EHttpProtocolException = class( Exception );<N>  EHttpConnectTimeout = class( Exception );<N>  EHttpUnknownError = class( Exception );<N><N>
  THttpMethod = (Get, Post);<N>  THttpAsync<T> = procedure(const Response: T);<N><N>function HttpResponse(const Url: TUrl; const Json: TJsonString;<N>  const Method: THttpMethod): TJsonString;<N><N>function ExcludeTrailingSlash(const S: string): string; inline;<N><N>
unit Entropy.TPanel.Paint;<N><N>interface<N>// http://stackoverflow.com/questions/10309190/how-i-can-change-the-color-of-a-tpanel-with-the-vcl-styles-enabled<N><N>uses<N>  Vcl.ExtCtrls;<N><N>type<N>  TPanel = class( Vcl.ExtCtrls.TPanel )<N>  protected<N>    procedure Paint; override;<N>  end;<N><N>
unit Uweb;<N><N>interface<N><N>Uses  VCL.Dialogs, Winapi.Windows, Winapi.Messages, System.SysUtils,<N>      System.Variants, System.Classes, Vcl.Graphics,<N>      IdBaseComponent,  IdComponent, IdTCPConnection, IdTCPClient, IdHTTP,<N>      System.Generics.Collections;<N>Const<N>  ClMonitor_Blue      = $009C5838;<N>  ClMonitor_DarkBlue  = $007C3818;<N>  ClMonitor_Red       = $001B1BB8;<N>  ClMonitor_DarkRed   = $00080898;<N>  ClMonitor_green     = $004AA617;<N>  ClMonitor_DarkGreen = $003D7A0C;<N><N>
unit UChxString;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls, <N>  Buttons, ExtCtrls;<N><N>type<N>  TFrm_ChxString = class(TForm)<N>    OKBtn: TButton;<N>    CancelBtn: TButton;<N>    Bevel1: TBevel;<N>    Edit1: TEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>{<N>var<N>  Frm_ChxString: TFrm_ChxString;<N>}  <N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
// Translation of the C headers for Oracle's XML parser<N>// e-delos<N><N>unit OraXML;<N><N>interface<N><N>{$IFNDEF MSWINDOWS}<N>	{$IFDEF WIN32}<N>		{$DEFINE MSWINDOWS}<N>  {$ENDIF}<N>{$ENDIF}<N><N>uses<N>{$IFDEF MSWINDOWS}<N>  Windows;<N>{$ENDIF}<N>{$IFDEF LINUX}<N>	Libc;<N>{$ENDIF}<N><N>
unit uDefs;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs;<N><N>var<N>  PA00nnn_SERVICE_COL : array[1..3] of string = ( 'CLE',              //1<N>                                                  'NUMERO',           //2<N>                                                  'LIBELLE_SERVICE'); //3<N><N>
unit magwmi;<N>{$WARN UNSAFE_TYPE off}<N>{$WARN UNSAFE_CAST off}<N>{$WARN UNSAFE_CODE off}<N>{$WARN SYMBOL_PLATFORM OFF}<N>{$WARN SYMBOL_LIBRARY OFF}<N>{$WARN SYMBOL_DEPRECATED OFF}<N><N>{<N>Magenta Systems WMI and SMART Component v5.5<N>Updated by Angus Robertson, Magenta Systems Ltd, England, 5th August 2013<N>delphi@magsys.co.uk, http://www.magsys.co.uk/delphi/<N>Copyright 2013, Magenta Systems Ltd<N><N>
partly based on articles in Delphi Developers Magazine by Craig Murphy and work by<N>Denis Blondeau (both needed the same bug fixes to read variant arrays properly)<N><N>note - WbemScripting_TLB was created by importing the Microsoft WMI Scripting type library<N><N>
unit UCommun;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Dialogs, StdCtrls, magwmi, magsubs1, Registry;<N><N>Const ClassComPort = '{4D36E978-E325-11CE-BFC1-08002BE10318}';<N><N>type TOSInfos = packed record<N>      WinVersion     : string;<N>      ServicePack    : string;<N>      OSArchitecture : string;<N>      BuildNumber    : string;<N>      end;<N>     TVGSE = packed record<N>       OSInfos : TOSInfos;<N>       ExePath : string;<N>     end;<N><N>
UNIT ChxCom_FRM;<N><N>INTERFACE<N><N>USES Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>    Buttons, ExtCtrls, Spin;<N><N>TYPE<N>    TFRM_ChxCom = CLASS(TForm)<N>        OKBtn: TButton;<N>        CancelBtn: TButton;<N>        Bevel1: TBevel;<N>        Label1: TLabel;<N>        SpinEdit1: TSpinEdit;<N>    PRIVATE<N>    { Private declarations }<N>    PUBLIC<N>    { Public declarations }<N>        FUNCTION execute(com: integer): integer;<N>    END;<N><N>
VAR<N>    FRM_ChxCom: TFRM_ChxCom;<N><N>IMPLEMENTATION<N><N>{$R *.DFM}<N><N>{ TFRM_ChxCom }<N><N>FUNCTION TFRM_ChxCom.execute(com: integer): integer;<N>BEGIN<N>    SpinEdit1.value := com;<N>    IF showmodal = mrok THEN<N>        result := SpinEdit1.value<N>    ELSE<N>        result := com;<N>END;<N><N>
unit uTPEGinkoiaProtocolManager;<N><N>interface<N><N>uses<N>  vcl.Dialogs, SysUtils, System.Win.ScktComp;<N><N>type<N>  TTPEGinkoiaProtocolReceivedCmdEvent = procedure(Sender: TObject;<N>    ACmd: string; AValue: string) of object;<N>  TTPEGinkoiaProtocolSendCmdEvent = procedure(Sender: TObject;<N>    ASocket: TCustomWinSocket; AText: string) of object;<N><N>
  TTPEGinkoiaProtocolManager = class<N>  private<N>    FCurrentSocket: TCustomWinSocket;<N><N>    FOnCHQPayment: TTPEGinkoiaProtocolReceivedCmdEvent;<N>    FOnCheckConnection: TTPEGinkoiaProtocolReceivedCmdEvent;<N>    FOnCancel: TTPEGinkoiaProtocolReceivedCmdEvent;<N>    FOnCBPayment: TTPEGinkoiaProtocolReceivedCmdEvent;<N>    FonSendCmdEvent: TTPEGinkoiaProtocolSendCmdEvent;<N><N>
unit uAcknowledgementCmd;<N><N>interface<N><N>uses<N>  uCommand, SysUtils;<N><N>type<N>  TECRAcknowledgementCmd = class(TECRCommand)<N>  protected<N>    function getLength: string; override;<N>    function getDataBlock: string; override;<N><N>  public<N>    constructor Create; overload;<N>    destructor Destroy; override;<N><N>
    function asString: string; override;<N>  end;<N><N>  TPTAcknowledgementCmd = class(TPTCommand)<N>  public<N>    function asString: string; override;<N>    function CmdResultCode: string; override;<N>    function CmdResultDescr: string; override;<N>  end;<N><N>
  TPTNegativeAcknowledgementCmd = class(TPTCommand)<N>  private<N>    FErrorCode: string;<N>  public<N>    constructor Create(ABytes: TBytes); override;<N><N>    function asString: string; override;<N>    function CmdResultCode: string; override;<N>    function CmdResultDescr: string; override;<N>  end;<N><N>
implementation<N><N>uses<N>  uZVTProtocolUtils, uZVTProtocolManager;<N><N>{ TECRAcknowledgementCmd }<N><N>function TECRAcknowledgementCmd.asString: string;<N>begin<N>  Result := 'Acknowledgement (80 00)';<N>end;<N><N>constructor TECRAcknowledgementCmd.Create;<N>begin<N>  inherited Create(AnsiChar(128), AnsiChar(00));<N>end;<N><N>
destructor TECRAcknowledgementCmd.Destroy;<N>begin<N><N>  inherited;<N>end;<N><N>function TECRAcknowledgementCmd.getDataBlock: string;<N>begin<N>  Result := '';<N>end;<N><N>function TECRAcknowledgementCmd.getLength: string;<N>begin<N>  Result := Chr(00);<N>end;<N><N>
{ TPTAcknowledgementCmd }<N><N>function TPTAcknowledgementCmd.asString: string;<N>begin<N>  Result := 'Acknowledgement (80 00)';<N>end;<N><N>function TPTAcknowledgementCmd.CmdResultCode: string;<N>begin<N>  Result := '00';<N>end;<N><N>function TPTAcknowledgementCmd.CmdResultDescr: string;<N>begin<N>  Result := '';<N>end;<N><N>
{ TPTNegativeAcknowledgementCmd }<N><N>function TPTNegativeAcknowledgementCmd.asString: string;<N>begin<N>  Result := Format('Negative Acknowledgement (84 %s) : %s', [CmdResultCode,<N>    CmdResultDescr]);<N>end;<N><N>function TPTNegativeAcknowledgementCmd.CmdResultCode: string;<N>begin<N>  Result := IntToHex(Ord(cmdInstr), 2);<N>end;<N><N>
function TPTNegativeAcknowledgementCmd.CmdResultDescr: string;<N>begin<N>  Result := ZVTErrorMessage(CmdResultCode);<N>end;<N><N>constructor TPTNegativeAcknowledgementCmd.Create(ABytes: TBytes);<N>begin<N>  inherited Create(ABytes);<N><N>  FCmdType := ptcmdtError;<N>end;<N><N>
unit uDiagnosisCmd;<N><N>interface<N><N>uses<N>  uCommand,<N>  SysUtils;<N><N>type<N>  TDiagnosisCmd = class(TECRCommand)<N>  protected<N>    function getLength: string; override;<N>    function getDataBlock: string; override;<N>  public<N>    constructor Create; overload;<N><N>
    function asString: string; override;<N>  end;<N><N>implementation<N><N>{ TDiagnosisCmd }<N><N>function TDiagnosisCmd.asString: string;<N>begin<N>  Result := 'Diagnosis (06 70)';<N>end;<N><N>constructor TDiagnosisCmd.Create;<N>begin<N>  inherited Create(Chr(06), AnsiChar(StrToInt('$70')));<N><N>
unit uRegistrationCmd;<N><N>interface<N><N>uses<N>  uCommand;<N><N>Type<N>  TRegistrationCmd = class(TECRCommand)<N>  private<N>    FCurrencyCode: string;<N>    FPassword: string;<N>  protected<N>    function getLength: string; override;<N>    function getDataBlock: string; override;<N><N>
  public<N>    constructor Create; overload;<N>    destructor Destroy; override;<N><N>    function asString: string; override;<N>  end;<N><N>implementation<N><N>uses<N>  uZVTProtocolManager;<N><N>{ TRegistrationCmd }<N><N>function TRegistrationCmd.asString: string;<N>begin<N>  Result := 'Registration (06 00)';<N>end;<N><N>
constructor TRegistrationCmd.Create;<N>begin<N>  inherited Create(Chr(06), Chr(00));<N><N>  FCmdType := ecrcmdtMaster;<N>  FCurrencyCode := Chr(09) + Chr(78);<N>  FPassword := Chr(00) + Chr(00) + Chr(00);<N>end;<N><N>destructor TRegistrationCmd.Destroy;<N>begin<N>  FCurrencyCode := '';<N>  FPassword := '';<N><N>
unit uStatusInfoCmd;<N><N>interface<N><N>uses<N>  SysUtils,<N>  uCommand;<N><N>type<N>  TIntermediateStatusInfoCmd = class(TPTCommand)<N>  private<N>    FStatus: string;<N><N>  public<N>    constructor Create(ABytes: TBytes); override;<N>    destructor Destroy; override;<N><N>
    function asString: string; override;<N>    function CmdResultCode: string; override;<N>    function CmdResultDescr: string; override;<N><N>    function getResponseCmd: TCommand; override;<N>  end;<N><N>  TStatusInfoCmd = class(TPTBMPCommand)<N>  private<N>  public<N>    constructor Create(ABytes: TBytes); override;<N><N>
    function Clone: TPTCommand; override;<N>    function getResponseCmd: TCommand; override;<N>    function getCardNumber: string;<N>  end;<N><N>implementation<N><N>uses<N>  uZVTProtocolUtils, uAcknowledgementCmd, uZVTProtocolManager, uBMPs;<N><N>{ TIntermediateStatusInfoCmd }<N><N>
function TIntermediateStatusInfoCmd.asString: string;<N>begin<N>  Result := 'Intermediate Status : ' + CmdResultDescr;<N>end;<N><N>function TIntermediateStatusInfoCmd.CmdResultCode: string;<N>begin<N>  Result := FStatus;<N>end;<N><N>function TIntermediateStatusInfoCmd.CmdResultDescr: string;<N>begin<N>  Result := ZVTStatusMessage(FStatus);<N>end;<N><N>
constructor TIntermediateStatusInfoCmd.Create(ABytes: TBytes);<N>begin<N>  inherited Create(ABytes);<N><N>  FSendResponse := True;<N>  FStatus := IntToHex(FBytes[5], 2);<N>end;<N><N>destructor TIntermediateStatusInfoCmd.Destroy;<N>begin<N>  FStatus := '';<N><N>
  inherited;<N>end;<N><N>function TIntermediateStatusInfoCmd.getResponseCmd: TCommand;<N>begin<N>  Result := TECRAcknowledgementCmd.Create;<N>end;<N><N>{ TStatusInfoCmd }<N><N>function TStatusInfoCmd.Clone: TPTCommand;<N>begin<N>  Result := TStatusInfoCmd.Create(FBytes);<N><N>
//  Result.FBytes := FBytes;<N>end;<N><N>constructor TStatusInfoCmd.Create(ABytes: TBytes);<N>begin<N>  inherited Create(ABytes);<N><N>  FSendResponse := True;<N>  FCmdType := ptcmdtResult;<N>end;<N><N>function TStatusInfoCmd.getCardNumber: string;<N>var<N>  bmp: TBMPBCD;<N>begin<N>  bmp := getBMP('22');<N>  if Assigned(bmp) then<N>    Result := bmp.FormatedValue<N>  else<N>    Result := 'Not Defined';<N>end;<N><N>
function TStatusInfoCmd.getResponseCmd: TCommand;<N>begin<N>  Result := TECRAcknowledgementCmd.Create;<N>end;<N><N>initialization<N><N>  TDefaultZVTProtocolManager.RegisterKnownPTCommand('04', 'FF', TIntermediateStatusInfoCmd);<N>  TDefaultZVTProtocolManager.RegisterKnownPTCommand('04', '0F', TStatusInfoCmd);<N><N>
unit uCompletionCmd;<N><N>interface<N><N>uses<N>  SysUtils,<N>  uCommand;<N><N>type<N>  TCompletionCmd = class(TPTBMPCommand)<N>  public<N>    constructor Create(ABytes: TBytes); override;<N><N>    function asString: string; override;<N>    function getResponseCmd: TCommand; override;<N>  end;<N><N>
implementation<N><N>uses<N>  uZVTProtocolManager, uAcknowledgementCmd, uBMPs;<N><N>{ TCompletionCmd }<N><N>function TCompletionCmd.asString: string;<N>begin<N>  Result := 'Completion : ' + Inherited asString;<N>end;<N><N>constructor TCompletionCmd.Create(ABytes: TBytes);<N>begin<N>  inherited Create(ABytes);<N><N>
  FCmdType := ptcmdtSucces;<N>  FSendResponse := True;<N>end;<N><N>function TCompletionCmd.getResponseCmd: TCommand;<N>begin<N>  Result := TECRAcknowledgementCmd.Create;<N>end;<N><N>initialization<N><N>  TDefaultZVTProtocolManager.RegisterKnownPTCommand('06', '0F', TCompletionCmd);<N><N>
unit magwmi;<N>{$WARN UNSAFE_TYPE off}<N>{$WARN UNSAFE_CAST off}<N>{$WARN UNSAFE_CODE off}<N>{$WARN SYMBOL_PLATFORM OFF}<N>{$WARN SYMBOL_LIBRARY OFF}<N>{$WARN SYMBOL_DEPRECATED OFF}<N><N>{<N>Magenta Systems WMI and SMART Component v5.5<N>Updated by Angus Robertson, Magenta Systems Ltd, England, 5th August 2013<N>delphi@magsys.co.uk, http://www.magsys.co.uk/delphi/<N>Copyright 2013, Magenta Systems Ltd<N><N>
partly based on articles in Delphi Developers Magazine by Craig Murphy and work by<N>Denis Blondeau (both needed the same bug fixes to read variant arrays properly)<N><N>note - WbemScripting_TLB was created by importing the Microsoft WMI Scripting type library<N><N>
unit GestionLog;<N><N>interface<N><N>type<N>  TErrorLevel = (el_Silent, el_Erreur, el_Warning, el_Info, el_Etape, el_Debug, el_Verbose);<N><N><N>procedure Log_Init(niv : TErrorLevel; Path : string);<N>procedure Log_ChangeNiv(niv : TErrorLevel);<N>procedure Log_Write(msg : string; niv : TErrorLevel = el_Debug);<N>procedure Log_WriteFmt(const msg: string; const args: array of const; const niv: TErrorLevel);<N><N>
implementation<N><N>uses<N>  SysUtils,<N>  TypInfo;<N><N>var<N>  LogNiv : TErrorLevel = el_silent;<N>  LogPath : string = '';<N><N>procedure Log_Init(Niv : TErrorLevel; Path : string);<N>begin<N>  LogNiv := niv;<N>  LogPath := Path;<N>end;<N><N>procedure Log_ChangeNiv(niv : TErrorLevel);<N>begin<N>  LogNiv := niv;<N>end;<N><N>
unit UCommun;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Dialogs, StdCtrls, magwmi, magsubs1, Registry,<N>  Winapi.ShellAPI;<N><N>Const ClassComPort = '{4D36E978-E325-11CE-BFC1-08002BE10318}';<N><N>type TOSInfos = packed record<N>      WinVersion     : string;<N>      ServicePack    : string;<N>      OSArchitecture : string;<N>      BuildNumber    : string;<N>      end;<N>     TVGSE = packed record<N>       OSInfos : TOSInfos;<N>       ExePath : string;<N>     end;<N><N>
unit magwmi;<N>{$WARN UNSAFE_TYPE off}<N>{$WARN UNSAFE_CAST off}<N>{$WARN UNSAFE_CODE off}<N>{$WARN SYMBOL_PLATFORM OFF}<N>{$WARN SYMBOL_LIBRARY OFF}<N>{$WARN SYMBOL_DEPRECATED OFF}<N><N>{<N>Magenta Systems WMI and SMART Component v5.5<N>Updated by Angus Robertson, Magenta Systems Ltd, England, 5th August 2013<N>delphi@magsys.co.uk, http://www.magsys.co.uk/delphi/<N>Copyright 2013, Magenta Systems Ltd<N><N>
partly based on articles in Delphi Developers Magazine by Craig Murphy and work by<N>Denis Blondeau (both needed the same bug fixes to read variant arrays properly)<N><N>note - WbemScripting_TLB was created by importing the Microsoft WMI Scripting type library<N><N>
unit GestionLog;<N><N>interface<N><N>type<N>  TErrorLevel = (el_Silent, el_Erreur, el_Warning, el_Info, el_Etape, el_Debug, el_Verbose);<N><N><N>procedure Log_Init(niv : TErrorLevel; Path : string);<N>procedure Log_ChangeNiv(niv : TErrorLevel);<N>procedure Log_Write(msg : string; niv : TErrorLevel = el_Debug);<N>procedure Log_WriteFmt(const msg: string; const args: array of const; const niv: TErrorLevel);<N><N>
implementation<N><N>uses<N>  SysUtils,<N>  TypInfo;<N><N>var<N>  LogNiv : TErrorLevel = el_silent;<N>  LogPath : string = '';<N><N>procedure Log_Init(Niv : TErrorLevel; Path : string);<N>begin<N>  LogNiv := niv;<N>  LogPath := Path;<N>end;<N><N>procedure Log_ChangeNiv(niv : TErrorLevel);<N>begin<N>  LogNiv := niv;<N>end;<N><N>
unit StdXML_TLB;<N><N>{ This file contains pascal declarations imported from a type library.<N>  This file will be written during each import or refresh of the type<N>  library editor.  Changes to this file will be discarded during the<N>  refresh process. }<N><N>
{ XMLComponents Framework Library }<N>{ Version 1.0 }<N><N>interface<N><N>{$IFNDEF MSWINDOWS}<N>	{$IFDEF WIN32}<N>		{$DEFINE MSWINDOWS}<N>  {$ENDIF}<N>{$ENDIF}<N><N>uses<N>	Classes,<N>{$IFDEF MSWINDOWS}<N>	Windows, ActiveX, Graphics, OleCtrls,<N>  StdVCL,<N>{$ENDIF}<N>  DAC_TLB;<N><N>
<N>{ -------------------------------------------------------<N>		Background Component   Copyright (r) by DreamFactory<N>    Version : 1.75   Author : William Yang<N>		Last Update 10 - Sep - 97<N>  ------------------------------------------------------ }<N><N>
unit Backgnd;<N><N>interface<N><N>uses<N>  SysUtils, Windows, Messages, Classes, DrawMan,<N>  	Graphics, NumMan, Controls, ColorMan, Gradient, DFClasses;<N><N>type<N>  TBackStyle = (bgSingleColor, bgGradient, bgSingleBitmap ,bgTileBitmap);<N><N>  TBackgndObj = class(TPersistent)<N>  private<N>    fPicture : TBitmap;<N>    fColor: TColor;<N>    fBackStyle : TBackStyle;<N>    fGradient: TGradient;<N>    fOnChange: TNotifyEvent;<N><N>
    procedure SetStyle(Value : TBackStyle);<N>    procedure SetPicture(Value : TBitmap);<N>    procedure SetGradient(Value: TGradient);<N>    procedure SetColor(Value: TColor);<N>    procedure GradChanged(Sender: TObject);<N>	public<N>  	constructor Create;<N>    destructor Destroy; override;<N><N>
    procedure Assign(Value: TBackgndObj);<N>    procedure Changed;<N><N> 	published<N>		property Gradient: TGradient read fGradient write SetGradient;<N>    property Picture : TBitmap read FPicture write SetPicture;<N>    property BackStyle : TBackStyle read FBackStyle write SetStyle;<N>    property Color: TColor read fColor write SetColor;<N>    property OnChange: TNotifyEvent read fOnChange write fOnChange;<N>  end;<N><N>
  TBackground = class(TDFGraphicControl)<N>  private<N>    { Private Declarations }<N>    fBackObj: TBackgndObj;<N>    procedure SetBackObj(Value: TBackgndObj);<N>    procedure BackObjChanged(Sender: TObject);<N>  protected<N>    { Protected Declarations }<N>    procedure PaintBackup; override;<N><N>
  public<N>    { Public Declarations }<N>    constructor Create(AOwner: TComponent); override;<N>    destructor Destroy; override;<N><N>  published<N>  	property BackObj: TBackgndObj read fBackObj write SetBackObj;<N>   	property Align;<N>    property Visible;<N>    property DragCursor;<N>    property DragMode;<N>    property Enabled;<N>    property PopupMenu;<N>    property ShowHint;<N><N>
    property OnClick;<N>    property OnDblClick;<N>    property OnDragDrop;<N>    property OnDragOver;<N>    property OnEndDrag;<N>    property OnMouseDown;<N>    property OnMouseMove;<N>    property OnMouseUp;<N>    property OnStartDrag;<N><N>  end;<N><N>
procedure PaintBackObj(Canvas: TCanvas; Rect: TRect; BackObj: TBackgndObj);<N>procedure Register;<N><N>implementation<N><N>{ TBackgnd Object }<N>constructor TBackgndObj.Create;<N>begin<N>	inherited Create;<N>	fBackStyle := bgSingleColor;<N>  fGradient := TGradient.Create;<N>  fGradient.OnChange := GradChanged;<N>  fPicture := TBitmap.Create;<N>end;<N><N>
destructor TBackgndObj.Destroy;<N>begin<N>	fGradient.Free;<N>	fPicture.Free;<N>end;<N><N>procedure TBackgndObj.Assign(Value: TBackgndObj);<N>begin<N>	fPicture.Assign(Value.Picture);<N>  fGradient.Assign(Value.Gradient);<N>  fBackStyle := Value.Backstyle;<N>  Changed;<N>end;<N><N>
procedure TBackgndObj.Changed;<N>begin<N>	if Assigned(fOnChange) then fOnChange(Self);<N>end;<N><N>procedure TBackgndObj.GradChanged(Sender: TObject);<N>begin<N>	Changed;<N>end;<N><N>procedure TBackgndObj.SetGradient(Value: TGradient);<N>begin<N>  if fGradient <> Value then<N>  begin<N>  	fGradient.Assign(Value);<N>  	Changed;<N>  end;<N>end;<N><N>
procedure TBackgndObj.SetStyle(Value: TBackStyle);<N>begin<N>  if fBackStyle <> Value then<N>  begin<N>  	fBackStyle := Value;<N>  	Changed;<N>  end;<N>end;<N><N>procedure TBackgndObj.SetPicture(Value: TBitmap);<N>begin<N>	if fPicture <> Value then<N>  begin<N>  	fPicture.Assign(Value);<N>  	Changed;<N>  end;<N>end;<N><N>
procedure TBackgndObj.SetColor(Value: TColor);<N>begin<N>	if fColor <> Value then<N>  begin<N>  	fColor := Value;<N>    Changed;<N>  end;<N>end;<N><N>{ TBackground }<N><N>constructor TBackground.Create(AOwner: TComponent);<N>begin<N>  inherited Create(AOwner);<N>  fBackObj := TBackgndObj.Create;<N>  fBackObj.OnChange := BackObjChanged;<N>  Setbounds(Left, Top, 144, 144);<N>end;<N><N>
destructor TBackground.Destroy;<N>begin<N>  fBackObj.Free;<N>  inherited Destroy;<N>end;<N><N>procedure TBackground.Paintbackup;<N>begin<N>	inherited Paintbackup;<N>	PaintBackObj(Backup.Canvas, ClientRect, fBackObj);<N>end;<N><N>procedure TBackground.SetBackObj(Value: TBackgndObj);<N>begin<N>	if fBackObj <> Value then<N>  begin<N>  	fBackObj.Assign(Value);<N>    Paintbackup;<N>    Invalidate;<N>  end;<N>end;<N><N>
procedure TBackground.BackObjChanged(Sender: TObject);<N>begin<N>	Paintbackup;<N>  Invalidate;<N>end;<N><N>procedure PaintBackObj(Canvas: TCanvas; Rect: TRect; BackObj: TBackgndObj);<N><N>	procedure DrawSinglePic;<N>  begin<N>		Canvas.CopyRect(Rect, BackObj.Picture.Canvas, Rect);<N>  end;<N><N>
	procedure DrawTilePic;<N>	begin<N>   	if BackObj.Picture <> nil then<N>			MultiClipPaint(Canvas, BackObj.Picture, Rect, Rect);<N>  end; {Procedure}<N><N>  procedure DrawOneColor;<N>  begin<N>  	Canvas.Brush.Color := BackObj.Color;<N>  	Canvas.FillRect(Rect)<N>  end;<N><N>
// Translation of the C headers for Oracle's XML parser<N>// e-delos<N><N>unit OraXML;<N><N>interface<N><N>{$IFNDEF MSWINDOWS}<N>	{$IFDEF WIN32}<N>		{$DEFINE MSWINDOWS}<N>  {$ENDIF}<N>{$ENDIF}<N><N>uses<N>{$IFDEF MSWINDOWS}<N>  Windows;<N>{$ENDIF}<N>{$IFDEF LINUX}<N>	Libc;<N>{$ENDIF}<N><N>
//$Log:<N>// 2    Utilitaires1.1         26/09/2006 11:02:54    pascal          rendu des<N>//      modifs<N>// 1    Utilitaires1.0         25/11/2005 08:09:39    pascal          <N>//$<N>//$NoKeywords$<N>//<N>unit UInstCltCst;<N><N>interface<N>uses<N>   SysUtils,<N>   Classes;<N><N>
const<N>   k_Dossier = '-11111338';<N>   K_Base = '-11111334';<N>   K_Soc = '-11111350';<N>   K_Mag = '-11111344';<N>   K_Poste = '-11111349';<N>   K_Adresse = '-11111333';<N>   K_GENMAGGESTIONCLT = '-11111346';<N>   K_GENMAGGESTIONCF = '-11111345';<N>   K_GENMAGGESTIONCLTCPT = '-11111459';<N>   K_GENPARAM = '-11111454';<N>   K_BQE = '-11111407';<N>   K_CFFID = '-11111410';<N>   K_MENID = '-11111418';<N>   K_MEDID = '-11111420';<N><N>
type<N>   TUnSite = class<N>      // Dans genBase<N>      // Bas_Nom = SERVEUR_"nom"-"IdCourtClient"<N>      // Secourt -- > = SERVEUR_"nom"-"IdCourtClient"_SEC<N>      // NoteBook --> NB"numero"_"nom"-"IdCourtClient"<N>      VraiNom : String ;<N>      Ident : String ;<N>      PLage : String ;<N>      Existe : Boolean ;<N>      id     : integer ;<N><N>
      Nom: string;<N>      Jetons: integer;<N>      NoteBook: integer;<N>      CA: Boolean;<N>      function ToXml(Dec: string): string;<N>      constructor Create;<N>      destructor destroy; override;<N>   end;<N><N>   TunDroit = class<N>      Nom: string;<N>      Actif: boolean;<N>      constructor Create;<N>      destructor destroy; override;<N>   end;<N><N>
//$Log:<N>// 2    Utilitaires1.1         26/09/2006 11:02:53    pascal          rendu des<N>//      modifs<N>// 1    Utilitaires1.0         27/04/2005 15:53:36    pascal          <N>//$<N>//$NoKeywords$<N>//<N>UNIT UInsCltCfg;<N><N>INTERFACE<N><N>USES<N>    inifiles,<N>    Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>    Buttons, ExtCtrls, Dialogs;<N><N>
//$Log:<N>// 1    Utilitaires1.0         25/11/2005 08:09:37    pascal          <N>//$<N>//$NoKeywords$<N>//<N>unit ChxSociete_frm;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls;<N><N>type<N>  Tfrm_ChxSociete = class(TForm)<N>    OKBtn: TButton;<N>    CancelBtn: TButton;<N>    Bevel1: TBevel;<N>    Label1: TLabel;<N>    Edit1: TEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit Uversion;<N><N>interface<N><N>uses<N>  Classes; // TStringList<N><N>const<N>  FileInfos : array [1..8] of string = ('FileDescription', 'CompanyName', 'FileVersion', 'InternalName',<N>                                        'LegalCopyRight', 'OriginalFileName', 'ProductName', 'ProductVersion');<N><N>
﻿unit UPassWord_Dlg;<N><N>interface<N><N>uses Winapi.Windows, System.SysUtils, System.Classes, Vcl.Graphics, Vcl.Forms,<N>  Vcl.Controls, Vcl.StdCtrls, Vcl.Buttons;<N><N>type<N>  TDlgPassword = class(TForm)<N>    LblPwd: TLabel;<N>    EdtPwd: TEdit;<N>    BtnOK: TButton;<N>    BtnCancel: TButton;<N>  private<N>    { Déclarations privées }<N>  public<N>    { Déclarations publiques }<N>  end;<N><N>
function IsPassworOk: Boolean;<N><N>implementation<N><N>uses<N>  UParams;<N><N>{$R *.dfm}<N><N>function IsPassworOk: Boolean;<N>begin<N>  with TDlgPassword.Create(nil) do<N>  try<N>    Result := (ShowModal = mrOK) and (EdtPwd.Text = SRepareBase.Password);<N>  finally<N>    Release;<N>  end;<N>end;<N><N>
// Translation of the C headers for Oracle's XML parser<N>// e-delos<N><N>unit OraXML;<N><N>interface<N><N>{$IFNDEF MSWINDOWS}<N>	{$IFDEF WIN32}<N>		{$DEFINE MSWINDOWS}<N>  {$ENDIF}<N>{$ENDIF}<N><N>uses<N>{$IFDEF MSWINDOWS}<N>  Windows;<N>{$ENDIF}<N>{$IFDEF LINUX}<N>	Libc;<N>{$ENDIF}<N><N>
unit URecalcAgrPrin_Types;<N><N>interface<N><N>uses Classes, IniFiles, SysUtils, Forms;<N><N>type<N>  TIniStruct = record<N>    Path : string;<N>    Fichier : string;<N>    ExportExe : String;<N>    From, SendTo : string;<N>    END;<N><N>  procedure LoadIni;<N><N>
unit ChxMag_frm;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls;<N><N>type<N>  Tfrm_ChxMag = class(TForm)<N>    OKBtn: TButton;<N>    Bevel1: TBevel;<N>    Lb_Mag: TListBox;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  frm_ChxMag: Tfrm_ChxMag;<N><N>implementation<N><N>{$R *.DFM}<N><N>end.<N>
unit System.Windows.neighbors;<N><N>interface<N>uses<N>      Winapi.Windows, Winapi.ShlObj, Winapi.ActiveX,System.SysUtils,<N>      Vcl.forms , system.Classes , Winapi.shellapi   ; <N>  <N>type<N>  PNetResourceArray = ^TNetResourceArray;<N>  TNetResourceArray = array[0..100] of TNetResource;<N><N>
  function CreateNetResourceList(ResourceType: DWord;<N>                              NetResource: PNetResource;<N>                              out Entries: DWord;<N>                              out List: PNetResourceArray): Boolean;<N><N>  procedure ScanNetworkResources(ResourceType, DisplayType: DWord; List: TStrings);<N>                              <N>  <N>  function BrowseForFolders(const Title: string; const Flag: integer; const Handle: Thandle): string;<N>implementation<N><N>
unit uPatchScript;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages,<N>  System.SysUtils, System.Variants, System.Classes, System.Types, System.IOutils,<N>  Data.DB, dialogs, FireDAC.Comp.Client,<N>  Vcl.ExtActns, Generics.Collections;<N><N>Type<N>  TpatchScript = class<N>    private<N>    class var Data: TFDConnection;<N>    Qry: TFDQuery;<N>//    SQL: TIBSQL;<N>    Tran: TFDTransaction;<N><N>
    public<N><N>    class var DirGinkoia : string ;<N>    class var Dirbase : string ;<N>    class var Lame : string ;<N><N>    class procedure OpenBase ;<N>    class procedure CloseBase ;<N>    class function ConnectTo : boolean ;<N><N>  {*    class procedure Script ;<N>    class procedure Patch ;   * }<N>  end;<N><N>
unit uVersionInfo;<N><N>interface<N><N>uses<N>  System.Classes, // TStringList<N>  System.Types;   // TValueRelationship<N>  <N>const<N>  FileInfos : array [1..8] of string = ('FileDescription', 'CompanyName', 'FileVersion', 'InternalName',<N>                                        'LegalCopyRight', 'OriginalFileName', 'ProductName', 'ProductVersion');<N><N>
unit uCustomAttribute;<N><N>interface<N> uses System.SysUtils ;<N><N><N>Type<N>   TcustomUrl = Class(Tcustomattribute) <N>     private<N>       Furl : String ;<N>     public<N>       Constructor Create(sUrl : string) ;  <N>       <N>   End;<N>   <N>       <N><N>implementation<N>Constructor TcustomUrl.Create(sUrl: string);<N>begin<N>   Furl := sUrl ;<N>end;<N><N>end.<N>
<N>//------------------------------------------------------------------------------<N>//About screen<N>//------------------------------------------------------------------------------<N><N>unit uAbout;<N><N>interface<N><N>uses Windows, SysUtils, Classes, Graphics, Forms, Controls, StdCtrls,<N>  Buttons, ExtCtrls, ShellAPI;<N><N>
type<N>  TAboutBox = class(TForm)<N>    Panel1: TPanel;<N>    ProgName: TLabel;<N>    OKButton: TButton;<N>    Version: TLabel;<N>    Label1: TLabel;<N>    procedure OKButtonClick(Sender: TObject);<N>    procedure FormCreate(Sender: TObject);<N>    procedure ProgramIconClick(Sender: TObject);<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  AboutBox: TAboutBox;<N><N>implementation<N><N>uses arch1;<N><N>{$R *.dfm}<N><N>//------------------------------------------------------------------------------<N>// Close window<N>//------------------------------------------------------------------------------<N>procedure TAboutBox.OKButtonClick(Sender: TObject);<N>begin<N> Close;<N>end; // TAboutBox.OKButtonClick<N><N>
{$I VER.INC}<N><N>//------------------------------------------------------------------------------<N>//Procedures for OUT-Archive operations<N>//------------------------------------------------------------------------------<N><N>unit uExtract;<N><N>interface<N><N>
uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, ExtCtrls, Buttons, ComCtrls, ShellCtrls, FileCtrl<N>  {$IFDEF ZF}<N>   ,ZipForge<N>  {$ENDIF}<N>  {$IFDEF ZF_int}<N>   ,FlexCompress<N>  {$ENDIF}<N>  {$IFDEF FC}<N>   ,FlexCompress<N>  {$ENDIF}<N>  ;<N><N>
type<N>  TfrmExtract = class(TForm)<N>    btnOK: TBitBtn;<N>    btnCancel: TBitBtn;<N>    rgOptions: TRadioGroup;<N>    Label1: TLabel;<N>    DriveComboBox1: TDriveComboBox;<N>    DirectoryListBox1: TDirectoryListBox;<N>    procedure btnOKClick(Sender: TObject);<N>    procedure FormActivate(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
{$I VER.INC}<N><N>//------------------------------------------------------------------------------<N>//Procedures for TO-Archive operations<N>//------------------------------------------------------------------------------<N><N>unit uAdd;<N><N>interface<N><N>
<N>//------------------------------------------------------------------------------<N>//Progress screen<N>//------------------------------------------------------------------------------<N><N>unit uProgress;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, Buttons, Gauges;<N><N>
type<N>  TfrmProgress = class(TForm)<N>    gOverall: TGauge;<N>    gFile: TGauge;<N>    lbFile: TLabel;<N>    btnCancel: TBitBtn;<N>    procedure FormCreate(Sender: TObject);<N>    procedure btnCancelClick(Sender: TObject);<N>    procedure FormShow(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    bCancel: Boolean;<N>    { Public declarations }<N>  end;<N><N>
var<N>  frmProgress: TfrmProgress;<N><N>implementation<N><N>{$R *.dfm}<N><N>//------------------------------------------------------------------------------<N>// OnFormCreate<N>//------------------------------------------------------------------------------<N>procedure TfrmProgress.FormCreate(Sender: TObject);<N>begin<N> bCancel := False;<N>end; // TfrmProgress.FormCreate<N><N>
//------------------------------------------------------------------------------<N>// OnCancelClick<N>//------------------------------------------------------------------------------<N>procedure TfrmProgress.btnCancelClick(Sender: TObject);<N>begin<N> bCancel := True;<N> Close;<N>end; // TfrmProgress.btnCancelClick<N><N>
unit uCustomAttribute;<N><N>interface<N> uses System.SysUtils ;<N><N><N>Type<N>   TcustomUrl = Class(Tcustomattribute) <N>     private<N>       Furl : String ;<N>     public<N>       Constructor Create(sUrl : string) ;  <N>       <N>   End;<N>   <N>       <N><N>implementation<N>Constructor TcustomUrl.Create(sUrl: string);<N>begin<N>   Furl := sUrl ;<N>end;<N><N>end.<N>
﻿unit uLog;<N><N>{$WARN UNIT_PLATFORM OFF}<N>{$WARN SYMBOL_PLATFORM OFF}<N><N>interface<N><N>uses<N>{$IF CompilerVersion > 27}<N>  System.Classes,<N>  System.SysUtils,<N>  System.StrUtils,<N>  Winapi.Windows,<N>  Winapi.Winsock,<N>  System.Contnrs,<N>  System.SyncObjs,<N>  System.iniFiles,<N>  idTCPClient,<N>  System.Math ;<N>{$ELSE}<N>  Classes,<N>  SysUtils,<N>  StrUtils,<N>  Windows,<N>  Winsock,<N>  Contnrs,<N>  SyncObjs,<N>  iniFiles,<N>  idTCPClient,<N>  Math ;<N>{$IFEND}<N><N>
unit uFileUtils;<N><N>interface<N><N>function GetTempDirectory(Base : string = '') : String;<N>function GetFileSize(FileName : string) : Int64;<N>function GetDiskFreeSpace(Drive : char) : Int64;<N>function DelTree(DirName : string): Boolean;<N><N>implementation<N><N>
uses<N>  SysUtils,<N>  IOUtils,<N>  ShellAPI;<N><N>function GetTempDirectory(Base : string) : String;<N>var<N>  tempFolder: string;<N>begin<N>  Randomize();<N>  if Trim(Base) = '' then<N>    tempFolder := TPath.GetTempPath()<N>  else<N>    tempFolder := IncludeTrailingPathDelimiter(Base);<N>  repeat<N>    result := IncludeTrailingPathDelimiter(IncludeTrailingPathDelimiter(tempFolder) + IntToStr(Random(999999999)));<N>  until not DirectoryExists(Result);<N>end;<N><N>
function GetFileSize(FileName : string) : Int64;<N>var<N>  FindStruc : TSearchRec;<N>begin<N>  Result := 0;<N>  try<N>    if FindFirst(FileName, faanyfile, FindStruc) = 0 THEN<N>      Result := FindStruc.Size;<N>  finally<N>    findClose(FindStruc);<N>  end;<N>end;<N><N>
unit UInfosBase;<N><N>interface<N><N>function CanConnect(Server, FileName, UserName, Password : string; Port : integer; out error :string) : boolean;<N>function GetInfosBase(Server, FileName, UserName, Password : string; Port : integer; out Version, Nom, Centrale, GUID, Sender : string; out DateVersion : TDateTime; out Generateur : integer; out Recalcul : boolean; out error :string) : boolean;<N><N>
implementation<N><N>uses<N>  Dialogs,<N>  SysUtils,<N>  uGestionBDD;<N><N>function CanConnect(Server, FileName, UserName, Password : string; Port : integer; out error :string) : boolean;<N>var<N>  Connexion : TMyConnection;<N>begin<N>  Result := false;<N>  error := '';<N><N>
  try<N>    try<N>      Connexion := GetNewConnexion(Server, FileName, UserName, Password, Port, false);<N>      Connexion.Open();<N>      if Connexion.Connected then<N>        Result := true;<N>    finally<N>      FreeAndNil(Connexion);<N>    end;<N>  except<N>    on e : exception do<N>    begin<N>      error := e.ClassName + ' - ' + e.Message;<N>      Result := false;<N>    end;<N>  end;<N>end;<N><N>
function GetInfosBase(Server, FileName, UserName, Password : string; Port : integer; out Version, Nom, Centrale, GUID, Sender : string; out DateVersion : TDateTime; out Generateur : integer; out Recalcul : boolean; out error :string) : boolean;<N>var<N>  Connexion : TMyConnection;<N>  Query : TMyQuery;<N>begin<N>  Result := false;<N>  Version := '';<N>  Nom := '';<N>  GUID := '';<N>  DateVersion := 0;<N>  Generateur := -1;<N>  Recalcul := false;<N>  error := '';<N><N>
  try<N>    try<N>      Connexion := GetNewConnexion(Server, FileName, UserName, Password, Port, false);<N>      Connexion.Open();<N>      if Connexion.Connected then<N>      begin<N>        try<N>          // requete<N>          Query := GetNewQuery(Connexion);<N><N>
          // existance des tables ?<N>          try<N>            Query.SQL.Text := 'select rdb$relation_name from rdb$relations where upper(rdb$relation_name) in (''GENVERSION'', ''GENBASES'', ''K'', ''GENPARAMBASE'', ''GENTRIGGER'', ''GENTRIGGERDIFF'');';<N>            Query.Open();<N>            if Query.Eof then<N>              Exit<N>            else if not (Query.RecordCount in [5, 6]) then<N>              Exit;<N>          finally<N>            Query.Close();<N>          end;<N><N>
unit uGinkoiaTools ;<N><N>interface<N><N>uses  Classes, SysUtils,<N>  {$IF CompilerVersion >= 27.0}WinApi.Windows,{$IFEND}<N>  {$IF CompilerVersion < 27.0}Windows,{$IFEND}<N>      Forms,<N>      uCreateProcess, uLog ;<N><N>type<N>  TGinkoiaToolsStatus = (gtsNone, gtsStopped, gtsPaused, gtsRunning, gtsFinished, gtsFailed, gtsCanceled, gtsKilled) ;<N><N>
  TGinkoiaTools = class<N>  private<N>    FStdStream : TStdStream ;<N><N>    FOnStart: TNotifyEvent;<N>    FOnPause: TNotifyEvent;<N>    FOnExit: TNotifyEvent;<N>    FOnCancel: TNotifyEvent;<N>    FOnStop: TNotifyEvent;<N>    FOnResume: TNotifyEvent;<N><N>
    FStatus    : TGinkoiaToolsStatus ;<N>    FStatusReq : TGinkoiaToolsStatus ;<N>    FStarted   : boolean ;<N><N>    function getCanceled: boolean;<N>    function getPaused: boolean;<N>    function getStarted: boolean;<N>    function getStopped: boolean;<N>    function getFinished : boolean ;<N><N>
unit uThreadProc;<N><N>{$WARN SYMBOL_DEPRECATED OFF}<N><N>interface<N><N>uses Classes, SysUtils, Forms ;<N><N>type<N>  TProcError = reference to procedure( aException : Exception ) ;<N><N>  {$M+}<N>  TThreadProc = class(TThread)<N>  private<N>    FWait       : boolean ;<N><N>
    procedure doFinish ;<N>    procedure doError ;<N>    procedure doFinally;<N><N>  protected<N>    FFinish     : TProc ;<N>    FError      : TProcError ;<N>    FFinally    : TProc;<N>    FException  : Exception ;<N>    FRun     : TProc ;<N><N>    procedure Execute ; override ;<N><N>
  public<N>    constructor Create ; reintroduce ;<N><N>    class function RunInThread(aProc: TProc) : TThreadProc ;<N>    function whenFinish(aProc: TProc) : TThreadProc ;<N>    function whenError(aProc : TProcError) : TThreadProc ;<N>    function whenFinally(aProc: TProc): TThreadProc;<N>    function Run : TThreadProc ;<N>    function RunAndWait: TThreadProc;<N>    class procedure Kill(var aThreadProc: TThreadProc) ;<N>    procedure SynchonizeProc(aProc : TThreadProcedure) ;<N><N>
  published<N>    property Terminated ;<N>  end;<N>  {$M-}<N><N>implementation<N><N>{ TThreadProc }<N><N>constructor TThreadProc.Create;<N>begin<N>  inherited Create(true) ;<N>  FRun     := nil ;<N>  FFinish  := nil ;<N>  FError   := nil ;<N>  FFinally := nil;<N>  FWait    := true ;<N><N>
  FreeOnTerminate := true ;<N>end;<N><N>procedure TThreadProc.doFinish;<N>begin<N>  if Assigned(FFinish) then<N>  begin<N>    try<N>      FFinish() ;<N>    except<N>    end;<N>  end;<N>end;<N><N>procedure TThreadProc.doError;<N>begin<N>  if Assigned(FError) then<N>  begin<N>    try<N>      FError(FException) ;<N>    except<N>    end;<N>  end;<N>end;<N><N>
﻿unit uLog;<N><N>{$WARN UNIT_PLATFORM OFF}<N>{$WARN SYMBOL_PLATFORM OFF}<N><N>interface<N><N>uses<N>{$IF CompilerVersion > 27}<N>  System.Classes,<N>  System.SysUtils,<N>  System.StrUtils,<N>  Winapi.Windows,<N>  Winapi.Winsock,<N>  System.Contnrs,<N>  System.SyncObjs,<N>  System.iniFiles,<N>  idTCPClient,<N>  System.Math ;<N>{$ELSE}<N>  Classes,<N>  SysUtils,<N>  StrUtils,<N>  Windows,<N>  Winsock,<N>  Contnrs,<N>  SyncObjs,<N>  iniFiles,<N>  idTCPClient,<N>  Math ;<N>{$IFEND}<N><N>
unit Unite_Def;<N><N>interface<N>  Uses Sysutils,Registry, Windows, IniFiles,Forms;<N><N>  type<N>  TModeRun = (mrServer, mrClient);<N><N>  type<N>  TInfoBase = record<N>    public<N>      NomBase : String;<N>      CodeTiers : string;<N>      Magasin : String;<N>      Infos : record<N>        Adresse ,<N>        CodePostal,<N>        Ville ,<N>        Telephone : String;<N>      end;<N>      procedure SaveIni;<N>      procedure LoadIni;<N>  end;<N><N>
unit uCommonThread;<N><N>interface<N><N>uses Classes,Contnrs,Controls, Forms, RzPanel, SysUtils, StdCtrls, ComCtrls, uSevenZip, uCommon, IdComponent,AdvProgr;<N><N>type<N>  TCreateBoxMode = (cmCopy,cmZip, cmDel);<N><N>  TCMNThread = class(TThread)<N>  private<N>    FIPSOURCE : String;<N>    FSourceDir       : String;<N>    FSourceFile      : String;<N>    FDestinationDir  : String;<N>    FDestinationFile : String;<N>    FParentScrollbox : TScrollBox;<N>    FActionMode      : TModeAct;<N><N>
    FCXGroupBox : TRzGroupBox;<N>    FLabelDe : TLabel;<N>    FLabelVers : TLabel;<N>    FProgressBar : TAdvProgress;<N><N>    FLogs : TStringList;<N>    FIsTerminated : Boolean;<N>    FVersionning : Boolean;<N>    FSplitZip : Boolean;<N><N>    FHTTPMAXSIZE : Int64;<N>    FLogonNetWork: Boolean;<N>    FLogonPassword: String;<N>    FLogonUser: String;<N> public<N>    constructor Create(CreateSuspended: Boolean);<N>    destructor Destroy;override;<N><N>
    procedure CreateLogBox(ATitle : String; AMode : TCreateBoxMode = cmCopy);<N>    procedure DestroyLogBox;<N>    procedure ZipFile;<N>    procedure HttpOnWorkBegin(ASender : TObject;AWorkMode : TWorkMode;AWorkCountMax : Int64);<N>    procedure HttpOnWork(ASender : TObject;AWorkMode : TWorkMode;AWorkCount : Int64);<N><N>
unit GestionLog;<N><N>interface<N><N>type<N>  TErrorLevel = (el_Silent, el_Erreur, el_Warning, el_Info, el_Etape, el_Debug, el_Verbose);<N><N>procedure Log_Init(niv : TErrorLevel; Path : string);<N>procedure Log_ChangeNiv(niv : TErrorLevel);<N>procedure Log_Write(msg : string; niv : TErrorLevel = el_Debug);<N>procedure Log_WriteFmt(const msg: string; const args: array of const; const niv: TErrorLevel);<N><N>
implementation<N><N>uses<N>  SysUtils,<N>  TypInfo;<N><N>var<N>  LogNiv : TErrorLevel = el_silent;<N>  LogPath : string = '';<N><N>procedure Log_Init(Niv : TErrorLevel; Path : string);<N>begin<N>  LogNiv := niv;<N>  LogPath := Path;<N>end;<N><N>procedure Log_ChangeNiv(niv : TErrorLevel);<N>begin<N>  LogNiv := niv;<N>end;<N><N>
unit BaseCrypt;<N><N>interface<N><N>function CryptString(const Value, Key : string) : string;<N>function DecryptString(const Value, Key : string) : string;<N><N>implementation<N><N>uses<N>  SysUtils;<N><N>function CryptString(const Value, Key : string) : string;<N>var<N>  i, j : Integer;<N>  PassPhrase : string;<N>begin<N>  Result := '';<N>  PassPhrase := Key;<N><N>
  j := 1;<N>  for i := 1 to Length(Value) do<N>  begin<N>    Result := Result + IntToHex(Ord(Value[i]) xor Ord(PassPhrase[j]), 2);<N>    Inc(j);<N>    if j > Length(PassPhrase) then<N>      j := 1;<N>  end;<N>end;<N><N>function DecryptString(const Value, Key : string) : string;<N>var<N>  i, j : Integer;<N>  PassPhrase : string;<N>begin<N>  Result := '';<N>  PassPhrase := Key;<N><N>
  i := 1;<N>  j := 1;<N>  repeat<N>    Result := Result + Chr(StrToInt('$' + Copy(Value, i, 2)) xor Ord(PassPhrase[j]));<N>    Inc(i, 2);<N>    Inc(j);<N>    if j > Length(PassPhrase) then<N>      j := 1;<N>  until i > Length(Value);<N>end;<N><N>end.<N><N><N>
// LaunchProcess - 04/08/2017 13:53:13<N>unit LaunchProcess_RS;<N><N>interface<N><N>const<N>  RS_Open = 'open';<N>  RS_Code = 'Code : "';<N>  RS_Libelle = '" - Libelle : "';<N>  RS_RetourDuProcess = 'Retour du process : "';<N>  RS_RetourDuProcess1 = 'Retour du process : "';<N>  RS_Code1 = 'Code : "';<N>  RS_Libelle1 = '" - Libelle : "';<N>  RS_RetourDuProcess2 = 'Retour du process : "';<N>  RS_RetourDuProcess3 = 'Retour du process : "';<N><N>implementation<N><N>end.<N>
unit uGestionBDD;<N><N>interface<N><N>uses<N>  SysUtils,<N>  IB_Components,<N>  IBODataset;<N><N>const<N>  CST_BASE_SERVEUR = 'localhost';<N>  CST_BASE_PORT = 3050;<N>  CST_BASE_LOGIN = 'sysdba';<N>  CST_BASE_PASSWORD = 'masterkey';<N><N>type<N>  TMySession = TIB_Session;<N>  TMyConnection = TIB_Connection;<N>  TMyTransaction = TIB_Transaction;<N>  TMyQuery = TIBOQuery;<N><N>
﻿unit uLog;<N><N>interface<N><N>uses Classes, SysUtils, StrUtils, Windows, Winsock, Contnrs, SyncObjs, iniFiles, idTCPClient, Math ;<N><N>{$M+}<N><N>//==============================================================================<N>type<N>    PColor = ^TColor;<N>    TColor = -$7FFFFFFF-1..$7FFFFFFF;<N><N>
    TLogElement = (elDate, elHost, elApp, elInst, elSrv, elMdl, elDos, elRef, elMag, elKey, elValue, elLevel, elNb, elData) ;<N>    TLogElements = set of TLogElement ;<N>    TLogLevel = (logNone, logDebug, logTrace, logInfo, logNotice, logWarning, logError, logCritical, logEmergency) ;<N>    TLogSendState = (sendNone, sendWait, sendDo, sendDone) ;<N>    TLogType = (ltNone, ltLocal, ltServer, ltBoth) ;<N><N>
unit uThreadProc;<N><N>interface<N><N>uses Classes, SysUtils, Forms;<N><N>type<N>  TProcError = reference to procedure( aException : Exception ) ;<N><N>  TThreadProc = class(TThread)<N>  private<N>    FFinish     : TProc ;<N>    FError      : TProcError ;<N>    FException  : Exception ;<N>    procedure doError ;<N>    procedure doFinish ;<N>  protected<N>    FRun     : TProc ;<N>    procedure Execute ; override ;<N>  public<N>    constructor Create ; reintroduce ;<N><N>
    class function RunInThread(aProc: TProc) : TThreadProc ;<N>    function whenFinish(aProc: TProc) : TThreadProc ;<N>    function whenError(aProc : TProcError) : TThreadProc ;<N>    function Run : TThreadProc ;<N>    function RunAndWait: TThreadProc;<N><N>
    procedure SynchonizeProc(aProc : TThreadProcedure) ;<N>  published<N>    property Terminated ;<N>  end;<N><N>implementation<N><N>{ TThreadProc }<N><N>constructor TThreadProc.Create;<N>begin<N>  inherited Create(true) ;<N>  FRun     := nil ;<N>  FError   := nil ;<N>  FFinish  := nil ;<N><N>
  FreeOnTerminate := true ;<N>end;<N><N>procedure TThreadProc.doError;<N>begin<N>  if Assigned(FError) then<N>  begin<N>    try<N>      FError(FException) ;<N>    except<N>    end;<N>  end;<N>end;<N><N>procedure TThreadProc.doFinish;<N>begin<N>  if Assigned(FFinish) then<N>  begin<N>    try<N>      FFinish() ;<N>    except<N>    end;<N>  end;<N>end;<N><N>
procedure TThreadProc.Execute;<N>begin<N>  inherited ;<N><N>  try<N>    FRun() ;<N><N>    if not Terminated then<N>    begin<N>      if Assigned(FFinish) then<N>        Synchronize(doFinish);<N>      Terminate;<N>    end ;<N>  except<N>    on E:Exception do<N>    begin<N>      FException := E ;<N>      if Assigned(FError) then<N>        Synchronize(doError) ;<N>    end;<N>  end;<N>end;<N><N>
function TThreadProc.Run: TThreadProc;<N>begin<N>  if Assigned(FRun) then<N>    Start ;<N><N>  Result := Self ;<N>end;<N><N>function TThreadProc.RunAndWait: TThreadProc;<N>begin<N>  if Assigned(FRun) then<N>    Start;<N><N>  while not Terminated do<N>  begin<N>    Application.ProcessMessages;<N>    Sleep(20);<N>  end;<N><N>
  Result := Self;<N>end;<N><N>class function TThreadProc.RunInThread(aProc: TProc): TThreadProc;<N>begin<N>  Result := TThreadProc.Create ;<N>  Result.FRun := aProc ;<N>end;<N><N>procedure TThreadProc.SynchonizeProc(aProc: TThreadProcedure);<N>begin<N>  Synchronize(aProc);<N>end;<N><N>
function TThreadProc.whenError(aProc: TProcError): TThreadProc;<N>begin<N>  FError := aProc ;<N>  Result := Self ;<N>end;<N><N>function TThreadProc.whenFinish(aProc: TProc): TThreadProc;<N>begin<N>  FFinish := aProc ;<N>  Result := Self ;<N>end;<N><N>end.<N><N>
unit uLogs;<N><N>interface<N><N>uses SysUtils, StdCtrls, Classes, Dialogs;<N><N>Type<N>  TLogs = class<N>  private<N>    FPath: String;<N>    FFilename: String;<N>    FMemo: TMemo;<N><N>  public<N>    constructor Create;<N><N>    procedure AddToLogs(AText : String; AShowInMemo : Boolean = True);<N>  published<N>    property FileName : String read FFilename write FFileName;<N>    property Path : String read FPath write FPath;<N>    property Memo : TMemo read FMemo write FMemo;<N>  end;<N><N>
  var<N>   Logs : TLogs;<N><N>implementation<N><N><N>{ TLogs }<N><N>procedure TLogs.AddToLogs(AText: String; AShowInMemo: Boolean);<N>var<N>  FFile : TFileStream;<N>  sLigne : String;<N>  Buffer : TBytes;<N>  {$IFNDEF VER185}<N>  Encoding : TEncoding;<N>  {$ENDIF}<N>begin<N>  if Trim(FFilename) = '' then<N>    raise Exception.Create('Nom de fichier obligatoire');<N><N>
  if Trim(FPath) = '' then<N>    raise Exception.Create('Chemin de destination du fichier obligatoire');<N><N>  sLigne := FormatDateTime('[DD/MM/YYYY hh:mm:ss] ',Now) + AText + #13#10;<N><N>  if Assigned(FMemo) and AShowInMemo then<N>  begin<N>    while FMemo.lines.count > 200 do<N>      FMemo.Lines.Delete(0);<N>    FMemo.Lines.Add(Trim(sLigne));<N>  end;<N><N>
unit uGrilleTaillesSP2K;<N><N>interface<N><N>uses SysUtils, Contnrs, uTaille;<N><N>type<N>  TGrilleTaillesSP2K = class<N>    private<N>      FGtfID: Integer;<N>      FListeTailles: TObjectList;<N><N>    public<N>      property GtfID: Integer read FGtfID write FGtfID;<N>      property ListeTailles: TObjectList read FListeTailles write FListeTailles;<N><N>
      constructor Create;<N>      destructor Destroy;   override;<N>  end;<N><N>  TListeGrillesTaillesSP2K = class(TObjectList)<N>    public<N>      function Add(GrilleTaillesSP2K: TGrilleTaillesSP2K): Integer;<N>      procedure GetGrilleTaillesSP2K(const nGtfID: Integer; ListeTailles: TObjectList);<N>  end;<N><N>
implementation<N><N>{ TGrilleTaillesSP2K }<N><N>constructor TGrilleTaillesSP2K.Create;<N>begin<N>  FListeTailles := TObjectList.Create;<N>end;<N><N>destructor TGrilleTaillesSP2K.Destroy;<N>begin<N>  FListeTailles.Free;<N><N>  inherited;<N>end;<N><N>{ TListeGrillesTaillesSP2K }<N><N>
function TListeGrillesTaillesSP2K.Add(GrilleTaillesSP2K: TGrilleTaillesSP2K): Integer;<N>begin<N>  if not Assigned(GrilleTaillesSP2K) then<N>    raise Exception.Create('Erreur :  pas de TGrilleTaillesSP2K !');<N><N>  Result := inherited Add(GrilleTaillesSP2K);<N>end;<N><N>
unit uCodeBarre;<N><N>interface<N><N>uses uSynchroObjBDD, uGestionBDD;<N><N>type<N>  {$M+}<N>  TCodeBarre = class(TMyObject)<N>  private<N>    FARFID: Integer;<N>    FTGFID: Integer;<N>    FCOUID: Integer;<N>    FCB: String;<N>    FTYPE: Integer;<N>    FCLTID: Integer;<N>    FARLID: Integer;<N>    FLOC: Integer;<N>    FMATID: Integer;<N>    FPRIN: Integer;<N>    FTCFID: Integer;<N><N>
unit uSynchroObjBDD;<N><N>interface<N><N>uses<N>  uGestionBDD, TypInfo, DB, SysUtils, Types, Classes;<N>  <N>type<N>  TTypeQry = (tqNone, tqSelect, tqUpdate, tqInsert);<N><N>  TMyObject = class(TPersistent)<N>  private <N>    function getChamps(aPrefix : string; aTQ: TTypeQry = tqNone) : String;<N><N>
unit uDM_ArticleFusion;<N><N>interface<N><N>uses SysUtils, uGestionBDD, uArticle, uCodeBarre;<N><N>type<N>  TDM_Article = class<N>  private<N>    FQuery: TMyQuery;<N><N>  public<N>    constructor Create(aQuery: TMyQuery);<N>    function GetArticleDestination(Article: TArticle): TArticle;<N>    function GetArticleDestinationFinale(Article: TArticle): TArticle;<N>    function IsArticleHasFusion(Article: TArticle): Boolean;<N>    function GetArticle(CB: TCodeBarre): TArticle;<N>  end;    <N><N>
implementation<N><N>{ TDM_Article }<N><N>constructor TDM_Article.Create(aQuery: TMyQuery);<N>begin<N>  if not Assigned(aQuery) then<N>    raise Exception.Create('Erreur :  pas de query !');<N>  FQuery := aQuery;<N>end;<N><N>function TDM_Article.GetArticleDestination(Article: TArticle): TArticle;<N>begin<N>  Result := nil;<N><N>
unit uTaillesTrav;<N><N>interface<N><N>uses<N>  uSynchroObjBDD;<N><N>type<N>  {$M+}<N>  TTaillesTrav = class(TMyObject)<N>  private<N>    FArtid: integer;<N>    FTgfid: integer;<N>   protected<N>    const<N>    TABLE_NAME='PLXTAILLESTRAV';<N>    TABLE_TRIGRAM='TTV';<N>    TABLE_PK='TTV_ID';<N>  public<N>    constructor create(); overload;<N>  published<N>    property Artid: integer read FArtid write FArtid;<N>    property Tgfid: integer read FTgfid write FTgfid;<N>  end;<N>  {$M-}<N><N>
unit uTaille;<N><N>interface<N><N>uses Classes, SysUtils, uSynchroObjBDD;<N><N>type<N>  {$M+}<N>  TTaille = class(TMyObject)<N>  private<N>    FCorres: string;<N>    FTgfid: integer;<N>    FGtfid: integer;<N>    FCode: string;<N>    FColumnx: string;<N>    FCentrale: integer;<N>    FOrdreaff: double;<N>    FNom: string;<N>    FTgsid: integer;<N>    FActive: integer;<N>    FStat: integer;<N>    FIdref: integer;<N><N>
unit uTailleTrav;<N><N>interface<N><N>uses<N>  uSynchroObjBDD;<N><N>type<N>  {$M+}<N>  TTailleTrav = class(TMyObject)<N>  private<N>    FArtid: integer;<N>    FTgfid: integer;<N>   protected<N>    const<N>    TABLE_NAME='PLXTAILLESTRAV';<N>    TABLE_TRIGRAM='TTV';<N>    TABLE_PK='TTV_ID';<N>  public<N>    constructor create(); overload;<N>  published<N>    property Artid: integer read FArtid write FArtid;<N>    property Tgfid: integer read FTgfid write FTgfid;<N>  end;<N>  {$M-}<N><N>
unit GestionEMail;<N><N>interface<N><N>uses<N>  Classes;<N><N>type<N>  SecuriteMail = (tsm_Aucun, tsm_TLS, tsm_SSL);<N><N>function SendMail(serveur : string; port : Integer; Login, Password : string; Securite : SecuriteMail;<N>                  expediteur, destinataires, titre, text : string;<N>                  PiecesJointes : TStrings) : Boolean;<N><N>
reset(mae);<N>    while not eof(mae)do begin<N>      read(mae,n);<N>      writeln('cod: ',n.cod);<N>    end;
﻿unit udmPromoVerifTypoAdobeStock_212889779;<N>{<N>  Unit generated by folder2FMXImageList the 01/03/2023 16:19:53<N><N>  Don't change it if you want to refresh the images by the program :<N>  it will erase all your changes !<N><N>  ******************************************************************************<N>  * Folder2FMXImageList<N>  ******************************************************************************<N>  (c) Patrick Prémartin - Olf Software<N><N>
  Source : https://github.com/DeveloppeurPascal/Folder2FMXImageList<N>  Issue : https://github.com/DeveloppeurPascal/Folder2FMXImageList/issues<N>  New features : https://github.com/DeveloppeurPascal/Folder2FMXImageList/discussions<N>  Download : https://folder2fmximagelist.olfsoftware.fr/<N>}<N>interface<N><N>
uses<N>  System.SysUtils, System.Classes, System.ImageList, FMX.ImgList;<N><N>type<N>  TdmPromoVerifTypoAdobeStock_212889779 = class(TDataModule)<N>    ImageList: TImageList;<N>  private<N>    { Déclarations privées }<N>  public<N>    { Déclarations publiques }<N>  end;<N><N>
unit uInfosDuJeu;<N><N>interface<N><N>const<N>  CNbColonnes = 4;<N>  CNbLignes = 4;<N><N>var<N>  NbCasesEnMouvement: integer;<N>  NbCasesALeurPlace: integer;<N>  PartieDemarree: boolean;<N>  PositionCaseVideX, PositionCaseVideY: integer;<N><N>implementation<N><N>initialization<N><N>NbCasesEnMouvement := 0;<N>NbCasesALeurPlace := 0;<N>PartieDemarree := false;<N><N>end.<N>
unit FTypes;<N><N>interface<N>uses SysUtils,Windows,forms;<N>type<N>  TArrayOfString=Array of string;<N>  TArrayOfInteger=array of integer;<N><N><N>  TKomunikat = class<N>  public<N>    procedure WyswietlKomunikat(Anapis: string; ANaglowek: string);<N>    function WyswietlKomunikatF(Anapis: string; ANaglowek: string): integer;<N>  end;<N>var<N>  Komunikat: TKomunikat;<N><N>
implementation<N><N>{ TKomunikat }<N><N>procedure TKomunikat.WyswietlKomunikat(Anapis, ANaglowek: string);<N>begin<N>with Application do begin<N>    SetWindowPos(handle, 0, 0, 0, 0, 0, SWP_NOZORDER or SWP_NOMOVE or SWP_NOSIZE or SWP_NOREDRAW);<N>    MessageBox(PChar(Anapis), PChar(ANaglowek), mb_OK or mb_IconInformation or mb_ApplModal);<N>  end;<N>end;<N><N>
function TKomunikat.WyswietlKomunikatF(Anapis, ANaglowek: string): integer;<N>var<N>  wynik: integer;<N>begin<N>  result := -1;<N>  with Application do begin<N>    wynik := MessageBox(Pchar(Anapis), PChar(ANaglowek), MB_YESNO or MB_ICONWARNING);<N>    SetWindowPos(Application.Handle, 0, 0, 0, 0, 0, SWP_NOZORDER or SWP_NOMOVE or SWP_NOSIZE or SWP_NOREDRAW);<N>    if wynik = id_Yes then begin<N>      result := 1;<N>    end;<N>  end;<N>end;<N><N>
unit fKontrahent;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, FModalBase, Vcl.StdCtrls, Vcl.Mask,<N>  Vcl.DBCtrls, Data.DB, Data.Win.ADODB, Vcl.ExtCtrls;<N><N>
unit fFaktury;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, FModalBase, Data.DB, Data.Win.ADODB,<N>  Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.ComCtrls, Vcl.Mask, Vcl.DBCtrls, Vcl.Buttons;<N><N>
unit uFaktury;<N><N>interface<N>uses Classes, Inifiles,Vcl.Forms,SysUtils;<N><N>type<N> TuFakturyParams=class<N> private<N>   FConnectionString:string;<N>   function LoadParamsINI:boolean;<N> public<N>   Constructor Create;<N>   property connectionString:string read FConnectionString;<N> end;<N><N>
unit fFirma;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, FModalBase, Data.DB, Data.Win.ADODB,<N>  Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.Mask, Vcl.DBCtrls;<N><N>
unit ChatGPT_API;<N><N>interface<N><N>uses System.Classes, Winapi.Windows, Winapi.Messages, System.SysUtils, System.JSON,<N>     System.Variants, Generics.Collections, IdBaseComponent, IdComponent, Vcl.Dialogs,<N>     IdTCPConnection, IdTCPClient, IdHTTP, IdGlobal, IdGlobalProtocols, IdCoderMIME,<N>     IdIOHandler, IdIOHandlerSocket, IdIOHandlerStack, IdSSL, IdSSLOpenSSL, IdMultipartFormData;<N><N>
PROGRAM hub;<N><N>TYPE<N>    withoutTypedef = RECORD<N>        var2: CHAR;<N>        varArray: array[1..10] of CHAR;<N>        var4: CHAR;<N>        var1: INTEGER;<N>        var0: INTEGER;<N>    END;<N><N>    withTypedef = RECORD<N>        varchar: CHAR;<N>        varint: INTEGER;<N>    END;<N><N>
FUNCTION function(a,b,c: INTEGER): INTEGER;<N>VAR<N>    var2: INTEGER;<N>BEGIN<N>    var2 := 7;<N>    function := 3;<N>END;<N><N>FUNCTION function1(x,y,z: INTEGER): INTEGER;<N>VAR<N>    var1, var2: INTEGER;<N>    var3: array[1..10] of CHAR;<N>    var4: CHAR;<N>    var5: INTEGER;<N>BEGIN<N>    var1 := 2;<N>    var2 := var3[1] + 5 * 2^(3-7/(var1+Ord(var3[1])));<N>    var4 := var3[1];<N>    var5 := function(var1,var2,Ord(var4));<N><N>
    function1 := x;<N>END;<N><N>BEGIN<N>    VAR<N>        var0main: CHAR;<N>        var1main: INTEGER;<N>        x, y: INTEGER;<N>        var5: INTEGER;<N><N>    var0main := ' ';<N>    var1main := 0;<N><N>    WHILE (((3+4) > 3) AND (x <> 0) OR (y <> 0)) DO<N>        var5 := Ord(' ') + 5 * 2^(3-7/(x+Ord(' ')));<N>    ENDWHILE;<N><N>
PROGRAM program;<N><N>TYPE<N>    withTypedef = RECORD<N>        var1, var2, var3: array [0..9] of CHAR;<N>        var4: CHAR;<N>        x, y, z: INTEGER;<N>    END;<N><N>    withoutTypedef = RECORD<N>        var1, var2, var3: array [0..9] of CHAR;<N>        var4: CHAR;<N>        x, y, z: INTEGER;<N>    END;<N><N>
FUNCTION function1(a,b,c: INTEGER): INTEGER;<N>VAR<N>    var2: INTEGER;<N>BEGIN<N>    var2 := 7;<N>    function1 := x;<N>END;<N><N>FUNCTION function(x,y,z: INTEGER): INTEGER;<N>VAR<N>    var1, var2, var3, var4, var5: CHAR;<N>BEGIN<N>    var1 := '2';<N>    var2 := var3[0] + 5 * 2^(3-7/(Ord(var1)+Ord(var3[0])));<N>    var4 := var3[0];<N>    var5 := Chr(function1(Ord(var1),Ord(var2),Ord(var3[0])));<N><N>
    function := 3;<N>END;<N><N>VAR<N>    var1, var2, var3, var4, var5, var6: CHAR;<N>    x, y, z: INTEGER;<N><N>BEGIN<N>    var5 := Chr(Ord(var3[0]) + 5 * 2^(3-7/(Ord(var1)+Ord(var3[0]))));<N><N>    WHILE(((3+4) > 3) AND (x <> 0) OR (y <> 0)) DO<N>        var5 := Chr(Ord(var3[0]) + 5 * 2^(3-7/(Ord(var1)+Ord(var3[0]))));<N>    ENDWHILE;<N><N>
    FOR x := 3 TO 32 DO<N>        var5 := Chr(Ord(var3[0]) + 5 * 2^(3-7/(Ord(var1)+Ord(var3[0]))));<N>        WHILE(((3+4) > 3) AND (x <> 0) OR (y <> 0)) DO<N>            var5 := Chr(Ord(var3[0]) + 5 * 2^(3-7/(Ord(var1)+Ord(var3[0]))));<N>        ENDWHILE;<N>    END;<N><N>
    IF((Ord(var1) > Ord(var2)) AND ((3+4) > 2)) THEN<N>        var5 := Chr(Ord(var3[0]) + 5 * 2^(3-7/(Ord(var1)+Ord(var3[0]))));<N>    ELSEIF ((3+4) > 2) THEN<N>        var5 := var3[0];<N>    ELSE<N>        WHILE(((3+4) > 3) AND (x <> 0) OR (y <> 0)) DO<N>            var5 := Chr(Ord(var3[0]) + 5 * 2^(3-7/(Ord(var1)+Ord(var3[0]))));<N>        ENDWHILE;<N>    ENDIF;<N><N>
    CASE (((3+4) > 3) AND (x <> 0) OR (y <> 0)) OF<N>    5=3:<N>        var6 := '7';<N>    4<>3:<N>        var2 := Ord(var5);<N>    ELSE<N>        var1 := Chr(function(21, 21, 21));<N>    END;<N><N>    WriteLn('This is a print', var7, var3, var0[23]);<N>END. <N><N><N>
0<N>1<N>2<N>3<N>4<N>5<N>6<N>7<N>8<N>9<N>10<N>01<N>00<N>001<N>0001<N>$001<N>$002<N>%0<N>%01<N>%11<N>%000<N>%0011<N>%10101010<N>-$001<N>-&2<N>-%01010101<N>-123<N>+$001<N>+&12<N>+%01010101<N>+123<N>
absolute  <N>and  <N>array  <N>asm  <N>begin  <N>case  <N>const  <N>constructor  <N>destructor  <N>div  <N>do  <N>downto  <N>else  <N>end  <N>file  <N>for  <N>function  <N>goto  <N>if  <N>implementation  <N>in  <N>inherited  <N>inline  <N>interface  <N>label  <N>mod  <N>nil  <N>not  <N>object  <N>of  <N>operator  <N>or  <N>packed  <N>procedure  <N>program  <N>record  <N>reintroduce  <N>repeat  <N>self  <N>set  <N>shl  <N>shr  <N>string  <N>then  <N>to  <N>type  <N>unit  <N>until  <N>uses  <N>var  <N>while  <N>with  <N>xor
as  <N>class  <N>dispinterface  <N>except  <N>exports  <N>finalization  <N>finally  <N>initialization  <N>inline  <N>is  <N>library  <N>on  <N>out  <N>packed  <N>property  <N>raise  <N>resourcestring  <N>threadvar  <N>try
PROGRAM hub;<N><N>TYPE<N>    withoutTypedef = RECORD<N>        var2: CHAR;<N>        varArray: array[1..10] of CHAR;<N>        var4: CHAR;<N>        var1: INTEGER;<N>        var0: INTEGER;<N>    END;<N><N>    withTypedef = RECORD<N>        varchar: CHAR;<N>        varint: INTEGER;<N>    END;<N><N>
FUNCTION function(a,b,c: INTEGER): INTEGER;<N>VAR<N>    var2: INTEGER;<N>BEGIN<N>    var2 := 7;<N>    function := 3;<N>END;<N><N>FUNCTION function1(x,y,z: INTEGER): INTEGER;<N>VAR<N>    var1, var2: INTEGER;<N>    var3: array[1..10] of CHAR;<N>    var4: CHAR;<N>    var5: INTEGER;<N>BEGIN<N>    var1 := 2;<N>    var2 := var3[1] + 5 * 2^(3-7/(var1+Ord(var3[1])));<N>    var4 := var3[1];<N>    var5 := function(var1,var2,Ord(var4));<N><N>
    function1 := x;<N>END;<N><N>BEGIN<N>    VAR<N>        var0main: CHAR;<N>        var1main: INTEGER;<N>        x, y: INTEGER;<N>        var5: INTEGER;<N><N>    var0main := ' ';<N>    var1main := 0;<N><N>    WHILE (((3+4) > 3) AND (x <> 0) OR (y <> 0)) DO<N>        var5 := Ord(' ') + 5 * 2^(3-7/(x+Ord(' ')));<N>    ENDWHILE;<N><N>
'This is a pascal string'<N>''<N>'a'<N>'A tabulator character: '#9' is easy to embed'<N>'the string starts here'#13#10'   and continues here'<N>'the string starts here'#10'   and continues here'<N>'the string starts here'#10'   and continues here'
paulo<N>paulo_oliveira<N>paulo_oliveira_123<N>paulo_oliveira_123_<N>paulo_oliveira_123_123<N>paulo_oliveira_123_123_<N>paulo_oliveira_123_123_123<N>paulo_oliveira_123_123_123_<N>_paulo_oliveira_123_123_123<N>_paulo_oliveira_123_123_123_<N>&break<N>&case<N>&abstract<N>&absolute<N>&as
unit uPpal;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Menus,<N>  System.Rtti, System.Bindings.Outputs, Data.Bind.EngExt, Fmx.Bind.DBEngExt,<N>  Data.Bind.Components, FMX.StdCtrls, FMX.Controls.Presentation;<N><N>
type<N>  TfPPal = class(TForm)<N>    MainMenu1: TMainMenu;<N>    MenuItem1: TMenuItem;<N>    MenuItem2: TMenuItem;<N>    MenuItem3: TMenuItem;<N>    BindingsList1: TBindingsList;<N>    Panel1: TPanel;<N>    Label1: TLabel;<N>    Label2: TLabel;<N>    Label3: TLabel;<N>    procedure MenuItem2Click(Sender: TObject);<N>    procedure MenuItem3Click(Sender: TObject);<N>    procedure FormCreate(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  fPPal: TfPPal;<N><N>implementation<N><N>{$R *.fmx}<N><N>uses uGestionar, uListar, uLogin;<N><N>procedure TfPPal.FormCreate(Sender: TObject);<N>begin<N>  //Mostramos la pantalla de inicio<N>  FLogin := TFLogin.Create(Self);<N>  try<N>    FLogin.ShowModal;<N>  finally<N>    Flogin.Free;<N>  end;<N>end;<N><N>
procedure TfPPal.MenuItem2Click(Sender: TObject);<N>begin<N>  fGestionar := TfGestionar.Create(Self);<N>  fGestionar.ShowModal;<N>end;<N><N>procedure TfPPal.MenuItem3Click(Sender: TObject);<N>begin<N>  fListar := TfListar.Create(Self);<N>  fListar.ShowModal;<N>end;<N><N>
unit untDMServidor;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes;<N><N>type<N>  TDataModule1 = class(TDataModule)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  DataModule1: TDataModule1;<N><N>implementation<N><N>{%CLASSGROUP 'Vcl.Controls.TControl'}<N><N>{$R *.dfm}<N><N>end.<N>
unit untThreadEnderecoIntegracao;<N><N>interface<N><N>uses<N>  System.Classes, System.SysUtils, Vcl.ComCtrls, Vcl.Forms, Vcl.Controls,<N>  Vcl.ExtCtrls, System.IniFiles, FireDAC.Comp.Client, Datasnap.DBClient,<N>  REST.Response.Adapter, REST.Client, Data.Bind.ObjectScope, Data.DB;<N><N>
type<N>  TfThreadEnderecoIntegracao = class(TThread)<N>  private<N>    { Private declarations }<N>    FQryEndereco: TFDQuery;<N>    FClientDataSet: TClientDataSet;<N>    FRESTResponseDataSetAdapter: TRESTResponseDataSetAdapter;<N>    FRESTRequest: TRESTRequest;<N>    FFDConnection: TFDConnection;<N><N>
unit untServidor;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,<N>  IPPeerServer,<N>  System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs,<N>  Vcl.StdCtrls;<N><N>type<N>  TfrmServidor = class(TForm)<N>    lblPorta: TLabel;<N>    edtPorta: TEdit;<N>    btnConectar: TButton;<N>    procedure btnConectarClick(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
//<N>// Created by the DataSnap proxy generator.<N>// 26/02/2023 16:45:26<N>// <N><N>unit ClientClassesUnit1;<N><N>interface<N><N>uses System.JSON, Data.DBXCommon, Data.DBXClient, Data.DBXDataSnap, Data.DBXJSON, Datasnap.DSProxy, System.Classes, System.SysUtils, Data.DB, Data.SqlExpr, Data.DBXDBReaders, Data.DBXCDSReaders, Data.DBXJSONReflect;<N><N>
unit datamodul;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, OraCall, Data.DB, DBAccess, Ora;<N><N>type<N>  Tdm = class(TDataModule)<N>    OraSession1: TOraSession;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  dm: Tdm;<N><N>implementation<N><N>{%CLASSGROUP 'Vcl.Controls.TControl'}<N><N>{$R *.dfm}<N><N>end.<N>
unit datamodul;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, OraCall, Data.DB, DBAccess, Ora;<N><N>type<N>  Tdm = class(TDataModule)<N>    OraSession1: TOraSession;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  dm: Tdm;<N><N>implementation<N><N>{%CLASSGROUP 'Vcl.Controls.TControl'}<N><N>{$R *.dfm}<N><N>end.<N>
// ************************************************************************ //<N>// The types declared in this file were generated from data read from the<N>// WSDL File described below:<N>// WSDL     : https://tckimlik.nvi.gov.tr/Service/KPSPublic.asmx?WSDL<N>//  >Import : https://tckimlik.nvi.gov.tr/Service/KPSPublic.asmx?WSDL>0<N>// Encoding : utf-8<N>// Version  : 1.0<N>// (2.04.2022 14:06:05 - - $Rev: 96726 $)<N>// ************************************************************************ //<N><N>
unit BAR69;<N><N>interface<N><N>uses<N>  SysUtils, Classes, DB, ADODB;<N><N>type<N>  TDM_Update = class(TDataModule)<N>    qSep2020: TADOQuery;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  DM_Update: TDM_Update;<N><N>implementation<N><N>uses<N>  BAR04;<N><N>{$R *.dfm}<N><N>end.<N>
unit BAR37;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, Buttons, ComCtrls, StdCtrls, DBCtrls, DB, ADODB, cxControls,<N>  cxContainer, cxEdit, cxTextEdit, cxMaskEdit, cxDropDownEdit, cxCalendar;<N><N>
unit BAR07;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, Buttons, ExtCtrls, StdCtrls, DBCtrls, Mask, DB, ADODB, ComCtrls,<N>  Grids, DBGrids, ExtDlgs, QuerySearchDlgADO, cxControls, cxContainer,<N>  cxEdit, cxTextEdit, cxMaskEdit, cxButtonEdit;<N><N>
unit POS12;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, Buttons;<N><N>type<N>  TfrmDevuelta = class(TForm)<N>    Label1: TLabel;<N>    lbdevuelta: TStaticText;<N>    BitBtn1: TBitBtn;<N>    procedure BitBtn1Click(Sender: TObject);<N>    procedure FormActivate(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>    recibido, devuelta : double;<N>  end;<N><N>
var<N>  frmDevuelta: TfrmDevuelta;<N><N>implementation<N><N>uses POS01, POS00;<N><N>{$R *.dfm}<N><N>procedure TfrmDevuelta.BitBtn1Click(Sender: TObject);<N>begin<N>  Close;<N>end;<N><N>procedure TfrmDevuelta.FormActivate(Sender: TObject);<N>var<N>  arch : textfile;<N>  codigo, cod, abrir : string;<N>  a : integer;<N>  lista : tstrings;<N>begin<N>  frmMain.DisplayDevuelta(recibido, devuelta); <N><N>
  {dm.Query1.Close;<N>  dm.Query1.SQL.Clear;<N>  dm.Query1.SQL.Add('select codigo_abre_caja from cajas_IP');<N>  dm.Query1.SQL.Add('where caja = :caj');<N>  dm.Query1.Parameters.ParamByName('caj').Value := frmMain.edCaja.Caption;<N>  dm.Query1.Open;<N>  codigo := dm.Query1.FieldByName('codigo_abre_caja').AsString;<N><N>
unit POS10;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls;<N><N>type<N>  TfrmNCF = class(TForm)<N>    Label1: TLabel;<N>    Label2: TLabel;<N>    Label3: TLabel;<N>    Label4: TLabel;<N>    procedure FormKeyDown(Sender: TObject; var Key: Word;<N>      Shift: TShiftState);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>    ncf : integer;<N>  end;<N><N>
var<N>  frmNCF: TfrmNCF;<N><N>implementation<N><N>uses POS01;<N><N>{$R *.dfm}<N><N>procedure TfrmNCF.FormKeyDown(Sender: TObject; var Key: Word;<N>  Shift: TShiftState);<N>begin<N>  if key = vk_f1 then<N>  begin<N>    ncf := 1;<N>    close;<N>  end<N>  else if key = vk_f2 then<N>  begin<N>    ncf := 2;<N>    close;<N>  end<N>  else if key = vk_f6 then<N>  begin<N>    ncf := 3;<N>    close;<N>  end<N>  else if key = vk_f9 then<N>  begin<N>    ncf := 4;<N>    close;<N>  end;<N>end;<N><N>
unit POS26;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, Buttons, DBCtrls, ExtCtrls;<N><N>type<N>  TfrmSerieFactura = class(TForm)<N>    pBottom: TPanel;<N>    BitBtn1: TBitBtn;<N>    BitBtn2: TBitBtn;<N>    pTop: TPanel;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  frmSerieFactura: TfrmSerieFactura;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit Unit1;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, ujson, StdCtrls;<N><N>type<N>  TForm1 = class(TForm)<N>    mmo1: TMemo;<N>    edt1: TEdit;<N>    btn1: TButton;<N>    procedure btn1Click(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
{<N>   Copyright 2005-2012 Sandy Barbour and Ben Supnik All rights reserved.  See<N>   license.txt for usage. X-Plane SDK Version: 2.1.1                          <N>}<N><N>UNIT XPUIGraphics;<N>INTERFACE<N><N>USES<N>    XPWidgetDefs;<N>   {$A4}<N>{___________________________________________________________________________<N> * UI GRAPHICS<N> ___________________________________________________________________________}<N><N>
{<N>   Copyright 2005-2012 Sandy Barbour and Ben Supnik All rights reserved.  See<N>   license.txt for usage. X-Plane SDK Version: 2.1.1                          <N>}<N><N>UNIT XPLMScenery;<N>INTERFACE<N>{<N>   This package contains APIs to interact with X-Plane's scenery system.      <N>}<N><N>
{<N>   Copyright 2005-2012 Sandy Barbour and Ben Supnik All rights reserved.  See<N>   license.txt for usage. X-Plane SDK Version: 2.1.1                          <N>}<N><N>UNIT XPLMPlugin;<N>INTERFACE<N>{<N>   These APIs provide facilities to find and work with other plugins and<N>   manage other plugins.                                                      <N>}<N><N>
{<N>   Copyright 2005-2012 Sandy Barbour and Ben Supnik All rights reserved.  See<N>   license.txt for usage. X-Plane SDK Version: 2.1.1                          <N>}<N><N>UNIT XPUIGraphics;<N>INTERFACE<N><N>USES<N>    XPWidgetDefs;<N>   {$A4}<N>{___________________________________________________________________________<N> * UI GRAPHICS<N> ___________________________________________________________________________}<N><N>
{<N>   Copyright 2005-2012 Sandy Barbour and Ben Supnik All rights reserved.  See<N>   license.txt for usage. X-Plane SDK Version: 2.1.1                          <N>}<N><N>UNIT XPLMScenery;<N>INTERFACE<N>{<N>   This package contains APIs to interact with X-Plane's scenery system.      <N>}<N><N>
{<N>   Copyright 2005-2012 Sandy Barbour and Ben Supnik All rights reserved.  See<N>   license.txt for usage. X-Plane SDK Version: 2.1.1                          <N>}<N><N>UNIT XPLMPlugin;<N>INTERFACE<N>{<N>   These APIs provide facilities to find and work with other plugins and<N>   manage other plugins.                                                      <N>}<N><N>
{<N>   Copyright 2005-2012 Sandy Barbour and Ben Supnik All rights reserved.  See<N>   license.txt for usage. X-Plane SDK Version: 2.1.1                          <N>}<N><N>UNIT XPUIGraphics;<N>INTERFACE<N><N>USES<N>    XPWidgetDefs;<N>   {$A4}<N>{___________________________________________________________________________<N> * UI GRAPHICS<N> ___________________________________________________________________________}<N><N>
{<N>   Copyright 2005-2012 Sandy Barbour and Ben Supnik All rights reserved.  See<N>   license.txt for usage. X-Plane SDK Version: 2.1.1                          <N>}<N><N>UNIT XPLMScenery;<N>INTERFACE<N>{<N>   This package contains APIs to interact with X-Plane's scenery system.      <N>}<N><N>
{<N>   Copyright 2005-2012 Sandy Barbour and Ben Supnik All rights reserved.  See<N>   license.txt for usage. X-Plane SDK Version: 2.1.1                          <N>}<N><N>UNIT XPLMPlugin;<N>INTERFACE<N>{<N>   These APIs provide facilities to find and work with other plugins and<N>   manage other plugins.                                                      <N>}<N><N>
unit UnitPrincipal;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.Menus, Vcl.ExtCtrls,<N>  Vcl.Imaging.pngimage, Data.DB, Data.Win.ADODB;<N><N>
unit tlconsul;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.Mask, Vcl.DBCtrls,<N>  Vcl.ExtCtrls, Data.DB, Data.Win.ADODB, Vcl.Grids, Vcl.DBGrids,<N>  FireDAC.Stan.Intf, FireDAC.Stan.Option, FireDAC.Stan.Param,<N>  FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf,<N>  FireDAC.Stan.StorageBin, FireDAC.Comp.DataSet, FireDAC.Comp.Client;<N><N>
unit UnitCadUsuario;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Data.DB, Vcl.Grids,<N>  Vcl.DBGrids, Data.Win.ADODB, Vcl.Mask, Vcl.DBCtrls, Vcl.ExtCtrls;<N><N>
unit UnitConsulta;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Data.DB, Vcl.Grids,<N>  Vcl.DBGrids, Vcl.StdCtrls, Data.Win.ADODB, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS,<N>  FireDAC.Phys.Intf, FireDAC.DApt.Intf, FireDAC.Stan.StorageBin,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client;<N><N>
unit UnitLogin;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.Imaging.pngimage,<N>  Vcl.StdCtrls, Data.DB, Data.Win.ADODB;<N><N>
unit UnitProduto;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.DBCtrls, Vcl.Mask,<N>  Vcl.ExtCtrls, Data.DB, Data.Win.ADODB, Vcl.Grids, Vcl.DBGrids;<N><N>
unit UnitFornecedor;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.Mask, Vcl.DBCtrls,<N>  Data.DB, Vcl.Grids, Vcl.DBGrids, Data.Win.ADODB, Vcl.ExtCtrls;<N><N>
unit UnitTelaSaida;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.Mask, Vcl.DBCtrls,<N>  Vcl.ExtCtrls, Data.DB, Data.Win.ADODB, Vcl.Grids, Vcl.DBGrids,<N>  FireDAC.Stan.Intf, FireDAC.Stan.Option, FireDAC.Stan.Param,<N>  FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, FireDAC.Stan.StorageBin;<N><N>
procedure row(n:integer);<N>begin<N>     if n >=0 then begin<N>        write (n, ' ');<N>        row(n-2)<N>     end;<N>end;<N>begin<N>    row(25);<N>end.
procedure fib (count,v,v0:integer);<N>  begin<N>       if count=0 then Exit;<N>       write(v, ' ');<N>           fib(count-1,v+v0,v);<N>  end;<N>begin<N>  fib(10,1,0);<N>end.
var a,b:longint;<N>    f1,f2:Text;<N>function Nod(x,y:longint):longint;<N>begin<N>  if x<>0 then Nod:=Nod(y mod x,x) else Nod:=y;<N>end;<N>begin<N>read(a,b);<N>writeln(Nod(a,b));<N>end.
unit Rate.DAO;<N><N>interface<N><N>uses<N>  System.SysUtils,<N>  System.Classes,<N>  System.Generics.Collections,<N>  Uni,<N>  Data.Connection,<N>  Rate.Entity;<N><N>type<N>  TRateDao = class<N>    FDataStream: TDataStream;<N>  public<N>    constructor Create(ADataStream: TDataStream); overload;<N>    procedure Insert(ARate: TRateEntity);<N>    function GetByDogId(ADogId: Integer): TArray<TRateEntity>;<N>  end;<N><N>
implementation<N><N>constructor TRateDao.Create(ADataStream: TDataStream);<N>begin<N>  FDataStream := ADataStream;<N>end;<N><N>procedure TRateDao.Insert(ARate: TRateEntity);<N>var<N>  LSQLQuery: TUniQuery;<N>begin<N>  LSQLQuery := nil;<N>  try<N>    LSQLQuery            := TUniQuery.Create(nil);<N>    LSQLQuery.Connection := FDataStream.con;<N><N>
    LSQLQuery.SQL.Add('INSERT INTO rate(rate, dog_id) ' + //<N>      'VALUES (:rate, :dog_id)');<N>    LSQLQuery.ParamByName('rate').AsInteger   := ARate.Rate;<N>    LSQLQuery.ParamByName('dog_id').AsInteger := ARate.DogId;<N><N>    LSQLQuery.Execute;<N>  finally<N>    LSQLQuery.Free;<N>  end;<N>end;<N><N>
unit Data.Connection;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, Data.DB, DBAccess, Uni, MemDS, UniProvider,<N>  MySQLUniProvider;<N><N>type<N>  TDataStream = class(TDataModule)<N>    con: TUniConnection;<N>    query: TUniQuery;<N>    sql: TUniSQL;<N>    dataSource: TUniDataSource;<N>    mysqlnprvdr: TMySQLUniProvider;<N>  end;<N><N>var<N>  DataStream: TDataStream;<N><N>implementation<N><N>{%CLASSGROUP 'Vcl.Controls.TControl'}<N><N>{$R *.dfm}<N><N>end.<N>
﻿unit Dog.Controller;<N><N>interface<N><N>uses<N>  MVCFramework,<N>  MVCFramework.Commons,<N>  MVCFramework.Serializer.Commons;<N><N>type<N><N>  [MVCPath('/api')]<N>  TDogs = class(TMVCController)<N><N>  public<N>    [MVCPath]<N>    [MVCHTTPMethod([httpGET])]<N>    procedure Index;<N><N>
    [MVCPath('/dogs')]<N>    [MVCHTTPMethod([httpGET])]<N>    procedure GetDogs;<N><N>    [MVCPath('/dogs/($id)')]<N>    [MVCHTTPMethod([httpGET])]<N>    procedure getDog(id: String);<N><N>    [MVCPath('/dogs/rate/($id)')]<N>    [MVCHTTPMethod([httpPOST])]<N>    procedure RateDog(id: String);<N><N>
  end;<N><N>implementation<N><N>uses<N>  System.SysUtils,<N>  MVCFramework.Logger,<N>  System.StrUtils,<N>  MVCFramework.RESTClient,<N>  MVCFramework.RESTClient.Intf,<N>  System.JSON,<N>  REST.JSON,<N>  Data.Connection,<N>  Dog.DAO,<N>  Dog.Entity;<N><N>procedure TDogs.Index;<N>begin<N>  render(200, '{"message":"Dog Rating API. =)"}')<N>end;<N><N>
procedure TDogs.GetDogs;<N>var<N>  LAPIClient     : IMVCRESTClient;<N>  LAPIResponse   : TJSONObject;<N>  LDogDAO        : TDogDAO;<N>  LDogEntity     : TDogEntity;<N>  LJsonResponse  : TJSONArray;<N>  LDataConnection: TDataStream;<N>  ArrayElement   : TJSonValue;<N>  LAPISource     : IMVCRESTResponse;<N>  LDogSerialized : TJSONObject;<N><N>
begin<N>  LAPIClient      := nil;<N>  LJsonResponse   := nil;<N>  LDataConnection := nil;<N>  LDogDAO         := nil;<N>  LAPIResponse    := nil;<N>  LAPISource      := nil;<N>  LDogEntity      := nil;<N>  ArrayElement    := nil;<N><N>  try<N>    LDataConnection := TDataStream.Create(nil);<N>    LDogEntity      := TDogEntity.Create;<N>    LDogDAO         := TDogDAO.Create(LDataConnection);<N><N>
unit Main.WebModule;<N><N>interface<N><N>uses<N>  System.SysUtils,<N>  System.Classes,<N>  Web.HTTPApp,<N>  MVCFramework;<N><N>type<N>  TDogRating = class(TWebModule)<N>    procedure WebModuleCreate(Sender: TObject);<N>    procedure WebModuleDestroy(Sender: TObject);<N>  private<N>    FMVC: TMVCEngine;<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  WebModuleClass: TComponentClass = TDogRating;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  System.IOUtils,<N>  MVCFramework.Commons,<N>  MVCFramework.Middleware.ActiveRecord,<N>  MVCFramework.Middleware.StaticFiles,<N>  MVCFramework.Middleware.Analytics,<N>  MVCFramework.Middleware.Trace,<N>  MVCFramework.Middleware.CORS,<N>  MVCFramework.Middleware.ETag,<N>  MVCFramework.Middleware.Compression,<N>  Dog.Controller;<N><N>
unit Rate.entity;<N><N>interface<N>uses<N>  MVCFramework.Serializer.Commons;<N>type TRateEntity = class<N>  private<N>    FIdRate: Integer;<N>    FRate: Integer;<N>    FDogId: Integer;<N><N>  public<N>    [MVCDoNotSerialize]<N>    property IdRate: Integer read FIdRate write FIdRate;<N>    property Rate: Integer read FRate write FRate;<N>    property DogId: Integer read FDogId write FDogId;<N>end;<N><N>implementation<N><N>end.<N>
﻿unit Dog.Controller;<N><N>interface<N><N>uses<N>  MVCFramework,<N>  MVCFramework.Commons,<N>  MVCFramework.Serializer.Commons;<N><N>type<N><N>  [MVCPath('/api')]<N>  TDogs = class(TMVCController)<N><N>  public<N>    [MVCPath]<N>    [MVCHTTPMethod([httpGET])]<N>    procedure Index;<N><N>
    [MVCPath('/dogs')]<N>    [MVCHTTPMethod([httpGET])]<N>    procedure GetDogs;<N><N>    [MVCPath('/dogs/($id)')]<N>    [MVCHTTPMethod([httpGET])]<N>    procedure getDog(id: String);<N><N>    [MVCPath('/dogs/rate/($id)')]<N>    [MVCHTTPMethod([httpPOST])]<N>    procedure RateDog(id: String);<N><N>
  end;<N><N>implementation<N><N>uses<N>  System.SysUtils,<N>  MVCFramework.Logger,<N>  System.StrUtils,<N>  MVCFramework.RESTClient,<N>  MVCFramework.RESTClient.Intf,<N>  System.JSON,<N>  REST.JSON,<N>  Data.Connection,<N>  Dog.DAO,<N>  Dog.Entity,<N>  Data.Source;<N><N>
procedure TDogs.Index;<N>begin<N>  render(200, '{"message":"Dog Rating API. =)"}')<N>end;<N><N>procedure TDogs.GetDogs;<N>var<N>  LAPIResponse   : TJSONObject;<N>  LDogDAO        : TDogDAO;<N>  LDogEntity     : TDogEntity;<N>  LJsonResponse  : TJSONValue;<N>  LDataConnection: TDataStream;<N>  ArrayElement   : TJSonValue;<N>  LAPISource     : IMVCRESTResponse;<N>  LDogSerialized : TJSONObject;<N><N>
  LDataSource: TDataSoruce;<N><N>begin<N>  LJsonResponse   := nil;<N>  LDataConnection := nil;<N>  LDogDAO         := nil;<N>  LAPIResponse    := nil;<N>  LAPISource      := nil;<N>  LDogEntity      := nil;<N>  ArrayElement    := nil;<N><N>  LDataSource := nil;<N><N>
  try<N>    LDataConnection := TDataStream.Create(nil);<N>    LDogEntity      := TDogEntity.Create;<N>    LDogDAO         := TDogDAO.Create(LDataConnection);<N>    LDataSource     := TDataSoruce.Create;<N><N>    if LAPISource.Success then<N>    begin<N>      LJsonResponse := TJSONValue.Create;<N>      LJsonResponse := LDataSource.GetDog;<N><N>
      try<N>        LDogEntity := LDogDAO.FindById(LJsonResponse.GetValue<string>('id'));<N>      except<N>        on E: Exception do<N>        begin<N>          LDogEntity.IdDog   := LJsonResponse.GetValue<string>('id');<N>          LDogEntity.Url     := LJsonResponse.GetValue<string>('url');<N>          LDogEntity.RateNumber := 0;<N>          LDogEntity.Rating     := 0;<N>          LDogDAO.Insert(LDogEntity);<N>        end;<N>      end;<N><N>
      render(201, LDogEntity);<N>    end;<N>  finally<N>    LJsonResponse.Free;<N>    LDataConnection.Free;<N>    LDogDAO.Free;<N>    LAPIResponse.Free;<N>    ArrayElement.Free;<N>  end;<N>end;<N><N>procedure TDogs.getDog(id: String);<N>var<N>  LDataConnection: TDataStream;<N>  LDogDAO        : TDogDAO;<N>  LDogEntity     : TDogEntity;<N><N>
unit Dog.Entity;<N><N>interface<N>uses<N>  MVCFramework.Serializer.Commons;<N>type TDogEntity = class<N>  private<N>    FIdDog: String;<N>    FRateNumber: Integer;<N>    FRating: Double;<N>    FUrl: String;<N>    <N>  public<N>    [MVCDoNotSerialize]<N>    property IdDog: String read FIdDog write FIdDog;<N>    property RateNumber: Integer read FRateNumber write FRateNumber;<N>    property Rating: Double read FRating write FRating;<N>    property Url: String read FUrl write FUrl;<N><N>end;<N><N>implementation<N><N>end.<N>
unit Data.Source;<N><N>interface<N><N>uses<N>  System.SysUtils,<N>  MVCFramework.RESTClient,<N>  MVCFramework.RESTClient.Intf,<N>  System.JSON,<N>  REST.JSON;<N><N>type<N>  TDataSoruce = class<N>    FAPIClient: TMVCRESTClient;<N>  Public<N>    constructor Create(); overload;<N>    function GetDog(): TJSONValue;<N>    destructor Destroy; override;<N>  end;<N><N>
implementation<N><N>constructor TDataSoruce.Create();<N>begin<N>  FAPIClient := TMVCRESTClient.Create;<N>  FAPIClient.BaseURL('https://api.thedogapi.com/v1/');<N>end;<N><N>function TDataSoruce.GetDog(): TJSONValue;<N>Var<N>  LAPIResponse: IMVCRESTResponse;<N>  LJSONArray  : TJSONArray;<N>begin<N>  LJSONArray := nil;<N>  try<N>    LJSONArray := TJSONArray.Create;<N><N>
    LAPIResponse := FAPIClient.Get('images/search');<N>    if not LAPIResponse.Success then<N>      raise Exception.Create('No dogs found =(');<N><N>    LJSONArray := TJSONArray.Create(TJSONObject.ParseJSONValue(LAPIResponse.Content) as TJSONArray);<N><N>    Result := LJSONArray[0];<N>  finally<N>  end;<N><N>
unit Main.WebModule;<N><N>interface<N><N>uses<N>  System.SysUtils,<N>  System.Classes,<N>  Web.HTTPApp,<N>  MVCFramework;<N><N>type<N>  TDogRating = class(TWebModule)<N>    procedure WebModuleCreate(Sender: TObject);<N>    procedure WebModuleDestroy(Sender: TObject);<N>  private<N>    FMVC: TMVCEngine;<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  WebModuleClass: TComponentClass = TDogRating;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses<N>  System.IOUtils,<N>  MVCFramework.Commons,<N>  MVCFramework.Middleware.ActiveRecord,<N>  MVCFramework.Middleware.StaticFiles,<N>  MVCFramework.Middleware.Analytics,<N>  MVCFramework.Middleware.Trace,<N>  MVCFramework.Middleware.CORS,<N>  MVCFramework.Middleware.ETag,<N>  MVCFramework.Middleware.Compression,<N>  Dog.Controller;<N><N>
unit Rate.DAO;<N><N>interface<N><N>uses<N>  System.SysUtils,<N>  System.Classes,<N>  System.Generics.Collections,<N>  Uni,<N>  Data.Connection,<N>  Rate.Entity,<N>  Dog.Entity;<N><N>type<N>  TRateDao = class<N>    FDataStream: TDataStream;<N>  public<N>    constructor Create(ADataStream: TDataStream); overload;<N>    procedure Insert(ARate: TRateEntity);<N>    function GetDogRating(AIdDog: string): TDogEntity;<N>  end;<N><N>
implementation<N><N>constructor TRateDao.Create(ADataStream: TDataStream);<N>begin<N>  FDataStream := ADataStream;<N>end;<N><N>procedure TRateDao.Insert(ARate: TRateEntity);<N>var<N>  LSQLQuery: TUniQuery;<N>begin<N>  LSQLQuery := nil;<N>  try<N>    LSQLQuery            := TUniQuery.Create(nil);<N>    LSQLQuery.Connection := FDataStream.con;<N><N>
    LSQLQuery.SQL.Add('INSERT INTO rate(rate, dog_id) ' + //<N>      'VALUES (:rate, :dog_id)');<N>    LSQLQuery.ParamByName('rate').AsInteger  := ARate.Rate;<N>    LSQLQuery.ParamByName('id_dog').AsString := ARate.IdDog;<N><N>    LSQLQuery.Execute;<N>  finally<N>    LSQLQuery.Free;<N>  end;<N>end;<N><N>
function TRateDao.GetDogRating(AIdDog: String): TDogEntity;<N>var<N>  LSQLQuery: TUniQuery;<N>begin<N>  try<N>    LSQLQuery            := TUniQuery.Create(nil);<N>    LSQLQuery.Connection := FDataStream.con;<N>    LSQLQuery.SQL.Add('SELECT AVG(rate) AS rating, COUNT(id_dog) AS rate_number FROM rate WHERE id_dog = :id_dog;');<N>    LSQLQuery.ParamByName('id_dog').AsString := AIdDog;<N>    LSQLQuery.Execute;<N>    LSQLQuery.Open;<N><N>
    if LSQLQuery.IsEmpty then<N>      raise Exception.Create('Id not Found');<N><N>    Result := TDogEntity.Create;<N>    Result.RateNumber := LSQLQuery.FieldByName('rate_number').AsInteger;<N>    Result.Rating := LSQLQuery.FieldByName('rating').AsCurrency;<N>  finally<N>    LSQLQuery.Free;<N>  end;<N>end;<N><N>
unit Rate.Entity;<N><N>interface<N>uses<N>  MVCFramework.Serializer.Commons;<N>type TRateEntity = class<N>  private<N>    FIdRate: Integer;<N>    FRate: Integer;<N>    FIdDog: String;<N><N>  public<N>    property IdRate: Integer read FIdRate write FIdRate;<N>    property Rate: Integer read FRate write FRate;<N>    property IdDog: String read FIdDog write FIdDog;<N><N>end;<N><N>implementation<N><N>end.<N>
unit Data.Connection;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, Data.DB, DBAccess, Uni, MemDS, UniProvider,<N>  MySQLUniProvider;<N><N>type<N>  TDataStream = class(TDataModule)<N>    con: TUniConnection;<N>    query: TUniQuery;<N>    sql: TUniSQL;<N>    dataSource: TUniDataSource;<N>    mysqlnprvdr: TMySQLUniProvider;<N>  end;<N><N>var<N>  DataStream: TDataStream;<N><N>implementation<N><N>{%CLASSGROUP 'Vcl.Controls.TControl'}<N><N>{$R *.dfm}<N><N>end.<N>
﻿procedure abc (n : integer);<N>  begin<N>  <N>  if n >= 0 then begin <N>  write(n,' ');<N>  abc(n - 2);<N>  end;<N>  end;<N>begin<N>abc(25);<N>write(0);<N>end.
﻿var a, b, c, d: integer;<N>function NOD(m, n: integer): integer;<N>var gunther: integer;<N>begin<N>gunther := m mod n;<N>if gunther = 0 then<N>NOD := n<N>else<N>NOD := NOD (n, gunther)<N>end;<N>begin<N>write('Введите числа: ');<N>readln(a, b);<N>d := NOD(a, b);<N>writeln('НОД Евклида = ', d);<N>end.
﻿procedure fib(i,n:integer);<N>begin<N>  write(i,' ');<N>  if i >= 21 then Exit;<N>  <N>  fib(i+n,i);<N>end;<N> <N>begin<N>  fib(1,1);<N>end.
﻿procedure FakeFor(s:string; i:integer; n: integer);<N>begin<N>writeln(s);<N>if i<n then FakeFor(s,i+1,n);<N>end;<N>begin<N>FakeFor('Привет',1,5);<N>end.
﻿var x,y: integer;<N>function stepen (a,b: integer):integer;<N>begin<N>  if b = 0 then  stepen:=1<N>  else stepen:= stepen(a,b-1)*a;<N>  end;<N>begin<N>  writeln('число?');<N>  readln(x);<N>  writeln('степень?');<N>  readln(y);<N>  writeln(stepen(x,y));<N>end.
﻿var x: integer;<N>   function fact (a: integer): integer;<N>   begin<N>        if (a<=1) then<N>          a:=1<N>        else<N>          a:=a+(fact(a-1));<N>   fact:=a;<N>end;<N>begin<N>writeln('Число?');<N>readln(x);<N>writeln(fact(x));<N>end.
unit uFormMensagem;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ComCtrls;<N><N>type<N>  TFormMensagem = class(TForm)<N>    RichEditMensagem: TRichEdit;<N>    procedure FormCreate(Sender: TObject);<N>    procedure FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N><N>
  end;<N><N>var<N>  FormMensagem: TFormMensagem;<N><N>implementation<N><N>{$R *.dfm}<N><N>procedure TFormMensagem.FormCreate(Sender: TObject);<N>begin<N>   Self.Caption := 'Mensagem';<N>   Self.Position := poDesktopCenter;<N>   Self.KeyPreview := true;<N>   Self.BorderIcons := Self.BorderIcons - [biMinimize];<N><N>
   RichEditMensagem.Clear();<N>   RichEditMensagem.Align := alClient;<N>   RichEditMensagem.ReadOnly := true;<N><N>end;<N><N>procedure TFormMensagem.FormKeyDown(Sender: TObject; var Key: Word;<N>  Shift: TShiftState);<N>begin<N>   if (Key = VK_ESCAPE) then Close;<N><N>
unit CEPController;<N><N>interface<N>uses<N>   System.Generics.Collections,<N>   CEPModel,<N>   CEPDAO;<N><N>type<N>   TCEPController = class<N>   private<N>      FMensagem: string;<N><N>   public<N>      property Mensagem: string read FMensagem write FMensagem;<N><N>
      function Get(var oCEPModel: TObjectList<TCEPModel>): boolean;<N>      function Insert(oCEPModel: TCEPModel): boolean;<N><N>end;<N><N>implementation<N><N>function TCEPController.Get(var oCEPModel: TObjectList<TCEPModel>): boolean;<N>var<N>   oCEPDAO : TCEPDAO;<N>begin<N>   oCEPDAO := TCEPDAO.Create();<N>   Result := oCEPDAO.Get(oCEPModel);<N><N>
unit CEPDAO;<N><N>interface<N>uses<N>   System.SysUtils, System.Classes, System.Types,<N>   System.Generics.Collections,<N>   uDM, Data.DB, CEPModel;<N><N>type<N>   TCEPDAO = class<N>   private<N>      FMensagem: string;<N><N>   public<N>      property Mensagem: string read FMensagem write FMensagem;<N><N>
      function Get(var oCEPModel: TObjectList<TCEPModel>): boolean;<N>      function Insert(oCEPModel: TCEPModel): boolean;<N><N>end;<N><N>implementation<N><N>function TCEPDAO.Get(var oCEPModel: TObjectList<TCEPModel>): boolean;<N>var<N>   oDados : TDataSet;<N>   oDataModuleBD : TDataModuleBD;<N>   iTally: integer;<N>begin<N>   Result := false;<N>   FMensagem := '';<N>   oCEPModel := nil;<N><N>
unit uDM;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf, FireDAC.Stan.Def,<N>  FireDAC.Phys, FireDAC.Stan.Param, FireDAC.DatS, FireDAC.DApt.Intf,<N>  FireDAC.Stan.Async, FireDAC.DApt, Data.DB, FireDAC.Comp.DataSet,<N>  FireDAC.Comp.Client, FireDAC.Phys.PGDef, FireDAC.Phys.PG, FireDAC.Stan.Pool,<N>  FireDAC.VCLUI.Wait;<N><N>
type<N>  TDataModuleBD = class(TDataModule)<N>    FDConexao: TFDConnection;<N>    FDPhysPgDriverLink1: TFDPhysPgDriverLink;<N>  private<N>    { Private declarations }<N>    FMensagem: string;<N><N>  public<N>     { Public declarations }<N>     property Mensagem: string read FMensagem write FMensagem;<N>     function Conectar(): boolean;<N>     procedure DesConectar();<N><N>
  end;<N><N>var<N>  DataModuleBD: TDataModuleBD;<N><N>implementation<N><N>{%CLASSGROUP 'Vcl.Controls.TControl'}<N><N>{$R *.dfm}<N><N>function TDataModuleBD.Conectar(): boolean;<N>begin<N>   Result := false;<N>   FMensagem := '';<N>   if (not FDConexao.Connected) then begin<N>      try<N>         FDConexao.Connected := true;<N>         Result := true;<N><N>
unit ClientesDAO;<N><N>interface<N>uses<N>   System.SysUtils, System.Classes, System.Generics.Collections,<N>   uDM, ClientesModel;<N><N>type<N>   TClientesDAO = class<N>   private<N>      FMensagem: string;<N><N>   public<N>      property Mensagem: string read FMensagem write FMensagem;<N><N>
      function Delete(oClientesModel: TClientesModel): boolean;<N>      function Insert(oClientesModel: TClientesModel): boolean;<N>      function InsertLote(oClientesModel: TObjectList<TClientesModel>): boolean;<N>      function UpDate(oClientesModel: TClientesModel): boolean;<N><N>
unit uRestAPI;<N><N>interface<N><N>uses<N>   REST.Types, REST.Client, REST.Json, Data.Bind.Components,<N>   Data.Bind.ObjectScope,<N>   CEPModel;<N><N>procedure Executar(sURL: string; var oCEPModel: TCEPModel);<N><N>implementation<N><N>var<N>    RESTClient: TRESTClient;<N>    RESTRequest: TRESTRequest;<N>    RESTResponse: TRESTResponse;<N><N>
<N>procedure Executar(sURL: string; var oCEPModel: TCEPModel);<N>var<N>   oJSON: TJson;<N>   sJSON: string;<N>begin<N>   oCEPModel := nil;<N>   RESTClient := TRESTClient.Create(nil);<N>   oJSON := TJson.Create();<N>   try<N>      RESTClient.BaseURL := sURL;<N>      RESTClient.ContentType := 'application/json';<N><N>
      RESTRequest := TRESTRequest.Create(nil);<N>      RESTResponse := TRESTResponse.Create(nil);<N><N>      RESTRequest.Client := RESTClient;<N>      RESTRequest.Response := RESTResponse;<N><N>      RESTRequest.Execute;<N>      sJSON := RESTResponse.Content;<N>      if (sJSON <> '') then begin<N>         //oCEPModel := TCEPModel.Create();<N><N>
unit TelaInicial;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs;<N><N>type<N>  TForm1 = class(TForm)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form1: TForm1;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit U_CadastroCidades;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, U_FormMain, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS,<N>  FireDAC.Phys.Intf, FireDAC.DApt.Intf, FireDAC.Stan.Async, FireDAC.DApt,<N>  Data.DB, FireDAC.Comp.Client, FireDAC.Comp.DataSet, Vcl.StdCtrls, Vcl.Buttons,<N>  Vcl.ExtCtrls, Vcl.Mask, Vcl.DBCtrls;<N><N>
type<N>  Tfrm_CadatroCidade = class(Tfrm_Principal)<N>    fd_QueryCadastroCONTROLE_CIDADE: TFDAutoIncField;<N>    fd_QueryCadastroNOME: TStringField;<N>    fd_QueryCadastroUF: TStringField;<N>    Label1: TLabel;<N>    txt_controle: TDBEdit;<N>    Label2: TLabel;<N>    txt_nomecidade: TDBEdit;<N>    Label3: TLabel;<N>    txt_UF: TDBEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit U_CadastroClientes;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, U_FormMain, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS,<N>  FireDAC.Phys.Intf, FireDAC.DApt.Intf, FireDAC.Stan.Async, FireDAC.DApt,<N>  FireDAC.Comp.Client, Data.DB, FireDAC.Comp.DataSet, Vcl.StdCtrls, Vcl.Buttons,<N>  Vcl.ExtCtrls, Vcl.DBCtrls, Vcl.Mask;<N><N>
unit U_FormMain;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.Buttons, Vcl.ExtCtrls,<N>  FireDAC.Stan.Intf, FireDAC.Stan.Option, FireDAC.Stan.Param,<N>  FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf,<N>  FireDAC.Stan.Async, FireDAC.DApt, FireDAC.Comp.Client, Data.DB,<N>  FireDAC.Comp.DataSet;<N><N>
{<N>This script should be applied to armor records to create a tempering recipe.<N>Adds item for temper based on keyword if item has ArmorMaterialIron  it will add IronIngot.<N>it will add the ArcaneBlacksmith perk as a requirements for all recipes, but this condition works only works for enchanted items.<N>}<N><N>
unit SK_Temperator;<N><N>uses SK_UtilsRemake;<N><N>// runs on script start<N>function Initialize: integer;<N>begin<N>  AddMessage('---Make armor temperable start---');<N>  Result := 0;<N>end;<N><N>// for every record selected in xEdit<N>function Process(selectedRecord: IInterface): integer;<N>var<N>recordSignature: string;<N>begin<N>recordSignature := Signature(selectedRecord);<N><N>
    // filter selected records, which are not valid<N>    // NOTE: only weapons and armors are exepted, for now<N>if not ((recordSignature = 'WEAP') or (recordSignature = 'ARMO')) then<N>exit;<N><N>makeTemperable(selectedRecord);<N><N>Result := 0;<N>end;<N><N>
unit Tributos;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes;<N><N>type<N>  TDTTributos = class(TComponent)<N>  private<N>    { Private declarations }<N>  protected<N>    { Protected declarations }<N>  public<N>    { Public declarations }<N>  published<N>    { Published declarations }<N>  end;<N><N>procedure Register;<N><N>implementation<N><N>procedure Register;<N>begin<N>  RegisterComponents('DT Inovacao', [TDTTributos]);<N>end;<N><N>end.<N>
unit Unit5;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, CalculoTributario, Data.DB, Vcl.Grids,<N>  Vcl.DBGrids, JvExDBGrids, JvDBGrid, Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.Mask,<N>  JvExMask, JvToolEdit, JvBaseEdits;<N><N>
unit Test;<N><N>// Interface<N>interface<N><N>uses<N>  DUnitX.TestFramework;<N><N>type<N>  [TestFixture]<N>  Setup = class<N>  public<N>    // Sample Methods<N>    [Setup]<N>    procedure Setup;<N>    [TearDown]<N>    procedure TearDown;<N>    // Simple single Test<N>    [Test]<N>    procedure SetupIsOK;<N>  end;<N><N><N>//Implementation<N>implementation<N><N>procedure Setup.Setup;<N>begin<N>end;<N><N>procedure Setup.TearDown;<N>begin<N>end;<N><N>procedure Setup.SetupIsOK;<N>begin<N>  Assert.Pass();<N>end;<N><N>initialization<N>  TDUnitX.RegisterTestFixture(Setup);<N><N>end.<N>
{ -----------------------------------------------------------------------------<N>    This program is free software: Under statement of join file README - LGPL.txt<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
unit constraintSimple.fmain;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects,<N>  FMX.Controls.Presentation, FMX.StdCtrls, System.Math,<N>  GS.Geometry.Direction;<N><N>
unit ULogin;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.StdCtrls,<N>  Vcl.Imaging.pngimage, UCadastro, Data.DB, Data.Win.ADODB, UPrincipal;<N><N>
unit UDados;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, Vcl.Menus, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf,<N>  FireDAC.Stan.Def, FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys,<N>  FireDAC.VCLUI.Wait, Data.DB, FireDAC.Comp.Client, FireDAC.Phys.FB,<N>  FireDAC.Phys.FBDef, Data.Win.ADODB, FireDAC.Phys.MSAcc, FireDAC.Phys.MSAccDef,<N>  FireDAC.Phys.MySQLDef, FireDAC.Comp.UI, FireDAC.Phys.MySQL;<N><N>
type<N>  TdmDados = class(TDataModule)<N>    adoConexao: TADOConnection;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  dmDados: TdmDados;<N><N>implementation<N><N>{%CLASSGROUP 'Vcl.Controls.TControl'}<N><N>
// UltraStar Deluxe - Karaoke Game<N>// SPDX-License-Identifier: GPL-2.0-or-later<N><N>unit UAudioInput_SDL;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>{$I ../switches.inc}<N><N>uses<N>  Classes,<N>  SysUtils,<N>  UMusic;<N><N>implementation<N><N>
uses<N>  sdl2,<N>  ctypes,<N>  math,<N>  UIni,<N>  ULog,<N>  URecord;<N><N>type<N>  TAudioInput_SDL = class(TAudioInputBase)<N>    private<N>      Initialized: boolean;<N>      function EnumDevices(): boolean;<N>    public<N>      function GetName: string; override;<N>      function InitializeRecord: boolean; override;<N>      function FinalizeRecord: boolean; override;<N>  end;<N><N>
  TSDLInputDevice = class(TAudioInputDevice)<N>    private<N>      DevID:   TSDL_AudioDeviceID;<N>      UseName: boolean;<N>    public<N>      function Start(): boolean; override;<N>      function Stop():  boolean; override;<N><N>      function GetVolume(): single;        override;<N>      procedure SetVolume(Volume: single); override;<N>  end;<N><N>
procedure MicrophoneCallback(inputDevice: TSDLInputDevice; input: pointer; len: cint); cdecl;<N>begin<N>  AudioInputProcessor.HandleMicrophoneData(input, len, inputDevice);<N>end;<N><N>function TSDLInputDevice.Start(): boolean;<N>var<N>  devName: PChar;<N>  spec:    TSDL_AudioSpec;<N>begin<N>  Result := false;<N><N>
  if DevID <= 0 then<N>  begin<N>    FillChar(spec, SizeOf(spec), 0);<N>    with spec do<N>    begin<N>      freq := Round(AudioFormat.SampleRate);<N>      format := AUDIO_S16SYS;<N>      channels := AudioFormat.Channels;<N>      callback := @MicrophoneCallback;<N>      userdata := pointer(Self);<N><N>
      samples := 0;<N>      if Ini.InputDeviceConfig[CfgIndex].Latency > 0 then<N>        samples := 1 shl Round(Max(Log2(freq / 1000 * Ini.InputDeviceConfig[CfgIndex].Latency), 0));<N>    end;<N><N>    devName := nil;<N>    if UseName then<N>      devName := PChar(Name);<N><N>
    DevID := SDL_OpenAudioDevice(devName, 1, @spec, @spec, 0);<N>    if DevID > 0 then<N>    begin<N>      if Ini.InputDeviceConfig[CfgIndex].Latency > 0 then<N>        Log.LogStatus('InputDevice "' + Name + '" opened with ' +<N>                      IntToStr(spec.samples) + ' samples (' +<N>                      IntToStr(round(spec.samples * 1000 / spec.freq)) +<N>                      'ms) buffer', 'SDL');<N>      SDL_PauseAudioDevice(DevID, 0);<N>    end;<N>  end;<N><N>
  Result := (DevID > 0);<N>end;<N><N>function TSDLInputDevice.Stop(): boolean;<N>begin<N>  SDL_CloseAudioDevice(DevID);<N>  DevID := 0;<N>  Result := true;<N>end;<N><N>function TSDLInputDevice.GetVolume(): single;<N>begin<N>  Result := 0;<N>end;<N><N>procedure TSDLInputDevice.SetVolume(Volume: single);<N>begin<N>end;<N><N>
function TAudioInput_SDL.GetName: String;<N>begin<N>  Result := 'SDL';<N>  if SDL_WasInit(SDL_INIT_AUDIO) <> 0 then<N>    Result := Result + ' (' + SDL_GetCurrentAudioDriver + ')';<N>end;<N><N>function TAudioInput_SDL.EnumDevices(): boolean;<N>var<N>  i:            integer;<N>  deviceIndex:  integer;<N>  maxDevices:   integer;<N>  name:         PChar;<N>  device:       TSDLInputDevice;<N>  spec:         TSDL_AudioSpec;<N>  dev:          TSDL_AudioDeviceID;<N>begin<N>  Result := false;<N><N>
  Log.LogInfo('Using ' + SDL_GetCurrentAudioDriver + ' driver', 'SDL');<N><N>  maxDevices := SDL_GetNumAudioDevices(1);<N>  if maxDevices < 1 then<N>    maxDevices := 1;<N><N>  // init array-size to max. input-devices count<N>  SetLength(AudioInputProcessor.DeviceList, maxDevices);<N><N>
  deviceIndex := 0;<N>  for i := 0 to High(AudioInputProcessor.DeviceList) do<N>  begin<N>    name := SDL_GetAudioDeviceName(i, 1);<N>    if (name = nil) and (i > 0) then<N>      break;<N><N>    FillChar(spec, SizeOf(spec), 0);<N>    with spec do<N>    begin<N>      freq := 44100;<N>      format := AUDIO_S16SYS;<N>      channels := 0; // override with SDL_AUDIO_CHANNELS<N>      samples := 0;<N>    end;<N><N>
    dev := SDL_OpenAudioDevice(name, 1, @spec, @spec, SDL_AUDIO_ALLOW_FREQUENCY_CHANGE or SDL_AUDIO_ALLOW_CHANNELS_CHANGE);<N>    if dev < 1 then<N>      continue;<N><N>    SDL_CloseAudioDevice(dev);<N><N>    device := TSDLInputDevice.Create();<N>    device.Name := DEFAULT_SOURCE_NAME;<N>    device.UseName := false;<N>    if name <> nil then<N>    begin<N>      device.Name := name;<N>      device.UseName := true;<N>    end;<N><N>
    device.MicSource := -1;<N>    device.SourceRestore := -1;<N>    SetLength(device.Source, 1);<N>    device.Source[0].Name := DEFAULT_SOURCE_NAME;<N><N>    // create audio-format info and resize capture-buffer array<N>    device.AudioFormat := TAudioFormatInfo.Create(<N>        spec.channels,<N>        spec.freq,<N>        asfS16<N>    );<N>    SetLength(device.CaptureChannel, device.AudioFormat.Channels);<N><N>
    Log.LogStatus('InputDevice "' + device.Name + '"@' +<N>        IntToStr(device.AudioFormat.Channels) + 'x' +<N>        FloatToStr(device.AudioFormat.SampleRate) + 'Hz ' +<N>        'defaults to ' + IntToStr(spec.samples) + ' samples buffer',<N>        'SDL');<N><N>
    AudioInputProcessor.DeviceList[deviceIndex] := device;<N>    Inc(deviceIndex);<N>  end;<N><N>  // adjust size to actual input-device count<N>  SetLength(AudioInputProcessor.DeviceList, deviceIndex);<N>  Log.LogStatus('#Input-Devices: ' + IntToStr(deviceIndex), 'SDL');<N>  Result := (deviceIndex > 0);<N>end;<N><N>
function TAudioInput_SDL.InitializeRecord(): boolean;<N>begin<N>  Result := false;<N><N>  if SDL_InitSubSystem(SDL_INIT_AUDIO) = -1 then<N>    Exit;<N><N>  Initialized := true;<N>  Result := EnumDevices();<N>end;<N><N>function TAudioInput_SDL.FinalizeRecord: boolean;<N>begin<N>  CaptureStop;<N>  if Initialized then<N>  begin<N>    SDL_QuitSubSystem(SDL_INIT_AUDIO);<N>    Initialized := false;<N>  end;<N>  Result := inherited FinalizeRecord();<N>end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UAudioPlayback_SoftMixer;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  Classes,<N>  sdl2,<N>  SysUtils,<N>  URingBuffer,<N>  UMusic,<N>  UAudioPlaybackBase;<N><N>type<N>  TAudioPlayback_SoftMixer = class;<N><N>  TGenericPlaybackStream = class(TAudioPlaybackStream)<N>    private<N>      Engine: TAudioPlayback_SoftMixer;<N>      LastReadSize: integer;  // size of data returned by the last ReadData() call<N>      LastReadTime: Cardinal; // time of the last ReadData() call<N><N>
      SampleBuffer:      PByteArray;<N>      SampleBufferSize:  integer;<N>      SampleBufferCount: integer; // number of available bytes in SampleBuffer<N>      SampleBufferPos:   integer;<N><N>      SourceBuffer:      PByteArray;<N>      SourceBufferSize:  integer;<N>      SourceBufferCount: integer; // number of available bytes in SourceBuffer<N><N>
      Converter: TAudioConverter;<N>      Status:    TStreamStatus;<N>      InternalLock: PSDL_Mutex;<N>      SoundEffects: TList;<N>      fVolume: single;<N><N>      FadeInStartTime, FadeInTime: cardinal;<N>      FadeInStartVolume, FadeInTargetVolume: single;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenTop5;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  SysUtils,<N>  sdl2,<N>  UDisplay,<N>  ULanguage,<N>  ULog,<N>  UMenu,<N>  UMusic,<N>  USongs,<N>  UThemes;<N><N>type<N>  TScreenTop5 = class(TMenu)<N>    public<N>      TextLevel:       integer;<N>      TextArtistTitle: integer;<N>      DifficultyShow:  integer;<N><N>
      StaticNumber:    array[1..5] of integer;<N>      TextNumber:      array[1..5] of integer;<N>      TextName:        array[1..5] of integer;<N>      TextScore:       array[1..5] of integer;<N>      TextDate:        array[1..5] of integer;<N><N>      Fadeout:         boolean;<N><N>
      constructor Create; override;<N>      function ParseInput(PressedKey: cardinal; CharCode: UCS4Char; PressedDown: boolean): boolean; override;<N>      function ParseMouse(MouseButton: integer; BtnDown: boolean; X, Y: integer): boolean; override;<N>      procedure OnShow; override;<N>      procedure DrawScores(difficulty: integer);<N>      function Draw: boolean; override;<N>  end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenPartyPlayer;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  UCommon,<N>  UMenu,<N>  ULog,<N>  sdl2,<N>  UDisplay,<N>  UMusic,<N>  UNote,<N>  UFiles,<N>  SysUtils,<N>  UScreenSingController,<N>  UScreenPartyNewRound,<N>  UScreenPartyWin,<N>  UScreenPartyScore,<N>  UThemes;<N><N>type<N>  TScreenPartyPlayer = class(TMenu)<N>    private<N>      CountTeams: integer;<N>      CountPlayer: array [0..2] of integer;<N><N>
      SelectTeams:     cardinal;<N>      SelectPlayers: array [0..2] of cardinal;<N>      procedure UpdateInterface;<N>      procedure UpdateParty;<N>    public<N>      Team1Name: cardinal;<N>      Player1Name: cardinal;<N>      Player2Name: cardinal;<N>      Player3Name: cardinal;<N>      Player4Name: cardinal;<N><N>
      Team2Name: cardinal;<N>      Player5Name: cardinal;<N>      Player6Name: cardinal;<N>      Player7Name: cardinal;<N>      Player8Name: cardinal;<N><N>      Team3Name: cardinal;<N>      Player9Name: cardinal;<N>      Player10Name: cardinal;<N>      Player11Name: cardinal;<N>      Player12Name: cardinal;<N><N>
      constructor Create; override;<N>      function ParseInput(PressedKey: cardinal; CharCode: UCS4Char; PressedDown: boolean): boolean; override;<N>      procedure OnShow; override;<N><N>      procedure SetAnimationProgress(Progress: real); override;<N>      function NoRepeatColors(ColorP:integer; Interaction:integer; Pos:integer):integer;<N>      procedure TeamColorButton(K: integer; Interact: integer);<N><N>
  end;<N><N>const<N>  ITeams:   array[0..1] of UTF8String = ('2', '3');<N>  IPlayers: array[0..3] of UTF8String = ('1', '2', '3', '4');<N><N>implementation<N><N>uses<N>  UAvatars,<N>  UGraphic,<N>  UMain,<N>  UIni,<N>  UTexture,<N>  UParty,<N>  UUnicodeUtils,<N>  UScreenPartyOptions,<N>  ULanguage;<N><N>
var<N>  Num: array[0..2]of integer;<N><N>procedure TScreenPartyPlayer.UpdateInterface;<N>  var<N>    I: integer;<N>    Btn: integer;<N>begin<N>  SelectsS[SelectPlayers[2]].Visible := (CountTeams = 1);<N><N>  Btn := 0;<N>  for I := 0 to 2 do<N>  begin<N>    TeamColorButton(Num[I], I);<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UScreenScore;<N><N>interface<N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N>{$I switches.inc}<N><N>
uses<N>  UCommon,<N>  UMenu,<N>  sdl2,<N>  SysUtils,<N>  UDataBase,<N>  UDisplay,<N>  UMusic,<N>  USongs,<N>  UThemes,<N>  dglOpenGL,<N>  math,<N>  UTexture,<N>  UIni,<N>  UDLLManager,<N>  UWebSDK;<N><N>const<N>  ZBars:            real = 0.8;   // Z value for the bars<N>  ZRatingPic:       real = 0.8;   // Z value for the rating pictures<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenOptionsThemes;<N><N>interface<N><N>{$MODE OBJFPC}<N><N>{$I switches.inc}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenStatDetail;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$mode objfpc}//{$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  UMenu,<N>  sdl2,<N>  SysUtils,<N>  UDisplay,<N>  UMusic,<N>  UIni,<N>  UDataBase,<N>  UThemes;<N><N>type<N>  TScreenStatDetail = class(TMenu)<N>    public<N>      Typ:  TStatType;<N>      Page: cardinal;<N>      Count: byte;<N>      Reversed: boolean;<N><N>
      TotEntrys: cardinal;<N>      TotPages:  cardinal;<N><N>      constructor Create; override;<N>      function ParseInput(PressedKey: cardinal; CharCode: UCS4Char; PressedDown: boolean): boolean; override;<N>      procedure OnShow; override;<N>      procedure SetAnimationProgress(Progress: real); override;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenOptionsProfiles;<N><N>interface<N><N>{$MODE OBJFPC}<N><N>{$I switches.inc}<N><N>
uses<N>  UCommon,<N>  sdl2,<N>  UMenu,<N>  UDisplay,<N>  UMusic,<N>  UFiles,<N>  UIni,<N>  UThemes;<N><N>type<N><N>  TScreenOptionsProfiles = class(TMenu)<N>    public<N>      constructor Create; override;<N>      function ParseInput(PressedKey: cardinal; CharCode: UCS4Char; PressedDown: boolean): boolean; override;<N>      procedure OnShow; override;<N>  end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenOptionsGame;<N><N>interface<N><N>{$MODE OBJFPC}<N><N>{$I switches.inc}<N><N>
uses<N>  sdl2,<N>  UMenu,<N>  UUnicodeUtils;<N><N>type<N>  TScreenOptionsGame = class(TMenu)<N>    private<N>      Language, SongMenu: integer; static;<N>      procedure ReloadScreen();<N>      procedure ReloadScreens();<N>    protected<N>      // interaction IDs<N>      ButtonExitIID: integer;<N>    public<N>      constructor Create; override;<N>      function ParseInput(PressedKey: cardinal; CharCode: UCS4Char; PressedDown: boolean): boolean; override;<N>      procedure OnShow; override;<N>  end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenPartyOptions;<N><N>interface<N><N>{$MODE OBJFPC}<N><N>{$I switches.inc}<N><N>
uses<N>  UScreenJukeboxPlaylist;<N><N>type<N>  TScreenPartyOptions = class(UScreenJukeboxPlaylist.TScreenJukeboxPlaylist)<N>    private<N>      SelectMode: cardinal;<N>      Mode: integer;<N>    protected<N>      procedure SetPlaylistsItems();<N>    public<N>      constructor CreateExtra(); override;<N>      function ParseInput(PressedKey: cardinal; CharCode: UCS4Char; PressedDown: boolean): boolean; override;<N>      procedure OnShow; override;<N>  end;<N><N>
implementation<N><N>uses<N>  sdl2,<N>  UDisplay,<N>  UGraphic,<N>  UIni,<N>  ULanguage,<N>  UMusic,<N>  UParty,<N>  UPlaylist,<N>  UScreenPartyNewRound,<N>  UScreenPartyScore,<N>  UScreenPartyWin,<N>  UScreenPartyPlayer,<N>  UScreenPartyRounds,<N>  UScreenPartyTournamentRounds,<N>  UScreenPartyTournamentPlayer,<N>  UScreenPartyTournamentOptions,<N>  UScreenPartyTournamentWin,<N>  USong,<N>  USongs,<N>  UThemes,<N>  UUnicodeUtils;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenPartyTournamentPlayer;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  UMenu,<N>  sdl2,<N>  UDisplay,<N>  UMusic,<N>  UFiles,<N>  UPartyTournament,<N>  SysUtils,<N>  ULog,<N>  UThemes;<N><N>type<N>  TScreenPartyTournamentPlayer = class(TMenu)<N>    private<N>      SelectPlayers: cardinal;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenPlayerSelector;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenPartyTournamentWin;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  sdl2,<N>  SysUtils,<N>  UCommon,<N>  UMenu,<N>  UDisplay,<N>  UMusic,<N>  UIni,<N>  UThemes;<N><N>type<N>  TScreenPartyTournamentWin = class(TMenu)<N>    public<N>      TextScorePlayer1:    cardinal;<N>      TextScorePlayer2:    cardinal;<N><N>
      TextNamePlayer1:     cardinal;<N>      TextNamePlayer2:     cardinal;<N><N>      StaticBGPlayer1:     cardinal;<N>      StaticBGPlayer2:     cardinal;<N><N>      constructor Create; override;<N>      function ParseInput(PressedKey: cardinal; CharCode: UCS4Char; PressedDown: boolean): boolean; override;<N>      procedure OnShow; override;<N>      procedure UpdateRounds;<N>      procedure SetAnimationProgress(Progress: real); override;<N>  end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenOptionsLyrics;<N><N>interface<N><N>{$MODE OBJFPC}<N><N>{$I switches.inc}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenMain;<N><N>interface<N><N>{$MODE OBJFPC}<N><N>{$I switches.inc}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenJukebox;<N><N>interface<N><N>{$MODE OBJFPC}<N><N>{$I switches.inc}<N><N>
uses<N>  SysUtils,<N>  sdl2,<N>  TextGL,<N>  dglOpenGL,<N>  UCommon,<N>  UDataBase,<N>  UFiles,<N>  UGraphicClasses,<N>  UIni,<N>  ULog,<N>  ULyrics,<N>  UMenu,<N>  UMusic,<N>  UPlaylist,<N>  USingScores,<N>  USongs,<N>  UTexture,<N>  UThemes,<N>  UPath,<N>  UTime,<N>  UHookableEvent,<N>  UVideo,<N>  UWebcam;<N><N>
type<N>  TSongJukebox = class<N>  public<N>    Id: integer;<N><N>    // sorting methods<N>    Genre:      UTF8String;<N>    Edition:    UTF8String;<N>    Language:   UTF8String;<N>    Year:       Integer;<N><N>    Title:      UTF8String;<N>    Artist:     UTF8String;<N><N>
  end;<N><N>  THandler = record<N>    changed:  boolean;<N>    change_time:  real;<N>  end;<N><N>  TLyricsSyncSource = class(TSyncSource)<N>    function GetClock(): real; override;<N>  end;<N><N>  TMusicSyncSource = class(TSyncSource)<N>    function GetClock(): real; override;<N>  end;<N><N>
  TTimebarMode = (<N>    tbmCurrent,   // current song position<N>    tbmRemaining, // remaining time<N>    tbmTotal      // total time<N>  );<N><N>type<N>  TScreenJukebox = class(TMenu)<N>  private<N>    // move song<N>    MoveX, MoveY: real;<N>    MoveInicial, MoveFinal: integer;<N>    MoveSong: boolean;<N><N>
    // items<N>    JukeboxStaticTimeProgress:       integer;<N>    JukeboxStaticTimeBackground:     integer;<N>    JukeboxStaticSongBackground:     integer;<N>    JukeboxStaticSongListBackground: integer;<N>    SongDescription:  array[0..9] of integer;<N>    SongDescriptionClone: integer;<N><N>
    JukeboxStaticActualSongStatic: array of integer;<N>    JukeboxStaticActualSongCover:           integer;<N>    JukeboxTextActualSongArtist:            integer;<N>    JukeboxTextActualSongTitle:             integer;<N><N>    JukeboxSongListUp:   integer;<N>    JukeboxSongListDown: integer;<N><N>
    // Jukebox SongMenu items<N>    JukeboxSongMenuPlayPause:            integer;<N>    JukeboxSongMenuPlaylist:             integer;<N>    JukeboxSongMenuOptions:              integer;<N>    JukeboxSongMenuNext:                 integer;<N>    JukeboxSongMenuPrevious:             integer;<N>    JukeboxStaticSongMenuTimeProgress:   integer;<N>    JukeboxStaticSongMenuTimeBackground: integer;<N>    JukeboxTextSongMenuTimeText:         integer;<N>    JukeboxStaticSongMenuBackground:     integer;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenOptionsAdvanced;<N><N>interface<N><N>{$MODE OBJFPC}<N><N>{$I switches.inc}<N><N>
uses<N>  UCommon,<N>  sdl2,<N>  UMenu,<N>  UDisplay,<N>  UMusic,<N>  UFiles,<N>  UIni,<N>  UThemes;<N><N>type<N><N>  TScreenOptionsAdvanced = class(TMenu)<N>   protected<N>      // interaction IDs<N>	  ButtonExitIID: integer;<N><N>    public<N>      constructor Create; override;<N>      function ParseInput(PressedKey: cardinal; CharCode: UCS4Char; PressedDown: boolean): boolean; override;<N>      procedure OnShow; override;<N>  end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenPartyRounds;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  UMenu,<N>  sdl2,<N>  UCommon,<N>  UDisplay,<N>  UMusic,<N>  UFiles,<N>  SysUtils,<N>  ULog,<N>  UThemes;<N><N>type<N>  TScreenPartyRounds = class(TMenu)<N>    private<N>      Actual: integer;<N><N>      SelectRoundCount: cardinal;<N>      SelectRound: array [0..6] of cardinal;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenStatMain;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenDevelopers;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  sdl2,<N>  StrUtils,<N>  SysUtils,<N>  UIni,<N>  UMenu,<N>  UMusic,<N>  UThemes;<N><N>type<N>  TScreenDevelopers = class(TMenu)<N>    public<N>      constructor Create; override;<N>      function ParseInput(PressedKey: cardinal; CharCode: UCS4Char; PressedDown: boolean): boolean; override;<N>      procedure SetAnimationProgress(Progress: real); override;<N>    private<N>      TextOverview: integer;<N>  end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenOptionsWebcam;<N><N>interface<N><N>{$MODE OBJFPC}<N><N>{$I switches.inc}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenOptionsNetwork;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenPartyTournamentRounds;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  sdl2,<N>  dglOpenGL,<N>  TextGL,<N>  SysUtils,<N>  UCommon,<N>  UIni,<N>  UMenu,<N>  UDisplay,<N>  UMusic,<N>  UPartyTournament,<N>  UScreenSingController,<N>  UScreenPartyTournamentWin,<N>  UThemes;<N><N>type<N><N>  Line = record<N>    X: real;<N>    Y: real;<N>    H: real;<N>    W: real;<N>  end;<N><N>
  TScreenPartyTournamentRounds = class(TMenu)<N>    public<N><N>      TextNamePlayer: array[0..1, 0..7] of cardinal;<N>      NextPlayersMark: array [0..15] of cardinal;<N>      TextWinner: cardinal;<N><N>      ButtonPlayer1: cardinal;<N>      ButtonPlayer2: cardinal;<N><N>
      TextColorPlayerR: array[0..1, 0..7] of real;<N>      TextColorPlayerG: array[0..1, 0..7] of real;<N>      TextColorPlayerB: array[0..1, 0..7] of real;<N><N>      R1, G1, B1: real;<N>      R2, G2, B2: real;<N><N>      DR1, DG1, DB1: real;<N>      DR2, DG2, DB2: real;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenJukeboxPlaylist;<N><N>interface<N><N>{$MODE OBJFPC}<N><N>{$I switches.inc}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenAbout;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  UMenu,<N>  sdl2,<N>  SysUtils,<N>  UDisplay,<N>  UMusic,<N>  UIni,<N>  UThemes;<N><N>type<N>  TScreenAbout = class(TMenu)<N>    public<N>      TextOverview: integer;<N>      AboutStaticBghelper: integer;<N>      constructor Create; override;<N>      function ParseInput(PressedKey: cardinal; CharCode: UCS4Char; PressedDown: boolean): boolean; override;<N>      procedure OnShow; override;<N>      procedure SetAnimationProgress(Progress: real); override;<N>  end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UScreenLoading;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses UMenu, UThemes;<N><N>type<N>  TScreenLoading = class(TMenu)<N>    public<N>      constructor Create; override;<N>  end;<N><N>implementation<N><N>constructor TScreenLoading.Create;<N>begin<N>  inherited Create;<N>  LoadFromTheme(Theme.Loading);<N>end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenSongMenu;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  UMenu,<N>  sdl2,<N>  UDisplay,<N>  UIni,<N>  UMusic,<N>  UFiles,<N>  SysUtils,<N>  UThemes;<N><N>type<N>  TScreenSongMenu = class(TMenu)<N>    private<N>      CurMenu: byte; // num of the cur. shown menu<N>    public<N>      Visible: boolean; // whether the menu should be drawn<N><N>
      constructor Create; override;<N>      function ParseInput(PressedKey: cardinal; CharCode: UCS4Char; PressedDown: boolean): boolean; override;<N>      procedure MenuShow(sMenu: byte);<N>      procedure HandleReturn;<N>      function CountMedleySongs: integer;<N>  end;<N><N>
const<N>  SM_Main = 1;<N><N>  SM_PlayList         = 64 or 1;<N>  SM_Playlist_Add     = 64 or 2;<N>  SM_Playlist_New     = 64 or 3;<N><N>  SM_Playlist_DelItem = 64 or 5;<N><N>  SM_Playlist_Load    = 64 or 8 or 1;<N>  SM_Playlist_Del     = 64 or 8 or 5;<N><N>
  SM_Party_Main       = 128 or 1;<N>  SM_Party_Joker      = 128 or 2;<N>  SM_Party_Free_Main  = 128 or 5;<N><N>  SM_Refresh_Scores   = 64 or 6;<N>  SM_Song             = 64 or 8;<N>  SM_Medley           = 64 or 16;<N>  SM_Sorting = 64 or 32;<N>  SM_Search_new_songs = 64 or 7;<N><N>
var<N>  ISelections1: array of UTF8String;<N>  SelectValue1: integer;<N><N>  ISelections2: array of UTF8String;<N>  SelectValue2: integer;<N><N>  ISelections3: array of UTF8String;<N>  SelectValue3: integer;<N><N>implementation<N><N>uses<N>  Math,<N>  UCommon,<N>  UDatabase,<N>  UGraphic,<N>  UMain,<N>  UNote,<N>  UTexture,<N>  ULanguage,<N>  UParty,<N>  UPlaylist,<N>  USong,<N>  USongs,<N>  UUnicodeUtils;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenOptionsMicrophones;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  UThemes,<N>  UMusic,<N>  URecord,<N>  UMenu;<N><N>type<N>  TDrawState = record<N>    ChannelIndex: integer;<N>    R, G, B: real;    // mapped player color (normal)<N>    RD, GD, BD: real; // mapped player color (dark)<N>  end;<N><N>
  TPeakInfo = record<N>    Volume: single;<N>    Time: cardinal;<N>  end;<N><N>  TScreenOptionsMicrophones = class(TMenu)<N>    private<N>      // max. count of input-channels determined for all devices<N>      MaxChannelCount: integer;<N><N>      // current input device<N>      CurrentDeviceIndex: integer;<N>      PreviewDeviceIndex: integer;<N><N>
      // string arrays for select-slide options<N>      InputSourceNames: array of UTF8String;<N>      InputDeviceNames: array of UTF8String;<N><N>      // dynamic generated themes for channel select-sliders<N>      SelectSlideChannelTheme: array of TThemeSelectSlide;<N><N>
      // indices for widget-updates<N>      SelectInputSourceID:   integer;<N>      SelectSlideChannelID: array of integer;<N>      SelectThresholdID: integer;<N><N>      // interaction IDs<N>      ExitButtonIID: integer;<N><N>      // dummy data for non-available channels<N>      ChannelToPlayerMapDummy: integer;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenPartyTournamentOptions;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  UMenu,<N>  sdl2,<N>  UDisplay,<N>  UMusic,<N>  UFiles,<N>  SysUtils,<N>  UThemes;<N><N>type<N>  TScreenPartyTournamentOptions = class(TMenu)<N>    private<N>      SelectRoundsFinal: cardinal;<N>      SelectRounds2Final: cardinal;<N>      SelectRounds4Final: cardinal;<N>      SelectRounds8Final: cardinal;<N><N>
      RoundFinalCount:  integer;<N>      Round2FinalCount: integer;<N>      Round4FinalCount: integer;<N>      Round8FinalCount: integer;<N><N>    public<N>      constructor Create; override;<N>      procedure UpdateTournament;<N>      function ParseInput(PressedKey: cardinal; CharCode: UCS4Char; PressedDown: boolean): boolean; override;<N>      procedure OnShow; override;<N>      procedure SetAnimationProgress(Progress: real); override;<N>  end;<N><N>
const<N>  IRoundCount:  array[0..2] of UTF8String = ('1', '3', '5');<N><N>implementation<N><N>uses<N>  UGraphic,<N>  UMain,<N>  UIni,<N>  UTexture,<N>  ULanguage,<N>  UPartyTournament,<N>  USong,<N>  UPlaylist,<N>  USongs,<N>  ULog,<N>  UNote,<N>  UUnicodeUtils;<N><N>
procedure TScreenPartyTournamentOptions.UpdateTournament();<N>begin<N><N>  if (SelectsS[SelectRounds8Final].Visible) then<N>    PartyTournament.Rounds[0] := StrToInt(IRoundCount[Round8FinalCount]);<N><N>  if (SelectsS[SelectRounds4Final].Visible) then<N>    PartyTournament.Rounds[1] := StrToInt(IRoundCount[Round4FinalCount]);<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenPartyNewRound;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  sdl2,<N>  SysUtils,<N>  UMenu,<N>  UDisplay,<N>  UMusic,<N>  UFiles,<N>  UThemes;<N><N>type<N>  TScreenPartyNewRound = class(TMenu)<N>    private<N>      VisibleRound:  Integer;<N><N>    public<N>      //Texts:<N>      TextRound: array [0..6] of cardinal;<N><N>
      TextWinner: array [0..6] of cardinal;<N><N>      TextNextRound: cardinal;<N>      TextNextRoundNo: cardinal;<N>      TextNextPlayer1: cardinal;<N>      TextNextPlayer2: cardinal;<N>      TextNextPlayer3: cardinal;<N><N>      //Statics<N>      StaticRound: array [0..6] of cardinal;<N><N>
      //Scores<N>      TextScoreTeam1: cardinal;<N>      TextScoreTeam2: cardinal;<N>      TextScoreTeam3: cardinal;<N>      TextNameTeam1: cardinal;<N>      TextNameTeam2: cardinal;<N>      TextNameTeam3: cardinal;<N><N>      TextTeam1Players: cardinal;<N>      TextTeam2Players: cardinal;<N>      TextTeam3Players: cardinal;<N><N>
      StaticTeam1: cardinal;<N>      StaticTeam2: cardinal;<N>      StaticTeam3: cardinal;<N>      StaticNextPlayer1: cardinal;<N>      StaticNextPlayer2: cardinal;<N>      StaticNextPlayer3: cardinal;<N><N><N><N>      constructor Create; override;<N>      function ParseInput(PressedKey: cardinal; CharCode: UCS4Char; PressedDown: boolean): boolean; override;<N>      procedure OnShow; override;<N>      procedure SetAnimationProgress(Progress: real); override;<N>      procedure Refresh;<N>  end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenOptionsGraphics;<N><N>interface<N><N>{$MODE OBJFPC}<N><N>{$I switches.inc}<N><N>
uses<N>  UMenu,<N>  sdl2,<N>  UDisplay,<N>  UMusic,<N>  UFiles,<N>  UIni,<N>  UThemes;<N><N>type<N>  TScreenOptionsGraphics = class(TMenu)<N>    private<N>      SelectWindowMode:    cardinal;<N>      SelectResolution:    cardinal;<N><N>      IResolutionEmpty:    array of UTF8String;<N>      ResolutionEmpty:     integer; // not used, only to prevent changing original by-ref passed variable<N><N>
      OldWindowMode:       integer;<N><N>      procedure UpdateWindowMode;<N>      procedure UpdateResolution;<N><N>    public<N>      constructor Create; override;<N>      function ParseInput(PressedKey: cardinal; CharCode: UCS4Char; PressedDown: boolean): boolean; override;<N>      procedure OnShow; override;<N>      procedure OnHide; override;<N>      procedure OnWindowResized; override;<N>  end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenPopup;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  sdl2,<N>  SysUtils,<N>  UDataBase,<N>  UDLLManager,<N>  ULog,<N>  UMenu,<N>  UMusic,<N>  md5,<N>  USkins,<N>  USongs,<N>  UScreenSong,<N>  UNote,<N>  UFiles,<N>  UTexture,<N>  UThemes,<N>  UWebSDK;<N><N>type<N>  TPopupCheckHandler = procedure(Value: boolean; Data: Pointer);<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenOptionsSound;<N><N>interface<N><N>{$MODE OBJFPC}<N><N>{$I switches.inc}<N><N>
uses<N>  sdl2,<N>  UDisplay,<N>  UFiles,<N>  UIni,<N>  ULanguage,<N>  UMenu,<N>  UMusic,<N>  UThemes;<N><N>type<N>  TScreenOptionsSound = class(TMenu)<N>  public<N>    constructor Create; override;<N>    function ParseInput(PressedKey: Cardinal; CharCode: UCS4Char;<N>      PressedDown: boolean): boolean; override;<N>    procedure OnShow; override;<N>  end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenPartyWin;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenJukeboxOptions;<N><N>interface<N><N>{$MODE OBJFPC}<N><N>{$I switches.inc}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenPartyScore;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N><N>unit UScreenOpen;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  Math,<N>  SysUtils,<N>  dglOpenGL,<N>  sdl2,<N>  UPath,<N>  UMenu,<N>  UMusic,<N>  UFiles,<N>  UTime,<N>  USongs,<N>  UIni,<N>  ULog,<N>  UTexture,<N>  UMenuText,<N>  ULyrics,<N>  UThemes;<N><N>type<N>  TScreenOpen = class(TMenu)<N>    private<N>      //fTextF:      array[0..1] of integer;<N>      fTextN:      integer; // text-box ID of filename<N>      fFilename:   IPath;<N>      fBackScreen: PMenu;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UScreenSingView;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  SysUtils,<N>  sdl2,<N>  dglOpenGL,<N>  TextGL,<N>  UCommon,<N>  UGraphicClasses,<N>  UHookableEvent,<N>  UIni,<N>  ULog,<N>  ULyrics,<N>  UAvatars,<N>  UMenu,<N>  UMusic,<N>  USingScores,<N>  USongs,<N>  UTexture,<N>  UThemes,<N>  UTime,<N>  USkins;<N><N>
type<N>  TScreenSingView = class<N>  public<N><N>    StaticDuet: array of cardinal;<N>    ColPlayer:  array[0..3] of TRGB;<N><N>    // timebar fields<N>    StaticTimeProgress: integer;<N>    TextTimeText: integer;<N><N>    StaticP1: array [0..1] of integer;<N>    TextP1:   integer;<N>    StaticP1Avatar: array [0..1] of integer;<N><N>
    // shown when game is in 2/4 player modus<N>    StaticP1TwoP: array [0..1] of integer;<N>    TextP1TwoP:   integer;<N>    StaticP1TwoPAvatar: array [0..1] of integer;<N><N>    // shown when game is in 3/6 player modus<N>    StaticP1ThreeP: array [0..1] of integer;<N>    TextP1ThreeP:   integer;<N>    StaticP1ThreePAvatar: array [0..1] of integer;<N><N>
    StaticP2R: array [0..1] of integer;<N>    TextP2R:   integer;<N>    StaticP2RAvatar: array [0..1] of integer;<N><N>    StaticP2M: array [0..1] of integer;<N>    TextP2M:   integer;<N>    StaticP2MAvatar: array [0..1] of integer;<N><N>    StaticP3R: array [0..1] of integer;<N>    TextP3R:   integer;<N>    StaticP3RAvatar: array [0..1] of integer;<N><N>
    // 4/6 players in one screen<N>    StaticP1FourP:  integer;<N>    StaticP2FourP:  integer;<N>    StaticP3FourP:  integer;<N>    StaticP4FourP:  integer;<N><N>    StaticP1FourPAvatar:  integer;<N>    StaticP2FourPAvatar:  integer;<N>    StaticP3FourPAvatar:  integer;<N>    StaticP4FourPAvatar:  integer;<N><N>
    TextP1FourP:   integer;<N>    TextP2FourP:   integer;<N>    TextP3FourP:   integer;<N>    TextP4FourP:   integer;<N><N>    StaticP1SixP:  integer;<N>    StaticP2SixP:  integer;<N>    StaticP3SixP:  integer;<N>    StaticP4SixP:  integer;<N>    StaticP5SixP:  integer;<N>    StaticP6SixP:  integer;<N><N>
    StaticP1SixPAvatar:  integer;<N>    StaticP2SixPAvatar:  integer;<N>    StaticP3SixPAvatar:  integer;<N>    StaticP4SixPAvatar:  integer;<N>    StaticP5SixPAvatar:  integer;<N>    StaticP6SixPAvatar:  integer;<N><N>    TextP1SixP:   integer;<N>    TextP2SixP:   integer;<N>    TextP3SixP:   integer;<N>    TextP4SixP:   integer;<N>    TextP5SixP:   integer;<N>    TextP6SixP:   integer;<N><N>
    // 3/6 players duet<N>    StaticDuetP1ThreeP: array [0..1] of integer;<N>    TextDuetP1ThreeP:   integer;<N>    StaticDuetP1ThreePAvatar: array [0..1] of integer;<N><N>    StaticDuetP2M: array [0..1] of integer;<N>    TextDuetP2M:   integer;<N>    StaticDuetP2MAvatar: array [0..1] of integer;<N><N>
    StaticDuetP3R: array [0..1] of integer;<N>    TextDuetP3R:   integer;<N>    StaticDuetP3RAvatar: array [0..1] of integer;<N><N>    // 4/6 players duet one screen<N>    StaticP1DuetFourP:  integer;<N>    StaticP2DuetFourP:  integer;<N>    StaticP3DuetFourP:  integer;<N>    StaticP4DuetFourP:  integer;<N><N>
    StaticP1DuetFourPAvatar:  integer;<N>    StaticP2DuetFourPAvatar:  integer;<N>    StaticP3DuetFourPAvatar:  integer;<N>    StaticP4DuetFourPAvatar:  integer;<N><N>    TextP1DuetFourP:   integer;<N>    TextP2DuetFourP:   integer;<N>    TextP3DuetFourP:   integer;<N>    TextP4DuetFourP:   integer;<N><N>
    StaticP1DuetSixP:  integer;<N>    StaticP2DuetSixP:  integer;<N>    StaticP3DuetSixP:  integer;<N>    StaticP4DuetSixP:  integer;<N>    StaticP5DuetSixP:  integer;<N>    StaticP6DuetSixP:  integer;<N><N>    StaticP1DuetSixPAvatar:  integer;<N>    StaticP2DuetSixPAvatar:  integer;<N>    StaticP3DuetSixPAvatar:  integer;<N>    StaticP4DuetSixPAvatar:  integer;<N>    StaticP5DuetSixPAvatar:  integer;<N>    StaticP6DuetSixPAvatar:  integer;<N><N>
    TextP1DuetSixP:   integer;<N>    TextP2DuetSixP:   integer;<N>    TextP3DuetSixP:   integer;<N>    TextP4DuetSixP:   integer;<N>    TextP5DuetSixP:   integer;<N>    TextP6DuetSixP:   integer;<N><N><N>    StaticPausePopup: integer;<N><N>    SongNameStatic:   integer;<N>    SongNameText:     integer;<N><N>
<N><N>    constructor Create;<N><N>    procedure DrawMedleyCountdown();<N>    function Draw: boolean;<N><N>    procedure SwapToScreen(Screen: integer);<N><N>    procedure WriteMessage(msg: UTF8String);<N>    procedure FadeMessage();<N>    procedure CloseMessage();<N><N>
    procedure MedleyTitleFadeOut();<N><N>    function GetLyricColor(Color: integer): TRGB;<N><N>    procedure DrawInfoLyricBar();<N>  end;<N>var<N>  lastVolume: single;<N><N>implementation<N><N>uses<N>  Classes,<N>  Math,<N>  UDatabase,<N>  UDllManager,<N>  UDraw,<N>  UGraphic,<N>  ULanguage,<N>  UNote,<N>  URecord,<N>  USong,<N>  UDisplay,<N>  UParty,<N>  UPathUtils,<N>  UUnicodeUtils,<N>  UScreenSingController,<N>  UWebcam,<N>  UWebSDK;<N><N>
const<N>  MAX_MESSAGE = 3;<N><N>//ToDo basisbit: check this again<N>// Dirty HacK<N>procedure TScreenSingView.SwapToScreen(Screen: integer);<N>begin<N>  { if screens = 2 and playerplay <= 3 the 2nd screen shows the<N>    textures of screen 1 }<N>  if (PlayersPlay <= 3) and (Screen = 2) then<N>    Screen := 1;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UScreenSingController;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  dglOpenGL,<N>  sdl2,<N>  SysUtils,<N>  TextGL,<N>  UAvatars,<N>  UCommon,<N>  UDisplay,<N>  UFiles,<N>  UGraphicClasses,<N>  UHookableEvent,<N>  UIni,<N>  ULog,<N>  ULyrics,<N>  UMenu,<N>  UMusic,<N>  UPath,<N>  UScreenSingView,<N>  USingScores,<N>  USkins,<N>  USongs,<N>  UTexture,<N>  UThemes,<N>  UTime;<N><N>
<N>type<N>  TPos = record // CurrentSong.Lines[part].Line[line].Note[note]<N>    part: integer;<N>    line: integer;<N>    note: integer;<N>    CP: integer;<N>  end;<N><N>  TLyricsSyncSource = class(TSyncSource)<N>    function GetClock(): real; override;<N>  end;<N><N>
  TMusicSyncSource = class(TSyncSource)<N>    function GetClock(): real; override;<N>  end;<N><N>  TTimebarMode = (<N>    tbmCurrent,   // current song position<N>    tbmRemaining, // remaining time<N>    tbmTotal      // total time<N>  );<N><N>type<N>  TScreenSingController = class(TMenu)<N>  private<N><N>
    StartNote:     TPos;<N><N>    procedure LoadNextSong();<N><N>    procedure SongError();<N>  public<N>    eSongLoaded: THookableEvent; //< event is called after lyrics of a song are loaded on OnShow<N>    Paused:     boolean; //pause Mod<N>    NumEmptySentences: array [0..1] of integer;<N>    // views<N>    fShowVisualization: boolean;<N>    fShowBackground: boolean;<N><N>
    fCurrentVideo: IVideo;<N>    fVideoClip:    IVideo;<N>    fLyricsSync: TLyricsSyncSource;<N>    fMusicSync: TMusicSyncSource;<N>    fTimebarMode: TTimebarMode;<N><N>    PlayMidi: boolean;<N><N>    removeVoice: boolean;<N>    fShowWebcam: boolean;<N><N>
    Act_Level: integer;<N>    Act_MD5Song: string;<N><N>    MedleyStart, MedleyEnd: real;<N><N>    Lyrics: TLyricEngine;<N>    LyricsDuetP1: TLyricEngine;<N>    LyricsDuetP2: TLyricEngine;<N><N>    // score manager:<N>    Scores: TSingScores;<N><N>    //the song was sung to the end<N>    SungToEnd: boolean;<N><N>
    //use pause<N>    SungPaused: boolean;<N><N>    // some settings to be set by plugins<N>    Settings: record<N>      Finish: Boolean; //< if true, screen will finish on next draw<N><N>      LyricsVisible: Boolean; //< shows or hides lyrics<N>      NotesVisible: Integer; //< if bit[playernum] is set the notes for the specified player are visible. By default all players notes are visible<N><N>
      PlayerEnabled: Integer; //< defines whether a player can score atm<N><N>      SoundEnabled: Boolean; //< mute or unmute sound<N>    end;<N><N>    // MIDI<N>    ChannelOff  : integer;<N><N>    MidiFadeIn: boolean;<N>    MidiFadeOut: boolean;<N>    FadeTime: cardinal;<N><N>
    InfoMessageBG: cardinal;<N>    InfoMessageText: cardinal;<N><N>    MessageTime: cardinal;<N>    MessageTimeFade: cardinal;<N><N>    TextMedleyFadeOut: boolean;<N>    TextMedleyFadeTime: cardinal;<N><N>    // names<N>    PlayerNames: array [1..IMaxPlayerCount] of UTF8String;<N>    PlayerDuetNames:array [1..IMaxPlayerCount] of UTF8String;<N><N>
    Tex_Background: TTexture;<N>    FadeOut: boolean;<N><N>    procedure ClearSettings;<N>    procedure ApplySettings; //< applies changes of settings record<N>    procedure EndSong;<N><N>    constructor Create; override;<N>    procedure OnShow; override;<N>    procedure OnShowFinish; override;<N>    procedure OnHide; override;<N>    function Draw: boolean; override;<N><N>
    function ParseInput(PressedKey: cardinal; CharCode: UCS4Char;<N>      PressedDown: boolean): boolean; override;<N><N>    function FinishedMusic: boolean;<N>	function ParseMouse(MouseButton: integer; BtnDown: boolean; X, Y: integer): boolean; override;<N><N>
    procedure AutoSendScore;<N>    procedure AutoSaveScore;<N><N>    procedure Finish; virtual;<N>    procedure Pause; // toggle pause<N>    procedure UpdateMedleyStats(medley_end: boolean);<N>    procedure OnSentenceEnd(CP: integer; SentenceIndex: cardinal);     // for linebonus + singbar<N>    procedure OnSentenceChange(CP: integer; SentenceIndex: cardinal);  // for golden notes<N>  end;<N><N>
var screenSingViewRef: TScreenSingView;<N>    TotalTime:              real;<N><N>implementation<N><N>uses<N>  Classes,<N>  Math,<N>  UDatabase,<N>  UDllManager,<N>  UDraw,<N>  UGraphic,<N>  ULanguage,<N>  UNote,<N>  URecord,<N>  USong,<N>  UParty,<N>  UPathUtils,<N>  UUnicodeUtils,<N>  UWebcam,<N>  UWebSDK;<N><N>
(*<N> * zlib pascal headers<N> * This file is part of Free Pascal, released under the LGPL.<N> *)<N><N>{$ifdef FPC}<N>  {$ifndef NO_SMART_LINK}<N>  {$smartlink on}<N>  {$endif}<N>{$endif}<N>unit zlib;<N><N>interface<N><N>{$ifdef FPC}<N>  {$mode objfpc} // Needed for array of const<N>  {$H+} // use long strings<N>  {$PACKRECORDS C}<N>{$endif}<N><N>
uses<N>  ctypes;<N><N>const<N>  ZLIB_VERSION = '1.2.3';<N><N>{$ifdef MSWINDOWS}<N>  libz = 'zlib1';<N>{$else}<N>  libz = 'z';<N>  {$IFDEF DARWIN}<N>    {$linklib libz}<N>  {$ENDIF}<N>{$endif}<N><N>type<N>  { Compatible with paszlib }<N>  uInt    = cuint;<N>  uLong   = culong;<N>  uLongf  = uLong; {FAR}<N>  PuLongf = ^uLongf;<N>  z_off_t = clong;<N>  pbyte   = ^byte;<N>  bytef   = byte; {FAR}<N>  pbytef  = ^byte; <N>  voidpf  = pointer;<N><N>
{<N>  BASS 2.4 Delphi unit<N>  Copyright (c) 1999-2016 Un4seen Developments Ltd.<N><N>  See the BASS.CHM file for more detailed documentation<N><N>  How to install<N>  --------------<N>  Copy BASS.PAS to the \LIB subdirectory of your Delphi path or your project dir<N><N>
  NOTE: Delphi users should use the BASS_UNICODE flag where possible<N>}<N><N>unit BASS;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>  {$PACKRECORDS C}<N>{$ENDIF}<N><N>{$IFDEF MSWINDOWS}<N>uses<N>  Windows;<N>{$ENDIF}<N><N>const<N>  BASSVERSION = $204;             // API version<N>  BASSVERSIONTEXT = '2.4';<N><N>
{ ============================================================================<N><N>       OpenGL 4.5 - Headertranslation<N><N>       Supported environments and targets :<N>        - (Win32) Delphi 6 and up<N>        - (Win32, Win64) Delphi XE2<N>        - (Win32, Win64, Linux, MacOSX) FreePascal (1.9.3 and up)<N><N>
==============================================================================<N><N>       Copyright (C) DGL-OpenGL-Portteam<N>       All Rights Reserved<N><N>       Obtained through:<N>       Bitbucket source repository - https://bitbucket.org/saschawillems/dglopengl<N>       Delphi OpenGL Community(DGL) - www.delphigl.com<N><N>
       Converted and maintained by DGL's OpenGL-Portteam :<N>         - Sascha Willems             - http://www.saschawillems.de<N>         - Steffen Xonna (Lossy eX)   - http://www.dev-center.de<N>       Additional input :<N>         - Andrey Gruzdev (Mac OS X patch for XE2 / FPC)<N>         - Lars Middendorf<N>         - Martin Waldegger (Mars)<N>         - Benjamin Rosseaux (BeRo)   - http://www.0ok.de<N>       Additional thanks:<N>           sigsegv (libdl.so)<N><N>
==============================================================================<N><N>  You may retrieve the latest version of this file at the Delphi OpenGL<N>  Community home page, located at http://www.delphigl.com/<N><N>  This Source Code Form is subject to the terms of the Mozilla Public License, <N>  v. 2.0. If a copy of the MPL was not distributed with this file, <N>  You can obtain one at http://mozilla.org/MPL/2.0/.<N><N>
  Software distributed under the License is distributed on an<N>  "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or<N>  implied. See the License for the specific language governing<N>  rights and limitations under the License.<N><N>==============================================================================<N><N>
<N>  History : see readme.md<N><N><N>============================================================================== }<N><N>{$define DGL_USE_SDL}<N>{<N>  Load the OpenGL library and query its functions using SDL.<N>}<N><N>{$define DGL_DEPRECATED}<N>{<N>  This define defines if the header should use deprecated ARB stuff or not.<N>  per Default the Header use deprecated Stuff.<N>}<N><N>
<N>{.$define DGL_TINY_HEADER}<N>{<N>  If you enable the define DGL_TINY_HEADER no function automatically will be loaded if you<N>  call ActivateRenderingContext. This may some bit faster and the smart linker can delete<N>  all non used functions. This will reduce the filesize of your binary file. But in this<N>  case you have to load the functions by yourself. There are two ways to do this.<N><N>
  1. You can load whole extension by calling the func Read_Extensionname. But if you do<N>     this it's possible to load functions you dont use. So you have the same "problem"<N>     like before. But it's only an bit smaler.<N>     > Read_GL_ARB_multitexture;<N><N>
{<N> **********************************************************************<N>  This file is part of LazUtils.<N><N>  See the file COPYING.modifiedLGPL.txt, included in this distribution,<N>  for details about the license.<N> **********************************************************************<N>}<N>unit LazUTF8Classes;<N><N>
{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, LazUTF8;<N><N>type<N><N>  { TFileStreamUTF8 }<N><N>  TFileStreamUTF8 = TFileStream;<N><N>  { TStringListUTF8 }<N><N>  TStringListUTF8 = class(TStringList)<N>  protected<N>    function DoCompareText(const s1,s2 : string) : PtrInt; override;<N>  public<N>    procedure LoadFromFile(const FileName: string); override;<N>    procedure SaveToFile(const FileName: string); override;<N>  end;<N><N>
  { TMemoryStreamUTF8 }<N><N>  TMemoryStreamUTF8 = class(TMemoryStream)<N>  public<N>    procedure LoadFromFile(const FileName: string);<N>    procedure SaveToFile(const FileName: string);<N>  end;<N><N>procedure LoadStringsFromFileUTF8(List: TStrings; const FileName: string);<N>procedure SaveStringsToFileUTF8(List: TStrings; const FileName: string);<N><N>
{<N> *****************************************************************************<N>  This file is part of LazUtils.<N><N>  See the file COPYING.modifiedLGPL.txt, included in this distribution,<N>  for details about the license.<N> *****************************************************************************<N><N>
{<N> *****************************************************************************<N>  This file is part of LazUtils.<N><N>  See the file COPYING.modifiedLGPL.txt, included in this distribution,<N>  for details about the license.<N> *****************************************************************************<N>}<N>unit Masks;<N><N>
{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Contnrs, LazUtilsStrConsts, LazUtf8;<N><N>type<N>  TMaskCharType = (mcChar, mcCharSet, mcAnyChar, mcAnyText);<N>  TMaskOption = (moCaseSensitive, moDisableSets);<N>  TMaskOptions = set of TMaskOption;<N><N>
  TCharSet = set of Char;<N>  PCharSet = ^TCharSet;<N><N>  TUtf8Char = String[7];<N><N>  TMaskChar = record<N>    case CharType: TMaskCharType of<N>      mcChar: (CharValue: TUtf8Char);<N>      mcCharSet: (Negative: Boolean; SetValue: PCharSet);<N>      mcAnyChar, mcAnyText: ();<N>  end;<N><N>
{<N> *****************************************************************************<N>  This file is part of LazUtils.<N><N>  See the file COPYING.modifiedLGPL.txt, included in this distribution,<N>  for details about the license.<N> *****************************************************************************<N>}<N>unit FPCAdds;<N><N>
{$mode objfpc}{$H+}{$inline on}<N><N>{$i lazutils_defines.inc}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>  TStreamSeekType = int64;<N>  TMemStreamSeekType = PtrInt;<N>  TCompareMemSize = PtrUInt;<N>  PHandle = ^THandle;<N><N>function StrToWord(const s: string): word;<N><N>
function AlignToPtr(const p: Pointer): Pointer; inline;<N>function AlignToInt(const p: Pointer): Pointer; inline;<N><N>implementation<N><N>function StrToWord(const s: string): word;<N>var<N>  i: Integer;<N>begin<N>  Result:=0;<N>  for i:=1 to Length(s) do<N>    Result:=Result*10+ord(s[i])-ord('0');<N>end;<N><N>
function AlignToPtr(const p: Pointer): Pointer; inline;<N>begin<N>{$IFDEF FPC_REQUIRES_PROPER_ALIGNMENT}<N>  Result := Align(p, SizeOf(Pointer));<N>{$ELSE}<N>  Result := p;<N>{$ENDIF}<N>end;<N><N>function AlignToInt(const p: Pointer): Pointer; inline;<N>begin<N>{$IFDEF FPC_REQUIRES_PROPER_ALIGNMENT}<N>  Result := Align(p, SizeOf(integer));<N>{$ELSE}<N>  Result := p;<N>{$ENDIF}<N>end;<N><N>
{<N> *****************************************************************************<N>  This file is part of LazUtils.<N><N>  See the file COPYING.modifiedLGPL.txt, included in this distribution,<N>  for details about the license.<N> *****************************************************************************<N>}<N><N>
{ ****************************************************************************<N>BB: 2013-05-19<N><N>Note to developers:<N><N>This unit should contain functions and procedures to<N>maintain compatibility with Delphi's FileUtil unit.<N><N>File routines that specifically deal with UTF8 filenames should go into<N>the LazFileUtils unit.<N><N>
***************************************************************************** }<N>unit FileUtil;<N><N>{$mode objfpc}{$H+}<N>{$i lazutils_defines.inc}<N><N>interface<N><N>uses<N>  Classes, SysUtils, StrUtils,<N>  // LazUtils<N>  Masks, LazUTF8, LazFileUtils;<N><N>
{<N> **********************************************************************<N>  This file is part of LazUtils.<N>  All functions are thread safe unless explicitely stated<N><N>  See the file COPYING.modifiedLGPL.txt, included in this distribution,<N>  for details about the license.<N> **********************************************************************<N>}<N>unit LazFileUtils;<N><N>
{$mode objfpc}{$H+}<N>{$i lazutils_defines.inc}<N>interface<N><N>uses<N>  Classes, SysUtils, SysConst, LazUTF8, LazUtilsStrConsts;<N><N>{$IF defined(Windows) or defined(darwin) or defined(HASAMIGA)}<N>{$define CaseInsensitiveFilenames}<N>{$IFDEF Windows}<N>  {$define HasUNCPaths}<N>{$ENDIF}<N>{$ENDIF}<N>{$IF defined(CaseInsensitiveFilenames)}<N>  {$define NotLiteralFilenames} // e.g. HFS+ normalizes file names<N>{$ENDIF}<N><N>
{<N> /***************************************************************************<N>                                  lazutf8.pas<N> ***************************************************************************/<N><N> *****************************************************************************<N>  This file is part of LazUtils<N><N>
  See the file COPYING.modifiedLGPL.txt, included in this distribution,<N>  for details about the license.<N> *****************************************************************************<N><N>  Useful routines for managing UTF-8 strings<N><N>  - all functions are thread safe unless explicitely stated<N>}<N>unit LazUTF8;<N><N>
{$mode objfpc}{$H+}{$inline on}<N><N>{$i lazutils_defines.inc}<N><N>interface<N><N>uses<N>  {$ifdef unix}<N>  // WideCompare* functions on Unix requires this. Must be used although it pulls in clib.<N>  cwstring,<N>  {$endif}<N>  {$IFDEF UTF8_RTL}<N>  FPCAdds,<N>  {$ENDIF}<N>  {$ifdef windows}<N>  Windows,<N>  {$endif}<N>  Classes, SysUtils, strutils;<N><N>
// AnsiToUTF8 and UTF8ToAnsi need a widestring manager under Linux, BSD, MacOSX<N>// but normally these OS use UTF-8 as system encoding so the widestringmanager<N>// is not needed.<N>function NeedRTLAnsi: boolean;// true if system encoding is not UTF-8<N>procedure SetNeedRTLAnsi(NewValue: boolean);<N><N>
// UTF8ToSys works like UTF8ToAnsi but more independent of widestringmanager<N>function UTF8ToSys(const s: string): string; overload; {$IFDEF UTF8_RTL}inline;{$ENDIF}<N>function UTF8ToSys(const AFormatSettings: TFormatSettings): TFormatSettings; overload; {$IFDEF UTF8_RTL}inline;{$ENDIF}<N><N>
// SysToUTF8 works like AnsiToUTF8 but more independent of widestringmanager<N>function SysToUTF8(const s: string): string; overload; {$IFDEF UTF8_RTL}inline;{$ENDIF}<N>function SysToUTF8(const AFormatSettings: TFormatSettings): TFormatSettings; overload;<N><N>
// converts OEM encoded string to UTF8 (used with some Windows specific functions)<N>function ConsoleToUTF8(const s: string): string; {$IFDEF UTF8_RTL}inline;{$ENDIF}<N>// converts UTF8 string to console encoding (used by Write, WriteLn)<N>function UTF8ToConsole(const s: string): string; {$IFDEF UTF8_RTL}inline;{$ENDIF}<N><N>
// for all Windows supporting 8bit codepages (e.g. not WinCE)<N>// converts string in Windows code page to UTF8 (used with some Windows specific functions)<N>function WinCPToUTF8(const s: string): string; {$ifdef WinCe}inline;{$endif}<N>// converts UTF8 string to Windows code page encoding (used by Write, WriteLn)<N>function UTF8ToWinCP(const s: string): string; {$ifdef WinCe}inline;{$endif}<N><N>
function ParamStrUTF8(Param: Integer): string;<N><N>{$ifdef windows}<N>procedure GetFormatSettingsUTF8;<N>procedure GetLocaleFormatSettingsUTF8(LCID: Integer; var aFormatSettings: TFormatSettings);<N>{$endif}<N><N>Function GetEnvironmentVariableCountUTF8: Integer; inline;<N>function GetEnvironmentStringUTF8(Index: Integer): string; inline;<N>function GetEnvironmentVariableUTF8(const EnvVar: string): String;<N>function SysErrorMessageUTF8(ErrorCode: Integer): String;<N><N>
// Returns the size of one codepoint in bytes.<N>function UTF8CodepointSize(p: PChar): integer; inline;<N>function UTF8CharacterLength(p: PChar): integer; deprecated 'Use UTF8CodepointSize instead.';<N>// Fast version of UTF8CodepointSize. Assumes the UTF-8 codepoint is valid.<N>function UTF8CodepointSizeFast(p: PChar): integer; inline;<N><N>
function UTF8Length(const s: string): PtrInt; inline;<N>function UTF8Length(p: PChar; ByteCount: PtrInt): PtrInt;<N>// Fast versions of UTF8Length. They assume the UTF-8 data is valid.<N>function UTF8LengthFast(const s: string): PtrInt; inline;<N>function UTF8LengthFast(p: PChar; ByteCount: PtrInt): PtrInt;<N><N>
{<N>    This file is part of the Free Pascal run time library.<N>    Copyright (c) 2004 by Marco van de Voort, member of the<N>    Free Pascal development team<N><N>    Implements C types for in header conversions<N><N>    See the file COPYING.FPC, included in this distribution,<N>    for details about the copyright.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.<N><N><N> **********************************************************************}<N><N>
unit UFreeType;<N><N>{$IFDEF FPC}<N>  {$mode delphi}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>  FreeType,<N>  dglOpenGL,<N>  classes,<N>  sysutils;<N><N>type<N>  // This holds all of the information related to any<N>  // freetype font that we want to create.<N>  TFontData = class<N>    h: single;                  ///< Holds the height of the font.<N>    textures: array of GLuint;  ///< Holds the texture id's<N>    list_base: GLuint;          ///< Holds the first display list id<N><N>
    // The init function will create a font of<N>    // of the height h from the file fname.<N>    constructor Create(const fname: string; h: cardinal);<N><N>    // Free all the resources assosiated with the font.<N>    destructor Destroy(); override;<N>  end;<N><N>
  TFreeType = class<N>    public<N>      // The flagship function of the library - this thing will print<N>      // out text at window coordinates x,y, using the font ft_font.<N>      // The current modelview matrix will also be applied to the text.<N>      class procedure print(ft_font: TFontData; x, y: single; const str: string);<N>  end;<N><N>
<N>implementation<N><N><N>// This function gets the first power of 2 >= the<N>// int that we pass it.<N>function next_p2 ( a: integer ): integer; inline;<N>begin<N>  Result := 1;<N>  while (Result < a) do<N>    Result := Result shl 1;<N>end;<N><N>type<N>  PAGLuint = ^AGLuint;<N>  AGLuint = array[0..High(Word)] of GLuint;<N><N>
// Create a display list coresponding to the given character.<N>procedure make_dlist ( face: FT_Face; ch: byte; list_base: GLuint; tex_base: PAGLuint );<N>var<N>  i, j: integer;<N>  width, height: integer;<N>  glyph: FT_Glyph;<N>  bitmap_glyph: FT_BitmapGlyph;<N>  bitmap: PFT_Bitmap;<N>  expanded_data: array of GLubyte;<N>  x, y: single;<N>begin<N>  // The first thing we do is get FreeType to render our character<N>  // into a bitmap.  This actually requires a couple of FreeType commands:<N><N>
  // Load the Glyph for our character.<N>  if (FT_Load_Glyph( face, FT_Get_Char_Index( face, ch ), FT_LOAD_DEFAULT ) <> 0) then<N>    raise Exception.create('FT_Load_Glyph failed');<N><N>  // Move the face's glyph into a Glyph object.<N>  if (FT_Get_Glyph( face^.glyph, glyph ) <> 0) then<N>    raise Exception.create('FT_Get_Glyph failed');<N><N>
  // Convert the glyph to a bitmap.<N>  FT_Glyph_To_Bitmap( glyph, ft_render_mode_normal, nil, 1 );<N>  bitmap_glyph := FT_BitmapGlyph(glyph);<N><N>  // This reference will make accessing the bitmap easier<N>  bitmap := @bitmap_glyph^.bitmap;<N><N>  // Use our helper function to get the widths of<N>  // the bitmap data that we will need in order to create<N>  // our texture.<N>  width := next_p2( bitmap.width );<N>  height := next_p2( bitmap.rows );<N><N>
unit SQLiteTable3;<N><N>{<N>  Simple classes for using SQLite's exec and get_table.<N><N>  TSQLiteDatabase wraps the calls to open and close an SQLite database.<N>  It also wraps SQLite_exec for queries that do not return a result set<N><N>  TSQLiteTable wraps execution of SQL query.<N>  It run query and read all returned rows to internal buffer.<N>  It allows accessing fields by name as well as index and can move through a<N>  result set forward and backwards, or randomly to any row.<N><N>
unit SQLite3;<N><N>{<N>  Simplified interface for SQLite.<N>  Updated for Sqlite 3 by Tim Anderson (tim@itwriting.com)<N>  Note: NOT COMPLETE for version 3, just minimal functionality<N>  Adapted from file created by Pablo Pissanetzky (pablo@myhtpc.net)<N>  which was based on SQLite.pas by Ben Hochstrasser (bhoc@surfeu.ch)<N>}<N><N>
{$IFDEF FPC}<N>  {$MODE DELPHI}<N>  {$H+}            (* use long strings *)<N>  {$PACKENUM 4}    (* use 4-byte enums *)<N>  {$PACKRECORDS C} (* C/C++-compatible record packing *)<N>{$ELSE}<N>  {$MINENUMSIZE 4} (* use 4-byte enums *)<N>{$ENDIF}<N><N>interface<N><N>
const<N>{$IF Defined(MSWINDOWS)}<N>  SQLiteDLL = 'sqlite3.dll';<N>{$ELSEIF Defined(DARWIN)}<N>  SQLiteDLL = 'libsqlite3.dylib';<N>  {$linklib libsqlite3}<N>{$ELSEIF Defined(UNIX)}<N>  SQLiteDLL = 'sqlite3.so';<N>{$IFEND}<N><N>// Return values for sqlite3_exec() and sqlite3_step()<N><N>
{**********************************************************************<N><N>  FFT.cpp<N><N>  Dominic Mazzoni<N><N>  September 2000<N><N>***********************************************************************<N><N>Fast Fourier Transform routines.<N><N>  This file contains a few FFT routines, including a real-FFT<N>  routine that is almost twice as fast as a normal complex FFT,<N>  and a power spectrum routine when you know you don't care<N>  about phase information.<N><N>
  Some of this code was based on a free implementation of an FFT<N>  by Don Cross, available on the web at:<N><N>    http://www.intersrv.com/~dcross/fft.html<N><N>  The basic algorithm for his code was based on Numerican Recipes<N>  in Fortran.  I optimized his code further by reducing array<N>  accesses, caching the bit reversal table, and eliminating<N>  float-to-double conversions, and I added the routines to<N>  calculate a real FFT and a real power spectrum.<N><N>
***********************************************************************<N><N>  Salvo Ventura - November 2006<N>  Added more window functions:<N>    * 4: Blackman<N>    * 5: Blackman-Harris<N>    * 6: Welch<N>    * 7: Gaussian(a=2.5)<N>    * 8: Gaussian(a=3.5)<N>    * 9: Gaussian(a=4.5)<N><N>
***********************************************************************<N><N>  This file is part of Audacity 1.3.4 beta (http://audacity.sourceforge.net/)<N>  Ported to Pascal by the UltraStar Deluxe Team<N>}<N><N>unit UFFT;<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>  {$H+} // Use long strings<N>{$ENDIF}<N><N>
unit projectM;<N><N>{$IFDEF FPC}<N>  {$MODE DELPHI}<N>  {$H+}            (* use long strings *)<N>  {$PACKENUM 4}    (* use 4-byte enums *)<N>  {$PACKRECORDS C} (* C/C++-compatible record packing *)<N>{$ELSE}<N>  {$MINENUMSIZE 4} (* use 4-byte enums *)<N>{$ENDIF}<N><N>
interface<N><N>uses<N>  SysUtils,<N>  ctypes,<N>  dglOpenGL,<N>  UConfig;<N><N>type<N>  // 16bit non-interleaved data<N>  TPCM16 = array[0..1, 0..511] of Smallint;<N>  PPCM16 = ^TPCM16;<N>  // 8bit non-interleaved data (512 samples)<N>  TPCM8_512 = array[0..1, 0..511] of byte;<N>  PPCM8_512 = ^TPCM8_512;<N>  // 8bit non-interleaved data (1024 samples)<N>  TPCM8_1024 = array[0..1, 0..1023] of byte;<N>  PPCM8_1024 = ^TPCM8_512;<N><N>
{ $Header: /MidiComp/MidiType.pas 2     10/06/97 7:33 Davec $ } <N><N>{ Written by David Churcher <dchurcher@cix.compulink.co.uk>,<N>  released to the public domain. }<N><N>unit MidiType;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>  {$H+} // use long strings<N>{$ENDIF}<N><N>
{ $Header: /MidiComp/MidiCons.pas 2     10/06/97 7:33 Davec $ }<N><N>{ Written by David Churcher <dchurcher@cix.compulink.co.uk>,<N>  released to the public domain. }<N><N>{ Midi Constants }<N>unit MidiCons;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>  {$H+} // use long strings<N>{$ENDIF}<N><N>
{ $Header: /MidiComp/MidiOut.pas 2     10/06/97 7:33 Davec $ }<N><N>{ Written by David Churcher <dchurcher@cix.compulink.co.uk>,<N>  released to the public domain. }<N><N>{ Thanks very much to Fred Kohler for the Technology code. }<N><N>unit MidiOut;<N><N>
{<N>  MIDI Output component.<N><N>  Properties:<N>   DeviceID:  Windows numeric device ID for the MIDI output device.<N> Between 0 and (midioutGetNumDevs-1), or MIDI_MAPPER (-1).<N>    Special value MIDI_MAPPER specifies output to the Windows MIDI mapper<N> Read-only while device is open, exception if changed while open<N><N>
 MIDIHandle:  The output handle to the MIDI device.<N> 0 when device is not open<N> Read-only, runtime-only<N><N> ProductName: Name of the output device product that corresponds to the<N> DeviceID property (e.g. 'MPU 401 out').<N> You can write to this while the device is closed to select a particular<N> output device by name (the DeviceID property will change to match).<N> Exception if this property is changed while the device is open.<N><N>
{ $Header: /MidiComp/DelphiMcb.pas 2     10/06/97 7:33 Davec $ }<N><N>{Midi callback for Delphi, was DLL for Delphi 1}<N><N>unit DelphiMcb;<N><N>{ These segment options required for the Midi callback functions }<N>{$IFNDEF FPC}<N>{$C PRELOAD FIXED PERMANENT}<N>{$ENDIF}<N><N>
interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>  {$H+} // use long strings<N>{$ENDIF}<N><N>uses<N>  Windows,<N>  MMsystem,<N>  CircBuf,<N>  MidiDefs,<N>  MidiCons;<N><N>procedure MidiHandler(<N>      hMidiIn: HMidiIn;<N>      wMsg: uint;<N>      dwInstance: dword;<N>      dwParam1: dword;<N>      dwParam2: dword); stdcall; export;<N><N>
function CircbufPutEvent(PBuffer: PCircularBuffer; PTheEvent: PMidiBufferItem): boolean; stdcall; export;<N><N>implementation<N><N>{ Add an event to the circular input buffer. }<N>function CircbufPutEvent(PBuffer: PCircularBuffer; PTheEvent: PMidiBufferItem): boolean; stdcall;<N>begin<N>  if PBuffer^.EventCount < PBuffer^.Capacity then<N>  begin<N>    inc(Pbuffer^.EventCount);<N><N>
    { Todo: better way of copying this record }<N>    with PBuffer^.PNextput^ do<N>    begin<N>      Timestamp := PTheEvent^.Timestamp;<N>      Data := PTheEvent^.Data;<N>      Sysex := PTheEvent^.Sysex;<N>    end;<N><N>    { Move to next put location, with wrap }<N>    inc(Pbuffer^.PNextPut);<N>    if PBuffer^.PNextPut = PBuffer^.PEnd then<N>      PBuffer^.PNextPut := PBuffer^.PStart;<N><N>
{ $Header: /MidiComp/MidiIn.pas 2     10/06/97 7:33 Davec $ }<N><N>{ Written by David Churcher <dchurcher@cix.compulink.co.uk>,<N>  released to the public domain. }<N><N>unit MidiIn;<N><N>{<N>  Properties:<N> DeviceID:  Windows numeric device ID for the MIDI input device.<N> Between 0 and NumDevs-1.<N> Read-only while device is open, exception when changed while open<N><N>
 MIDIHandle:  The input handle to the MIDI device.<N> 0 when device is not open<N> Read-only, runtime-only<N><N> MessageCount:  Number of input messages waiting in input buffer<N><N> Capacity:  Number of messages input buffer can hold<N> Defaults to 1024<N> Limited to (64K/event size)<N> Read-only when device is open (exception when changed while open)<N><N>
 SysexBufferSize: Size in bytes of each sysex buffer<N> Defaults to 10K<N> Minimum 0K (no buffers), Maximum 64K-1<N><N> SysexBufferCount:  Number of sysex buffers<N> Defaults to 16<N> Minimum 0 (no buffers), Maximum (avail mem/SysexBufferSize)<N> Check where these buffers are allocated?<N><N>
 SysexOnly: True to ignore all non-sysex input events. May be changed while<N> device is open. Handy for patch editors where you have lots of short MIDI<N> events on the wire which you are always going to ignore anyway.<N><N> DriverVersion: Version number of MIDI device driver. High-order byte is<N> major version, low-order byte is minor version.<N><N>
{ $Header: /MidiComp/MidiDefs.pas 2     10/06/97 7:33 Davec $ }<N><N>{ Written by David Churcher <dchurcher@cix.compulink.co.uk>,<N>  released to the public domain. }<N><N><N>{ Common definitions used by DELPHMID.DPR and the Midi components.<N>  This must be a separate unit to prevent large chunks of the VCL being<N>  linked into the DLL. }<N>unit Mididefs;<N><N>
{<N>  Shows a large black area where midi note/controller events are shown<N>  just to monitor midi activity (for the MidiPlayer)<N><N>  version 1.0 first release<N><N>  for comments/bugs<N>  F.Bouwmans<N>  fbouwmans@spiditel.nl<N><N>  if you think this component is nice and you use it, sent me a short email.<N>  I've seen that other of my components have been downloaded a lot, but I've<N>  got no clue wether they are actually used.<N>  Don't worry because you are free to use these components<N>}<N><N>
{ $Header: /MidiComp/CircBuf.pas 2     10/06/97 7:33 Davec $ }<N><N>{ Written by David Churcher <dchurcher@cix.compulink.co.uk>,<N>  released to the public domain. }<N><N><N>{ A First-In First-Out circular buffer.<N>  Port of circbuf.c from Microsoft's Windows Midi monitor example.<N>  I did do a version of this as an object (see Rev 1.1) but it was getting too <N>  complicated and I couldn't see any real benefits to it so I dumped it <N>  for an ordinary memory buffer with pointers. <N><N>
  This unit is a bit C-like, everything is done with pointers and extensive<N>  use is made of the undocumented feature of the inc() function that <N>  increments pointers by the size of the object pointed to.<N>  All of this could probably be done using Pascal array notation with<N>  range-checking turned off, but I'm not sure it's worth it.<N>}<N><N>
unit CircBuf;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>  {$H+} // use long strings<N>{$ENDIF}<N><N>uses<N>  Windows,<N>  MMSystem;<N><N>type<N>  { Midi input event }<N>  TMidiBufferItem = record<N>    timestamp: dword; { Timestamp in milliseconds after midiInStart }<N>    data: dword;      { Midi message received }<N>    sysex: PMidiHdr;  { Pointer to sysex MIDIHDR, nil if not sysex }<N>  end;<N>  PMidiBufferItem = ^TMidiBufferItem;<N><N>
{<N>  Load a midifile and get access to tracks and events<N>  I did build this component to convert midifiles to wave files<N>  or play the files on a software synthesizer which I'm currenly<N>  building.<N><N>  version 1.0 first release<N><N>  version 1.1<N>    added some function<N>    function KeyToStr(key : integer) : string;<N>    function MyTimeToStr(val : integer) : string;<N>    Bpm can be set to change speed<N><N>
  version 1.2<N>    added some functions<N>    function  GetTrackLength:integer;<N>    function  Ready: boolean;<N><N>  version 1.3<N>    update by Chulwoong,<N>    He knows how to use the MM timer, the timing is much better now, thank you<N><N>  for comments/bugs<N>  F.Bouwmans<N>  fbouwmans@spiditel.nl<N><N>
  if you think this component is nice and you use it, sent me a short email.<N>  I've seen that other of my components have been downloaded a lot, but I've<N>  got no clue wether they are actually used.<N>  Don't worry because you are free to use these components<N><N>
  Timing has improved, however because the messages are handled by the normal<N>  windows message loop (of the main window) it is still influenced by actions<N>  done on the window (minimize/maximize ..).<N>  Use of a second thread with higher priority which only handles the<N>  timer message should increase performance. If somebody knows such a component<N>  which is freeware please let me know.<N><N>
  interface description:<N><N>  procedure ReadFile:<N>    actually read the file which is set in Filename<N><N>  function GetTrack(index: integer) : TMidiTrack;<N><N>  property Filename<N>    set/read filename of midifile<N><N>  property NumberOfTracks<N>    read number of tracks in current file<N><N>
  property TicksPerQuarter: integer<N>    ticks per quarter, tells how to interpret the time value in midi events<N><N>  property FileFormat: TFileFormat<N>    tells the format of the current midifile<N><N>  property Bpm:integer<N>    tells Beats per minut<N><N>
  property OnMidiEvent:TOnMidiEvent<N>    called while playing for each midi event<N><N>  procedure StartPlaying;<N>    start playing the current loaded midifile from the beginning<N><N>  procedure StopPlaying;<N>    stop playing the current midifile<N><N>
  procedure PlayToTime(time : integer);<N>    if playing yourself then events from last time to this time are produced<N><N><N>  function KeyToStr(key : integer) : string;<N>      give note string on key value:  e.g. C4<N><N>  function MyTimeToStr(val : integer) : string;<N>      give time string from msec time<N><N>
  function  GetTrackLength:integer;<N>      gives the track lenght in msec (assuming the bpm at the start oof the file)<N><N>  function  Ready: boolean;<N>      now you can check wether the playback is finished<N><N>}<N><N>unit MidiFile;<N><N>interface<N><N>
{$IFDEF FPC}<N>  {$MODE Delphi}<N>  {$H+} // use long strings<N>{$ENDIF}<N><N>uses<N>  Windows,<N>  Messages,<N>  Classes,<N>  {$IFDEF FPC}<N>  WinAllocation,<N>  {$ENDIF}<N>  SysUtils,<N>  UPath;<N><N>type<N>  TChunkType = (illegal, header, track);<N>  TFileFormat = (single, multi_synch, multi_asynch);<N>  PByte = ^byte;<N><N>
  TMidiEvent = record<N>    event: byte;<N>    data1: byte;<N>    data2: byte;<N>    str: string;<N>    dticks: integer;<N>    time: integer;<N>    mtime: integer;<N>    len: integer;<N>  end;<N>  PMidiEvent = ^TMidiEvent;<N><N>  TOnMidiEvent = procedure(event: PMidiEvent) of object;<N>  TEvent = procedure of object;<N><N>
  TMidiTrack = class(TObject)<N>  protected<N>    events: TList;<N>    name: string;<N>    instrument: string;<N>    currentTime: integer;<N>    currentPos: integer;<N>    ready: boolean;<N>    trackLenght: integer;<N>    procedure checkReady;<N>  public<N>    OnMidiEvent: TOnMidiEvent;<N>    OnTrackReady: TEvent;<N>    constructor Create;<N>    destructor Destroy; override;<N><N>
    procedure Rewind(pos: integer);<N>    procedure PlayUntil(pos: integer);<N>    procedure GoUntil(pos: integer);<N><N>    procedure putEvent(event: PMidiEvent);<N>    function getEvent(index: integer): PMidiEvent;<N>    function getName: string;<N>    function getInstrument: string;<N>    function getEventCount: integer;<N>    function getCurrentTime: integer;<N>    function getTrackLength: integer;<N>    function isReady:boolean;<N>  end;<N><N>
  TMidiFile = class(TComponent)<N>  private<N>    { Private declarations }<N>    procedure MidiTimer(sender : TObject);<N>    procedure WndProc(var Msg : TMessage);<N>  protected<N>    { Protected declarations }<N>    MidiFile: TBinaryFileStream;<N>    chunkType: TChunkType;<N>    chunkLength: integer;<N>    chunkData: PByte;<N>    chunkIndex: PByte;<N>    chunkEnd: PByte;<N>    FPriority: dword;<N><N>
    // midi file attributes<N>    FFileFormat: TFileFormat;<N>    numberTracks: integer;<N>    deltaTicks: integer;<N>    FBpm: integer;<N>    FBeatsPerMeasure: integer;<N>    FusPerTick: double;<N>    FFilename: IPath;<N><N>    Tracks: TList;<N>    currentTrack: TMidiTrack;<N>    FOnMidiEvent: TOnMidiEvent;<N>    FOnUpdateEvent: TNotifyEvent;<N><N>
{$MODE OBJFPC}<N><N>unit cpucount;<N>interface<N>//returns number of cores: a computer with two hyperthreaded cores will report 4<N>function GetLogicalCpuCount: Integer;<N><N>implementation<N><N>{$IF defined(windows)}<N>uses windows;<N>{$endif}<N><N>{$IF defined(darwin)}<N>uses ctypes, sysctl;<N>{$endif}<N><N>
unit WinAllocation;<N><N>// FPC misses AllocateHWnd and DeallocateHWnd which is used by several<N>// libraries such as Midi... or DirWatch.<N>// Since FPC 2.2.2 there are dummies in Classes that just raise RunTime exceptions.<N>// To avoid those exceptions, include this unit AFTER Classes.<N>// Maybe the dummies will be replaced by functional routines in the future.WinAllocation<N>//<N>// THESE FUNCTIONS ARE ONLY FOR COMPATIBILITY WITH SOME EXTERNAL WIN32 LIBS.<N>// DO NOT USE THEM IN USDX CODE.<N>//<N><N>
interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>uses<N>  Classes,<N>  Windows;<N><N>function  AllocateHWnd(Method: TWndMethod): HWND;<N>procedure DeallocateHWnd(hWnd: HWND);<N><N>implementation<N><N>function AllocateHWndCallback(hWnd: HWND; uMsg: UINT; wParam: WPARAM; lParam: LPARAM): LRESULT; stdcall;<N>var<N>  Msg: TMessage;<N>  MethodPtr: ^TWndMethod;<N>begin<N>  FillChar(Msg, SizeOf(Msg), 0);<N>  Msg.msg := uMsg;<N>  Msg.wParam := wParam;<N>  Msg.lParam := lParam;<N><N>
  MethodPtr := Pointer(GetWindowLongPtr(hwnd, GWL_USERDATA));<N>  if Assigned(MethodPtr) then<N>    MethodPtr^(Msg);<N><N>  Result := DefWindowProc(hwnd, uMsg, wParam, lParam);<N>end;<N><N>function AllocateHWnd(Method: TWndMethod): HWND;<N>var<N>  ClassExists: Boolean;<N>  WndClass, OldClass: TWndClass;<N>  MethodPtr: ^TMethod;<N>begin<N>  Result := 0;<N><N>
  // setup class-info<N>  FillChar(WndClass, SizeOf(TWndClass), 0);<N>  WndClass.hInstance := HInstance;<N>  // Important: do not enable AllocateHWndCallback before the msg-handler method is assigned,<N>  //   otherwise race-conditions might occur<N>  WndClass.lpfnWndProc := @DefWindowProc;<N>  WndClass.lpszClassName:= 'USDXUtilWindowClass';<N><N>
{*<N>SDL_net:  An example cross-platform network library for use with SDL<N>Copyright (C) 1997-2013 Sam Lantinga <slouken@libsdl.org><N>Copyright (C) 2012 Simeon Maxein <smaxein@googlemail.com><N><N>This software is provided 'as-is', without any express or implied<N>warranty.  In no event will the authors be held liable for any damages<N>arising from the use of this software.<N><N>
unit sdl2_ttf;<N><N>{*<N>  SDL_ttf:  A companion library to SDL for working with TrueType (tm) fonts<N>  Copyright (C) 2001-2013 Sam Lantinga <slouken@libsdl.org><N><N>  This software is provided 'as-is', without any express or implied<N>  warranty.  In no event will the authors be held liable for any damages<N>  arising from the use of this software.<N><N>
unit sdl2_image;<N><N>{*<N>  SDL_image:  An example image loading library for use with SDL<N>  Copyright (C) 1997-2013 Sam Lantinga <slouken@libsdl.org><N><N>  Pascal-Header-Translation 2013 by Tim Blume<N><N>  Both, header translation and sdl_image, under following license:<N><N>
  This software is provided 'as-is', without any express or implied<N>  warranty.  In no event will the authors be held liable for any damages<N>  arising from the use of this software.<N><N>  Permission is granted to anyone to use this software for any purpose,<N>  including commercial applications, and to alter it and redistribute it<N>  freely, subject to the following restrictions:<N><N>
  1. The origin of this software must not be misrepresented; you must not<N>     claim that you wrote the original software. If you use this software<N>     in a product, an acknowledgment in the product documentation would be<N>     appreciated but is not required.<N>  2. Altered source versions must be plainly marked as such, and must not be<N>     misrepresented as being the original software.<N>  3. This notice may not be removed or altered from any source distribution.<N><N>
  ChangeLog (Header-Translation):<N>  -------------------------------<N><N>  v.1.72-stable; 29.09.2013: fixed bug with procedure without parameters <N>                             (they must have brackets)<N>  v.1.70-stable; 11.09.2013: MacOS compatibility (with Delphi)<N>  v.1.33-Alpha; 31.07.2013: Initial Commit<N><N>
*}<N><N>{$DEFINE SDL_IMAGE}<N><N>{$I jedi.inc}<N><N>interface<N><N>uses<N>  SDL2;<N><N>const<N>  {$IFDEF WINDOWS}<N>    IMG_LibName = 'SDL2_image.dll';<N>  {$ENDIF}<N><N>  {$IFDEF UNIX}<N>    {$IFDEF DARWIN}<N>      IMG_LibName = 'libSDL2_image.dylib';<N>    {$ELSE}<N>      {$IFDEF FPC}<N>        IMG_LibName = 'libSDL2_image.so';<N>      {$ELSE}<N>        IMG_LibName = 'libSDL2_image.so.0';<N>      {$ENDIF}<N>    {$ENDIF}<N>  {$ENDIF}<N><N>
  {$IFDEF MACOS}<N>    IMG_LibName = 'SDL2_image';<N>    {$IFDEF FPC}<N>      {$linklib libSDL2_image}<N>    {$ENDIF}<N>  {$ENDIF}<N><N>  {* Printable format: "%d.%d.%d", MAJOR, MINOR, PATCHLEVEL *}<N>  SDL_IMAGE_MAJOR_VERSION = 2;<N>  SDL_IMAGE_MINOR_VERSION = 0;<N>  SDL_IMAGE_PATCHLEVEL    = 0;<N><N>
unit sdl2_mixer;<N><N>{*<N>  SDL_mixer:  An audio mixer library based on the SDL library<N>  Copyright (C) 1997-2013 Sam Lantinga <slouken@libsdl.org><N><N>  This software is provided 'as-is', without any express or implied<N>  warranty.  In no event will the authors be held liable for any damages<N>  arising from the use of this software.<N><N>
unit sdl2_gfx;<N><N>(*<N><N>SDL2_framerate.h: framerate manager<N>SDL2_gfxPrimitives.h: graphics primitives for SDL<N>SDL2_imageFilter.h: byte-image "filter" routines <N>SDL2_rotozoom.h: rotozoomer, zoomer and shrinker for 32bit or 8bit surfaces<N><N>Copyright (C) 2001-2012  Andreas Schiffler<N><N>
This software is provided 'as-is', without any express or implied<N>warranty. In no event will the authors be held liable for any damages<N>arising from the use of this software.<N><N>Permission is granted to anyone to use this software for any purpose,<N>including commercial applications, and to alter it and redistribute it<N>freely, subject to the following restrictions:<N><N>
1. The origin of this software must not be misrepresented; you must not<N>claim that you wrote the original software. If you use this software<N>in a product, an acknowledgment in the product documentation would be<N>appreciated but is not required.<N><N>2. Altered source versions must be plainly marked as such, and must not be<N>misrepresented as being the original software.<N><N>
3. This notice may not be removed or altered from any source<N>distribution.<N><N>Andreas Schiffler -- aschiffler at ferzkopp dot net<N><N>*)<N><N>{$INCLUDE jedi.inc}<N><N>interface<N>   uses SDL2;<N><N>const<N>  {$IFDEF WINDOWS}<N>    GFX_LibName = 'SDL2_gfx.dll';<N>  {$ENDIF}<N><N>
  {$IFDEF UNIX}<N>    {$IFDEF DARWIN}<N>      GFX_LibName = 'libSDL2_gfx.dylib';<N>    {$ELSE}<N>      {$IFDEF FPC}<N>        GFX_LibName = 'libSDL2_gfx.so';<N>      {$ELSE}<N>        GFX_LibName = 'libSDL2_gfx.so.0';<N>      {$ENDIF}<N>    {$ENDIF}<N>  {$ENDIF}<N><N>
  {$IFDEF MACOS}<N>    GFX_LibName = 'SDL2_gfx';<N>    {$IFDEF FPC}<N>      {$linklib libSDL2_gfx}<N>    {$ENDIF}<N>  {$ENDIF}<N><N>  {$IF DEFINED(DELPHI) AND DEFINED(MACOS)}<N>     {$DEFINE DELMAC}<N>  {$ENDIF}<N><N>Procedure SDL_GFX_VERSION(Out X: TSDL_Version);<N><N>
{---< SDL2_framerate.h >---}<N><N>Const<N>   {*!<N>    \brief Highest possible rate supported by framerate controller in Hz (1/s).<N>    *}<N>   FPS_UPPER_LIMIT = 200;<N><N>   {*!<N>    \brief Lowest possible rate supported by framerate controller in Hz (1/s).<N>    *}<N>   FPS_LOWER_LIMIT = 1;<N><N>
   {*!<N>    \brief Default rate of framerate controller in Hz (1/s).<N>    *}<N>   FPS_DEFAULT = 30;<N><N>Type<N>   {*! <N>    \brief Structure holding the state and timing information of the framerate controller. <N>    *}<N>   <N>   TFPSManager = record<N>      framecount : uInt32;<N>      rateticks : Single; // float rateticks;<N>      baseticks : uInt32;<N>      lastticks : uInt32;<N>      rate : uInt32;<N>   end;<N>   <N>   PFPSManager = ^TFPSManager;<N><N>
unit opencv_core;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>uses<N>  SysUtils, opencv_types,<N>  {$IFDEF WIN32}<N>    Windows, Dialogs;<N>  {$ELSE}<N>    dynlibs;<N>  {$ENDIF}<N><N>var<N><N>///* Creates IPL image (header and data) */<N>  cvCreateImage: function(size: CvSize; depth: integer; channels: integer ): PIplImage;cdecl;<N>//  cvCreateMemStorage: function( block_size: integer = 0): PCvMemStorage;cdecl;<N><N>
unit opencv_imgproc;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>uses<N>  SysUtils, opencv_types,<N>  {$IFDEF WIN32}<N>    Windows, Dialogs;<N>  {$ELSE}<N>    dynlibs;<N>  {$ENDIF}<N><N>///****************************************************************************************\<N>//*                                    Image Processing                                    *<N>//\****************************************************************************************/<N><N>
///* Copies source 2D array inside of the larger destination array and<N>//   makes a border of the specified type (IPL_BORDER_*) around the copied area. */<N>var cvCopyMakeBorder: procedure (src,dst:PCvArr; offset: CvPoint;<N>                             bordertype: integer; value: CvScalar{CV_DEFAULT(cvScalarAll(0)} ); cdecl;<N><N>
const<N> CV_BLUR_NO_SCALE =0;<N> CV_BLUR          =1;<N> CV_GAUSSIAN      =2;<N> CV_MEDIAN        =3;<N> CV_BILATERAL     =4;<N><N>///* Smoothes array (removes noise) */<N>var cvSmooth: procedure( src, dst: PIplImage;<N>                         smoothtype: integer = CV_GAUSSIAN;<N>                         size1: integer = 3;<N>                         size2: integer = 0;<N>                         sigma1: double = 0;<N>                         sigma2: double = 0);cdecl;<N><N>
///* Convolves the image with the kernel */<N>var cvFilter2D: procedure(src: PCvArr; dst:PCvArr; kernel:PCvMat;<N>                          anchor:CvPoint  );cdecl;<N><N>///* Finds integral image: SUM(X,Y) = sum(x<X,y<Y)I(x,y) */<N>var cvIntegral:procedure(image:PCvArr; sum: PCvArr;<N>                       sqsum:PCvArr = nil;<N>                       tilted_sum:PCvArr = nil);cdecl;<N><N>
///*<N>//   Smoothes the input image with gaussian kernel and then down-samples it.<N>//   dst_width = floor(src_width/2)[+1],<N>//   dst_height = floor(src_height/2)[+1]//*/<N>var cvPyrDown: procedure(src: PCvArr; dst: PCvArr;<N>                     filter: integer = 7);cdecl;<N><N>
unit opencv_highgui;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>uses<N>  SysUtils, opencv_types,<N>  {$IFDEF WIN32}<N>    Windows, Dialogs;<N>  {$ELSE}<N>    dynlibs;<N>  {$ENDIF}<N><N><N>///****************************************************************************************\<N>//*                                  Basic GUI functions                                   *<N>//\****************************************************************************************/<N><N>
///* this function is used to set some external parameters in case of X Window */<N>var cvInitSystem:function (argc: integer;argv: ppchar): integer;  cdecl;<N><N>var cvStartWindowThread:function (): integer; cdecl;<N><N>const<N>  CV_WINDOW_AUTOSIZE = 1;<N>var<N>///* create window */<N>  cvNamedWindow: function (name:pansichar; flags: integer): integer; cdecl;<N><N>
///* display image within window (highgui windows remember their content) */<N>  cvShowImage: procedure(name:pansichar; image: pointer); cdecl;<N><N>///* resize/move window */<N>  cvResizeWindow: procedure(name:pansichar; width, height: integer);  cdecl;<N>  cvMoveWindow: procedure(name:pansichar; width, height: integer);  cdecl;<N><N>
<N>///* destroy window and all the trackers associated with it */<N>  cvDestroyWindow: procedure (name:pansichar);  cdecl;<N>  cvDestroyAllWindows: procedure ;  cdecl;<N><N>///* get native window handle (HWND in case of Win32 and Widget in case of X Window) */<N>  cvGetWindowHandle: function(name:pansichar): LongInt; cdecl;<N><N>
///* get name of highgui window given its native handle */<N>  cvGetWindowName: function(window_handle:LongInt): pansichar; cdecl;<N><N>//typedef void (CV_CDECL *CvTrackbarCallback)(int pos);<N><N>///* create trackbar and display it on top of given window, set callback */<N>  cvCreateTrackbar: function(trackbar_name,window_name:pansichar; value: PInteger; count: integer; on_change: pointer ): integer; cdecl;<N><N>
unit opencv_types;<N><N>interface<N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>type<N><N>  PCvArr = ^CvArr;<N>  CvArr = pointer;<N><N><N>  Cv32suf = packed record<N>    i: integer;<N>    u: Cardinal; // unsigned<N>    f: single;<N>  end;<N><N>  Cv64suf = packed record<N>    i: Int64;<N>    u: UInt64;<N>    f: double;<N>  end;<N><N>
<N>///****************************************************************************************\<N>//*                             Common macros and inline functions                         *<N>//\****************************************************************************************/<N>const<N>  CV_PI   = 3.1415926535897932384626433832795;<N>  CV_LOG2 = 0.69314718055994530941723212145818;<N><N>
<N><N><N>///****************************************************************************************\<N>//*                                  Image type (IplImage)                                 *<N>//\****************************************************************************************/<N><N>
<N><N>type<N>  IplROI =  packed record<N>      coi: integer;// /* 0 - no COI (all channels are selected), 1 - 0th channel is selected ...*/<N>      xOffset: integer;//;<N>      yOffset: integer;//;<N>      width: integer;//;<N>      height: integer;//;<N>  end;<N><N>
  IplTileInfo = packed  record<N>  end;<N>  PIplTileInfo = ^IplTileInfo;<N><N>  _IplROI = IplROI;<N>  P_IplROI = ^_IplROI;<N><N><N>const<N>  IPL_DEPTH_SIGN = $80000000;<N><N>  IPL_DEPTH_1U    = 1;<N>  IPL_DEPTH_8U    = 8;<N>  IPL_DEPTH_16U   =16;<N>  IPL_DEPTH_32F   =32;<N><N>
  IPL_DEPTH_8S = (IPL_DEPTH_SIGN OR 8);<N>  IPL_DEPTH_16S= (IPL_DEPTH_SIGN OR 16);<N>  IPL_DEPTH_32S= (IPL_DEPTH_SIGN OR 32);<N><N>  IPL_DATA_ORDER_PIXEL = 0;<N>  IPL_DATA_ORDER_PLANE = 1;<N><N>  IPL_ORIGIN_TL= 0;<N>  IPL_ORIGIN_BL= 1;<N><N>  IPL_ALIGN_4BYTES  = 4;<N>  IPL_ALIGN_8BYTES  = 8;<N>  IPL_ALIGN_16BYTES =16;<N>  IPL_ALIGN_32BYTES =32;<N><N>
  IPL_ALIGN_DWORD =  IPL_ALIGN_4BYTES;<N>  IPL_ALIGN_QWORD =  IPL_ALIGN_8BYTES;<N><N>  IPL_BORDER_CONSTANT  = 0;<N>  IPL_BORDER_REPLICATE = 1;<N>  IPL_BORDER_REFLECT   = 2;<N>  IPL_BORDER_WRAP      = 3;<N><N>type<N>  PPIplImage = ^PIplImage;<N>  PIplImage = ^IplImage;<N><N>
{=============================================================================<N>  BASS_FX 2.4 - Copyright (c) 2002-2014 (: JOBnik! :) [Arthur Aminov, ISRAEL]<N>                                                      [http://www.jobnik.org]<N><N>         bugs/suggestions/questions:<N>           forum  : http://www.un4seen.com/forum/?board=1<N>                    http://www.jobnik.org/smforum<N>           e-mail : bass_fx@jobnik.org<N>        --------------------------------------------------<N><N>
  BASS_FX unit is based on BASS_FX 1.1 unit:<N>  ------------------------------------------<N>  (c) 2002 Roger Johansson. w1dg3r@yahoo.com<N><N>  NOTE: This unit will work only with BASS_FX version 2.4.11.1<N>        Check www.un4seen.com or www.jobnik.org for any later versions.<N><N>
  * Requires BASS 2.4 (available at http://www.un4seen.com)<N><N>  How to install:<N>  ---------------<N>  Copy BASS_FX.PAS & BASS.PAS to the \LIB subdirectory of your Delphi path<N>  or your project dir.<N>=============================================================================}<N><N>
unit BASS_FX;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>  {$PACKRECORDS C}<N>{$ENDIF}<N><N>uses Bass, Math;    // Math is used for BASS_BFX_Linear2dB/dB2Linear functions below<N><N>const<N>	// BASS_CHANNELINFO types<N>	BASS_CTYPE_STREAM_TEMPO = $1f200;<N>	BASS_CTYPE_STREAM_REVERSE = $1f201;<N><N>
	// Tempo / Reverse / BPM / Beat flag<N>	BASS_FX_FREESOURCE = $10000;		// Free the source handle as well?<N><N>	{$IFDEF MSWINDOWS}<N>		bass_fxdll = 'bass_fx.dll';<N>	{$ELSE}<N>		bass_fxdll = 'libbass_fx.so';<N>	{$ENDIF}<N><N>// BASS_FX Version<N>function BASS_FX_GetVersion(): DWORD; {$IFDEF MSWINDOWS}stdcall{$ELSE}cdecl{$ENDIF}; external bass_fxdll;<N><N>
unit ULua;<N><N>(*<N> * A complete Pascal wrapper for Lua DLL module.<N> * Version 5.1 or 5.2<N> *<N> * Created by Geo Massar, 2006<N> * Distributed as free/open source.<N> *)<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>{$DEFINE HaveCONFIG}<N><N>
{$IFDEF HaveCONFIG}<N>uses<N>  UConfig;<N>{$ELSE}<N>const<N>  {$IFNDEF lua_VERSION_MAJOR}<N>  LUA_VERSION_MAJOR = '5';<N>  {$ENDIF}<N>  {$IFNDEF lua_VERSION_MINOR}<N>  LUA_VERSION_MINOR = '1';<N>  {$ENDIF}<N>  {$IFNDEF lua_VERSION_RELEASE}<N>  LUA_VERSION_RELEASE = '4';<N>  {$ENDIF}<N>  LUA_VERSION_INT = 1000000*(ord(LUA_VERSION_MAJOR) - ord('0')) + 1000*(ord(LUA_VERSION_MINOR) - ord('0')) + lua_VERSION_RELEASE;<N>{$ENDIF}<N><N>
const<N>  LUA_VERSION_NUM =     100*(ord(LUA_VERSION_MAJOR) - ord('0')) +       ord(LUA_VERSION_MINOR) - ord('0');<N><N>{$IFDEF WIN32}<N>  LUA_LIB_NAME = 'lua' + LUA_VERSION_MAJOR + '.' + lua_VERSION_MINOR + '.dll';<N>{$ENDIF}<N>{$IFDEF UNIX}<N>  {$IFDEF DARWIN}<N>    LUA_LIB_NAME = 'liblua.dylib';<N>    {$linklib liblua}<N>  {$ELSE}<N>    LUA_LIB_NAME = lua_lib_name;<N>  {$ENDIF}<N>{$ENDIF}<N><N>
type<N>  size_t   = Cardinal;<N>  Psize_t  = ^size_t;<N>  PPointer = ^Pointer;<N>  ptrdiff_t = LongInt;<N><N>  lua_State = record end;<N>  Plua_State = ^lua_State;<N><N>(* formats for Lua numbers *)<N>{$IFNDEF LUA_NUMBER_SCAN}<N>const<N>  LUA_NUMBER_SCAN = '%lf';<N>{$ENDIF}<N><N>
{$IFNDEF LUA_NUMBER_FMT}<N>const<N>  LUA_NUMBER_FMT = '%.14g';<N>{$ENDIF}<N><N>(*****************************************************************************)<N>(*                               luaconfig.h                                 *)<N>(*****************************************************************************)<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit ULuaUsdx;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses ULua;<N><N>{ some basic lua c functions from usdx table }<N><N>{ Usdx.Time - returns sdl_time to have time numbers comparable with<N>              ultrastar deluxe ones. no arguments }<N>function ULuaUsdx_Time(L: Plua_State): Integer; cdecl;<N><N>
{ Usdx.Version - returns Usdx version string (the same that US_Version<N>  language-constant does). no arguments }<N>function ULuaUsdx_Version(L: Plua_State): Integer; cdecl;<N><N>{ Usdx.Hook - returns an hook table with name and Unhook function<N>              arguments: event_name: string }<N>function ULuaUsdx_Hook(L: Plua_State): Integer; cdecl;<N><N>
{ Usdx.ShutMeDown - no results, no arguments<N>  unloads the calling plugin }<N>function ULuaUsdx_ShutMeDown(L: Plua_State): Integer; cdecl;<N><N>const<N>  ULuaUsdx_Lib_f: array [0..4] of lual_reg = (<N>    (name:'Version'; func:ULuaUsdx_Version),<N>    (name:'Time'; func:ULuaUsdx_Time),<N>    (name:'Hook'; func:ULuaUsdx_Hook),<N>    (name:'ShutMeDown'; func:ULuaUsdx_ShutMeDown),<N>    (name:nil;func:nil)<N>  );<N><N>
implementation<N>uses sdl2, ULuaCore, ULuaUtils, UHookableEvent, UConfig;<N><N>{ Usdx.Time - returns sdl_time to have time numbers comparable with<N>              ultrastar deluxe ones. no arguments }<N>function ULuaUsdx_Time(L: Plua_State): Integer; cdecl;<N>  var top: Integer;<N>begin<N>  //remove arguments (if any)<N>  top := lua_gettop(L);<N><N>
  if (top > 0) then<N>    lua_pop(L, top);<N><N>  //push result<N>  lua_pushinteger(L, SDL_GetTicks);<N>  Result := 1; //one result<N>end;<N><N>{ Usdx.Version - returns Usdx version string (the same that US_Version<N>  language-constant does). no arguments }<N>function ULuaUsdx_Version(L: Plua_State): Integer; cdecl;<N>  var top: Integer;<N>begin<N>  //remove arguments (if any)<N>  top := lua_gettop(L);<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit ULuaScreenSing;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  UIni,<N>  ULua;<N><N>{ returns a table with following structure:<N>    t[1..playercount] = score of player i }<N>function ULuaScreenSing_GetScores(L: Plua_State): Integer; cdecl;<N><N>{ returns a table with following structure:<N>    t[1..playercount] = rating of player i range: [0..1] }<N>function ULuaScreenSing_GetRating(L: Plua_State): Integer; cdecl;<N><N>
{ returns a table with following structure:<N>    t[1..playercount] = rect of players score background: table(x, y, w, h) }<N>function ULuaScreenSing_GetScoreBGRect(L: Plua_State): Integer; cdecl;<N><N>{ returns a table with following structure:<N>    t[1..playercount] = rect of players rating bar: table(x, y, w, h) }<N>function ULuaScreenSing_GetRBRect(L: Plua_State): Integer; cdecl;<N><N>
{ ScreenSing.GetBPM - no arguments<N>  returns the beats per minutes of the current song in quarts }<N>function ULuaScreenSing_GetBPM(L: Plua_State): Integer; cdecl;<N><N>{ ScreenSing.BeatsToSeconds(Beats: float)<N>  returns the time in seconds that the given number of beats (in quarts) last }<N>function ULuaScreenSing_BeatsToSeconds(L: Plua_State): Integer; cdecl;<N><N>
{ ScreenSing.SecondsToBeats(Seconds: float)<N>  returns the Beats in quarts that the given seconds last }<N>function ULuaScreenSing_SecondsToBeats(L: Plua_State): Integer; cdecl;<N><N>{ ScreenSing.GetBeat() - returns current beat of lyricstate (in quarts) }<N>function ULuaScreenSing_GetBeat(L: Plua_State): Integer; cdecl;<N><N>
{ finishes current song, if sing screen is not shown it will raise<N>  an error }<N>function ULuaScreenSing_Finish(L: Plua_State): Integer; cdecl;<N><N>{ ScreenSing.GetSettings - no arguments<N>  returns a table filled with the data of TScreenSing.Settings }<N>function ULuaScreenSing_GetSettings(L: Plua_State): Integer; cdecl;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit ULuaUtils;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses ULua, ULuaCore;<N><N>{ converts a lua table with a structure like:<N>    * = 1 , * = 4 , * = 5<N>  to an integer with the value:<N>    0b11001<N>  does not pop anything }<N>function Lua_ToBinInt(L: PLua_State; idx: Integer): Integer;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit ULuaCore;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  SysUtils,<N>  UHookableEvent,<N>  ULua,<N>  UPath;<N><N>type<N>  { this exception is raised when the lua panic function<N>    is called. Only in case we use call instead of pcall.<N>    it has the lua error string in its message attribute }<N>  ELuaException = class(Exception);<N><N>
  { record represents item of Eventlist of TLuaCore }<N>  PEventListItem = ^TEventListItem;<N>  TEventListItem = record<N>    Event: THookableEvent;<N>    Next:  PEventListItem;<N>  end;<N><N>  { record represents a module }<N>  TLuaModule = record<N>    Name:      string;<N>    Functions: array of luaL_reg; // modules functions, with trailing nils this time<N>  end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UPath;<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>{$H+}<N>{$I switches.inc}<N><N>
interface<N><N>uses<N>  SysUtils,<N>  Classes,<N>  IniFiles,<N>  {$IFDEF MSWINDOWS}<N>  LazFileUtils,<N>  LazUTF8,<N>  LazUTF8Classes,<N>  {$ENDIF}<N>  UConfig,<N>  UUnicodeUtils,<N>  SDL2;<N><N>type<N>  IPath = interface;<N><N>  {$IFDEF FPC}<N>  TFileHandle = THandle;<N>  {$ELSE}<N>  TFileHandle = Longint;<N>  {$ENDIF}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UThemes;<N><N>interface<N><N>{$MODE OBJFPC}<N><N>{$I switches.inc}<N><N>
uses<N>  IniFiles,<N>  SysUtils,<N>  Classes,<N>  UCommon,<N>  ULog,<N>  UIni,<N>  USkins,<N>  UTexture,<N>  UPath;<N><N>type<N>  TBackgroundType =<N>    (bgtNone, bgtColor, bgtTexture, bgtVideo, bgtFade, bgtAuto);<N><N>const<N>  ThemeMinVersion = 19.12;<N>  DefaultTheme = 'Argon';<N>  BGT_Names: array [TBackgroundType] of string =<N>    ('none', 'color', 'texture', 'video', 'fade', 'auto');<N><N>
type<N>  TThemeBackground = record<N>    BGType: TBackgroundType;<N>    Color:  TRGB;<N>    Tex:    string;<N>    Alpha:  real;<N>  end;<N><N>const<N>  //Defaul Background for Screens w/o Theme<N>  DEFAULT_BACKGROUND: TThemeBackground = (<N>    BGType: bgtColor;<N>    Color:  (R:1; G:1; B:1);<N>    Tex:    '';<N>    Alpha:  1.0<N>  );<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit USong;<N><N>interface<N>{$IFDEF FPC}<N>  {$MODE OBJFPC}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  {$IFDEF MSWINDOWS}<N>    Windows,<N>  {$ELSE}<N>    {$IFNDEF DARWIN}<N>      syscall,<N>    {$ENDIF}<N>    baseunix,<N>    UnixType,<N>  {$ENDIF}<N>  MD5,<N>  SysUtils,<N>  Classes,<N>  {$IFDEF DARWIN}<N>    cthreads,<N>  {$ENDIF}<N>  UCatCovers,<N>  UCommon,<N>  UFilesystem,<N>  ULog,<N>  UMusic, //needed for TLines<N>  UPath,<N>  UPlatform,<N>  UTexture,<N>  UTextEncoding,<N>  UUnicodeUtils;<N><N>
type<N><N>  TSingMode = ( smNormal, smPartyClassic, smPartyFree, smPartyChallenge, smPartyTournament, smPlaylistRandom , smMedley );<N><N>  TMedleySource = ( msNone, msCalculated, msTag );<N><N>  TMedley = record<N>    Source:       TMedleySource;  //source of the information<N>    StartBeat:    integer;        //start beat of medley<N>    EndBeat:      integer;        //end beat of medley<N>  end;<N><N>
  TScore = record<N>    Name:       UTF8String;<N>    Score:      integer;<N>    Date:       UTF8String;<N>  end;<N><N>  TSong = class<N>  private<N>    SongFile: TTextFileStream;<N>    FileLineNo : integer;  // line, which is read last, for error reporting<N><N>
    function DecodeFilename(Filename: RawByteString): IPath;<N>    procedure ParseNote(LineNumber: integer; TypeP: char; StartP, DurationP, NoteP: integer; LyricS: UTF8String);<N>    procedure NewSentence(LineNumberP: integer; Param1: integer);<N>    procedure FindRefrain(); // tries to find a refrain for the medley mode and preview start<N><N>
    function ParseLyricStringParam(const Line: RawByteString; var LinePos: integer): RawByteString;<N>    function ParseLyricIntParam(const Line: RawByteString; var LinePos: integer): integer;<N>    function ParseLyricText(const Line: RawByteString; var LinePos: integer): RawByteString;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UDraw;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UPathUtils;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UTexture;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UFont;<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>{$I switches.inc}<N><N>
interface<N><N>  // Flip direction of y-axis.<N>  // Default is a cartesian coordinate system with y-axis in upper direction<N>  // but with USDX the y-axis is in lower direction.<N>  {$DEFINE FLIP_YAXIS}<N><N>// Enables the Freetype font cache<N>{$DEFINE ENABLE_FT_FACE_CACHE}<N><N>
uses<N>  {$IF Defined(MSWINDOWS)}<N>  LazUTF8,<N>  LazUTF8Classes,<N>  {$IFEND}<N>  FreeType,<N>  dglOpenGL,<N>  sdl2,<N>  Math,<N>  Classes,<N>  SysUtils,<N>  UUnicodeUtils,<N>  UPath;<N><N>type<N><N>  PGLubyteArray = ^TGLubyteArray;<N>  TGLubyteArray = array[0 .. (MaxInt div SizeOf(GLubyte))-1] of GLubyte;<N>  TGLubyteDynArray = array of GLubyte;<N><N>
  TUCS4StringArray = array of UCS4String;<N><N>  TGLColor = packed record<N>    case byte of<N>      0: ( vals: array[0..3] of GLfloat; );<N>      1: ( r, g, b, a: GLfloat; );<N>  end;<N><N>  TBoundsDbl = record<N>    Left, Right: double;<N>    Bottom, Top: double;<N>  end;<N><N>
  TPositionDbl = record<N>    X, Y: double;<N>  end;<N><N>  TTextureSize = record<N>    Width, Height: integer;<N>  end;<N><N>  TBitmapCoords = record<N>    Left, Top: double;<N>    Width, Height: integer;<N>  end;<N><N>  EFontError = class(Exception);<N><N>
  {**<N>   * Abstract base class representing a glyph.<N>   *}<N>  TGlyph = class<N>    protected<N>      function GetAdvance(): TPositionDbl; virtual; abstract;<N>      function GetBounds(): TBoundsDbl; virtual; abstract;<N>    public<N>      procedure Render(UseDisplayLists: boolean); virtual; abstract;<N>      procedure RenderReflection(); virtual; abstract;<N><N>
      {** Distance to next glyph (in pixels) *}<N>      property Advance: TPositionDbl read GetAdvance;<N>      {** Glyph bounding box (in pixels) *}<N>      property Bounds: TBoundsDbl read GetBounds;<N>  end;<N><N>  {**<N>   * Font styles used by TFont.Style<N>   *}<N>  TFontStyle = set of (Italic, Underline, Reflect);<N><N>
  {**<N>   * Base font class.<N>   *}<N>  TFont = class<N>    private<N>      {** Non-virtual reset-method used in Create() and Reset() }<N>      procedure ResetIntern();<N><N>    protected<N>      fFilename: IPath;<N>      fStyle: TFontStyle;<N>      fUseKerning: boolean;<N>      fLineSpacing: single;       // must be inited by subclass<N>      fReflectionSpacing: single; // must be inited by subclass to -2*Descender<N>      fGlyphSpacing: single;<N>      fReflectionPass: boolean;<N><N>
      {**<N>       * Splits lines in Text seperated by newline (char-code #13).<N>       * @param Text   UCS-4 encoded string<N>       * @param Lines  splitted UCS4String lines<N>       *}<N>      procedure SplitLines(const Text: UCS4String; var Lines: TUCS4StringArray);<N><N>
      {**<N>       * Print an array of UCS4Strings. Each array-item is a line of text.<N>       * Lines of text are seperated by the line-spacing.<N>       * This is the base function for all text drawing.<N>       *}<N>      procedure Print(const Text: TUCS4StringArray); overload; virtual;<N><N>
      {**<N>       * Draws an underline.<N>       *}<N>      procedure DrawUnderline(const Text: UCS4String); virtual;<N><N>      {**<N>       * Renders (one) line of text.<N>       *}<N>      procedure Render(const Text: UCS4String); virtual; abstract;<N><N>
      {**<N>       * Returns the bounds of text-lines contained in Text.<N>       * @param(Advance  if true the right bound is set to the advance instead<N>       *   of the minimal right bound.)<N>       *}<N>      function BBox(const Text: TUCS4StringArray; Advance: boolean): TBoundsDbl; overload; virtual; abstract;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UPlatformWindows;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>// turn off messages for platform specific symbols<N>{$WARN SYMBOL_PLATFORM OFF}<N><N>uses<N>  Windows,<N>  Classes,<N>  UPlatform,<N>  UPath;<N><N>type<N>  TPlatformWindows = class(TPlatform)<N>    private<N>      UseLocalDirs: boolean;<N><N>
      function GetSpecialPath(CSIDL: integer): IPath;<N>      procedure DetectLocalExecution();<N>    public<N>      procedure Init; override;<N>      function TerminateIfAlreadyRunning(var WndTitle: String): Boolean; override;<N><N>      function GetLogPath: IPath; override;<N>      function GetGameSharedPath: IPath; override;<N>      function GetGameUserPath: IPath; override;<N>  end;<N><N>
  function GetConsoleWindow: THandle; stdcall; external kernel32 name 'GetConsoleWindow';<N>  function HasConsole: Boolean;<N><N>implementation<N><N>uses<N>  SysUtils,<N>  ShlObj,<N>  UConfig;<N><N>procedure TPlatformWindows.Init;<N>begin<N>  inherited Init();<N>  DetectLocalExecution();<N>end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UGraphicClasses;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  UTexture,<N>  ULog,<N>  UIni,<N>  SDL2;<N><N>const<N>  DelayBetweenFrames : cardinal = 60;<N><N>type<N><N> TParticleType = (GoldenNote, PerfectNote, NoteHitTwinkle, PerfectLineTwinkle, ColoredStar, Flare);<N><N> TColour3f = record<N>   r, g, b: real;<N> end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UDLLManager;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  UWebSDK,<N>  UFiles,<N>  UPath,<N>  UFilesystem;<N><N>type<N>  TDLLMan = class<N>    private<N>      hLibW:     THandle;<N><N>      P_SendScore:       fModi_SendScore;<N>      P_EncryptScore:    fModi_EncryptScore;<N>      P_Login:           fModi_Login;<N>      P_EncryptPassword: fModi_EncryptPassword;<N>      P_DownloadScore:   fModi_DownloadScore;<N>      P_VerifySong:      fModi_VerifySong;<N><N>
    public<N>      Websites: array of TWebsiteInfo;<N>      WebsitePaths: array of IPath;<N>      SelectedW: ^TWebsiteInfo;<N><N>      constructor Create;<N><N>      procedure GetWebsiteList;<N><N>      procedure ClearWebsiteInfo(No: cardinal);<N>      function  LoadWebsiteInfo(const Filename: IPath; No: cardinal): boolean;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UNote;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UMusic;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  SysUtils,<N>  Classes,<N>  UTime,<N>  UBeatTimer,<N>  UPath,<N>  UWebcam;<N><N>type<N>  TNoteType = (ntFreestyle, ntNormal, ntGolden, ntRap, ntRapGolden);<N><N>  TPos = record<N>    CP:   integer;<N>    line: integer;<N>    note: integer;<N>  end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit ULanguage;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  UUnicodeUtils;<N><N>type<N>  TLanguageEntry = record<N>    ID:     AnsiString;  //**< identifier (ASCII)<N>    Text:   UTF8String;  //**< translation (UTF-8)<N>  end;<N><N>  TLanguageList = record<N>    Name:     AnsiString;  //**< language name (ASCII)<N>  end;<N><N>
  TLanguageEntryArray = array of TLanguageEntry;<N><N>  TLanguage = class<N>    private<N>      List:   array of TLanguageList;<N><N>      Entry:        TLanguageEntryArray; //**< Entrys of Chosen Language<N>      EntryDefault: TLanguageEntryArray; //**< Entrys of Standard Language<N>      EntryConst:   TLanguageEntryArray; //**< Constant Entrys e.g. Version<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UWebcam;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  Classes,<N>  UTexture,<N>  opencv_highgui,<N>  opencv_core,<N>  opencv_imgproc,<N>  opencv_types;<N><N>type<N><N>  TWebcam = class<N>    private<N>      LastTickFrame: integer;<N>      LastFrame:     PIplImage;<N>      RGBFrame:      PIplImage;<N><N>
    public<N>      Capture: PCvCapture;<N>      TextureCam: TTexture;<N><N>      constructor Create;<N>      procedure Release;<N>      procedure Restart;<N>      procedure GetWebcamFrame();<N>      function FrameEffect(Nr_Effect: integer; Frame: PIplImage): PIplImage;<N>      function FrameAdjust(Frame: PIplImage): PIplImage;<N>   end;<N><N>
var<N>  Webcam:    TWebcam;<N>  IsEnabled: Boolean;<N><N><N>implementation<N><N>uses<N>  dglOpenGL,<N>  SysUtils,<N>  sdl2,<N>  ULog,<N>  UIni;<N><N>//----------<N>//Create - Construct Class - Dummy for now<N>//----------<N>constructor TWebcam.Create;<N>var<N>  H, W, I: integer;<N>  s: string;<N>begin<N>  inherited;<N><N>
  if (Ini.WebCamID <> 0) then<N>  begin<N>    try<N>      Capture := cvCreateCameraCapture(Ini.WebCamID - 1);<N>      IsEnabled := true;<N>    except<N>      IsEnabled:=false;<N>    end;<N><N>    if (IsEnabled = true) and (Capture <> nil) then<N>    begin<N>      S := IWebcamResolution[Ini.WebcamResolution];<N><N>
      I := Pos('x', S);<N>      W := StrToInt(Copy(S, 1, I-1));<N>      H := StrToInt(Copy(S, I+1, 1000));<N><N>      cvSetCaptureProperty(Capture, CV_CAP_PROP_FRAME_WIDTH, W);<N>      cvSetCaptureProperty(Capture, CV_CAP_PROP_FRAME_HEIGHT, H);<N>    end;<N>  end;<N><N>
end;<N><N>procedure TWebcam.Release;<N>begin<N>  try<N>  if (IsEnabled = true) and (Capture <> nil) then<N>    cvReleaseCapture(@Capture);<N>  except<N>    ;<N>  end;<N>  IsEnabled:=false;<N>end;<N><N>procedure TWebcam.Restart;<N>begin<N>  Release;<N>  try<N>    Webcam := TWebcam.Create;<N>  except<N>    ;<N>  end;<N>end;<N><N>
procedure TWebcam.GetWebcamFrame();<N>var<N>  WebcamFrame: PIplImage;<N>begin<N>  if (IsEnabled = true) and((SDL_GetTicks() - LastTickFrame) >= 1000/StrToInt(IWebcamFPS[Ini.WebCamFPS])) then<N>  begin<N>    if TextureCam.TexNum > 0 then<N>      UTexture.Texture.UnLoadTexture(TextureCam);<N><N>
    WebcamFrame := cvQueryFrame(Capture);<N><N>    if (Ini.WebCamFlip = 0) then<N>      cvFlip(WebcamFrame, nil, 1);<N><N>    WebcamFrame := FrameAdjust(WebcamFrame);<N>    WebcamFrame := FrameEffect(Ini.WebCamEffect, WebcamFrame);<N><N>    TextureCam := Texture.CreateTexture(WebcamFrame.imageData, nil, WebcamFrame.Width, WebcamFrame.Height, WebcamFrame.depth);<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UFiles;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N>{$I switches.inc}<N><N>
uses<N>  SysUtils,<N>  Classes,<N>  ULog,<N>  UMusic,<N>  USongs,<N>  USong,<N>  UPath;<N><N>procedure ResetSingTemp;<N><N>type<N>  TSaveSongResult = (ssrOK, ssrFileError, ssrEncodingError);<N><N>{**<N> * Throws a TEncodingException if the song's fields cannot be encoded in the<N> * requested encoding.<N> *}<N>function SaveSong(const Song: TSong; const Lines: TLines; const Name: IPath): TSaveSongResult;<N><N>
implementation<N><N>uses<N>  TextGL,<N>  UIni,<N>  UNote,<N>  UPlatform,<N>  UUnicodeUtils,<N>  UTextEncoding;<N><N>//--------------------<N>// Resets the temporary Sentence Arrays for each Player and some other Variables<N>//--------------------<N>procedure ResetSingTemp;<N>var<N>  Count:  integer;<N>begin<N>  for Count := 0 to High(Player) do begin<N>    Player[Count].Score := 0;<N>    Player[Count].LengthNote := 0;<N>    Player[Count].HighNote := -1;<N>  end;<N>end;<N><N>
//--------------------<N>// Saves a Song<N>//--------------------<N>function SaveSong(const Song: TSong; const Lines: TLines; const Name: IPath): TSaveSongResult;<N>var<N>  C:      integer;<N>  N:      integer;<N>  S:      AnsiString;<N>  NoteState: AnsiString;<N>  SongFile: TTextFileStream;<N><N>
  function EncodeToken(const Str: UTF8String): RawByteString;<N>  var<N>    Success: boolean;<N>  begin<N>    Success := EncodeStringUTF8(Str, Result, Song.Encoding);<N>    if (not Success) then<N>      SaveSong := ssrEncodingError;<N>  end;<N>begin<N>  Result := ssrOK;<N><N>
  try<N>    SongFile := TMemTextFileStream.Create(Name, fmCreate);<N>    try<N>      // to-do: should we really write the BOM?<N>      //        it causes problems w/ older versions<N>      //        e.g. usdx 1.0.1a or ultrastar < 0.7.0<N>      if (Song.Encoding = encUTF8) then<N>        SongFile.WriteString(UTF8_BOM);<N><N>
      // do not save "auto" encoding tag<N>      if (Song.Encoding <> encAuto) then<N>        SongFile.WriteLine('#ENCODING:' + EncodingName(Song.Encoding));<N>      SongFile.WriteLine('#TITLE:'    + EncodeToken(Song.Title));<N>      SongFile.WriteLine('#ARTIST:'   + EncodeToken(Song.Artist));<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UImage;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  sdl2,<N>  UPath;<N><N>{$DEFINE HaveBMP}<N>{$DEFINE HaveJPG}<N>//const<N>  //PixelFmt_RGBA<N>  //PixelFmt_RGB<N>  //PixelFmt_BGRA<N>  //PixelFmt_BGR<N><N>type<N>  TImagePixelFmt = (<N>    ipfRGBA, ipfRGB, ipfBGRA, ipfBGR<N>  );<N><N>
(*******************************************************<N> * Image saving<N> *******************************************************)<N>{$IFDEF HaveBMP}<N>function WriteBMPImage(const FileName: IPath; Surface: PSDL_Surface): boolean;<N>{$ENDIF}<N>{$IFDEF HaveJPG}<N>function WriteJPGImage(const FileName: IPath; Surface: PSDL_Surface; Quality: integer): boolean;<N>{$ENDIF}<N><N>
(*******************************************************<N> * Image loading<N> *******************************************************)<N><N>function LoadImage(const Filename: IPath): PSDL_Surface;<N><N>(*******************************************************<N> * Image manipulation<N> *******************************************************)<N><N>
function PixelFormatEquals(fmt1, fmt2: PSDL_PixelFormat): boolean;<N>procedure ScaleImage(var ImgSurface: PSDL_Surface; Width, Height: cardinal);<N>procedure FitImage(var ImgSurface: PSDL_Surface; Width, Height: cardinal);<N>procedure ColorizeImage(ImgSurface: PSDL_Surface; NewColor: cardinal);<N><N>
implementation<N><N>uses<N>  SysUtils,<N>  Classes,<N>  Math,<N>  {$IFDEF MSWINDOWS}<N>  Windows,<N>  {$ENDIF}<N>  {$IFDEF HaveJPG}<N>    {$IFDEF Delphi}<N>    Graphics,<N>    jpeg,<N>    {$ELSE}<N>    jpeglib,<N>    jerror,<N>    jcparam,<N>    jdatadst, jcapimin, jcapistd,<N>    {$ENDIF}<N>  {$ENDIF}<N>  zlib,<N>  SDL2_image,<N>  UCommon,<N>  ULog;<N><N>
function IsRGBSurface(pixelFmt: PSDL_PixelFormat): boolean;<N>begin<N>  Result := (pixelFmt.BitsPerPixel = 24) and<N>            (pixelFmt.RMask = $0000FF)   and<N>            (pixelFmt.GMask = $00FF00)   and<N>            (pixelFmt.BMask = $FF0000);<N>end;<N><N>
function IsRGBASurface(pixelFmt: PSDL_PixelFormat): boolean;<N>begin<N>  Result := (pixelFmt.BitsPerPixel = 32) and<N>            (pixelFmt.RMask = $000000FF) and<N>            (pixelFmt.GMask = $0000FF00) and<N>            (pixelFmt.BMask = $00FF0000) and<N>            (pixelFmt.AMask = $FF000000);<N>end;<N><N>
function IsBGRSurface(pixelFmt: PSDL_PixelFormat): boolean;<N>begin<N>  Result := (pixelFmt.BitsPerPixel = 24) and<N>            (pixelFmt.BMask = $0000FF)   and<N>            (pixelFmt.GMask = $00FF00)   and<N>            (pixelFmt.RMask = $FF0000);<N>end;<N><N>
function IsBGRASurface(pixelFmt: PSDL_PixelFormat): boolean;<N>begin<N>  Result := (pixelFmt.BitsPerPixel = 32) and<N>            (pixelFmt.BMask = $000000FF) and<N>            (pixelFmt.GMask = $0000FF00) and<N>            (pixelFmt.RMask = $00FF0000) and<N>            (pixelFmt.AMask = $FF000000);<N>end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit USongs;<N><N>interface<N><N>{$MODE OBJFPC}<N><N>{$I switches.inc}<N><N>
uses<N>  Classes,<N>  {$IFDEF MSWINDOWS}<N>    Windows,<N>    LazUTF8Classes,<N>  {$ELSE}<N>    baseunix,<N>    cthreads,<N>    cmem,<N>    {$IFNDEF DARWIN}<N>    syscall,<N>    {$ENDIF}<N>    UnixType,<N>  {$ENDIF}<N>  CpuCount,<N>  sdl2,<N>  SysUtils,<N>  UCatCovers,<N>  UCommon,<N>  UImage,<N>  UIni,<N>  ULog,<N>  UPath,<N>  UPlatform,<N>  UPlaylist,<N>  USong,<N>  UTexture;<N><N>
type<N>  TSongFilter = (sfAll, sfArtist, sfCategory, sfPlaylist, sfTitle);<N><N>  TScore = record<N>    Name:   UTF8String;<N>    Score:  integer;<N>    Length: string;<N>  end;<N><N>  TProgressSong = record<N>    Folder: UTF8String;<N>    FolderProcessed: UTF8String;<N>    Total: integer;<N>    Finished: boolean;<N>    CoversPreload: boolean;<N>  end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UPlatform;<N><N>// Comment by Eddie:<N>// This unit defines an interface for platform specific utility functions.<N>// The Interface is implemented in separate files for each platform:<N>// UPlatformWindows, UPlatformLinux and UPlatformMacOSX.<N><N>
interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>{$I switches.inc}<N><N>uses<N>  Classes,<N>  UPath;<N><N>type<N>  TPlatform = class<N>    function GetExecutionDir(): IPath;<N>    procedure Init; virtual;<N><N>    function TerminateIfAlreadyRunning(var WndTitle: string): boolean; virtual;<N>    procedure Halt; virtual;<N><N>
    function GetLogPath:        IPath; virtual; abstract;<N>    function GetGameSharedPath: IPath; virtual; abstract;<N>    function GetGameUserPath:   IPath; virtual; abstract;<N>  end;<N><N>  function Platform(): TPlatform;<N><N>implementation<N><N>uses<N>  SysUtils,<N>  {$IF Defined(MSWINDOWS)}<N>  UPlatformWindows,<N>  {$ELSEIF Defined(DARWIN)}<N>  UPlatformMacOSX,<N>  {$ELSEIF Defined(UNIX)}<N>  UPlatformLinux,<N>  {$IFEND}<N>  ULog,<N>  UUnicodeUtils,<N>  UFilesystem;<N><N>
<N>// I modified it to use the Platform_singleton in this location (in the implementation)<N>// so that this variable can NOT be overwritten from anywhere else in the application.<N>// the accessor function platform, emulates all previous calls to work the same way.<N>var<N>  Platform_singleton: TPlatform;<N><N>
function Platform: TPlatform;<N>begin<N>  Result := Platform_singleton;<N>end;<N><N>(**<N> * Default Init() implementation<N> *)<N>procedure TPlatform.Init;<N>begin<N>end;<N><N>(**<N> * Default Halt() implementation<N> *)<N>procedure TPlatform.Halt;<N>begin<N>  // Note: Application.terminate is NOT the same<N>  System.Halt;<N>end;<N><N>
{**<N> * Returns the directory of the executable<N> *}<N>function TPlatform.GetExecutionDir(): IPath;<N>var<N>  ExecName, ExecDir: IPath;<N>begin<N>  ExecName := Path(ParamStr(0));<N>  ExecDir := ExecName.GetPath;<N>  Result := ExecDir.GetAbsolutePath();<N>end;<N><N>
(**<N> * Default TerminateIfAlreadyRunning() implementation<N> *)<N>function TPlatform.TerminateIfAlreadyRunning(var WndTitle: string): boolean;<N>begin<N>  Result := false;<N>end;<N><N>initialization<N>{$IF Defined(MSWINDOWS)}<N>  Platform_singleton := TPlatformWindows.Create;<N>{$ELSEIF Defined(DARWIN)}<N>  Platform_singleton := TPlatformMacOSX.Create;<N>{$ELSEIF Defined(UNIX)}<N>  Platform_singleton := TPlatformLinux.Create;<N>{$IFEND}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit ULog;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UParty;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE DELPHI}<N>{$ENDIF}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>//TODO: lots of parts in this code should be rewritten in a more object oriented way.<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit TextGL;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  dglOpenGL,<N>  sdl2,<N>  Classes,<N>  UCommon,<N>  UFont,<N>  ULog,<N>  UPath,<N>  UTexture;<N><N>type<N>  PGLFont = ^TGLFont;<N>  TGLFont = record<N>    Font:     TScalableFont;<N>    Outlined: boolean;<N>    X, Y, Z:  real;<N>  end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UPlaylist;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  Classes,<N>  UIni,<N>  USong,<N>  UPath,<N>  UPathUtils;<N><N>type<N>  TPlaylistItem = record<N>    Artist: UTF8String;<N>    Title:  UTF8String;<N>    SongID: Integer;<N>  end;<N><N>  APlaylistItem = array of TPlaylistItem;<N><N>
  TPlaylist = record<N>    Name:     UTF8String;<N>    Filename: IPath;<N>    Items:    APlaylistItem;<N>  end;<N><N>  APlaylist = array of TPlaylist;<N><N>  //----------<N>  //TPlaylistManager - Class for Managing Playlists (Loading, Displaying, Saving)<N>  //----------<N>  TPlaylistManager = class<N>    private<N><N>
    public<N>      CurPlayList:  integer;<N>      CurItem:      Cardinal;<N><N>      Playlists:    APlaylist;<N><N>      constructor Create;<N>      procedure   LoadPlayLists;<N>      function    LoadPlayList(Index: Cardinal; const Filename: IPath): Boolean;<N>      procedure   SavePlayList(Index: Cardinal);<N><N>
      function SetPlayList(Index: Cardinal): TPlayList;<N><N>      function    AddPlaylist(const Name: UTF8String): Cardinal;<N>      procedure   DelPlaylist(const Index: Cardinal);<N><N>      procedure   AddItem(const SongID: Cardinal; const iPlaylist: Integer = -1);<N>      procedure   DelItem(const iItem: Cardinal; const iPlaylist: Integer = -1);<N><N>
      procedure   GetNames(var PLNames: array of UTF8String);<N>      function    GetIndexbySongID(const SongID: Cardinal; const iPlaylist: Integer = -1): Integer;<N>    end;<N><N>  var<N>    PlayListMan:  TPlaylistManager;<N><N><N>implementation<N><N>uses<N>  LazUTF8,<N>  SysUtils,<N>  USongs,<N>  ULog,<N>  UMain,<N>  UFilesystem,<N>  UGraphic,<N>  UThemes,<N>  UUnicodeUtils;<N><N>
//----------<N>//Create - Construct Class - Dummy for now<N>//----------<N>constructor TPlayListManager.Create;<N>begin<N>  inherited;<N>  Self.CurPlayList := -1;<N>end;<N><N>//----------<N>//LoadPlayLists - Load list of Playlists from PlayList Folder<N>//----------<N>Procedure   TPlayListManager.LoadPlayLists;<N>var<N>  Len:  Integer;<N>  PlayListBuffer: TPlayList;<N>  Iter: IFileIterator;<N>  FileInfo: TFileInfo;<N>begin<N>  SetLength(Playlists, 0);<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit ULyrics;<N><N>interface<N><N>{$MODE OBJFPC}<N><N>{$I switches.inc}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit USingScores;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UGraphic;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UMain;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  SysUtils,<N>  SDL2;<N><N>var<N>  CheckMouseButton: boolean; // for checking mouse motion<N>  MAX_FPS: Byte; // 0 to 255 is enough<N><N><N>procedure Main;<N>procedure MainLoop;<N>procedure CheckEvents;<N><N>type<N>  TMainThreadExecProc = procedure(Data: Pointer);<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UJoystick;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  Classes,<N>  strutils,<N>  typinfo, // for GetEnumName<N>  fgl, // TGFMap<N>  math,<N>  SDL2;<N><N>const<N><N>  JOYSTICK_MOUSE_REPEAT       = 1;<N>  JOYSTICK_MOUSE_DEADZONE     = 0.01;<N>  JOYSTICK_MOUSE_DEFAULTSPEED = 550;<N><N>
  JOYSTICK_AXIS_PRESSED_THRESHOLD = 0.2;<N>  JOYSTICK_AXIS_RELEASED_THRESHOLD = 0.7;<N>  JOYSTICK_AXIS_REPEAT_THRESHOLD = 0.8;<N>  JOYSTICK_AXIS_REPEAT_TIME = 150; // milliseconds to ignore repeated input<N>  JOYSTICK_AXIS_MAX_RANGE = 32767; // SDL ranges -32768 to 32767<N><N>
  { Missing SDL header constants }<N><N>  SDL_HAT_CENTERED  = $0000;<N>  SDL_HAT_UP        = $0001;<N>  SDL_HAT_RIGHT     = $0002;<N>  SDL_HAT_DOWN      = $0004;<N>  SDL_HAT_LEFT      = $0008;<N>  SDL_HAT_RIGHTUP   = SDL_HAT_RIGHT or SDL_HAT_UP;<N>  SDL_HAT_RIGHTDOWN = SDL_HAT_RIGHT or SDL_HAT_DOWN;<N>  SDL_HAT_LEFTUP    = SDL_HAT_LEFT or SDL_HAT_UP;<N>  SDL_HAT_LEFTDOWN  = SDL_HAT_LEFT or SDL_HAT_DOWN;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UPlatformLinux;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  Classes,<N>  UPlatform,<N>  UConfig,<N>  UPath;<N><N>type<N>  TPlatformLinux = class(TPlatform)<N>    private<N>      UseLocalDirs: boolean;<N><N>      procedure DetectLocalExecution();<N>      function GetHomeDir(): IPath;<N>    public<N>      procedure Init; override;<N><N>
      function GetLogPath        : IPath; override;<N>      function GetGameSharedPath : IPath; override;<N>      function GetGameUserPath   : IPath; override;<N>  end;<N><N>implementation<N><N>uses<N>  UCommandLine,<N>  BaseUnix,<N>  pwd,<N>  SysUtils,<N>  ULog;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UDataBase;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  Classes,<N>  SQLiteTable3,<N>  UDllManager,<N>  UIni,<N>  UPath,<N>  USong,<N>  USongs,<N>  UTextEncoding;<N><N>//--------------------<N>//DataBaseSystem - Class including all DB methods<N>//--------------------<N>type<N>  TStatType = (<N>    stBestScores,   // Best scores<N>    stBestSingers,  // Best singers<N>    stMostSungSong, // Most sung songs<N>    stMostPopBand   // Most popular band<N>  );<N><N>
  // abstract super-class for statistic results<N>  TStatResult = class<N>    public<N>      Typ: TStatType;<N>  end;<N><N>  TStatResultBestScores = class(TStatResult)<N>    public<N>      Singer:       UTF8String;<N>      Score:        word;<N>      Difficulty:   byte;<N>      SongArtist:   UTF8String;<N>      SongTitle:    UTF8String;<N>      Date:         UTF8String;<N>  end;<N><N>
  TStatResultBestSingers = class(TStatResult)<N>    public<N>      Player:       UTF8String;<N>      AverageScore: word;<N>  end;<N><N>  TStatResultMostSungSong = class(TStatResult)<N>    public<N>      Artist:       UTF8String;<N>      Title:        UTF8String;<N>      TimesSung:    word;<N>  end;<N><N>
  TStatResultMostPopBand = class(TStatResult)<N>    public<N>      ArtistName:   UTF8String;<N>      TimesSungTot: word;<N>  end;<N><N>  PUserInfo = ^TUserInfo;<N>  TUserInfo = record<N>    Username:     UTF8String;<N>    Password:     UTF8String;<N>    SendSavePlayer:   integer;<N>    AutoMode:      integer;<N>    AutoPlayer:      integer;<N>    AutoScoreEasy:   integer;<N>    AutoScoreMedium: integer;<N>    AutoScoreHard:   integer;<N>    Save:                boolean;<N>  end;<N><N>
  PNetworkUser = ^TNetworkUser;<N>  TNetworkUser = record<N>    Website:  UTF8String;<N>    UserList: array of TUserInfo;<N>  end;<N><N>  TDataBaseSystem = class<N>    private<N>      ScoreDB:      TSQLiteDatabase;<N>      fFilename: IPath;<N><N>      function GetVersion(): integer;<N>      procedure SetVersion(Version: integer);<N>    public<N>      // Network<N>      NetworkUser: array of TNetworkUser;<N><N>
      property Filename: IPath read fFilename;<N><N>      destructor Destroy; override;<N><N>      procedure Init(const Filename: IPath);<N>      procedure ReadScore(Song: TSong);<N>      procedure AddScore(Song: TSong; Level: integer; const Name: UTF8String; Score: integer);<N>      procedure WriteScore(Song: TSong);<N><N>
      procedure ReadUsers;<N>      procedure UpdateUsers;<N>      procedure DeleteUser(Website: UTF8String; Username: UTF8String);<N>      procedure NewUser(Website: UTF8String; Username, Password: UTF8String);<N><N>      procedure AddWebsite;<N><N>      procedure AddSong(Song: TSong);<N><N>
      procedure AddMax_Score (Song: TSong; WebID: integer; Receive_Max_Score: integer; Level: integer);<N>      procedure AddMedia_Score (Song: TSong; WebID: integer; Receive_Media_Score: integer; Level: integer);<N>      procedure AddUser_Score (Song: TSong; WebID: integer; Receive_User_Score: string; Level: integer);<N><N>
      function ReadMaxScore(Artist, Title: UTF8String; WebID, Level: integer): integer;<N>      function ReadAverageScore(Artist, Title: UTF8String; WebID, Level: integer): integer;<N>      function ReadUser_Score(Artist, Title: UTF8String; WebID, Level: integer): string;<N><N>
      function ReadMaxScoreLocal(Artist, Title: UTF8String; Level: integer): integer;<N>      function ReadAverageScoreLocal(Artist, Title: UTF8String; Level: integer): integer;<N>      function ReadUserScoreLocal(Artist, Title: UTF8String; Level: integer): string;<N><N>
      function Delete_Score(Song: TSong; WebID: integer): integer;<N><N>      function GetStats(Typ: TStatType; Count: byte; Page: cardinal; Reversed: boolean): TList;<N>      procedure FreeStats(StatList: TList);<N>      function GetTotalEntrys(Typ: TStatType): cardinal;<N>      function GetStatReset: TDateTime;<N>      function FormatDate(time_stamp: integer): UTF8String;<N><N>
      procedure SaveSongOptions(Song: TSong; Options: TSongOptions);<N>      function GetSongOptions(Song: TSong): TSongOptions;<N>  end;<N><N>var<N>  DataBase: TDataBaseSystem;<N><N>implementation<N><N>uses<N>  DateUtils,<N>  ULanguage,<N>  UUnicodeUtils,<N>  StrUtils,<N>  SysUtils,<N>  ULog;<N><N>
{<N> cDBVersion - history<N> 0 = USDX 1.01 or no Database<N> 01 = USDX 1.1<N>}<N>const<N>  cDBVersion = 01; // 0.1<N>  cUS_Scores = 'us_scores';<N>  cUS_Songs  = 'us_songs';<N>  cUS_Statistics_Info = 'us_statistics_info';<N>  cUS_Users_Info = 'us_users_info';<N>  cUS_Webs = 'us_webs';<N>  cUS_Webs_Stats = 'us_webs_stats';<N><N>
(**<N> * Open database and create tables if they do not exist<N> *)<N>procedure TDataBaseSystem.Init(const Filename: IPath);<N>begin<N>  if Assigned(ScoreDB) then<N>    Exit;<N><N>  Log.LogStatus('Initializing database: "' + Filename.ToNative + '"', 'TDataBaseSystem.Init');<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UCommandLine;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  UPath;<N><N>type<N>  TScreenMode = (scmDefault, scmFullscreen, scmWindowed);<N>  TSplitMode = (spmDefault, spmNoSplit, spmSplit);<N><N>  {**<N>   * Reads infos from ParamStr and set some easy interface variables<N>   *}<N>  TCMDParams = class<N>    private<N>      fLanguage:   string;<N>      fResolution: string;<N><N>
      procedure ShowHelp();<N><N>      procedure ReadParamInfo;<N>      procedure ResetVariables;<N><N>      function GetLanguage:   integer;<N>      function GetResolution: integer;<N>    public<N>      // some boolean variables set when reading infos<N>      Debug:      boolean;<N>      Benchmark:  boolean;<N>      NoLog:      boolean;<N>      ScreenMode: TScreenMode;<N>      Split:      TSplitMode;<N><N>
      // some value variables set when reading infos {-1: Not Set, others: Value}<N>      Depth:      integer;<N>      Screens:    integer;<N><N>      // some strings set when reading infos {Length=0: Not Set}<N>      SongPath:   IPath;<N>      ConfigFile: IPath;<N>      ScoreFile:  IPath;<N><N>
      // pseudo integer values<N>      property Language:      integer read GetLanguage;<N>      property Resolution:    integer read GetResolution;<N><N>      property CustomResolution:    string read fResolution;<N><N>      // some procedures for reading infos<N>      constructor Create;<N>  end;<N><N>
var<N>  Params:    TCMDParams;<N><N>const<N>  cHelp            = 'help';<N>  cDebug           = 'debug';<N>  cMediaInterfaces = 'showinterfaces';<N><N><N>implementation<N><N>uses SysUtils,<N>     UPlatform;<N><N>{**<N> * Resets variables and reads info<N> *}<N>constructor TCMDParams.Create;<N>begin<N>  inherited;<N><N>
  if FindCmdLineSwitch( cHelp ) or FindCmdLineSwitch( 'h' ) then<N>    ShowHelp();<N><N>  ResetVariables;<N>  ReadParamInfo;<N>end;<N><N>procedure TCMDParams.ShowHelp();<N><N>  function Fmt(aString : string) : string;<N>  begin<N>    Result := Format('%-15s', [aString]);<N>  end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit USkins;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  IniFiles,<N>  UCommon,<N>  UPath;<N><N>type<N>  TSkinTexture = record<N>    Name:     string;<N>    FileName: IPath;<N>  end;<N><N>  TSkinEntry = record<N>    Theme:    string;<N>    Name:     string;<N>    Path:     IPath;<N>    FileName: IPath;<N>    DefaultColor: integer;<N>    Creator:  string;<N>  end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UDisplay;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  dglOpenGL,<N>  Math,<N>  sdl2,<N>  SysUtils,<N>  UCommon,<N>  UHookableEvent,<N>  UMenu,<N>  UMusic,<N>  UPath,<N>  UTexture;<N><N>type<N>  TDisplay = class<N>    private<N>      ePreDraw: THookableEvent;<N>      eDraw: THookableEvent;<N><N>
      // fade-to-black<N>      BlackScreen:   boolean;<N><N>      FadeEnabled:   boolean;  // true if fading is enabled<N>      FadeFailed:    boolean;  // true if fading is possible (enough memory, etc.)<N>      FadeStartTime: cardinal; // time when fading starts, 0 means that the fade texture must be initialized<N>      DoneOnShow:    boolean;  // true if passed onShow after fading<N><N>
      FadeTex:       array[0..1] of GLuint;<N>      TexW, TexH:    Cardinal;<N><N>      FPSCounter:    cardinal;<N>      NextFPSSwap:   cardinal;<N><N>      OSD_LastError: string;<N><N>      { software cursor data }<N>      Cursor_X:              double;<N>      Cursor_Y:              double;<N>      Cursor_Pressed:        boolean;<N><N>
      // used for cursor fade out when there is no movement<N>      Cursor_Visible:      boolean;<N>      Cursor_LastMove:     cardinal;<N>      Cursor_Fade:         boolean;<N><N>      Cursor_Update:       boolean;<N><N>      Console_Draw:         boolean;<N>      Console_ScrollOffset: integer;<N>      // textures for software mouse cursor<N>      Tex_Cursor_Unpressed: TTexture;<N>      Tex_Cursor_Pressed:   TTexture;<N>      procedure DrawDebugInformation;<N>      procedure DrawDebugConsole;<N><N>
      { Handles parsing of inputs when console is opened. Called from ParseInput }<N>      function ConsoleParseInput(PressedKey: cardinal; CharCode: UCS4Char; PressedDown : boolean): boolean;<N>       { Handles parsing of inputs when console is opened. Called from ParseMouse }<N>      function ConsoleParseMouse(MouseButton: integer; BtnDown: boolean; X, Y: integer): boolean;<N><N>
      { called by MoveCursor and OnMouseButton to update last move and start fade in }<N>      procedure UpdateCursorFade;<N><N>    public<N>      NextScreen:          PMenu;<N>      CurrentScreen:       PMenu;<N><N>      // popup data<N>      NextScreenWithCheck: Pmenu;<N>      CheckOK:             boolean;<N><N>
      // FIXME: Fade is set to 0 in UMain and other files but not used here anymore.<N>      Fade:                real;<N><N>      constructor Create;<N>      destructor  Destroy; override;<N><N>      procedure InitFadeTextures();<N><N>      procedure ToggleConsole;<N><N>
      procedure SaveScreenShot;<N><N>      function  Draw: boolean;<N><N>      // TODO rewrite ParseInput to include handling/suppressing input as return, use KeepGoing as by-reference<N>      { checks if display is handling the passed key in ParseInput. calls HandleInput of cur or next Screen if assigned }<N>      function ShouldHandleInput(PressedKey: cardinal; CharCode: UCS4Char; PressedDown : boolean; out SuppressKey: boolean): boolean;<N><N>
      { calls ParseInput of cur or next Screen if assigned }<N>      function ParseInput(PressedKey: cardinal; CharCode: UCS4Char; PressedDown : boolean): boolean;<N><N>      { calls ParseMouse of cur or next Screen if assigned }<N>      function ParseMouse(MouseButton: integer; BtnDown: boolean; X, Y: integer): boolean;<N><N>
      { sets SDL_ShowCursor depending on options set in Ini }<N>      procedure SetCursor;<N><N>      { called when cursor moves, positioning of software cursor }<N>      procedure MoveCursor(X, Y: double);<N><N>      { called when left or right mousebutton is pressed or released }<N>      procedure OnMouseButton(Pressed: boolean);<N>      { fades to specific screen (playing specified sound) }<N>      function FadeTo(Screen: PMenu; const aSound: TAudioPlaybackStream = nil): PMenu;<N><N>
      { abort fading to the current screen, may be used in OnShow, or during fade process }<N>      procedure AbortScreenChange;<N><N>      { draws software cursor }<N>      procedure DrawCursor;<N><N>      { forces to update cursor (position and set visibility) }<N>      procedure UpdateCursor;<N><N>
      { returns whether this display is requesting an cursor update }<N>      function NeedsCursorUpdate(): boolean;<N><N>      { called when the window has been resized }<N>      procedure OnWindowResized(); virtual;<N><N>  end;<N><N>var<N>  Display: TDisplay;<N>  SupportsNPOT: Boolean;<N>  LastFPS:       cardinal;<N><N>
const<N>  { constants for screen transition<N>    time in milliseconds }<N>  FADE_DURATION = 400;<N>  { constants for software cursor effects<N>    time in milliseconds }<N>  CURSOR_FADE_IN_TIME = 500;      // seconds the fade in effect lasts<N>  CURSOR_FADE_OUT_TIME = 2000;    // seconds the fade out effect lasts<N>  CURSOR_AUTOHIDE_TIME = 5000;   // seconds until auto fade out starts if there is no mouse movement<N><N>
implementation<N><N>uses<N>  StrUtils,<N>  TextGL,<N>  UCommandLine,<N>  UGraphic,<N>  UIni,<N>  UImage,<N>  ULanguage,<N>  ULog,<N>  UMain,<N>  UPathUtils,<N>  UTime;<N><N>constructor TDisplay.Create;<N>begin<N>  inherited Create;<N><N>  // create events for plugins<N>  ePreDraw := THookableEvent.Create('Display.PreDraw');<N>  eDraw := THookableEvent.Create('Display.Draw');<N><N>
  // init popup<N>  CheckOK             := false;<N>  NextScreen          := nil;<N>  NextScreenWithCheck := nil;<N>  BlackScreen         := false;<N><N>  // init fade<N>  FadeStartTime := 0;<N>  FadeEnabled := (Ini.ScreenFade = 1);<N>  FadeFailed  := false;<N>  DoneOnShow  := false;<N><N>
  glGenTextures(2, PGLuint(@FadeTex));<N>  SupportsNPOT := (AnsiContainsStr(glGetString(GL_EXTENSIONS),'texture_non_power_of_two')) and not (AnsiContainsStr(glGetString(GL_EXTENSIONS), 'Radeon X16'));<N>  InitFadeTextures();<N><N>  // set LastError for OSD to No Error<N>  OSD_LastError := 'No Errors';<N><N>
  // software cursor default values<N>  Cursor_LastMove := 0;<N>  Cursor_Visible  := false;<N>  Cursor_Pressed  := false;<N>  Cursor_X        := -1;<N>  Cursor_Y        := -1;<N>  Cursor_Fade     := false;<N>  Cursor_Update   := false;<N><N>  Tex_Cursor_Unpressed := UTexture.Texture.LoadTexture('Cursor', TEXTURE_TYPE_TRANSPARENT, 0);<N>  Tex_Cursor_Pressed := UTexture.Texture.LoadTexture('Cursor_Pressed', TEXTURE_TYPE_TRANSPARENT, 0);<N>end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UMenuStatic;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  UTexture,<N>  UMenuInteract,<N>  dglOpenGL;<N><N>type<N>  TStatic = class<N>    public<N>      Texture:           TTexture; // Button Screen position and size<N>      Visible:           boolean;<N><N>      // for list item<N>      TextureSelect:     TTexture;<N>      TextureDeselect:   TTexture; // Button Screen position and size<N><N>
      //Reflection Mod<N>      Reflection:        boolean;<N>      Reflectionspacing: real;<N><N>      procedure Draw;<N>      constructor Create(Textura: TTexture); overload;<N>      function GetMouseOverArea: TMouseOverRect;<N>  end;<N><N>implementation<N>uses<N>  UDrawTexture,<N>  UDisplay;<N><N>
procedure TStatic.Draw;<N>begin<N>  if Visible then<N>  begin<N>    DrawTexture(Texture);<N><N>  //Reflection Mod<N>    if (Reflection) then // Draw Reflections<N>    begin<N>      with Texture do<N>      begin<N>        //Bind Tex and GL Attributes<N>        glEnable(GL_TEXTURE_2D);<N>        glEnable(GL_BLEND);<N><N>
        glDepthRange(0, 10);<N>        glDepthFunc(GL_LEQUAL);<N>        glEnable(GL_DEPTH_TEST);<N><N>        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);<N>        glBindTexture(GL_TEXTURE_2D, TexNum);<N><N>        //Draw<N>        glBegin(GL_QUADS);//Top Left<N>          glColor4f(ColR * Int, ColG * Int, ColB * Int, Alpha-0.3);<N>          glTexCoord2f(TexX1*TexW, TexY2*TexH);<N>          glVertex3f(x, y+h*scaleH+ Reflectionspacing, z);<N><N>
          //Bottom Left<N>          glColor4f(ColR * Int, ColG * Int, ColB * Int, 0);<N>          glTexCoord2f(TexX1*TexW, 0.5*TexH+TexY1);<N>          glVertex3f(x, y+h*scaleH + h*scaleH/2 + Reflectionspacing, z);<N><N><N>          //Bottom Right<N>          glColor4f(ColR * Int, ColG * Int, ColB * Int, 0);<N>          glTexCoord2f(TexX2*TexW, 0.5*TexH+TexY1);<N>          glVertex3f(x+w*scaleW, y+h*scaleH + h*scaleH/2 + Reflectionspacing, z);<N><N>
          //Top Right<N>          glColor4f(ColR * Int, ColG * Int, ColB * Int, Alpha-0.3);<N>          glTexCoord2f(TexX2*TexW, TexY2*TexH);<N>          glVertex3f(x+w*scaleW, y+h*scaleH + Reflectionspacing, z);<N>        glEnd;<N><N>        glDisable(GL_TEXTURE_2D);<N>        glDisable(GL_DEPTH_TEST);<N>        glDisable(GL_BLEND);<N>      end;<N>    end;<N>  end;<N>end;<N><N>
constructor TStatic.Create(Textura: TTexture);<N>begin<N>  inherited Create;<N>  Texture := Textura;<N>end;<N><N>function TStatic.GetMouseOverArea: TMouseOverRect;<N>begin<N>  Result.X := Self.Texture.X;<N>  Result.Y := Self.Texture.Y;<N>  Result.W := Self.Texture.W;<N>  Result.H := Self.Texture.H;<N>end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UMenuSelectSlide;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UMenuText;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  math,<N>  SysUtils,<N>  dglOpenGL,<N>  sdl2,<N>  TextGL,<N>  UMenuInteract,<N>  UTexture;<N><N>type<N>  TText = class<N>    private<N>      SelectBool:  boolean;<N>      TextString:  UTF8String;<N>      TextTiles:   array of UTF8String;<N><N>
      STicks:      cardinal;<N>      SelectBlink: boolean;<N>    public<N>      X:      real;<N>      Y:      real;<N>      Z:      real;<N>      MoveX:  real;       // some modifier for x - position that don't affect the real Y<N>      MoveY:  real;       // some modifier for y - position that don't affect the real Y<N>      W:      real;       // text wider than W is broken<N>//      H:      real;<N>      Size:   real;<N>      ColR:   real;<N>      ColG:   real;<N>      ColB:   real;<N><N>
      Alpha:  real;<N>      Int:    real;<N>      Style:   integer;<N>      Visible: boolean;<N>      Align:   integer; // 0 = left, 1 = center, 2 = right<N><N>      // reflection<N>      Reflection:        boolean;<N>      ReflectionSpacing: real;<N><N>      Writable: boolean;<N><N>
      procedure SetSelect(Value: boolean);<N>      property Selected: boolean read SelectBool write SetSelect;<N><N>      procedure SetText(Value: UTF8String);<N>      property  Text: UTF8String read TextString write SetText;<N><N>      procedure DeleteLastLetter; //< Deletes the rightmost letter<N><N>
      procedure Draw;<N>      constructor Create; overload;<N>      constructor Create(X, Y: real; const Text: UTF8String); overload;<N>      constructor Create(ParX, ParY, ParW: real; ParStyle: integer; ParSize, ParColR, ParColG, ParColB: real; ParAlign: integer; const ParText: UTF8String; ParReflection: boolean; ParReflectionSpacing: real; ParZ: real; Writable: boolean); overload;<N><N>
      function GetMouseOverArea: TMouseOverRect;<N>  end;<N><N>implementation<N><N>uses<N>  UGraphic,<N>  UDisplay,<N>  {$IFDEF MSWINDOWS}<N>    LazUTF8,<N>  {$ELSE}<N>    UUnicodeUtils,<N>  {$ENDIF}<N>  StrUtils;<N><N>procedure TText.SetSelect(Value: boolean);<N>begin<N>  SelectBool := Value;<N><N>
  // set cursor visible<N>  SelectBlink := true;<N>  STicks := SDL_GetTicks() div 550;<N>end;<N><N>procedure TText.SetText(Value: UTF8String);<N>var<N>  NextPos:   cardinal;  // next pos of a space etc.<N>  LastPos:   cardinal;  // last pos "<N>  LastBreak: cardinal;  // last break<N>  isBreak:   boolean;   // true if the break is not caused because the text is out of the area<N>  FirstWord: word;      // is first word after break?<N>  Len:       word;      // length of the tiles array<N><N>
  function GetNextPos: boolean;<N>  var<N>    T1, {T2,} T3: cardinal;<N>  begin<N>    LastPos := NextPos;<N><N>    // next space (if width is given)<N>    if (W > 0) then<N>      T1 := PosEx(' ', Value, LastPos + 1)<N>    else<N>      T1 := Length(Value);<N><N>
    {// next -<N>    T2 := PosEx('-', Value, LastPos + 1);}<N><N>    // next break<N>    T3 := PosEx('\n', Value, LastPos + 1);<N><N>    if T1 = 0 then<N>      T1 := Length(Value);<N>    {if T2 = 0 then<N>      T2 := Length(Value); }<N>    if T3 = 0 then<N>      T3 := Length(Value);<N><N>
    // get nearest pos<N>    NextPos := min(T1, T3{min(T2, T3)});<N><N>    if (LastPos = cardinal(Length(Value))) then<N>      NextPos := 0;<N><N>    isBreak := (NextPos = T3) and (NextPos <> cardinal(Length(Value)));<N>    Result := (NextPos <> 0);<N>  end;<N><N>
  procedure AddBreak(const From, bTo: cardinal);<N>  begin<N>    if (isBreak) or (bTo - From >= 1) then<N>    begin<N>      Inc(Len);<N>      SetLength (TextTiles, Len);<N>      TextTiles[Len-1] := Trim(Copy(Value, From, bTo - From));<N><N>      if isBreak then<N>        LastBreak := bTo + 2<N>      else<N>        LastBreak := bTo + 1;<N>      FirstWord := 0;<N>    end;<N>  end;<N><N>
begin<N>  isBreak:=false;<N>  // set TextString<N>  TextString := Value;<N><N>  // set cursor visible<N>  SelectBlink := true;<N>  STicks := SDL_GetTicks() div 550;<N><N>  // exit if there is no need to create tiles<N>  if (W <= 0) and (Pos('\n', Value) = 0) then<N>  begin<N>    SetLength (TextTiles, 1);<N>    TextTiles[0] := Value;<N>    Exit;<N>  end;<N><N>
  // create tiles<N>  // reset text array<N>  SetLength (TextTiles, 0);<N>  Len := 0;<N><N>  // reset counter vars<N>  LastPos := 1;<N>  NextPos := 1;<N>  LastBreak := 1;<N>  FirstWord := 1;<N><N>  if (W > 0) then<N>  begin<N>    // set font properties<N>    SetFontStyle(Style);<N>    SetFontSize(Size);<N>  end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UMenu;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  SysUtils,<N>  Math,<N>  dglOpenGL,<N>  sdl2,<N>  ULanguage,<N>  UPath,<N>  UMenuBackground,<N>  UMenuButton,<N>  UMenuButtonCollection,<N>  UMenuInteract,<N>  UMenuSelectSlide,<N>  UMenuStatic,<N>  UMenuText,<N>  UMusic,<N>  UTexture,<N>  UThemes;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N><N>unit UMenuButton;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
{$I switches.inc}<N><N>uses<N>  TextGL,<N>  UTexture,<N>  dglOpenGL,<N>  UMenuText,<N>  sdl2,<N>  UMenuInteract;<N><N>type<N>  CButton = class of TButton;<N><N>  TButton = class<N>    protected<N>      SelectBool:   boolean;<N><N>      FadeProgress: real;<N>      FadeLastTick: cardinal;<N><N>
      DeSelectW,<N>      DeSelectH,<N>      PosX,<N>      PosY:         real;<N><N><N>    public<N>      Text:                      array of TText;<N>      Texture:                   TTexture; // Button Screen position and size<N>      Texture2:                  TTexture; // second texture only used for fading full resolution covers<N><N>
      Colorized:                 boolean;<N>      DeSelectTexture:           TTexture; // texture for colorized hack<N><N>      FadeTex:                   TTexture; //Texture for beautiful fading<N>      FadeTexPos:                byte;     //Pos of the FadeTexture (0: Top, 1: Left, 2: Bottom, 3: Right)<N><N>
      DeselectType:              integer;  // not used yet<N>      Visible:                   boolean;<N><N>      Reflection:                boolean;<N>      Reflectionspacing,<N>      DeSelectReflectionspacing: real;<N><N>      Fade,<N>      FadeText:                  boolean;<N><N>
      Selectable:                boolean;<N><N>      //Number of the Parent Collection, 0 if in no Collection<N>      Parent:  byte;<N><N>      SelectColR,<N>      SelectColG,<N>      SelectColB,<N>      SelectInt,<N>      SelectTInt:   real;<N>      //Fade Mod<N>      SelectW:      real;<N>      SelectH:      real;<N><N>
      DeselectColR,<N>      DeselectColG,<N>      DeselectColB,<N>      DeselectInt,<N>      DeselectTInt: real;<N><N>      procedure SetY(Value: real);<N>      procedure SetX(Value: real);<N>      procedure SetW(Value: real);<N>      procedure SetH(Value: real);<N><N>
      procedure SetSelect(Value: boolean); virtual;<N>      property X: real read PosX write SetX;<N>      property Y: real read PosY write SetY;<N>      property Z: real read Texture.z write Texture.z;<N>      property W: real read DeSelectW write SetW;<N>      property H: real read DeSelectH write SetH;<N>      property Selected: boolean read SelectBool write SetSelect;<N><N>
      procedure   Draw; virtual;<N><N>      constructor Create(); overload;<N>      constructor Create(Textura: TTexture); overload;<N>      constructor Create(Textura, DSTexture: TTexture); overload;<N>      destructor  Destroy; override;<N><N>      function GetMouseOverArea: TMouseOverRect;<N>  end;<N><N>
implementation<N><N>uses<N>  SysUtils,<N>  UDisplay,<N>  UDrawTexture;<N><N>procedure TButton.SetX(Value: real);<N>{var<N>  dx:   real;<N>  T:    integer;    // text}<N>begin<N>  {dY := Value - Texture.y;<N><N>  Texture.X := Value;<N><N>  for T := 0 to High(Text) do<N>    Text[T].X := Text[T].X + dY;}<N><N>
  PosX := Value;<N>  if (FadeTex.TexNum = 0) then<N>    Texture.X := Value;<N><N>end;<N><N>procedure TButton.SetY(Value: real);<N>{var<N>  dY: real;<N>  T:  integer;    // text}<N>begin<N>  {dY := Value - PosY;<N><N><N>  for T := 0 to High(Text) do<N>    Text[T].Y := Text[T].Y + dY;}<N><N>
  PosY := Value;<N>  if (FadeTex.TexNum = 0) then<N>    Texture.y := Value;<N>end;<N><N>procedure TButton.SetW(Value: real);<N>begin<N>  if SelectW = DeSelectW then<N>    SelectW := Value;<N><N>  DeSelectW := Value;<N><N>  if not Fade then<N>  begin<N>    if SelectBool then<N>      Texture.W := SelectW<N>    else<N>      Texture.W := DeSelectW;<N>  end;<N>end;<N><N>
procedure TButton.SetH(Value: real);<N>begin<N>  if SelectH = DeSelectH then<N>    SelectH := Value;<N><N>  DeSelectH := Value;<N><N>  if not Fade then<N>  begin<N>    if SelectBool then<N>      Texture.H := SelectH<N>    else<N>      Texture.H := DeSelectH;<N>  end;<N>end;<N><N>
procedure TButton.SetSelect(Value : boolean);<N>var<N>  T: integer;<N>begin<N>  SelectBool := Value;<N><N>  if (Value) then<N>  begin<N>    Texture.ColR  := SelectColR;<N>    Texture.ColG  := SelectColG;<N>    Texture.ColB  := SelectColB;<N>    Texture.Int   := SelectInt;<N><N>
    Texture2.ColR := SelectColR;<N>    Texture2.ColG := SelectColG;<N>    Texture2.ColB := SelectColB;<N>    Texture2.Int  := SelectInt;<N><N>    for T := 0 to High(Text) do<N>    begin<N>      Text[T].SetSelect(SelectBool);<N>      Text[T].Int := SelectTInt;<N>    end;<N><N>
    //Fade Mod<N>    if Fade then<N>    begin<N>      if (FadeProgress <= 0) then<N>        FadeProgress := 0.125;<N>    end<N>    else<N>    begin<N>      Texture.W := SelectW;<N>      Texture.H := SelectH;<N>    end;<N>  end<N>  else<N>  begin<N>    Texture.ColR  := DeselectColR;<N>    Texture.ColG  := DeselectColG;<N>    Texture.ColB  := DeselectColB;<N>    Texture.Int   := DeselectInt;<N><N>
    Texture2.ColR := DeselectColR;<N>    Texture2.ColG := DeselectColG;<N>    Texture2.ColB := DeselectColB;<N>    Texture2.Int  := DeselectInt;<N><N>    for T := 0 to High(Text) do<N>    begin<N>      Text[T].SetSelect(SelectBool);<N>      Text[T].Int := DeselectTInt;<N>    end;<N><N>
    //Fade Mod<N>    if Fade then<N>    begin<N>      if (FadeProgress >= 1) then<N>        FadeProgress := 0.875;<N>    end<N>    else<N>    begin<N>      Texture.W := DeSelectW;<N>      Texture.H := DeSelectH;<N>    end;<N>  end;<N>end;<N><N>// ***** Public methods ****** //<N><N>
procedure TButton.Draw;<N>var<N>  T:       integer;<N>  Tick:    cardinal;<N>  Spacing: real;<N>  y1, y2, y3, y4: real;<N>begin<N>  if Visible then<N>  begin<N>    //Fade Mod<N>    T:=0;<N>    if Fade then<N>    begin<N>      if (FadeProgress < 1) and (FadeProgress > 0) then<N>      begin<N>        Tick := SDL_GetTicks() div 16;<N>        if (Tick <> FadeLastTick) then<N>        begin<N>          FadeLastTick := Tick;<N><N>
          if SelectBool then<N>            FadeProgress := FadeProgress + 0.125<N>          else<N>            FadeProgress := FadeProgress - 0.125;<N><N>          if (FadeText) then<N>          begin<N>            for T := 0 to high(Text) do<N>            begin<N>              Text[T].MoveX := (SelectW - DeSelectW) * FadeProgress;<N>              Text[T].MoveY := (SelectH - DeSelectH) * FadeProgress;<N>            end;<N>          end;<N><N>
{*<N>    UltraStar WorldParty - Karaoke Game<N><N>	UltraStar WorldParty is the legal property of its developers,<N>	whose names	are too numerous to list here. Please refer to the<N>	COPYRIGHT file distributed with this source distribution.<N><N>    This program is free software: you can redistribute it and/or modify<N>    it under the terms of the GNU General Public License as published by<N>    the Free Software Foundation, either version 3 of the License, or<N>    (at your option) any later version.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<N>    GNU General Public License for more details.<N><N>
    You should have received a copy of the GNU General Public License<N>    along with this program. Check "LICENSE" file. If not, see<N>	<http://www.gnu.org/licenses/>.<N> *}<N>unit UWebSDK;<N><N>interface<N><N>{$IFDEF FPC}<N>  {$MODE Delphi}<N>{$ENDIF}<N><N>
(***  Copyright (c) 2002-2005, Jeffrey Pohlmeyer, <yetanothergeek@yahoo.com>  ***)<N>(* Licensed per the file COPYING, which should be included in all distributions *)<N><N>unit curldbug; <N><N>// This unit just returns string representations of the enumerated types.<N>// It is intended for debugging purposes only - NOT for production use!<N><N>
interface<N>{$IFDEF FPC}{$MODE OBJFPC}{$ENDIF}<N><N>uses curlobj, curl_h; <N><N>(*<N>    Using the "curl_h"  and "curlobj" units together is NOT recommended. <N>    It can cause some strange-looking compile-time errors, like:<N>    -->>  Type mismatch: got "CurlCode", expected "CurlCode"  <<-- huh???<N>    This is because the types are defined in both units.<N>    So I had to jump through a few hoops to get this unit to<N>    work with either curlobj or curl_h. <N>*)<N><N>
{ This file was automatically created by Lazarus. Do not edit!<N>This source is only used to compile and install the package.<N> }<N><N>unit curlpas; <N><N>interface<N><N>uses<N>  lazcurl, LazarusPackageIntf; <N><N>implementation<N><N>procedure Register; <N>begin<N>  RegisterUnit('lazcurl', @lazcurl.Register); <N>end; <N><N>initialization<N>  RegisterPackage('curlpas', @Register); <N>end.<N>
(***  Copyright (c) 2002-2005, Jeffrey Pohlmeyer, <yetanothergeek@yahoo.com>  ***)<N>(* Licensed per the file COPYING, which should be included in all distributions *)<N><N>{$IFNDEF CURL_H_INCLUDE}<N>unit curl_h;<N><N>{$IFDEF FPC}{$MODE OBJFPC}{$ENDIF}<N><N>
interface<N><N>{$IFDEF WIN32}<N>uses winsock;<N>{$ELSE}<N>uses BaseUnix;<N>{$ENDIF}<N>{$ENDIF CURL_H_INCLUDE}<N><N>{$MINENUMSIZE 4}<N><N>{$IFDEF WIN32}<N>type<N>  off_t = longint;<N>  size_t = longword;<N>  time_t = longint;<N>  ptime_t = ^time_t;<N>{$ENDIF}<N><N>
const<N>  LIB_CURL = {$IFDEF LINUX} 'libcurl.so' {$ELSE} 'libcurl-3.dll' {$ENDIF};<N><N>{$IFDEF FPC}{$PACKRECORDS C}{$ENDIF}<N><N>const<N>  CURLM_CALL_MULTI_PERFORM = -1;<N>  CURLM_OK = 0;<N>  CURLM_BAD_HANDLE = 1;<N>  CURLM_BAD_EASY_HANDLE = 2;<N>  CURLM_OUT_OF_MEMORY = 3;<N>  CURLM_INTERNAL_ERROR = 4;<N>  CURLM_LAST = 5;<N><N>
type<N>  curlioerr = (<N>    CURLIOE_OK,<N>    CURLIOE_UNKNOWNCMD,<N>    CURLIOE_FAILRESTART,<N>    CURLIOE_LAST<N>  );<N><N>  curliocmd = (<N>    CURLIOCMD_NOP,<N>    CURLIOCMD_RESTARTREAD,<N>    CURLIOCMD_LAST<N>  );<N><N>  curl_infotype = (<N>    CURLINFO_TEXT = 0,<N>    CURLINFO_HEADER_IN,<N>    CURLINFO_HEADER_OUT,<N>    CURLINFO_DATA_IN,<N>    CURLINFO_DATA_OUT,<N>    CURLINFO_SSL_DATA_IN,<N>    CURLINFO_SSL_DATA_OUT,<N>    CURLINFO_END<N>  );<N><N>
unit Only_One;<N><N>interface<N><N>function Init_Mutex(mid: string): boolean;<N><N>implementation<N><N>uses Windows;<N><N>var<N>  mut: thandle;<N><N>function mut_id(s: string): string;<N>var<N>  f: integer;<N>begin<N>  result := s;<N>  for f := 1 to length(s) do<N>    if result[f] = '\' then<N>      result[f] := '_';<N>end;<N><N>
function Init_Mutex(mid: string): boolean;<N>begin<N>  Mut := CreateMutex(nil, false, pchar(mut_id(mid)));<N>  Result := not ((Mut = 0) or (GetLastError = ERROR_ALREADY_EXISTS));<N>end;<N><N>initialization<N>  mut := 0;<N>finalization<N>  if mut <> 0 then<N>    CloseHandle(mut);<N>end.<N><N>
unit uTThreadEndereco;<N><N>interface<N><N>uses<N>  System.Classes, Model.Banco, FireDAC.Comp.Client;<N><N>type<N>  TThreadEndereco = class(TThread)<N>  private<N><N>  protected<N>    dmBanco : TdmBanco;<N>    procedure Execute; override;<N>  public<N>    constructor Create;<N>    procedure  Sincronizar();<N>    destructor Destroy; override;<N>  end;<N><N>
implementation<N><N>{ TThreadEndereco }<N><N>uses Model.Pessoa, Modelo.Endereco, Controller.Pessoa;<N><N>constructor TThreadEndereco.Create;<N>begin<N>  inherited Create(True);<N>  FreeOnTerminate := True;<N><N>  dmBanco := TdmBanco.Create(nil);<N>  dmBanco.Banco.Connected := True;<N>end;<N><N>
destructor TThreadEndereco.Destroy;<N>begin<N>  dmBanco.Banco.Connected := False;<N>  inherited;<N>end;<N><N>procedure TThreadEndereco.Execute;<N>var<N>  qry : TFDQuery;<N>begin<N>  inherited;<N><N>  While True do<N>  begin<N>    Sleep(5000); //Aguarda Cinco segudos<N>    Self.Sincronizar();<N>  end;<N>end;<N><N>
procedure TThreadEndereco.Sincronizar();<N>var<N>  endereco : TEnderecoIntegracao;<N>  serro : string;<N>begin<N>  try<N>    endereco := TEnderecoIntegracao.Create;<N>    endereco.AtualizaEndereco();<N>  except<N>    endereco.Free;<N>  end;<N>end;<N><N>end.<N><N><N>
unit Model.Banco;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf, FireDAC.Stan.Def,<N>  FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys, FireDAC.Phys.PG,<N>  FireDAC.Phys.PGDef, Data.DB, FireDAC.Comp.Client, Vcl.Forms, System.IniFiles,<N>  FireDAC.Stan.Param, FireDAC.DatS, FireDAC.DApt.Intf, FireDAC.DApt,<N>  FireDAC.Comp.DataSet;<N><N>
type<N>  TdmBanco = class(TDataModule)<N>    FDPhysPgDriverLink: TFDPhysPgDriverLink;<N>    SqlAux: TFDQuery;<N>    Banco: TFDConnection;<N>    MemTable: TFDMemTable;<N>    procedure DataModuleCreate(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  dmBanco: TdmBanco;<N><N>implementation<N><N>{%CLASSGROUP 'System.Classes.TPersistent'}<N><N>{$R *.dfm}<N><N>procedure TdmBanco.DataModuleCreate(Sender: TObject);<N>var<N>  ArqIni: TIniFile;<N>  Caminho, sParametros: string;<N>begin<N>  Caminho := ExtractFilePath(Application.ExeName);<N><N>
  ArqIni := TIniFile.Create(Caminho+'Server.ini');<N><N>  try<N>    Banco.Params.Clear;<N>    Banco.Params.Add('Database='+ArqIni.ReadString('Banco', 'Database', ''));<N>    Banco.Params.Add('User_Name='+ArqIni.ReadString('Banco', 'UserName', ''));<N>    Banco.Params.Add('Password='+ArqIni.ReadString('Banco', 'Password', ''));<N>    Banco.Params.Add('Server='+ArqIni.ReadString('Banco', 'Server', ''));<N>    Banco.Params.Add('DriverID=PG');<N>  finally<N>    ArqIni.Free;<N>  end;<N>end;<N><N>
unit Mercado.Libre.View;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms,<N>  Vcl.Dialogs, Vcl.StdCtrls;<N><N>type<N>  TFrmMercadoLibre = class(TForm)<N>    btnGetUserInfo: TButton;<N>    memoResponse: TMemo;<N>    editUserID: TEdit;<N>    editAccess_Token: TEdit;<N>    procedure btnGetUserInfoClick(Sender: TObject);<N>  end;<N><N>
var<N>  FrmMercadoLibre: TFrmMercadoLibre;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses REST.Types, RESTRequest4D, Mercado.Libre.Consts;<N><N>procedure TFrmMercadoLibre.btnGetUserInfoClick(Sender: TObject);<N>var<N>  LResponse: RESTRequest4D.IResponse;<N>begin<N>  if Trim(editUserID.Text) = EmptyStr then<N>    Exit;<N>  if Trim(editAccess_Token.Text) = EmptyStr then<N>    Exit;<N><N>
  LResponse := RESTRequest4D.TRequest.New<N>    .BaseURL(ML_APIBASE)<N>    .Resource(ML_GET_USR_INF_REGEX)<N>    .AddUrlSegment('cust_id', editUserID.Text)<N>    .Token('Bearer ' + editAccess_Token.Text)<N>    .Accept(REST.Types.CONTENTTYPE_APPLICATION_JSON)<N>    .RaiseExceptionOn500(True)<N>    .Get;<N><N>
  memoResponse.Lines.Clear;<N>  memoResponse.Lines.Add(Format('Http status: %d', [LResponse.StatusCode]));<N>  memoResponse.Lines.Add(Format('Http text: %s', [LResponse.StatusText]));<N>  memoResponse.Lines.Add(Format('Response content: %s', [LResponse.Content]));<N>end;<N><N>
unit Samples.Main;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms,<N>  Vcl.Dialogs, Vcl.StdCtrls, FireDAC.Stan.Intf, FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS,<N>  FireDAC.Phys.Intf, FireDAC.DApt.Intf, Data.DB, FireDAC.Comp.DataSet, FireDAC.Comp.Client, Vcl.ExtCtrls, Vcl.ComCtrls,<N>  Vcl.Imaging.pngimage, Vcl.Mask;<N><N>
unit RESTRequest4D.Request.NetHTTP;<N><N>interface<N><N>uses System.Net.Mime, System.Net.HttpClientComponent, System.Net.HttpClient, RESTRequest4D.Request.Contract, System.Classes,<N>  Data.DB, System.JSON, System.SysUtils, REST.Json, IdURI, System.NetEncoding, RESTRequest4D.Utils, DataSet.Serialize,<N>  RESTRequest4D.Response.NetHTTP, RESTRequest4D.Response.Contract, System.Net.URLClient;<N><N>
unit RESTRequest4D.Request.Indy;<N><N>{$IFDEF FPC}<N>  {$mode delphi}<N>{$ENDIF}<N><N>interface<N><N>uses RESTRequest4D.Request.Contract, RESTRequest4D.Response.Contract, IdHTTP, IdSSLOpenSSL, IdCTypes, IdSSLOpenSSLHeaders,<N>  RESTRequest4D.Utils, IdMultipartFormData,<N>  {$IFDEF FPC}<N>    DB, Classes, fpjson, jsonparser, fpjsonrtti, SysUtils;<N>  {$ELSE}<N>    Data.DB, System.Classes, System.JSON, System.SysUtils, REST.Json;<N>  {$ENDIF}<N><N>
unit RESTRequest4D.Request.FPHTTPClient;<N><N>{$IFDEF FPC}<N>  {$mode delphi}<N>{$ENDIF}<N><N>interface<N><N>uses Classes, SysUtils, DB, RESTRequest4D.Request.Contract, RESTRequest4D.Response.Contract,<N>  RESTRequest4D.Utils, DataSet.Serialize, FPHTTPClient, openssl, opensslsockets, fpjson, fpjsonrtti,<N>  Generics.Collections;<N><N>
type<N>  TFile = class<N>  private<N>    FFileStream: TStream;<N>    FFileName: string;<N>    FContentType: string;<N>  public<N>    constructor Create(const AFileStream: TStream; const AFileName: string; const AContentType: string); overload;<N>    destructor Destroy; override;<N>  end;<N><N>
unit RESTRequest4D.Request.Synapse;<N><N>{$IFDEF FPC}<N>  {$mode delphi}<N>{$ENDIF}<N><N>interface<N><N>uses Classes, SysUtils, DB, RESTRequest4D.Request.Contract, RESTRequest4D.Response.Contract, RESTRequest4D.Utils,<N>  DataSet.Serialize, httpsend, ssl_openssl, Generics.Collections,<N>  {$IFDEF FPC}<N>    fpjson, fpjsonrtti, base64;<N>  {$ELSE}<N>    System.Json,<N>    System.NetEncoding,<N>    REST.Json;<N>  {$ENDIF}<N><N>
type<N>  TFile = class<N>  private<N>    FFileStream: TStream;<N>    FFileName: string;<N>    FContentType: string;<N>  public<N>    constructor Create(const AFileStream: TStream; const AFileName: string; const AContentType: string); overload;<N>    destructor Destroy; override;<N>  end;<N><N>
unit RESTRequest4D.Response.Indy;<N><N>{$IFDEF FPC}<N>  {$mode delphi}<N>{$ENDIF}<N><N>interface<N><N>uses RESTRequest4D.Response.Contract, IdHTTP,<N>  {$IFDEF FPC}<N>    SysUtils, fpjson, Classes, jsonparser;<N>  {$ELSE}<N>    System.SysUtils, System.JSON, System.Classes;<N>  {$ENDIF}<N><N>
unit RESTRequest4D;<N><N>interface<N><N>uses<N>  {$IF NOT (DEFINED(RR4D_INDY) or DEFINED(FPC) or DEFINED(RR4D_NETHTTP))}<N>    REST.Types,<N>  {$ENDIF}<N>  RESTRequest4D.Request.Contract, RESTRequest4D.Response.Contract;<N><N>type<N>  IRequest = RESTRequest4D.Request.Contract.IRequest;<N>  IResponse = RESTRequest4D.Response.Contract.IResponse;<N><N>
  TRequest = class<N>  public<N>    class function New: IRequest;<N>  end;<N><N>{$IF NOT (DEFINED(RR4D_INDY) or DEFINED(FPC) or DEFINED(RR4D_NETHTTP))}<N>const<N>  poDoNotEncode = REST.Types.poDoNotEncode;<N>  poTransient = REST.Types.poTransient;<N>  poAutoCreated = REST.Types.poAutoCreated;<N>  {$IF COMPILERVERSION >= 33}<N>    poFlatArray = REST.Types.poFlatArray;<N>    poPHPArray = REST.Types.poPHPArray;<N>    poListArray = REST.Types.poListArray;<N>  {$ENDIF}<N><N>
  pkCOOKIE = REST.Types.pkCOOKIE;<N>  pkGETorPOST = REST.Types.pkGETorPOST;<N>  pkURLSEGMENT = REST.Types.pkURLSEGMENT;<N>  pkHTTPHEADER = REST.Types.pkHTTPHEADER;<N>  pkREQUESTBODY = REST.Types.pkREQUESTBODY;<N>  {$IF COMPILERVERSION >= 32}<N>    pkFILE = REST.Types.pkFILE;<N>  {$ENDIF}<N>  {$IF COMPILERVERSION >= 33}<N>    pkQUERY = REST.Types.pkQUERY;<N>  {$ENDIF}<N>{$ENDIF}<N><N>
implementation<N><N>uses<N>  {$IF DEFINED(FPC) and (not DEFINED(RR4D_INDY)) and (not DEFINED(RR4D_SYNAPSE))}<N>    RESTRequest4D.Request.FPHTTPClient;<N>  {$ELSEIF DEFINED(RR4D_INDY)}<N>    RESTRequest4D.Request.Indy;<N>  {$ELSEIF DEFINED(RR4D_NETHTTP)}<N>    RESTRequest4D.Request.NetHTTP;<N>  {$ELSEIF DEFINED(RR4D_SYNAPSE)}<N>    RESTRequest4D.Request.Synapse;<N>  {$ELSE}<N>    RESTRequest4D.Request.Client;<N>  {$ENDIF}<N><N>
class function TRequest.New: IRequest;<N>begin<N>  {$IF DEFINED(FPC) and (not DEFINED(RR4D_INDY)) and (not DEFINED(RR4D_SYNAPSE))}<N>    Result := TRequestFPHTTPClient.Create;<N>  {$ELSEIF DEFINED(RR4D_INDY)}<N>    Result := TRequestIndy.Create;<N>  {$ELSEIF DEFINED(RR4D_NETHTTP)}<N>    Result := TRequestNetHTTP.Create;<N>  {$ELSEIF DEFINED(RR4D_SYNAPSE)}<N>    Result := TRequestSynapse.Create;<N>  {$ELSE}<N>    Result := TRequestClient.Create;<N>  {$ENDIF}<N>end;<N><N>
unit RESTRequest4D.Utils;<N><N>interface<N><N>{$IFNDEF FPC}<N>uses DB;<N>{$ENDIF}<N><N>type<N>  TMethodRequest = (mrGET, mrPOST, mrPUT, mrPATCH, mrDELETE);<N><N>  TRESTRequest4DelphiUtils = class<N>  public<N>    {$IFNDEF FPC}<N>    class procedure ActiveCachedUpdates(const ADataSet: TDataSet; const AActive: Boolean = True);<N>    {$ENDIF}<N>  end;<N><N>
unit RESTRequest4D.Response.Synapse;<N><N>{$IFDEF FPC}<N>  {$mode delphi}<N>{$ENDIF}<N><N>interface<N><N>uses Classes, SysUtils, RESTRequest4D.Response.Contract, httpsend, ssl_openssl,<N>  {$IFDEF FPC}<N>    fpjson, jsonparser;<N>  {$ELSE}<N>    System.Json;<N>  {$ENDIF}<N><N>
unit RESTRequest4D.Request.Contract;<N><N>interface<N><N>uses RESTRequest4D.Response.Contract,<N>  {$IF NOT (DEFINED(RR4D_INDY) or DEFINED(FPC) or DEFINED(RR4D_NETHTTP))}<N>    REST.Types,<N>  {$ENDIF}<N>  {$IFDEF FPC}<N>    SysUtils, fpjson, Classes, DB;<N>  {$ELSE}<N>    System.SysUtils, System.JSON, System.Classes, Data.DB;<N>  {$ENDIF}<N><N>
unit Horse.Jhonson;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, HTTPDefs, fpjson, jsonparser,<N>{$ELSE}<N>  System.Classes, System.JSON, System.SysUtils, Web.HTTPApp,<N>{$ENDIF}<N>  Horse, Horse.Commons;<N><N>
function Jhonson: THorseCallback; overload;<N>function Jhonson(const ACharset: string): THorseCallback; overload;<N><N>procedure Middleware(Req: THorseRequest; Res: THorseResponse; Next: {$IF DEFINED(FPC)}TNextProc{$ELSE}TProc{$ENDIF});<N><N>implementation<N><N>
var<N>  Charset: string;<N><N>function Jhonson: THorseCallback; overload;<N>begin<N>  Result := Jhonson('UTF-8');<N>end;<N><N>function Jhonson(const ACharset: string): THorseCallback; overload;<N>begin<N>  Charset := ACharset;<N>  Result := Middleware;<N>end;<N><N>
Library Apache;<N><N>{$DEFINE Apache2_4}<N>{$DEFINE FPCAPACHE_2_4}<N>{$MODE DELPHI}{$H+}<N><N>Uses<N>{$ifdef unix}<N>  cthreads,<N>{$endif}<N>  Horse, httpd24, fpApache24, custapache24;<N><N>const<N>  ModuleName = 'apache_horse_module';<N><N>var<N>  ApacheModuleData : module; {$ifdef unix} public name ModuleName;{$endif unix}<N><N>
exports ApacheModuleData name ModuleName;<N><N>procedure GetPing(Req: THorseRequest; Res: THorseResponse; Next: TNextProc);<N>begin<N>  Res.Send('pong');<N>end;<N><N>begin<N>  THorse.Get('/ping', GetPing);<N><N>  THorse.DefaultModule := @ApacheModuleData;<N>  THorse.HandlerName := 'apache_horse_module-handle';<N>  THorse.ModuleName := ModuleName;<N><N>
unit Views.Main;<N><N>{$MODE DELPHI}{$H+}<N><N>interface<N><N>uses Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, Buttons, Horse;<N><N>type<N><N>  { TFrmMain }<N><N>  TFrmMain = class(TForm)<N>    btnStart: TBitBtn;<N>    btnStop: TBitBtn;<N>    edtPort: TEdit;<N>    Label1: TLabel;<N>    procedure btnStartClick(Sender: TObject);<N>    procedure btnStopClick(Sender: TObject);<N>  private<N>    procedure Status;<N>    procedure Start;<N>    procedure Stop;<N>  end;<N><N>
var<N>  FrmMain: TFrmMain;<N><N>implementation<N><N>procedure DoPing(Req: THorseRequest; Res: THorseResponse; Next: TNextProc);<N>begin<N>  Res.Send('pong');<N>end;<N><N>{$R *.lfm}<N><N>procedure TFrmMain.btnStartClick(Sender: TObject);<N>begin<N>  Start;<N>  Status;<N>end;<N><N>
procedure TFrmMain.btnStopClick(Sender: TObject);<N>begin<N>  Stop;<N>  Status;<N>end;<N><N>procedure TFrmMain.Status;<N>begin<N>  btnStop.Enabled := THorse.IsRunning;<N>  btnStart.Enabled := not THorse.IsRunning;<N>  edtPort.Enabled := not THorse.IsRunning;<N>end;<N><N>
unit DaemonManager;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, DaemonApp;<N><N>type<N><N>  { TDaemon_Manager }<N><N>  TDaemon_Manager = class(TDaemonMapper)<N>    procedure Daemon_ManagerCreate(Sender: TObject);<N>  private<N><N>
  public<N><N>  end;<N><N>var<N>  Daemon_Manager: TDaemon_Manager;<N><N>implementation<N><N>procedure RegisterMapper;<N>begin<N>  RegisterDaemonMapper(TDaemon_Manager)<N>end;<N><N>{$R *.lfm}<N><N>{ TDaemon_Manager }<N><N>procedure TDaemon_Manager.Daemon_ManagerCreate(Sender: TObject);<N>begin<N><N>
unit DaemonMain;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, DaemonApp;<N><N>type<N>  TDaemon_Main = class(TDaemon)<N>    procedure DataModuleCreate(Sender: TObject);<N>    procedure DataModuleShutDown(Sender: TCustomDaemon);<N>    procedure DataModuleStart(Sender: TCustomDaemon; var OK: Boolean);<N>  end;<N><N>
var<N>  Daemon_Main: TDaemon_Main;<N><N>implementation<N><N>uses<N>  Horse;<N><N>procedure RegisterDaemon;<N>begin<N>  RegisterDaemonClass(TDaemon_Main)<N>end;<N><N>procedure RunHorse;<N>begin<N>  THorse.Listen(9000);<N>end;<N><N>procedure Ping(Req: THorseRequest; Res: THorseResponse; Next: TNextProc);<N>begin<N>  Res.Send('pong');<N>end;<N><N>
{$R *.lfm}<N><N>{ TDaemon_Main }<N><N>procedure TDaemon_Main.DataModuleCreate(Sender: TObject);<N>begin<N>  THorse.Get('ping', @Ping);<N>end;<N><N>procedure TDaemon_Main.DataModuleShutDown(Sender: TCustomDaemon);<N>begin<N>  THorse.StopListen;<N>end;<N><N>
unit Main.Form;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Horse, Vcl.StdCtrls, Vcl.Samples.Spin, Vcl.Mask, Vcl.ExtCtrls, Vcl.ComCtrls;<N><N>
unit Main.Service;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.SvcMgr, Vcl.Dialogs;<N><N>type<N>  TMainService = class(TService)<N>    procedure ServiceCreate(Sender: TObject);<N>    procedure ServiceStart(Sender: TService; var Started: Boolean);<N>    procedure ServiceStop(Sender: TService; var Stopped: Boolean);<N>  public<N>    function GetServiceController: TServiceController; override;<N>  end;<N><N>
var<N>  MainService: TMainService;<N><N>implementation<N><N>uses Horse;<N><N>{$R *.dfm}<N><N>procedure ServiceController(CtrlCode: DWord); stdcall;<N>begin<N>  MainService.Controller(CtrlCode);<N>end;<N><N>function TMainService.GetServiceController: TServiceController;<N>begin<N>  Result := ServiceController;<N>end;<N><N>
procedure TMainService.ServiceCreate(Sender: TObject);<N>begin<N>  THorse.Get('ping',<N>    procedure(Req: THorseRequest; Res: THorseResponse; Next: TProc)<N>    begin<N>      Res.Send('pong');<N>    end);<N>end;<N><N>procedure TMainService.ServiceStart(Sender: TService; var Started: Boolean);<N>begin<N>  THorse.Listen;<N>  Started := True;<N>end;<N><N>
unit Tests.Api.Vcl;<N><N>interface<N><N>uses<N>  DUnitX.TestFramework, System.JSON, RESTRequest4D.Request, System.Classes,<N>  Controllers.Api, Horse, Horse.Jhonson, SysUtils;<N><N>type<N>  [TestFixture]<N>  TApiTest = class(TObject)<N>  private<N>    FJSONObject: TJSONObject;<N>    FJSONArray: TJSONArray;<N><N>
    procedure CreateApi;<N>    procedure StartApiListen;<N>    procedure StartApiListenPort;<N>    procedure StartApiListenHost;<N>    procedure StartApiListens;<N>    procedure StartApiPortListens;<N>    procedure StopApiListen;<N>    procedure StopApi;<N>  public<N>    [TearDown]<N>    procedure TearDown;<N><N>
    [Test]<N>    procedure TestGet;<N>    [Test]<N>    [TestCase('Test01', 'POST request test')]<N>    procedure TestPost(const AValue: string);<N>    [Test]<N>    [TestCase('Test01', 'PUT request test')]<N>    procedure TestPut(const AValue: string);<N>    [Test]<N>    [TestCase('Test01', '1')]<N>    procedure TestDelete(const AValue: string);<N>    [Test]<N>    procedure TestGStartApiPortListens;<N>    [Test]<N>    procedure TestCreateApi;<N>    [Test]<N>    procedure TestToHorse;<N>  end;<N><N>
implementation<N><N>{ TApiTest }<N><N>procedure TApiTest.StartApiListen;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        THorse<N>          .Use(Jhonson);<N><N>        Controllers.Api.Registry;<N>        THorse.MaxConnections := 10;<N>        THorse.Listen;<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiListenPort;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen(9000);<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiListenHost;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen('0.0.0.0');<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiListens;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen(<N>          procedure(Horse: THorse)<N>          begin<N>          end);<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiPortListens;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen(9000,<N>          procedure(Horse: THorse)<N>          begin<N>          end);<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StopApiListen;<N>begin<N>  THorse.StopListen;<N>end;<N><N>procedure TApiTest.StopApi;<N>begin<N>  // Warnings have been disabled for this segment as the stop has been depreciated.<N>  {$WARNINGS OFF}<N>  THorse.StopListen;<N>  {$WARNINGS ON}<N>end;<N><N>
procedure TApiTest.TestGStartApiPortListens;<N>begin<N>  StartApiPortListens;<N>  StopApi;<N>end;<N><N>procedure TApiTest.TestGet;<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListen;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')<N>    .Accept('application/json')<N>    .Get;<N><N>
  FJSONArray := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONArray;<N><N>  Assert.AreEqual(9000, THorse.Port);<N>  Assert.AreEqual('0.0.0.0', THorse.Host);<N>  Assert.AreEqual(10, THorse.MaxConnections);<N>  Assert.AreEqual(LResponse.StatusCode, 200);<N>  Assert.AreEqual(FJSONArray.Count, 3);<N>  StopApiListen;<N>end;<N><N>
procedure TApiTest.TestPost(const AValue: string);<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListenPort;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')<N>    .Accept('application/json')<N>    .AddBody('{"value": "' + AValue + '"}')<N>    .Post;<N><N>
  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;<N>  Assert.AreEqual(LResponse.StatusCode, 201);<N><N>  if (not FJSONObject.GetValue('value').Null) then<N>    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)<N>  else<N>    Assert.Fail('The return is not without correct format.');<N>  StopApiListen;<N>end;<N><N>
procedure TApiTest.TestPut(const AValue: string);<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListenHost;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')<N>    .Accept('application/json')<N>    .AddBody('{"value": "' + AValue + '"}')<N>    .Put;<N><N>
  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;<N>  Assert.AreEqual(LResponse.StatusCode, 200);<N><N>  if (not FJSONObject.GetValue('value').Null) then<N>    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)<N>  else<N>    Assert.Fail('The return is not in the correct format.');<N>  StopApiListen;<N>end;<N><N>
procedure TApiTest.TestDelete(const AValue: string);<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListens;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test/' + AValue)<N>    .Accept('application/json')<N>    .Delete;<N><N>  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;<N>  Assert.AreEqual(LResponse.StatusCode, 200);<N><N>
  if (not FJSONObject.GetValue('value').Null) then<N>    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)<N>  else<N>    Assert.Fail('The return is not in the correct format.');<N>  StopApiListen;<N>end;<N><N>procedure TApiTest.CreateApi;<N>begin<N>  // Warnings have been disabled for this segment as the create has been depreciated.<N>  {$WARNINGS OFF}<N>  THorse.Create;<N>  {$WARNINGS ON}<N>end;<N><N>
procedure TApiTest.TearDown;<N>begin<N>  FreeAndNil(FJSONObject);<N>  FreeAndNil(FJSONArray);<N>end;<N><N>procedure TApiTest.TestCreateApi;<N>begin<N>  Assert.WillRaise(CreateApi, Exception, 'The Horse instance has already been created');<N>end;<N><N>procedure TApiTest.TestToHorse;<N>begin<N>  Assert.IsNotNull(THorse.ToModule.ToHorse, 'Module instance must not be null');<N>end;<N><N>
unit Tests.Horse.Core.Param;<N><N>interface<N><N>uses<N>  DUnitX.TestFramework,<N>  Horse.Exception,<N>  Horse.Core.Param,<N>  System.Generics.Collections,<N>  System.Classes,<N>  System.DateUtils,<N>  System.SysUtils;<N><N>type<N>  [TestFixture]<N>  TTestHorseCoreParam = class<N>  private<N>    FParams: TDictionary<string, String>;<N>    FHorseParam: THorseCoreParam;<N>    FData: TDateTime;<N>    FTime: TTime;<N>    FFormatSettings: TFormatSettings;<N>    FStream: TStream;<N><N>
    function RequiredMessage(const AKey: String): string;<N>    function ConvertErrorMessage(const AKey, AValue, AType: String): string;<N><N>  public<N>    [Setup]<N>    procedure Setup;<N><N>    [TearDown]<N>    procedure TearDown;<N><N>    [Test]<N>    procedure ContainsKey;<N><N>
    [Test]<N>    procedure NotContainsKey;<N><N>    [Test]<N>    procedure ContainsKeyDiferentCase;<N><N>    [Test]<N>    procedure ContainsValue;<N><N>    [Test]<N>    procedure NotContainsValue;<N><N>    [Test]<N>    procedure ToArray;<N><N>    [Test]<N>    procedure TryGetValueTrue;<N><N>
    [Test]<N>    procedure TryGetValueFalse;<N><N>    [Test]<N>    procedure TryGetValueDiferentCase;<N><N>    [Test]<N>    procedure Content;<N><N>    [Test]<N>    procedure Count;<N><N>    [Test]<N>    procedure List;<N><N>    [Test]<N>    procedure Index;<N><N>
    [Test]<N>    procedure IndexNotFound;<N><N>    [Test]<N>    procedure IndexDiferentCase;<N><N>    [Test]<N>    procedure AsBoolean;<N><N>    [Test]<N>    [TestCase('TrueValue1', 'True,true,true')]<N>    [TestCase('TrueValue2', '1,1,true')]<N>    [TestCase('FalseValue1', 'False,true,false')]<N>    [TestCase('FalseValue2', '5,1,false')]<N>    procedure AsBooleanParam(AParamValue, ATrueValue: string; AResult: Boolean);<N><N>
    [Test]<N>    procedure AsBooleanNotRequired;<N><N>    [Test]<N>    procedure AsBooleanRequired;<N><N>    [Test]<N>    procedure AsCurrency;<N><N>    [Test]<N>    procedure AsCurrencyDecimalSeparator;<N><N>    [Test]<N>    procedure AsCurrencyNotRequired;<N><N>
    [Test]<N>    procedure AsCurrencyRequired;<N><N>    [Test]<N>    procedure AsCurrencyErrorFormat;<N><N>    [Test]<N>    procedure AsDateTime;<N><N>    [Test]<N>    procedure AsDateTimeRequired;<N><N>    [Test]<N>    procedure AsDateTimeNotRequired;<N><N>
    [Test]<N>    procedure AsDateTimeOnlyData;<N><N>    [Test]<N>    procedure AsDateTimeChangeFormat;<N><N>    [Test]<N>    procedure AsDateTimeInvalidFormat;<N><N>    [Test]<N>    procedure AsDate;<N><N>    [Test]<N>    procedure AsDateRequired;<N><N>    [Test]<N>    procedure AsDateNotRequired;<N><N>
    [Test]<N>    procedure AsDateChangeFormat;<N><N>    [Test]<N>    procedure AsDateInvalidFormat;<N><N>    [Test]<N>    procedure AsExtended;<N><N>    [Test]<N>    procedure AsExtendedDecimalSeparator;<N><N>    [Test]<N>    procedure AsExtendedNotRequired;<N><N>
    [Test]<N>    procedure AsExtendedRequired;<N><N>    [Test]<N>    procedure AsExtendedErrorFormat;<N><N>    [Test]<N>    procedure AsFloat;<N><N>    [Test]<N>    procedure AsFloatDecimalSeparator;<N><N>    [Test]<N>    procedure AsFloatNotRequired;<N><N>
    [Test]<N>    procedure AsFloatRequired;<N><N>    [Test]<N>    procedure AsFloatErrorFormat;<N><N>    [Test]<N>    procedure AsInteger;<N><N>    [Test]<N>    procedure AsIntegerNotRequired;<N><N>    [Test]<N>    procedure AsIntegerRequired;<N><N>    [Test]<N>    procedure AsIntegerErrorFormat;<N><N>
    [Test]<N>    procedure AsInt64;<N><N>    [Test]<N>    procedure AsInt64NotRequired;<N><N>    [Test]<N>    procedure AsInt64Required;<N><N>    [Test]<N>    procedure AsInt64ErrorFormat;<N><N>    [Test]<N>    procedure AsISO8601DateTime;<N><N>    [Test]<N>    procedure AsISO8601DateTimeOnlyData;<N><N>
    [Test]<N>    procedure AsISO8601DateTimeNotRequired;<N><N>    [Test]<N>    procedure AsISO8601DateTimeRequired;<N><N>    [Test]<N>    procedure AsISO8601DateTimeErrorFormat;<N><N>    [Test]<N>    procedure AsStream;<N><N>    [Test]<N>    procedure AsStreamNotFoundNotRequired;<N><N>
    [Test]<N>    procedure AsStreamNotFoundRequired;<N><N>    [Test]<N>    procedure AsStreamSaveToFile;<N><N>    [Test]<N>    procedure AsStreamNotFoundSaveToFile;<N><N>    [Test]<N>    procedure AsString;<N><N>    [Test]<N>    procedure AsStringRequired;<N><N>
    [Test]<N>    procedure AsStringNotRequired;<N><N>    [Test]<N>    procedure AsStringDiferentCase;<N><N>    [Test]<N>    procedure AsTime;<N><N>    [Test]<N>    procedure AsTimeRequired;<N><N>    [Test]<N>    procedure AsTimeNotRequired;<N><N>    [Test]<N>    procedure AsTimeChangeFormat;<N><N>
    [Test]<N>    procedure AsTimeInvalidFormat;<N>  end;<N><N>implementation<N><N>{ TTestHorseCoreParam }<N><N>procedure TTestHorseCoreParam.AsBoolean;<N>begin<N>  FParams.AddOrSetValue('Key1', 'True');<N>  Assert.IsTrue(FHorseParam.Field('Key1').Required.AsBoolean);<N>end;<N><N>
procedure TTestHorseCoreParam.AsBooleanNotRequired;<N>begin<N>  Assert.IsFalse(FHorseParam.Field('Key1').AsBoolean);<N>end;<N><N>procedure TTestHorseCoreParam.AsBooleanParam(AParamValue, ATrueValue: string; AResult: Boolean);<N>begin<N>  FParams.AddOrSetValue('Key1', AParamValue);<N>  Assert.AreEqual(AResult, FHorseParam.Field('Key1').Required.TrueValue(ATrueValue).AsBoolean);<N>end;<N><N>
procedure TTestHorseCoreParam.AsBooleanRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsBoolean;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>procedure TTestHorseCoreParam.AsCurrency;<N>begin<N>  FParams.AddOrSetValue('Key1', '5.5');<N>  Assert.AreEqual('5,5', CurrToStr( FHorseParam.Field('Key1').AsCurrency));<N>end;<N><N>
procedure TTestHorseCoreParam.AsCurrencyDecimalSeparator;<N>begin<N>  FParams.AddOrSetValue('Key1', '5,5');<N>  Assert.AreEqual('5,5', CurrToStr( FHorseParam.Field('Key1').AsCurrency));<N>end;<N><N>procedure TTestHorseCoreParam.AsCurrencyErrorFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', '5a');<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsCurrency;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', '5a', 'numeric'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsCurrencyNotRequired;<N>begin<N>  Assert.AreEqual('0', CurrToStr(FHorseParam.Field('Key1').AsCurrency));<N>end;<N><N>procedure TTestHorseCoreParam.AsCurrencyRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsCurrency;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsDate;<N>begin<N>  FData := EncodeDate(2021, 11, 13);<N>  FParams.Add('Key1', '2021-11-13 10:25:32');<N><N>  Assert.AreEqual(DateToStr(FData), DateToStr(FHorseParam.Field('Key1').AsDate));<N>end;<N><N>procedure TTestHorseCoreParam.AsDateChangeFormat;<N>begin<N>  FData := EncodeDate(2021, 11, 13);<N>  FParams.Add('Key1', '13/11/2021');<N><N>
  Assert.AreEqual(DateToStr(FData), DateToStr(FHorseParam.Field('Key1').Required.DateFormat('dd/MM/yyyy').AsDate));<N>end;<N><N>procedure TTestHorseCoreParam.AsDateInvalidFormat;<N>begin<N>  FParams.Add('Key1', '2021/11-13');<N><N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsDate;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', '2021/11-13', 'date'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsDateNotRequired;<N>begin<N>  Assert.IsTrue(FHorseParam.Field('Key1').AsDate = 0);<N>end;<N><N>procedure TTestHorseCoreParam.AsDateRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsDate;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsDateTime;<N>begin<N>  FData := EncodeDateTime(2021, 11, 13, 10, 25, 32, 0);<N>  FParams.Add('Key1', '2021-11-13 10:25:32');<N><N>  Assert.AreEqual(DateToStr(FData), DateToStr(FHorseParam.Field('Key1').AsDateTime));<N>end;<N><N>
procedure TTestHorseCoreParam.AsDateTimeChangeFormat;<N>begin<N>  FData := EncodeDateTime(2021, 11, 13, 10, 25, 32, 0);<N>  FParams.Add('Key1', '13/11/2021 10:25:32');<N><N>  Assert.AreEqual(DateToStr(FData), DateToStr(FHorseParam.Field('Key1').Required.DateFormat('dd/MM/yyyy').AsDateTime));<N>end;<N><N>
procedure TTestHorseCoreParam.AsDateTimeInvalidFormat;<N>begin<N>  FParams.Add('Key1', '2021/11-13 10:25:32');<N><N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsDateTime;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', '2021/11-13 10:25:32', 'datetime'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsDateTimeNotRequired;<N>begin<N>  Assert.IsTrue(FHorseParam.Field('Key1').Required(False).AsDateTime = 0);<N>end;<N><N>procedure TTestHorseCoreParam.AsDateTimeOnlyData;<N>begin<N>  FData := EncodeDate(2021, 11, 13);<N>  FParams.Add('Key1', '2021-11-13');<N><N>
  Assert.AreEqual(DateToStr(FData), DateToStr(FHorseParam.Field('Key1').AsDateTime));<N>end;<N><N>procedure TTestHorseCoreParam.AsDateTimeRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsDateTime;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsExtended;<N>begin<N>  FParams.AddOrSetValue('Key1', '5.5');<N>  Assert.AreEqual('5,5', FHorseParam.Field('Key1').AsExtended.ToString(FFormatSettings));<N>end;<N><N>procedure TTestHorseCoreParam.AsExtendedDecimalSeparator;<N>begin<N>  FParams.AddOrSetValue('Key1', '5,5');<N>  Assert.AreEqual('5,5', FHorseParam.Field('Key1').AsExtended.ToString(FFormatSettings));<N>end;<N><N>
procedure TTestHorseCoreParam.AsExtendedErrorFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', '5a');<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsExtended;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', '5a', 'numeric'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsExtendedNotRequired;<N>begin<N>  Assert.AreEqual('0', FHorseParam.Field('Key1').AsExtended.ToString);<N>end;<N><N>procedure TTestHorseCoreParam.AsExtendedRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsExtended;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsFloat;<N>begin<N>  FParams.AddOrSetValue('Key1', '5.5');<N>  Assert.AreEqual('5,5', FHorseParam.Field('Key1').AsFloat.ToString(FFormatSettings));<N>end;<N><N>procedure TTestHorseCoreParam.AsFloatDecimalSeparator;<N>begin<N>  FParams.AddOrSetValue('Key1', '5,5');<N>  Assert.AreEqual('5,5', FHorseParam.Field('Key1').AsFloat.ToString(FFormatSettings));<N>end;<N><N>
procedure TTestHorseCoreParam.AsFloatErrorFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', '5a');<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsFloat;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', '5a', 'numeric'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsFloatNotRequired;<N>begin<N>  Assert.AreEqual('0', FHorseParam.Field('Key1').Required(False).AsFloat.ToString);<N>end;<N><N>procedure TTestHorseCoreParam.AsFloatRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required(True).AsFloat;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsInt64;<N>begin<N>  FParams.AddOrSetValue('Key1', '5');<N>  Assert.AreEqual('5', FHorseParam.Field('Key1').AsInt64.ToString);<N>end;<N><N>procedure TTestHorseCoreParam.AsInt64ErrorFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value');<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsInt64;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', 'Value', 'int64'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsInt64NotRequired;<N>begin<N>  Assert.AreEqual('0', FHorseParam.Field('Key1').Required(False).AsInt64.ToString);<N>end;<N><N>procedure TTestHorseCoreParam.AsInt64Required;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required(True).AsInt64;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsInteger;<N>begin<N>  FParams.AddOrSetValue('Key1', '5');<N>  Assert.AreEqual(5, FHorseParam.Field('Key1').AsInteger);<N>end;<N><N>procedure TTestHorseCoreParam.AsIntegerErrorFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value');<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsInteger;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', 'Value', 'integer'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsIntegerNotRequired;<N>begin<N>  Assert.AreEqual(0, FHorseParam.Field('Key1').AsInteger);<N>end;<N><N>procedure TTestHorseCoreParam.AsIntegerRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required(True).AsInteger;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsISO8601DateTime;<N>begin<N>  FData := EncodeDateTime(2021, 11, 13, 10, 21, 22, 0);<N>  FParams.AddOrSetValue('Key1', '2021-11-13T10:21:22');<N><N>  Assert.AreEqual(DateToStr(FData), DateToStr(FHorseParam.Field('Key1').AsISO8601DateTime));<N>end;<N><N>
procedure TTestHorseCoreParam.AsISO8601DateTimeErrorFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', '2021-11-13 10:21:22');<N>  Assert.WillNotRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsISO8601DateTime;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsISO8601DateTimeNotRequired;<N>begin<N>  Assert.IsTrue(FHorseParam.Field('Key1').Required(False).AsISO8601DateTime = 0);<N>end;<N><N>procedure TTestHorseCoreParam.AsISO8601DateTimeOnlyData;<N>begin<N>  FData := EncodeDateTime(2021, 11, 13, 10, 21, 22, 0);<N>  FParams.AddOrSetValue('Key1', '2021-11-13');<N><N>
  Assert.AreEqual(FormatDateTime('dd/MM/yyyy', FData), FormatDateTime('dd/MM/yyyy', FHorseParam.Field('Key1').AsISO8601DateTime));<N>end;<N><N>procedure TTestHorseCoreParam.AsISO8601DateTimeRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsISO8601DateTime;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsStream;<N>begin<N>  FStream := TStringStream.Create('1234');<N>  FHorseParam.AddStream('Key1', FStream);<N><N>  Assert.IsNotNull(FHorseParam.Field('Key1').AsStream);<N>  Assert.AreEqual<Int64>(0, FHorseParam.Field('Key1').AsStream.Position);<N>end;<N><N>
procedure TTestHorseCoreParam.AsStreamNotFoundNotRequired;<N>begin<N>  Assert.IsNull(FHorseParam.Field('Key1').AsStream);<N>end;<N><N>procedure TTestHorseCoreParam.AsStreamNotFoundRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required(True).AsStream<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsStreamNotFoundSaveToFile;<N>var<N>  LFile: String;<N>begin<N>  LFile := 'test.txt';<N>  Assert.IsFalse(FileExists(LFile));<N><N>  FHorseParam.Field('Key1').SaveToFile(LFile);<N>  Assert.IsFalse(FileExists(LFile));<N>end;<N><N>
procedure TTestHorseCoreParam.AsStreamSaveToFile;<N>var<N>  LFile: String;<N>begin<N>  LFile := 'test.txt';<N>  Assert.IsFalse(FileExists(LFile));<N><N>  FStream := TStringStream.Create('1234');<N>  FHorseParam.AddStream('Key1', FStream);<N><N>  FHorseParam.Field('Key1').SaveToFile(LFile);<N>  Assert.IsTrue(FileExists(LFile));<N>  DeleteFile(LFile);<N>end;<N><N>
procedure TTestHorseCoreParam.AsString;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value');<N>  Assert.AreEqual('Value', FHorseParam.Field('Key1').AsString);<N>end;<N><N>procedure TTestHorseCoreParam.AsStringDiferentCase;<N>begin<N>  FParams.AddOrSetValue('key1', 'Value');<N>  Assert.AreEqual('Value', FHorseParam.Field('Key1').AsString);<N>end;<N><N>
procedure TTestHorseCoreParam.AsStringNotRequired;<N>begin<N>  Assert.IsEmpty(FHorseParam.Field('Key1').AsString);<N>end;<N><N>procedure TTestHorseCoreParam.AsStringRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsString;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsTime;<N>begin<N>  FTime := EncodeTime(10, 15, 54, 0);<N>  FParams.AddOrSetValue('Key1', '10:15:54');<N><N>  Assert.AreEqual(FTime, FHorseParam.Field('Key1').AsTime);<N>end;<N><N>procedure TTestHorseCoreParam.AsTimeChangeFormat;<N>begin<N>  FTime := EncodeTime(10, 15, 0, 0);<N>  FParams.AddOrSetValue('Key1', '10:15:54');<N><N>
  Assert.AreEqual(FTime, FHorseParam.Field('Key1').TimeFormat('hh:mm').AsTime);<N>end;<N><N>procedure TTestHorseCoreParam.AsTimeInvalidFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', '10/00');<N><N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      Assert.AreEqual(FTime, FHorseParam.Field('Key1').AsTime);<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', '10/00', 'time'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsTimeNotRequired;<N>begin<N>  Assert.IsTrue(FHorseParam.Field('Key1').AsTime = 0);<N>end;<N><N>procedure TTestHorseCoreParam.AsTimeRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      Assert.AreEqual(FTime, FHorseParam.Field('Key1').Required.AsTime);<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.ContainsKey;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value');<N>  Assert.IsTrue(FHorseParam.ContainsKey('Key1'));<N>end;<N><N>procedure TTestHorseCoreParam.ContainsKeyDiferentCase;<N>begin<N>  FParams.AddOrSetValue('key1', 'Value');<N>  Assert.IsTrue(FHorseParam.ContainsKey('KEY1'));<N>end;<N><N>
procedure TTestHorseCoreParam.ContainsValue;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value');<N>  Assert.IsTrue(FHorseParam.ContainsValue('Value'));<N>end;<N><N>procedure TTestHorseCoreParam.Content;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value1');<N>  FParams.AddOrSetValue('Key2', 'Value2');<N><N>
  Assert.AreEqual(2, FHorseParam.Content.Count);<N>  Assert.AreEqual('Key1', FHorseParam.Content.Names[0]);<N>  Assert.AreEqual('Key2', FHorseParam.Content.Names[1]);<N>  Assert.AreEqual('Value1', FHorseParam.Content.ValueFromIndex[0]);<N>  Assert.AreEqual('Value2', FHorseParam.Content.ValueFromIndex[1]);<N>end;<N><N>
function TTestHorseCoreParam.ConvertErrorMessage(const AKey, AValue, AType: String): string;<N>begin<N>  result := Format('The %s param ''%s'' is not valid a %s type.', [AKey, AValue, AType]);<N>end;<N><N>procedure TTestHorseCoreParam.Count;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value1');<N>  FParams.AddOrSetValue('Key2', 'Value2');<N><N>
  Assert.AreEqual(2, FHorseParam.Count);<N>end;<N><N>procedure TTestHorseCoreParam.Index;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value1');<N>  Assert.AreEqual('Value1', FHorseParam['Key1']);<N>end;<N><N>procedure TTestHorseCoreParam.IndexDiferentCase;<N>begin<N>  FParams.AddOrSetValue('KEY1', 'Value1');<N>  Assert.AreEqual('Value1', FHorseParam['key1']);<N>end;<N><N>
procedure TTestHorseCoreParam.IndexNotFound;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value1');<N>  Assert.IsEmpty(FHorseParam.Items['Value1']);<N>end;<N><N>procedure TTestHorseCoreParam.List;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value1');<N>  FParams.AddOrSetValue('Key2', 'Value2');<N><N>
  Assert.AreEqual(2, FHorseParam.Count);<N>  Assert.AreEqual(FParams, FHorseParam.Dictionary);<N>end;<N><N>procedure TTestHorseCoreParam.NotContainsKey;<N>begin<N>  FParams.AddOrSetValue('Key', 'Value');<N>  Assert.IsFalse(FHorseParam.ContainsKey('Value'));<N>end;<N><N>
procedure TTestHorseCoreParam.NotContainsValue;<N>begin<N>  FParams.AddOrSetValue('Key', 'Value');<N>  Assert.IsFalse(FHorseParam.ContainsValue('Key'));<N>end;<N><N>function TTestHorseCoreParam.RequiredMessage(const AKey: String): string;<N>begin<N>  result := Format('The %s param is required.', [AKey]);<N>end;<N><N>
procedure TTestHorseCoreParam.Setup;<N>begin<N>  FParams := TDictionary<String, String>.Create;<N>  FHorseParam := THorseCoreParam.create(FParams);<N>  FFormatSettings := TFormatSettings.Create;<N>  FFormatSettings.DecimalSeparator := ',';<N>  FData := 0;<N>  FTime := 0;<N>end;<N><N>
procedure TTestHorseCoreParam.TearDown;<N>begin<N>  FreeAndNil(FHorseParam);<N>  FreeAndNil(FStream);<N>end;<N><N>procedure TTestHorseCoreParam.ToArray;<N>var<N>  LPairs: TArray<TPair<String, String>>;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value1');<N>  FParams.AddOrSetValue('Key2', 'Value2');<N><N>
  LPairs := FHorseParam.ToArray;<N><N>  Assert.AreEqual(2, Length(LPairs));<N>  Assert.AreEqual('Key1', LPairs[0].Key);<N>  Assert.AreEqual('Value1', LPairs[0].Value);<N>  Assert.AreEqual('Key2', LPairs[1].Key);<N>  Assert.AreEqual('Value2', LPairs[1].Value);<N>end;<N><N>
procedure TTestHorseCoreParam.TryGetValueDiferentCase;<N>var<N>  LValue: String;<N>begin<N>  FParams.AddOrSetValue('KEY1', 'Value1');<N>  Assert.IsTrue(FHorseParam.TryGetValue('key1', LValue));<N>  Assert.AreEqual('Value1', LValue);<N>end;<N><N>procedure TTestHorseCoreParam.TryGetValueFalse;<N>var<N>  LValue: String;<N>begin<N>  Assert.IsFalse(FHorseParam.TryGetValue('Key1', LValue));<N>end;<N><N>
unit Tests.Api.Console;<N><N>interface<N><N>uses<N>  DUnitX.TestFramework, System.JSON, RESTRequest4D.Request, System.Classes,<N>  Controllers.Api, Horse, Horse.Jhonson, SysUtils;<N><N>type<N>  [TestFixture]<N>  TApiTest = class(TObject)<N>  private<N>    FJSONObject: TJSONObject;<N>    FJSONArray: TJSONArray;<N><N>
    procedure CreateApi;<N>    procedure StartApiListen;<N>    procedure StartApiListenPort;<N>    procedure StartApiListenHost;<N>    procedure StartApiListens;<N>    procedure StartApiPortListens;<N>    procedure StopApiListen;<N>    procedure StopApi;<N>  public<N>    [TearDown]<N>    procedure TearDown;<N><N>
    [Test]<N>    procedure TestGet;<N>    [Test]<N>    [TestCase('Test01', 'POST request test')]<N>    procedure TestPost(const AValue: string);<N>    [Test]<N>    [TestCase('Test01', 'PUT request test')]<N>    procedure TestPut(const AValue: string);<N>    [Test]<N>    [TestCase('Test01', '1')]<N>    procedure TestDelete(const AValue: string);<N>    [Test]<N>    procedure TestGStartApiPortListens;<N>    [Test]<N>    procedure TestCreateApi;<N>    [Test]<N>    procedure TestToHorse;<N>  end;<N><N>
implementation<N><N>{ TApiTest }<N><N>procedure TApiTest.StartApiListen;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        THorse<N>          .Use(Jhonson);<N><N>        Controllers.Api.Registry;<N>        THorse.MaxConnections := 10;<N>        THorse.Listen;<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiListenPort;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen(9000);<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiListenHost;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen('0.0.0.0');<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiListens;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen(<N>          procedure(Horse: THorse)<N>          begin<N>          end,<N>          procedure(Horse: THorse)<N>          begin<N>          end);<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiPortListens;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen(9000,<N>          procedure(Horse: THorse)<N>          begin<N>          end,<N>          procedure(Horse: THorse)<N>          begin<N>          end);<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StopApiListen;<N>begin<N>  THorse.StopListen;<N>end;<N><N>procedure TApiTest.StopApi;<N>begin<N>  // Warnings have been disabled for this segment as the stop has been depreciated.<N>  {$WARNINGS OFF}<N>  THorse.StopListen;<N>  {$WARNINGS ON}<N>end;<N><N>
procedure TApiTest.TestGStartApiPortListens;<N>begin<N>  StartApiPortListens;<N>  StopApi;<N>end;<N><N>procedure TApiTest.TestGet;<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListen;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')<N>    .Accept('application/json')<N>    .Get;<N><N>
  FJSONArray := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONArray;<N>  Assert.AreEqual(9000, THorse.Port);<N>  Assert.AreEqual('0.0.0.0', THorse.Host);<N>  Assert.AreEqual(10, THorse.MaxConnections);<N>  Assert.AreEqual(LResponse.StatusCode, 200);<N>  Assert.AreEqual(FJSONArray.Count, 3);<N>  StopApiListen;<N>end;<N><N>
procedure TApiTest.TestPost(const AValue: string);<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListenPort;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')<N>    .Accept('application/json')<N>    .AddBody('{"value": "' + AValue + '"}')<N>    .Post;<N><N>
  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;<N>  Assert.AreEqual(LResponse.StatusCode, 201);<N><N>  if (not FJSONObject.GetValue('value').Null) then<N>    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)<N>  else<N>    Assert.Fail('The return is not without correct format.');<N>  StopApiListen;<N>end;<N><N>
procedure TApiTest.TestPut(const AValue: string);<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListenHost;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')<N>    .Accept('application/json')<N>    .AddBody('{"value": "' + AValue + '"}')<N>    .Put;<N><N>
  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;<N>  Assert.AreEqual(LResponse.StatusCode, 200);<N><N>  if (not FJSONObject.GetValue('value').Null) then<N>    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)<N>  else<N>    Assert.Fail('The return is not in the correct format.');<N>  StopApiListen;<N>end;<N><N>
procedure TApiTest.TestDelete(const AValue: string);<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListens;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test/' + AValue)<N>    .Accept('application/json')<N>    .Delete;<N><N>  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;<N>  Assert.AreEqual(LResponse.StatusCode, 200);<N><N>
  if (not FJSONObject.GetValue('value').Null) then<N>    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)<N>  else<N>    Assert.Fail('The return is not in the correct format.');<N>  StopApiListen;<N>end;<N><N>procedure TApiTest.CreateApi;<N>begin<N>  // Warnings have been disabled for this segment as the create has been depreciated.<N>  {$WARNINGS OFF}<N>  THorse.Create;<N>  {$WARNINGS ON}<N>end;<N><N>
procedure TApiTest.TearDown;<N>begin<N>  FreeAndNil(FJSONObject);<N>  FreeAndNil(FJSONArray);<N>end;<N><N>procedure TApiTest.TestCreateApi;<N>begin<N>  Assert.WillRaise(CreateApi, Exception, 'The Horse instance has already been created');<N>end;<N><N>procedure TApiTest.TestToHorse;<N>begin<N>  Assert.IsNotNull(THorse.ToModule.ToHorse, 'Module instance must not be null');<N>end;<N><N>
unit Tests.Commons;<N><N>interface<N><N>uses<N>  DUnitX.TestFramework, Horse.Commons;<N><N>type<N>  [TestFixture]<N>  TCommonsTest = class(TObject)<N>  public<N>    [Test]<N>    procedure TestMimeTypesToString;<N>  end;<N><N>implementation<N><N>{ TCommonsTest }<N><N>
unit Tests.Horse.Core.Files;<N><N>interface<N><N>uses<N>  DUnitX.TestFramework,<N>  Horse.Core.Files,<N>  System.Classes,<N>  System.SysUtils;<N><N>type<N>  [TestFixture]<N>  TTestHorseCoreFile = class<N>  private<N>    FHorseFile: THorseCoreFile;<N>    FFileName: String;<N><N>
  public<N>    [Setup]<N>    procedure Setup;<N><N>    [Teardown]<N>    procedure Teardown;<N><N>    [Test]<N>    procedure EmptyFileName;<N><N>    [Test]<N>    procedure InvalidFileName;<N><N>    [Test]<N>    procedure DelphiFile;<N>  end;<N><N>implementation<N><N>
{ TTestHorseCoreFile }<N><N>procedure TTestHorseCoreFile.DelphiFile;<N>begin<N>  FFileName := ExtractFilePath(GetModuleName(HInstance));<N>  FFileName := FFileName.Replace('tests\', 'src\Horse.pas');<N><N>  FHorseFile := THorseCoreFile.Create(FFileName);<N><N>
  Assert.AreEqual('text/x-pascal', FHorseFile.ContentType);<N>  Assert.IsNotNull(FHorseFile.ContentStream);<N>  Assert.IsTrue(FHorseFile.Size > 0);<N>end;<N><N>procedure TTestHorseCoreFile.EmptyFileName;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseFile := THorseCoreFile.Create(EmptyStr);<N>    end,<N>    Exception,<N>    'Invalid FileName');<N>end;<N><N>
procedure TTestHorseCoreFile.InvalidFileName;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseFile := THorseCoreFile.Create('C:\InvalidFile.txt2');<N>    end,<N>    Exception,<N>    'File not exist');<N>end;<N><N>procedure TTestHorseCoreFile.Setup;<N>begin<N>  FFileName := EmptyStr;<N>end;<N><N>
unit Controllers.Api;<N><N>interface<N><N>uses<N>  Horse, System.JSON, Horse.Commons;<N><N>procedure Registry;<N>procedure DoGetApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>procedure DoPostApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>procedure DoPutApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>procedure DoDeleteApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N><N>
implementation<N><N>procedure Registry;<N>begin<N>  THorse<N>    .Group<N>      .Prefix('/Api')<N>        .Delete('/Test/:id', DoDeleteApi)<N>        .Route('/Test')<N>          .Get(DoGetApi)<N>          .Post(DoPostApi)<N>          .Put(DoPutApi)<N>end;<N><N>
procedure DoGetApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LList: TJSONArray;<N>  LObject01: TJSONObject;<N>  LObject02: TJSONObject;<N>  LObject03: TJSONObject;<N>begin<N>  LList := TJSONArray.Create;<N>  try<N>    LObject01 := TJSONObject.Create;<N>    LObject01.AddPair(TJSONPair.Create('value', 'test01'));<N>    LList.AddElement(LObject01);<N><N>
    LObject02 := TJSONObject.Create;<N>    LObject02.AddPair(TJSONPair.Create('value', 'test02'));<N>    LList.AddElement(LObject02);<N><N>    LObject03 := TJSONObject.Create;<N>    LObject03.AddPair(TJSONPair.Create('value', 'test03'));<N>    LList.AddElement(LObject03);<N><N>
    Res.Send(LList.ToString);<N>  finally<N>    LList.Free;<N>  end;<N>end;<N><N>procedure DoPostApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LValue: string;<N>  LRequest: TJSONObject;<N>  LResponse: TJSONObject;<N>begin<N>  LValue := '';<N>  LRequest := TJSONObject.ParseJSONValue(Req.Body) as TJSONObject;<N>  try<N>    if (not LRequest.GetValue('value').Null) then<N>      LValue := LRequest.GetValue('value').value;<N><N>
    LResponse := TJSONObject.Create;<N>    try<N>      LResponse.AddPair(TJSONPair.Create('value', LValue));<N><N>      Res.Send(LResponse.ToString).Status(THTTPStatus.Created);<N>    finally<N>      LResponse.Free;<N>    end;<N>  finally<N>    LRequest.Free;<N>  end;<N>end;<N><N>
procedure DoPutApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LValue: string;<N>  LRequest: TJSONObject;<N>  LResponse: TJSONObject;<N>begin<N>  LValue := '';<N>  LRequest := TJSONObject.ParseJSONValue(Req.Body) as TJSONObject;<N>  try<N>    if (not LRequest.GetValue('value').Null) then<N>      LValue := LRequest.GetValue('value').value;<N><N>
    LResponse := TJSONObject.Create;<N>    try<N>      LResponse.AddPair(TJSONPair.Create('value', LValue));<N><N>      Res.Send(LResponse.ToString);<N>    finally<N>      LResponse.Free;<N>    end;<N>  finally<N>    LRequest.Free;<N>  end;<N>end;<N><N>procedure DoDeleteApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LValue: string;<N>  LResponse: TJSONObject;<N>begin<N>  LValue := Req.Params['id'];<N><N>
unit Horse.Core.RouterTree.NextCaller;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections, fpHTTP, httpprotocol,<N>{$ELSE}<N>  System.NetEncoding, System.SysUtils, Web.HTTPApp, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Commons, Horse.Request, Horse.Response, Horse.Callback;<N><N>
﻿unit Web.WebConst;<N><N>interface<N><N>resourcestring<N>  sDuplicateActionName = 'Duplicate action name';<N>  sOnlyOneDispatcher = 'Only one WebDispatcher per form/data module';<N>  sHTTPItemName = 'Name';<N>  sHTTPItemURI = 'PathInfo';<N>  sHTTPItemEnabled = 'Enabled';<N>  sHTTPItemDefault = 'Default';<N>  sHTTPItemProducer = 'Producer';<N>  sHTTPItemMethod = 'Method';<N><N>
unit Horse.Proc;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF NOT DEFINED(FPC)}<N>uses System.SysUtils;<N>{$ENDIF}<N><N>type<N>  TNextProc = {$IF DEFINED(FPC)}procedure of object{$ELSE}System.SysUtils.TProc{$ENDIF};<N>  TProc = {$IF DEFINED(FPC)}procedure{$ELSE}System.SysUtils.TProc{$ENDIF};<N><N>{$IF DEFINED(FPC)}<N>  TProc<T> = procedure(Arg1: T);<N>{$ENDIF}<N><N>implementation<N><N>end.<N>
unit Horse.Provider.CGI;<N><N>interface<N><N>{$IF DEFINED(HORSE_CGI) AND NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, System.SysUtils;<N><N>type<N>  THorseProvider<T: class> = class(THorseProviderAbstract<T>)<N>  private<N>    class procedure InternalListen; static;<N>  public<N>    class procedure Listen; overload; override;<N>    class procedure Listen(const ACallback: TProc<T>); reintroduce; overload; static;<N>  end;<N>{$ENDIF}<N><N>
implementation<N><N>{$IF DEFINED(HORSE_CGI) AND NOT DEFINED(FPC)}<N>uses Web.WebBroker, Web.CGIApp, Horse.WebModule;<N><N>class procedure THorseProvider<T>.InternalListen;<N>begin<N>  Application.Initialize;<N>  Application.WebModuleClass := WebModuleClass;<N>  DoOnListen;<N>  Application.Run;<N>end;<N><N>
class procedure THorseProvider<T>.Listen;<N>begin<N>  inherited;<N>  InternalListen;<N>end;<N><N>class procedure THorseProvider<T>.Listen(const ACallback: TProc<T>);<N>begin<N>  inherited;<N>  SetOnListen(ACallback);<N>  InternalListen;<N>end;<N>{$ENDIF}<N><N>
unit Horse.Provider.FPC.Apache;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_APACHE) AND DEFINED(FPC)}<N>uses<N>{$IFDEF unix}<N>  cthreads,<N>{$ENDIF}<N>  fphttp, httpdefs, httpd24, fpApache24, custapache24, SysUtils, Classes, Horse.Provider.Abstract,<N>  Horse.Constants, Horse.Proc;<N><N>
unit Horse.Provider.FPC.Daemon;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_DAEMON)}<N>uses SysUtils, Classes, httpdefs, fpHTTP, fphttpserver, Horse.Request, Horse.Response, Horse.Core, Horse.Provider.Abstract, Horse.Constants,<N>  Horse.Proc, Horse.Commons, Horse.Exception;<N><N>
unit Horse.Core.Param.Field;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, DateUtils, Generics.Collections,<N>{$ELSE}<N>  System.SysUtils, System.Classes, System.DateUtils, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Exception, Horse.Commons, Horse.Core.Param.Field.Brackets,<N>  Horse.Core.Param.Config;<N><N>
type<N><N>  THorseCoreParamField = class<N>  private<N>    FContains: Boolean;<N>    FFieldName: string;<N>    FRequired: Boolean;<N>    FRequiredMessage: string;<N>    FInvalidFormatMessage: string;<N>    FDateFormat: string;<N>    FTimeFormat: string;<N>    FReturnUTC: Boolean;<N>    FTrueValue: string;<N>    FValue: string;<N>    FStream: TStream;<N>    FLhsBrackets: THorseCoreParamFieldLhsBrackets;<N><N>
    function GetFormatSettings: TFormatSettings;<N>    procedure RaiseHorseException(const AMessage: string); overload;<N>    procedure RaiseHorseException(const AMessage: string; const Args: array of const); overload;<N>    function TryISO8601ToDate(const AValue: string; out Value: TDateTime): Boolean;<N><N>
unit Horse.Provider.FPC.LCL;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_LCL)}<N>uses SysUtils, Classes, httpdefs, fpHTTP, fphttpapp, Horse.Provider.Abstract, Horse.Constants, Horse.Proc;<N><N>type<N><N>
unit Horse.Session;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections;<N>{$ELSE}<N>  System.SysUtils, System.Generics.Collections;<N>{$ENDIF}<N><N>type<N>  TSession = class<N>  end;<N><N>
unit Horse.Callback;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  Generics.Collections, fpHTTP,<N>{$ELSE}<N>  Web.HTTPApp, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Request, Horse.Response, Horse.Proc, Horse.Commons;<N><N>
{ ****************************************************************************** }<N>{ }<N>{ Linux Daemon with Delphi }<N>{ }<N>{ Author: Paolo Rossi (2017) }<N>{ }<N>{ http://www.paolorossi.net }<N>{ http://blog.paolorossi.net }<N>{ https://github.com/paolo-rossi }<N>{ }<N>{ ****************************************************************************** }<N>unit ThirdParty.Posix.Syslog;<N><N>
unit Horse.Core.Group.Contract;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses Horse.Core.Route.Contract, Horse.Core.RouterTree, Horse.Callback;<N><N>type<N>  IHorseCoreGroup<T: class> = interface<N>    ['{5EB734D6-6944-473E-9C79-506647E2F5E8}']<N>    function Prefix(const APrefix: string): IHorseCoreGroup<T>;<N>    function Route(const APath: string): IHorseCoreRoute<T>;<N><N>
unit Horse.WebModule;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, httpdefs, fpHTTP, fpWeb,<N>{$ELSE}<N>  System.SysUtils, System.Classes, Web.HTTPApp,<N>{$ENDIF}<N>  Horse.Core, Horse.Commons;<N><N>
unit Horse.Provider.FPC.FastCGI;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(FPC) AND DEFINED(HORSE_FCGI)}<N>uses SysUtils, Classes, fpFCGI, httpdefs, fpHTTP, Horse.Provider.Abstract, Horse.Constants, Horse.Proc;<N><N>
unit Horse.Exception.Interrupted;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils;<N>{$ELSE}<N>  System.SysUtils;<N>{$ENDIF}<N><N>type<N>  EHorseCallbackInterrupted = class(Exception)<N>    constructor Create; reintroduce;<N>  end;<N><N>implementation<N><N>constructor EHorseCallbackInterrupted.Create;<N>begin<N>  inherited Create(EmptyStr);<N>end;<N><N>end.<N>
unit Horse.Core.Files;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, Generics.Collections;<N>{$ELSE}<N>  System.SysUtils, System.Classes, System.Generics.Collections;<N>{$ENDIF}<N><N>
unit Horse.Core.Param.Header;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, Generics.Collections, fpHTTP, fphttpserver, httpprotocol, HTTPDefs,<N>{$ELSE}<N>  System.Classes, System.SysUtils, System.Generics.Collections,<N>  Web.HTTPApp, IdCustomHTTPServer, IdHeaderList, Horse.Rtti,<N>{$ENDIF}<N>  Horse.Core.Param, Horse.Commons, Horse.Rtti.Helper;<N><N>
type<N>  THorseCoreParamHeader = class<N>  private<N>    class function GetHeadersList(const AWebRequest: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF}): TStrings;<N>  public<N>    class function GetHeaders(const AWebRequest: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF}): THorseList;<N>  end;<N><N>
unit Horse.Core.Route.Contract;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses Horse.Core.RouterTree, Horse.Callback;<N><N>type<N>  IHorseCoreRoute<T: class> = interface<N>    ['{8D593D98-44B3-4FD2-A21B-BA29F784B3AA}']<N>    function AddCallback(const ACallback: THorseCallback): IHorseCoreRoute<T>;<N>    function AddCallbacks(const ACallbacks: TArray<THorseCallback>): IHorseCoreRoute<T>;<N><N>
    function All(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const ACallbacks: array of THorseCallback; const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    function Get(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Get(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Get(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Get(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Put(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Put(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Put(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Put(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Head(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Head(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Head(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Head(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Post(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Post(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Post(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Post(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
unit Horse.Request;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, fpHTTP, HTTPDefs,<N>{$ELSE}<N>  System.SysUtils, System.Classes, Web.HTTPApp,<N>  {$IF CompilerVersion > 32.0}<N>    Web.ReqMulti,<N>  {$ENDIF}<N>{$ENDIF}<N>  Horse.Core.Param, Horse.Core.Param.Header, Horse.Commons, Horse.Session;<N><N>
unit Horse.Provider.ISAPI;<N><N>interface<N><N>{$IF DEFINED(HORSE_ISAPI) AND NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, System.SysUtils, Web.Win.ISAPIApp;<N><N>type<N>  THorseProvider<T: class> = class(THorseProviderAbstract<T>)<N>  private<N>    class procedure InternalListen; static;<N>  public<N>    class procedure Listen; overload; override;<N>    class procedure Listen(const ACallback: TProc<T>); reintroduce; overload; static;<N>  end;<N>{$ENDIF}<N><N>
implementation<N><N>{$IF DEFINED(HORSE_ISAPI) AND NOT DEFINED(FPC)}<N>uses Web.WebBroker, System.Win.ComObj, Winapi.ActiveX, Horse.WebModule;<N><N>exports<N>  GetExtensionVersion,<N>  HttpExtensionProc,<N>  TerminateExtension;<N><N>class procedure THorseProvider<T>.InternalListen;<N>begin<N>  CoInitFlags := COINIT_MULTITHREADED;<N>  Application.Initialize;<N>  Application.WebModuleClass := WebModuleClass;<N>  DoOnListen;<N>  Application.Run;<N>end;<N><N>
class procedure THorseProvider<T>.Listen;<N>begin<N>  inherited;<N>  InternalListen;<N>end;<N><N>class procedure THorseProvider<T>.Listen(const ACallback: TProc<T>);<N>begin<N>  inherited;<N>  SetOnListen(ACallback);<N>  InternalListen;<N>end;<N>{$ENDIF}<N><N>
unit Horse.Core.Group;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils,<N>{$ELSE}<N>  System.SysUtils,<N>{$ENDIF}<N>  Horse.Core.Group.Contract, Horse.Core.Route.Contract, Horse.Core.RouterTree, Horse.Callback;<N><N>
type<N>  THorseCoreGroup<T: class> = class(TInterfacedObject, IHorseCoreGroup<T>)<N>  private<N>    FHorseCore: TObject;<N>    FPrefix: string;<N>    function NormalizePath(const APath: string): string;<N>  public<N>    constructor Create;<N><N>    function Prefix(const APrefix: string): IHorseCoreGroup<T>;<N>    function Route(const APath: string): IHorseCoreRoute<T>;<N><N>
unit Horse.Provider.Daemon;<N><N>interface<N><N>{$IF DEFINED(HORSE_DAEMON) AND NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, Horse.Constants, Horse.Provider.IOHandleSSL, IdHTTPWebBrokerBridge, IdSSLOpenSSL, IdContext,<N>  System.SyncObjs, System.SysUtils, Posix.SysTypes;<N><N>
unit Horse.Constants;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>const<N>  DEFAULT_HOST = '0.0.0.0';<N>  DEFAULT_PORT = 9000;<N>  START_RUNNING = 'Server is runing on %s:%d';<N>  HORSE_VERSION = '3.0.2';<N><N>implementation<N><N>end.<N>
unit Horse.Commons;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$MODESWITCH TypeHelpers}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  Classes,<N>  SysUtils,<N>  StrUtils,<N>  RegExpr<N>{$ELSE}<N>    System.Classes,<N>  System.SysUtils,<N>  System.RegularExpressions<N>{$ENDIF}<N>    ;<N><N>
unit Horse.Core.RouterTree;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections, fpHTTP, httpprotocol,<N>{$ELSE}<N>  System.SysUtils, System.NetEncoding, Web.HTTPApp, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Request, Horse.Response, Horse.Proc, Horse.Commons, Horse.Callback;<N><N>
unit Horse.Rtti.Helper;<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  RTTI;<N>{$ELSE}<N>  System.Rtti;<N>{$ENDIF}<N><N>type<N>  THorseRttiTypeHelper = class helper for TRttiType<N>  public<N>    {$IF NOT DEFINED(FPC)}<N>    function FieldValueAsObject(const AInstance: Pointer; const AFieldName: string): TObject;<N>    {$ENDIF}<N>  end;<N><N>
implementation<N><N>{$IF NOT DEFINED(FPC)}<N>function THorseRttiTypeHelper.FieldValueAsObject(const AInstance: Pointer; const AFieldName: string): TObject;<N>var<N>  LField: TRttiField;<N>begin<N>  Result := nil;<N>  LField := GetField(AFieldName);<N>  if Assigned(LField) then<N>    Result := LField.GetValue(AInstance).AsObject;<N>end;<N>{$ENDIF}<N><N>
unit Horse.Response;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, fpHTTP, HTTPDefs,<N>{$ELSE}<N>  System.SysUtils, System.Classes, Web.HTTPApp,<N>  {$IF CompilerVersion > 32.0}<N>    Web.ReqMulti,<N>  {$ENDIF}<N>{$ENDIF}<N>  Horse.Commons, Horse.Core.Files;<N><N>
unit Horse.Provider.Console;<N><N>interface<N><N>{$IF NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, Horse.Constants, Horse.Provider.IOHandleSSL, IdHTTPWebBrokerBridge, IdSSLOpenSSL, IdContext,<N>  System.Classes, System.SyncObjs, System.SysUtils;<N><N>
unit Horse.Core.Param;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, DateUtils, Generics.Collections, fpHTTP, fphttpserver, HTTPDefs,<N>{$ELSE}<N>  System.SysUtils, System.Classes, System.DateUtils, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Exception, Horse.Commons, Horse.Core.Param.Field;<N><N>
unit Horse.Core;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections,<N>{$ELSE}<N>  System.SysUtils, System.Generics.Collections, Web.HTTPApp,<N>{$ENDIF}<N>  Horse.Core.RouterTree, Horse.Commons, Horse.Request, Horse.Response, Horse.Constants, Horse.Callback,<N>  Horse.Core.Group.Contract, Horse.Core.Route.Contract;<N><N>
unit Horse.Core.Route;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils,<N>{$ELSE}<N>  System.SysUtils,<N>{$ENDIF}<N>  Horse.Core.Route.Contract, Horse.Core.RouterTree, Horse.Callback;<N><N>
type<N>  THorseCoreRoute<T: class> = class(TInterfacedObject, IHorseCoreRoute<T>)<N>  private<N>    FPath: string;<N>    FHorseCore: TObject;<N>  public<N>    constructor Create(const APath: string);<N><N>    function This: IHorseCoreRoute<T>;<N>    function AddCallback(const ACallback: THorseCallback): IHorseCoreRoute<T>;<N>    function AddCallbacks(const ACallbacks: TArray<THorseCallback>): IHorseCoreRoute<T>;<N><N>
    function All(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const ACallbacks: array of THorseCallback; const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    function Get(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Get(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Get(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Get(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Put(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Put(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Put(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Put(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Head(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Head(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Head(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Head(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Post(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Post(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Post(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Post(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
unit DataSet.Serialize.Samples.Basic;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses Classes, SysUtils, memds, DB, Forms, Controls, Graphics, Dialogs, ComCtrls,<N>  ExtCtrls, StdCtrls, DBGrids, fpjson, DataSet.Serialize, TypInfo;<N><N>type<N><N>  { TFrmBasic }<N><N>
unit DataSet.Serialize.Samples.Master.Detail;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, ExtCtrls, ComCtrls, StdCtrls, Grids, DBGrids, DataSet.Serialize,<N>  ZConnection, ZDataset, fpjson, DB;<N><N>
unit DataSet.Serialize.Samples.Basic;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics, System.JSON, Vcl.Controls,<N>  Vcl.Forms, Vcl.Dialogs, Vcl.ComCtrls, Vcl.ExtCtrls, Vcl.StdCtrls, Data.DB, Vcl.Grids, Vcl.DBGrids, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, DataSet.Serialize;<N><N>
unit DataSet.Serialize.Samples.Configuration;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.StdCtrls, DataSet.Serialize, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf, Data.DB,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, Vcl.CheckLst, Vcl.Grids, Vcl.DBGrids, System.JSON;<N><N>
unit DataSet.Serialize.Samples.Master.Detail;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.ComCtrls, Vcl.StdCtrls, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf, Data.DB, FireDAC.Comp.DataSet,<N>  FireDAC.Comp.Client, Vcl.Grids, Vcl.DBGrids, DataSet.Serialize, System.JSON;<N><N>
unit DataSet.Serialize.Language;<N><N>interface<N><N>type<N>  /// <summary><N>  ///   Languages handled by helper Validate (JSON).<N>  /// </summary><N>  TLanguageType = (ptBR, enUS);<N><N>implementation<N><N>end.<N>
unit DataSet.Serialize;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson,<N>{$ELSE}<N>  System.JSON, Data.DB,<N>{$ENDIF}<N>  DataSet.Serialize.Language, DataSet.Serialize.Config;<N><N>type<N>  TLanguageType = DataSet.Serialize.Language.TLanguageType;<N>  TDataSetSerializeConfig = DataSet.Serialize.Config.TDataSetSerializeConfig;<N>  TCaseNameDefinition = DataSet.Serialize.Config.TCaseNameDefinition;<N><N>
unit DataSet.Serialize.Export;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  Classes, DB, Generics.Collections, fpjson;<N>{$ELSE}<N>  Data.DB, System.JSON;<N>{$ENDIF}<N><N>type<N>  {$IF DEFINED(FPC)}<N>  { TJSONExtFloatNumber }<N>  TJSONExtFloatNumber =class(TJSONFloatNumber)<N>    function GetAsString: TJSONStringType; override;<N>  end;<N>  {$ENDIF}<N><N>
unit DataSet.Serialize.UpdatedStatus;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB;<N>{$ELSE}<N>  Data.DB;<N>{$ENDIF}<N><N>type<N>  TUpdateStatusHelper = record helper for TUpdateStatus<N>    function ToString: string;<N>  end;<N><N>
implementation<N><N>function TUpdateStatusHelper.ToString: string;<N>begin<N>  case Self of<N>    usModified:<N>      Result := 'MODIFIED';<N>    usInserted:<N>      Result := 'INSERTED';<N>    usDeleted:<N>      Result := 'DELETED';<N>  else<N>    Result := 'UNMODIFIED';<N>  end;<N>end;<N><N>
﻿unit DataSet.Serialize.Import;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson, Generics.Collections,<N>{$ELSE}<N>  System.JSON, Data.DB, System.StrUtils, System.SysUtils, System.Rtti,<N>  {$IF CompilerVersion >= 20}<N>    System.Character,<N>  {$ENDIF}<N>{$ENDIF}<N>  DataSet.Serialize.Language, DataSet.Serialize.Utils;<N><N>
unit uFrmMenuPadrao;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, uFrmPadrao, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS,<N>  FireDAC.Phys.Intf, FireDAC.DApt.Intf, FireDAC.Stan.Async, FireDAC.DApt,<N>  Data.DB, FireDAC.Comp.DataSet, FireDAC.Comp.Client, Vcl.Menus;<N><N>
{<N>   Copyright 2005-2012 Sandy Barbour and Ben Supnik All rights reserved.  See<N>   license.txt for usage. X-Plane SDK Version: 2.1.1                          <N>}<N><N>UNIT XPUIGraphics;<N>INTERFACE<N><N>USES<N>    XPWidgetDefs;<N>   {$A4}<N>{___________________________________________________________________________<N> * UI GRAPHICS<N> ___________________________________________________________________________}<N><N>
{<N>   Copyright 2005-2012 Sandy Barbour and Ben Supnik All rights reserved.  See<N>   license.txt for usage. X-Plane SDK Version: 2.1.1                          <N>}<N><N>UNIT XPLMScenery;<N>INTERFACE<N>{<N>   This package contains APIs to interact with X-Plane's scenery system.      <N>}<N><N>
{<N>   Copyright 2005-2012 Sandy Barbour and Ben Supnik All rights reserved.  See<N>   license.txt for usage. X-Plane SDK Version: 2.1.1                          <N>}<N><N>UNIT XPLMPlugin;<N>INTERFACE<N>{<N>   These APIs provide facilities to find and work with other plugins and<N>   manage other plugins.                                                      <N>}<N><N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit ConfirmationDialog;<N><N>interface<N><N>uses<N>  UConfirmationForm, LazarusPackageIntf;<N><N>implementation<N><N>procedure Register;<N>begin<N>end;<N><N>initialization<N>  RegisterPackage('ConfirmationDialog', @Register);<N>end.<N>
unit UObjectTypeBase;<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>  ENotImplemented = class(Exception);<N><N>  IAssignable = interface<N>    procedure Assign(Source: TInterfacedObject);<N>  end;<N><N>  ISortable = interface<N>    procedure Sort;<N>  end;<N><N>  IStreamable = interface<N>    procedure GetStream(Stream: TStream);<N>    procedure SetStrem(Stream: TStream);<N>  end;<N><N>implementation<N><N>end.<N>
unit UObjectDateTime;<N><N>interface<N><N>uses<N>  UObjectTypeBase, UObjectBoolean, Types, SysUtils, UObjectDouble, DateUtils, Classes;<N><N>type<N>  TDateTime = class(TDouble, IInterface)<N><N>  end;<N><N>implementation<N><N>{ TDateTime }<N><N><N>end.<N>
unit UMainForm;<N><N>{$mode delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ComCtrls, SpecializedList, SpecializedDictionary, SpecializedQueue,<N>  DateUtils, SpecializedMatrix, SpecializedStream;<N><N>
unit SpecializedStream;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, SpecializedList, DateUtils;<N><N>type<N>  TSeekOrigin = (soBegin, soCurrent, soEnd);<N><N>{$MACRO ON}<N><N>// TStreamInteger<Integer, Integer><N>{$DEFINE TGStreamIndex := Integer}<N>{$DEFINE TGStreamItem := Integer}<N>{$DEFINE TGStreamList := TListStreamInteger}<N>{$DEFINE TGStream := TStreamInteger}<N>{$DEFINE INTERFACE}<N>{$I 'GenericStream.inc'}<N><N>
// TStreamByte<Integer, Byte><N>{$DEFINE TGStreamIndex := Integer}<N>{$DEFINE TGStreamItem := Byte}<N>{$DEFINE TGStreamList := TListStreamByte}<N>{$DEFINE TGStream := TBaseStreamByte}<N>{$DEFINE INTERFACE}<N>{$I 'GenericStream.inc'}<N><N>// TStreamPointer<Integer, Pointer><N>{$DEFINE TGStreamIndex := Integer}<N>{$DEFINE TGStreamItem := Pointer}<N>{$DEFINE TGStreamList := TListStreamPointer}<N>{$DEFINE TGStream := TStreamPointer}<N>{$DEFINE INTERFACE}<N>{$I 'GenericStream.inc'}<N><N>
unit SpecializedTree;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>{$MACRO ON}<N>// TTreeInteger<Integer, Integer><N>{$DEFINE TGTreeIndex := Integer}<N>{$DEFINE TGTreeItem := Integer}<N>{$DEFINE TGTree := TTreeInteger}<N>{$DEFINE TGTreeNode := TTreeNodeInteger}<N>{$DEFINE TGTreeNodeList := TTreeNodeListInteger}<N>{$DEFINE INTERFACE}<N>{$I 'GenericTree.inc'}<N><N>
// TTreeString<Integer, string><N>{$DEFINE TGTreeIndex := Integer}<N>{$DEFINE TGTreeItem := string}<N>{$DEFINE TGTree := TTreeString}<N>{$DEFINE TGTreeNode := TTreeNodeString}<N>{$DEFINE TGTreeNodeList := TTreeNodeListString}<N>{$DEFINE INTERFACE}<N>{$I 'GenericTree.inc'}<N><N>
// TTreePointer<Integer, Pointer><N>{$DEFINE TGTreeIndex := Integer}<N>{$DEFINE TGTreeItem := Pointer}<N>{$DEFINE TGTree := TTreePointer}<N>{$DEFINE TGTreeNode := TTreeNodePointer}<N>{$DEFINE TGTreeNodeList := TTreeNodeListPointer}<N>{$DEFINE INTERFACE}<N>{$I 'GenericTree.inc'}<N><N>
implementation<N><N>{$DEFINE IMPLEMENTATION_USES}<N>{$I 'GenericTree.inc'}<N><N>// TTreeInteger<Integer, Integer><N>{$DEFINE TGTreeIndex := Integer}<N>{$DEFINE TGTreeItem := Integer}<N>{$DEFINE TGTree := TTreeInteger}<N>{$DEFINE TGTreeNode := TTreeNodeInteger}<N>{$DEFINE TGTreeNodeList := TTreeNodeListInteger}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericTree.inc'}<N><N>
// TTreeString<Integer, string><N>{$DEFINE TGTreeIndex := Integer}<N>{$DEFINE TGTreeItem := string}<N>{$DEFINE TGTree := TTreeString}<N>{$DEFINE TGTreeNode := TTreeNodeString}<N>{$DEFINE TGTreeNodeList := TTreeNodeListString}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericTree.inc'}<N><N>
// TTreePointer<Integer, Pointer><N>{$DEFINE TGTreeIndex := Integer}<N>{$DEFINE TGTreeItem := Pointer}<N>{$DEFINE TGTree := TTreePointer}<N>{$DEFINE TGTreeNode := TTreeNodePointer}<N>{$DEFINE TGTreeNodeList := TTreeNodeListPointer}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericTree.inc'}<N><N>
unit SpecializedQueue;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>{$MACRO ON}<N><N>// TQueueInteger<Integer, Integer><N>{$DEFINE TGQueueIndex := Integer}<N>{$DEFINE TGQueueItem := Integer}<N>{$DEFINE TGQueue := TQueueInteger}<N>{$DEFINE TGQueueList := TQueueListInteger}<N>{$DEFINE INTERFACE}<N>{$I 'GenericQueue.inc'}<N><N>
// TQueueInteger<Integer, Pointer><N>{$DEFINE TGQueueIndex := Integer}<N>{$DEFINE TGQueueItem := Pointer}<N>{$DEFINE TGQueue := TQueuePointer}<N>{$DEFINE TGQueueList := TQueueListPointer}<N>{$DEFINE INTERFACE}<N>{$I 'GenericQueue.inc'}<N><N>// TQueueByte<Integer, Byte><N>{$DEFINE TGQueueIndex := Integer}<N>{$DEFINE TGQueueItem := Byte}<N>{$DEFINE TGQueue := TQueueByte}<N>{$DEFINE TGQueueList := TQueueListByte}<N>{$DEFINE INTERFACE}<N>{$I 'GenericQueue.inc'}<N><N>
implementation<N><N>{$DEFINE IMPLEMENTATION_USES}<N>{$I 'GenericQueue.inc'}<N><N>// TQueueInteger<Integer, Integer><N>{$DEFINE TGQueueIndex := Integer}<N>{$DEFINE TGQueueItem := Integer}<N>{$DEFINE TGQueue := TQueueInteger}<N>{$DEFINE TGQueueList := TQueueListInteger}<N>{$DEFINE IMPLEMENTATION}<N>{$I '..\Generic\GenericQueue.inc'}<N><N>
// TQueueInteger<Integer, Pointer><N>{$DEFINE TGQueueIndex := Integer}<N>{$DEFINE TGQueueItem := Pointer}<N>{$DEFINE TGQueue := TQueuePointer}<N>{$DEFINE TGQueueList := TQueueListPointer}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericQueue.inc'}<N><N>// TQueueByte<Integer, Byte><N>{$DEFINE TGQueueIndex := Integer}<N>{$DEFINE TGQueueItem := Byte}<N>{$DEFINE TGQueue := TQueueByte}<N>{$DEFINE TGQueueList := TQueueListByte}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericQueue.inc'}<N><N>
unit SpecializedStack;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>{$MACRO ON}<N><N>// TStackInteger<Integer, Integer><N>{$DEFINE TGStackIndex := Integer}<N>{$DEFINE TGStackItem := Integer}<N>{$DEFINE TGStackList := TListStackInteger}<N>{$DEFINE TGStack := TStackInteger}<N>{$DEFINE INTERFACE}<N>{$I 'GenericStack.inc'}<N><N>
// TStackInteger<Integer, Pointer><N>{$DEFINE TGStackIndex := Integer}<N>{$DEFINE TGStackItem := Pointer}<N>{$DEFINE TGStackList := TListStackPointer}<N>{$DEFINE TGStack := TStackPointer}<N>{$DEFINE INTERFACE}<N>{$I 'GenericStack.inc'}<N><N><N>implementation<N><N>
{$DEFINE IMPLEMENTATION_USES}<N>{$I 'GenericStack.inc'}<N><N>// TStackInteger<Integer, Integer><N>{$DEFINE TGStackIndex := Integer}<N>{$DEFINE TGStackItem := Integer}<N>{$DEFINE TGStackList := TListStackInteger}<N>{$DEFINE TGStack := TStackInteger}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericStack.inc'}<N><N>
// TStackInteger<Integer, Pointer><N>{$DEFINE TGStackIndex := Integer}<N>{$DEFINE TGStackItem := Pointer}<N>{$DEFINE TGStackList := TListStackPointer}<N>{$DEFINE TGStack := TStackPointer}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericStack.inc'}<N>end.<N><N><N>
unit SpecializedDictionary;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>{$MACRO ON}<N><N>// TDictionaryStringString<Integer, TPair<string, string>><N>{$DEFINE TGDictionaryIndex := Integer}<N>{$DEFINE TGPair := TPairStringString}<N>{$DEFINE TGPairKey := string}<N>{$DEFINE TGPairValue := string}<N>{$DEFINE TGDictionary := TDictionaryStringString}<N>{$DEFINE TGDictionaryList := TDictionaryStringStringList}<N>{$DEFINE INTERFACE}<N>{$I 'GenericDictionary.inc'}<N><N>
// TDictionaryIntegerString<Integer, TPair<Integer, string>><N>{$DEFINE TGDictionaryIndex := Integer}<N>{$DEFINE TGPair := TPairIntegerString}<N>{$DEFINE TGPairKey := Integer}<N>{$DEFINE TGPairValue := string}<N>{$DEFINE TGDictionary := TDictionaryIntegerString}<N>{$DEFINE TGDictionaryList := TDictionaryIntegerStringList}<N>{$DEFINE INTERFACE}<N>{$I 'GenericDictionary.inc'}<N><N>
<N>implementation<N><N>{$DEFINE IMPLEMENTATION_USES}<N>{$I '..\Generic\GenericDictionary.inc'}<N><N><N>// TDictionaryStringString<Integer, TPair<string, string>><N>{$DEFINE TGDictionaryIndex := Integer}<N>{$DEFINE TGPair := TPairStringString}<N>{$DEFINE TGPairKey := string}<N>{$DEFINE TGPairValue := string}<N>{$DEFINE TGDictionary := TDictionaryStringString}<N>{$DEFINE TGDictionaryList := TDictionaryStringStringList}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericDictionary.inc'}<N><N>
// TDictionaryIntegerString<Integer, TPair<Integer, string>><N>{$DEFINE TGDictionaryIndex := Integer}<N>{$DEFINE TGPair := TPairIntegerString}<N>{$DEFINE TGPairKey := Integer}<N>{$DEFINE TGPairValue := string}<N>{$DEFINE TGDictionary := TDictionaryIntegerString}<N>{$DEFINE TGDictionaryList := TDictionaryIntegerStringList}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericDictionary.inc'}<N><N>
unit SpecializedSet;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>{$MACRO ON}<N><N>// TSetInteger<Integer, Integer><N>{$DEFINE TGSetIndex := Integer}<N>{$DEFINE TGSetItem := Integer}<N>{$DEFINE TGSetList := TSetListInteger}<N>{$DEFINE TGSet := TSetInteger}<N>{$DEFINE INTERFACE}<N>{$I 'GenericSet.inc'}<N><N>
// TSetPointer<Integer, Pointer><N>{$DEFINE TGSetIndex := Integer}<N>{$DEFINE TGSetItem := Pointer}<N>{$DEFINE TGSetList := TSetListPointer}<N>{$DEFINE TGSet := TSetPointer}<N>{$DEFINE INTERFACE}<N>{$I 'GenericSet.inc'}<N><N>implementation<N><N>{$DEFINE IMPLEMENTATION_USES}<N>{$I 'GenericSet.inc'}<N><N>
// TSetInteger<Integer, Integer><N>{$DEFINE TGSetIndex := Integer}<N>{$DEFINE TGSetItem := Integer}<N>{$DEFINE TGSetList := TSetListInteger}<N>{$DEFINE TGSet := TSetInteger}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericSet.inc'}<N><N>// TSetPointer<Integer, Pointer><N>{$DEFINE TGSetIndex := Integer}<N>{$DEFINE TGSetItem := Pointer}<N>{$DEFINE TGSetList := TSetListPointer}<N>{$DEFINE TGSet := TSetPointer}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericSet.inc'}<N><N>
unit SpecializedList;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>{$MACRO ON}<N><N>// TListInteger<Integer, Integer><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Integer}<N>{$DEFINE TGList := TListInteger}<N>{$DEFINE INTERFACE}<N>{$I 'GenericList.inc'}<N><N>
// TListBoolean<Integer, Boolean><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Boolean}<N>{$DEFINE TGList := TListBoolean}<N>{$DEFINE INTERFACE}<N>{$I 'GenericList.inc'}<N><N>// TListSmallInt<Integer, SmallInt><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := SmallInt}<N>{$DEFINE TGList := TListSmallInt}<N>{$DEFINE INTERFACE}<N>{$I 'GenericList.inc'}<N><N>
// TListDouble<Integer, Double><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Double}<N>{$DEFINE TGList := TListDouble}<N>{$DEFINE INTERFACE}<N>{$INCLUDE '..\Generic\GenericList.inc'}<N><N>// TListPointer<Integer, Pointer><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Pointer}<N>{$DEFINE TGList := TListPointer}<N>{$DEFINE INTERFACE}<N>{$I 'GenericList.inc'}<N><N>
// TListString<Integer, string><N>{$DEFINE TGListStringIndex := Integer}<N>{$DEFINE TGListStringItem := string}<N>{$DEFINE TGListString := TListString}<N>{$DEFINE INTERFACE}<N>{$I 'GenericListString.inc'}<N><N>// TListByte<Integer, Byte><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Byte}<N>{$DEFINE TGList := TListByteBase}<N>{$DEFINE INTERFACE}<N>{$I 'GenericList.inc'}<N><N>
TListByte = class(TListByteBase)<N>  procedure WriteToStream(Stream: TStream);<N>  procedure WriteToStreamPart(Stream: TStream; ItemIndex, ItemCount: TGListIndex);<N>  procedure ReplaceStream(Stream: TStream);<N>  procedure ReplaceStreamPart(Stream: TStream; ItemIndex, ItemCount: TGListIndex);<N>  procedure AddStream(Stream: TStream);<N>  procedure AddStreamPart(Stream: TStream; ItemCount: TGListIndex);<N>end;<N><N>
// TListChar<Integer, Char><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Char}<N>{$DEFINE TGList := TListCharBase}<N>{$DEFINE INTERFACE}<N>{$I 'GenericList.inc'}<N><N>// TListObject<Integer, TObject><N>{$DEFINE TGListObjectIndex := Integer}<N>{$DEFINE TGListObjectItem := TObject}<N>{$DEFINE TGListObjectList := TListObjectList}<N>{$DEFINE TGListObject := TListObject}<N>{$DEFINE INTERFACE}<N>{$I 'GenericListObject.inc'}<N><N>
<N>{ TListChar }<N><N>// TListByte<Integer, Char><N>TListChar = class(TListCharBase)<N>  procedure UpperCase;<N>  procedure LowerCase;<N>  procedure Trim;<N>  procedure TrimLeft;<N>  procedure TrimRight;<N>end;<N><N>// TListMethodBase<Integer, TMethod><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := TMethod}<N>{$DEFINE TGList := TListMethodBase}<N>{$DEFINE INTERFACE}<N>{$I 'GenericList.inc'}<N><N>
// TListMethod<Integer, TMethod><N>TListMethod = class(TListMethodBase)<N>  procedure CallAll;<N>end;<N><N>// TListNotifyEventBase<Integer, TNotifyEvent><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := TNotifyEvent}<N>{$DEFINE TGList := TListNotifyEventBase}<N>{$DEFINE INTERFACE}<N>{$I 'GenericList.inc'}<N><N>
// TListNotifyEvent<Integer, TNotifyEvent><N>TListNotifyEvent = class(TListNotifyEventBase)<N>  procedure CallAll(Sender: TObject);<N>end;<N><N><N>TBaseEvent = procedure of object;<N><N>// TListSimpleEventBase<Integer, TBaseEvent><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := TBaseEvent}<N>{$DEFINE TGList := TListSimpleEventBase}<N>{$DEFINE INTERFACE}<N>{$I 'GenericList.inc'}<N><N>
// TListSimpleEvent<Integer, TSimpleEvent><N>TListSimpleEvent = class(TListSimpleEventBase)<N>  procedure CallAll;<N>end;<N><N><N>// TFileListByte<Integer, Byte><N>{$DEFINE TGFileListIndex := Integer}<N>{$DEFINE TGFileListItem := Byte}<N>{$DEFINE TGFileListList := TFileListListByte}<N>{$DEFINE TGFileList := TFileListByte}<N>{$DEFINE INTERFACE}<N>{$I 'GenericFileList.inc'}<N><N>
function StrToStr(Value: string): string;<N><N><N><N><N><N>implementation<N><N>{$DEFINE IMPLEMENTATION_USES}<N>{$I 'GenericList.inc'}<N><N>// TListInteger<Integer, Integer><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Integer}<N>{$DEFINE TGList := TListInteger}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>
// TListSmallInt<Integer, SmallInt><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := SmallInt}<N>{$DEFINE TGList := TListSmallInt}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>// TListBoolean<Integer, Boolean><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Boolean}<N>{$DEFINE TGList := TListBoolean}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>
// TListDouble<Integer, Double><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Double}<N>{$DEFINE TGList := TListDouble}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>// TListPointer<Integer, Pointer><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Pointer}<N>{$DEFINE TGList := TListPointer}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>
// TListString<Integer, string><N>{$DEFINE TGListStringIndex := Integer}<N>{$DEFINE TGListStringItem := string}<N>{$DEFINE TGListString := TListString}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericListString.inc'}<N><N>// TListByte<Integer, Byte><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Byte}<N>{$DEFINE TGList := TListByteBase}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>
// TListByte<Integer, Char><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Char}<N>{$DEFINE TGList := TListCharBase}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>// TListObject<Integer, TObject><N>{$DEFINE TGListObjectIndex := Integer}<N>{$DEFINE TGListObjectItem := TObject}<N>{$DEFINE TGListObjectList := TListObjectList}<N>{$DEFINE TGListObject := TListObject}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericListObject.inc'}<N><N>
// TListMethod<Integer, TMethod><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := TMethod}<N>{$DEFINE TGList := TListMethodBase}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>// TListNotifyEventBase<Integer, TNotifyEvent><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := TNotifyEvent}<N>{$DEFINE TGList := TListNotifyEventBase}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>
// TListSimpleEventBase<Integer, TBaseEvent><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := TBaseEvent}<N>{$DEFINE TGList := TListSimpleEventBase}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>// TFileListByte<Integer, Byte><N>{$DEFINE TGFileListIndex := Integer}<N>{$DEFINE TGFileListItem := Byte}<N>{$DEFINE TGFileListList := TFileListListByte}<N>{$DEFINE TGFileList := TFileListByte}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericFileList.inc'}<N><N>
<N>function StrToStr(Value: string): string;<N>begin<N>  Result := Value;<N>end;<N><N>{ TListSimpleEvent }<N><N>procedure TListSimpleEvent.CallAll;<N>var<N>  I: TGListIndex;<N>begin<N>  I := 0;<N>  while (I < Count) do begin<N>    TBaseEvent(Items[I])();<N>    I := I + 1;<N>  end;<N>end;<N><N>
<N>{ TListChar }<N><N>procedure TListChar.UpperCase;<N>var<N>  I: TGListIndex;<N>begin<N>  for I := 0 to Count - 1 do<N>    if (FItems[I] in ['a'..'z']) then<N>      FItems[I] := Char(Byte(FItems[I]) - 32);<N>end;<N><N>procedure TListChar.LowerCase;<N>var<N>  I: TGListIndex;<N>begin<N>  for I := 0 to Count - 1 do<N>    if (FItems[I] in ['A'..'Z']) then<N>      FItems[I] := Char(Byte(FItems[I]) + 32);<N>end;<N><N>
procedure TListChar.Trim;<N>begin<N>  TrimLeft;<N>  TrimRight;<N>end;<N><N>procedure TListChar.TrimLeft;<N>var<N>  I: TGListIndex;<N>begin<N>  I := 0;<N>  while (I < Count) and (FItems[I] = ' ') do<N>    I := I + 1;<N>  if I < Count then<N>    DeleteItems(0, I);<N>end;<N><N>
procedure TListChar.TrimRight;<N>var<N>  I: TGListIndex;<N>begin<N>  I := Count - 1;<N>  while (I >= 0) and (FItems[I] = ' ') do<N>    I := I - 1;<N>  if I >= 0 then<N>    DeleteItems(I + 1, Count - I - 1);<N>end;<N><N>procedure TListMethod.CallAll;<N>var<N>  I: TGListIndex;<N>begin<N>  I := 0;<N>  while (I < Count) do begin<N>    Items[I];<N>    I := I + 1;<N>  end;<N>end;<N><N>
procedure TListNotifyEvent.CallAll(Sender: TObject);<N>var<N>  I: TGListIndex;<N>begin<N>  I := Count - 1;<N>  while (I >= 0) do begin<N>    TNotifyEvent(Items[I])(Sender);<N>    I := I - 1;<N>  end;<N>end;<N><N>{ TListByte }<N><N>procedure TListByte.WriteToStream(Stream: TStream);<N>var<N>  I: Integer;<N>begin<N>  Stream.Position := 0;<N>  I := 0;<N>  while I < Count do begin<N>    Stream.WriteByte(Items[I]);<N>    I := I + 1;<N>  end;<N>end;<N><N>
procedure TListByte.WriteToStreamPart(Stream: TStream; ItemIndex, ItemCount: Integer);<N>var<N>  I: Integer;<N>begin<N>  I := ItemIndex;<N>  while I < ItemCount do begin<N>    Stream.WriteByte(Items[I]);<N>    I := I + 1;<N>  end;<N>end;<N><N>procedure TListByte.ReplaceStream(Stream: TStream);<N>var<N>  I: Integer;<N>begin<N>  Stream.Position := 0;<N>  I := 0;<N>  while I < Count do begin<N>    Items[I] := Stream.ReadByte;<N>    I := I + 1;<N>  end;<N>end;<N><N>
procedure TListByte.ReplaceStreamPart(Stream: TStream; ItemIndex,<N>  ItemCount: Integer);<N>var<N>  I: Integer;<N>begin<N>  I := ItemIndex;<N>  while I < ItemCount do begin<N>    Items[I] := Stream.ReadByte;<N>    I := I + 1;<N>  end;<N>end;<N><N>procedure TListByte.AddStream(Stream: TStream);<N>var<N>  I: Integer;<N>begin<N>  Stream.Position := 0;<N>  I := Count;<N>  Count := Count + Stream.Size;<N>  while I < Count do begin<N>    Items[I] := Stream.ReadByte;<N>    I := I + 1;<N>  end;<N>end;<N><N>
procedure TListByte.AddStreamPart(Stream: TStream; ItemCount: Integer);<N>var<N>  I: Integer;<N>begin<N>  I := Count;<N>  Count := Count + ItemCount;<N>  while I < Count do begin<N>    Items[I] := Stream.ReadByte;<N>    I := I + 1;<N>  end;<N>end;<N><N><N>end.<N><N><N>
unit SpecializedMatrix;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils; <N><N>type<N>  {$MACRO ON}<N><N>// TMatrixInteger<Integer, Integer, Integer><N>{$DEFINE TGMatrixIndexX := Integer}<N>{$DEFINE TGMatrixIndexY := Integer}<N>{$DEFINE TGMatrixItem := Integer}<N>{$DEFINE TGMatrixIndex := TMatrixIntegerIndex}<N>{$DEFINE TGMatrixRow := TMatrixIntegerRow}<N>{$DEFINE TGMatrix := TMatrixInteger}<N>{$DEFINE INTERFACE}<N>{$I 'GenericMatrix.inc'}<N><N>
// TMatrixByte<Integer, Integer, Byte><N>{$DEFINE TGMatrixIndexX := Integer}<N>{$DEFINE TGMatrixIndexY := Integer}<N>{$DEFINE TGMatrixItem := Byte}<N>{$DEFINE TGMatrixIndex := TMatrixByteIndex}<N>{$DEFINE TGMatrixRow := TMatrixByteRow}<N>{$DEFINE TGMatrix := TMatrixByte}<N>{$DEFINE INTERFACE}<N>{$I 'GenericMatrix.inc'}<N><N>
// TMatrixObject<Integer, Integer, TObject><N>{$DEFINE TGMatrixIndexX := Integer}<N>{$DEFINE TGMatrixIndexY := Integer}<N>{$DEFINE TGMatrixItem := TObject}<N>{$DEFINE TGMatrixIndex := TMatrixObjectIndex}<N>{$DEFINE TGMatrixRow := TMatrixObjectRow}<N>{$DEFINE TGMatrix := TMatrixObject}<N>{$DEFINE INTERFACE}<N>{$I 'GenericMatrix.inc'}<N><N>
implementation<N><N>{$DEFINE IMPLEMENTATION_USES}<N>{$I 'GenericMatrix.inc'}<N><N>// TMatrixInteger<Integer, Integer, Integer><N>{$DEFINE TGMatrixIndexX := Integer}<N>{$DEFINE TGMatrixIndexY := Integer}<N>{$DEFINE TGMatrixItem := Integer}<N>{$DEFINE TGMatrixIndex := TMatrixIntegerIndex}<N>{$DEFINE TGMatrixRow := TMatrixIntegerRow}<N>{$DEFINE TGMatrix := TMatrixInteger}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericMatrix.inc'}<N><N>
// TMatrixByte<Integer, Integer, Byte><N>{$DEFINE TGMatrixIndexX := Integer}<N>{$DEFINE TGMatrixIndexY := Integer}<N>{$DEFINE TGMatrixItem := Byte}<N>{$DEFINE TGMatrixIndex := TMatrixByteIndex}<N>{$DEFINE TGMatrixRow := TMatrixByteRow}<N>{$DEFINE TGMatrix := TMatrixByte}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericMatrix.inc'}<N><N>
// TMatrixObject<Integer, Integer, TObject><N>{$DEFINE TGMatrixIndexX := Integer}<N>{$DEFINE TGMatrixIndexY := Integer}<N>{$DEFINE TGMatrixItem := TObject}<N>{$DEFINE TGMatrixIndex := TMatrixObjectIndex}<N>{$DEFINE TGMatrixRow := TMatrixObjectRow}<N>{$DEFINE TGMatrix := TMatrixObject}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericMatrix.inc'}<N><N>
unit UGenericShared;<N><N>{$mode Delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils; <N><N>function FastCompareMem(P1, P2: Pointer; Length: cardinal): Boolean; inline;<N>function FastCompareMem2(P1, P2: Pointer; Length: cardinal): Boolean; inline;<N><N>
implementation<N><N>function FastCompareMem(P1, P2: Pointer; Length: cardinal): Boolean;<N>var<N>  i: cardinal;<N>begin<N>  Result:=True;<N>  I:=0;<N>  If (P1)<>(P2) then<N>    While Result and (i<Length) do<N>      begin<N>      Result:=PByte(P1)^=PByte(P2)^;<N>      Inc(I);<N>      Inc(pchar(P1));<N>      Inc(pchar(P2));<N>      end;<N>end;<N><N>
function FastCompareMem2(P1, P2: Pointer; Length: cardinal): Boolean;<N>var<N>  i: cardinal;<N>begin<N>  Result:=True;<N>  I:=0;<N>  If (P1)<>(P2) then<N>    While Result and (i<Length) do<N>      begin<N>      Result:=PByte(P1)^=PByte(P2)^;<N>      Inc(I);<N>      Inc(pchar(P1));<N>      Inc(pchar(P2));<N>      end;<N>end;<N><N>
unit UMainForm;<N><N>{$mode delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ComCtrls, DateUtils, GenericList, GenericMatrix, GenericQueue, fgl,<N>  GenericDictionary, SpecializedStream, SpecializedList;<N><N>
unit GenericPoint;<N><N>{$mode delphi}<N><N>interface<N><N>type<N>  TGPoint<T> = record<N>    X: T;<N>    Y: T;<N>    procedure Add(Point: TGPoint<T>);<N> end;<N><N><N>implementation<N><N>procedure TGPoint<T>.Add(Point: TGPoint<T>);<N>begin<N>  X := X + Point.X;<N>  Y := Y + Point.Y;<N>end;<N><N>end.<N>
unit GenericMatrix;<N><N>{$mode delphi}<N><N>interface<N><N>type<N>  TGMatrix<T> = class<N>  public<N>    type<N>      TSortCompare = function(const Item1, Item2: T): Integer of object;<N>      TToStringConverter = function(Item: T): string;<N>      TFromStringConverter = function(Text: string): T;<N>      TRow = array of T;<N>      TMerge = function(Item1, Item2: T): T of object;<N><N>
unit SpecializedStream;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, SpecializedList, DateUtils, GenericStream, GenericList;<N><N>type<N>  TStreamByte = class(TGStream<Byte>)<N>    function ReadBuffer(var Buffer; Count: Integer): Integer; virtual; abstract;<N>    function WriteBuffer(var Buffer; Count: Integer): Integer; virtual; abstract;<N>  end;<N><N>
unit UParser;<N><N>{$mode delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, DateUtils;<N><N>type<N>  { TParser }<N>  TParser = class<N>    WhiteSpaces: string;<N>    Text: string;<N>    Index: Integer;<N>    function CheckNext(Text: string; Shift: Boolean = False): Boolean;<N>    constructor Create;<N>  end;<N><N>implementation<N><N>{ TParser }<N><N>function TParser.CheckNext(Text: string; Shift: Boolean): Boolean;<N>begin<N><N>end;<N><N>constructor TParser.Create;<N>begin<N>  WhiteSpaces := ' '#9#10#13;<N>end;<N><N>end.<N>
// Date: 2011-02-01<N><N>unit UThreadEx;<N><N>interface<N><N>uses<N>  Classes, SysUtils, SyncObjs, Contnrs;<N>  <N>const<N>  Quantum = 10; // ms<N><N>type<N><N>  { TThreadEx }<N><N>  TThreadEx = class(TThread)<N>  private<N>  public<N>    constructor Create(CreateSuspended: Boolean;<N>      const StackSize: SizeUInt = DefaultStackSize);<N>    destructor Destroy; override;<N>    procedure Sleep(Delay: Cardinal);<N>    class function CurrentThread: TThread;<N>  end;<N><N>
unit UPlatform;<N><N>{$mode Delphi}{$H+}<N><N>interface<N><N>uses<N>  {$IFDEF Windows}Windows,{$ENDIF}<N>  {$IFDEF Linux}BaseUnix, UnixUtil, Unix,{$ENDIF}<N>  Classes, SysUtils, DateUtils, SyncObjs;<N><N>function NowPrecise: TDateTime;<N>function GetLogicalProcessorCount: Integer;<N><N>
// Date: 2010-02-07<N><N>(*<N>Not implemented yet<N>- Stack limit checking<N>- measurement of cpu usage by micro threads<N>- wait for multiple objects<N>- micro thread priority<N>*)<N><N>unit UMicroThreading;<N><N>{$mode Delphi}{$H+}<N>{$asmmode intel}<N><N>
interface<N><N>uses<N>  {$IFDEF UNIX}{$IFDEF UseCThreads}<N>  cthreads,<N>  {$ENDIF}{$ENDIF}<N>  Classes, ExtCtrls, SysUtils, Contnrs, SyncObjs, DateUtils, Dialogs, Forms,<N>  UPlatform, UMicroThreadList, UThreadEx;<N><N>const<N>  DefaultStackSize = $8000;<N><N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit MicroThreading; <N><N>interface<N><N>uses<N>  UMicroThreading, UPlatform, UMicroThreadList, UThreadEx, <N>  UMicroThreadCallStack, LazarusPackageIntf;<N><N>implementation<N><N>procedure Register; <N>begin<N>  RegisterUnit('UMicroThreading', @UMicroThreading.Register); <N>end; <N><N>initialization<N>  RegisterPackage('MicroThreading', @Register); <N>end.<N>
unit UMainForm;<N><N>{$mode Delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ComCtrls, ExtCtrls, Spin, Menus, UMicroThreading, DateUtils, UPlatform,<N>  UMicroThreadList, UThreadEx;<N><N>
type<N>  TMainForm = class;<N><N>  { TWorker }<N><N>  TWorker = class(TMicroThread)<N>    procedure Execute; override;<N>  private<N>    MainForm: TMainForm;<N>    procedure DoWriteToMemo;<N>    constructor Create(CreateSuspended: Boolean;<N>      const StackSize: SizeUInt = DefaultStackSize);<N>    destructor Destroy; override;<N>  end;<N><N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit PrintPreview;<N><N>interface<N><N>uses<N>  UPrintPreview, UVectorCanvas, LazarusPackageIntf;<N><N>implementation<N><N>procedure Register;<N>begin<N>  RegisterUnit('UPrintPreview', @UPrintPreview.Register);<N>end;<N><N>initialization<N>  RegisterPackage('PrintPreview', @Register);<N>end.<N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit CoolWeb;<N><N>interface<N><N>uses<N>  UHTTPServer, UHTTPServerCGI, UHTTPServerTCP, UHTTPServerTurboPower, <N>  UTurboPowerForm, UHTTPSessionFile, UHTTPSessionMySQL, USqlDatabase, <N>  UTCPServer, UPageList, UUser, UHtmlClasses, UMemoryStreamEx, UMIMEType, <N>  UXmlClasses, UWebPage, UWebApp, LazIDEReg, LazarusPackageIntf;<N><N>
unit LazIDEReg;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, LazIDEIntf, ProjectIntf, FormEditingIntf, UWebPage, Forms, Controls;<N><N>type<N>   { TFileDescWebPage }<N><N>  TFileDescWebPage = class(TFileDescPascalUnitWithResource)<N>  public<N>    constructor Create; override;<N>    function GetInterfaceUsesSection: string; override;<N>    function GetLocalizedName: string; override;<N>    function GetLocalizedDescription: string; override;<N>  end;<N><N>
  TCGIApplicationDescriptor = class(TProjectDescriptor)<N>  public<N>    constructor Create; override;<N>    function GetLocalizedName: string; override;<N>    function GetLocalizedDescription: string; override;<N>    function InitProject(AProject: TLazProject): TModalResult; override;<N>    function CreateStartFiles(AProject: TLazProject): TModalResult; override;<N>  end;<N><N>
<N>resourcestring<N>  SWebPageTitle = 'CoolWeb page';<N>  SWebPageDescription = '';<N>  SCGIAppTitle = 'CoolWeb application';<N>  SCGIAppDescription = '';<N><N>var<N>  FileDescriptorWebPage: TFileDescWebPage;<N>  CGIAppDescriptor: TCGIApplicationDescriptor;<N><N>
<N>procedure Register;<N><N>implementation<N><N>procedure Register;<N>begin<N>  FileDescriptorWebPage := TFileDescWebPage.Create;<N>  RegisterProjectFileDescriptor(FileDescriptorWebPage);<N>  CGIAppDescriptor := TCGIApplicationDescriptor.Create;<N>  RegisterProjectDescriptor(CGIAppDescriptor);<N>  FormEditingHook.RegisterDesignerBaseClass(TWebPage);<N>end;<N><N>
{ TFileDescWebPage }<N><N>constructor TFileDescWebPage.Create;<N>begin<N>  inherited Create;<N>  Name := 'CoolWeb page';<N>  ResourceClass := TWebPage;<N>  UseCreateFormStatements := False;<N>end;<N><N>function TFileDescWebPage.GetInterfaceUsesSection: string;<N>begin<N>  Result := inherited GetInterfaceUsesSection;<N>  Result := Result + ', UWebPage, UHTTPServer';<N>end;<N><N>
function TFileDescWebPage.GetLocalizedName: string;<N>begin<N>  Result := SWebPageTitle;<N>end;<N><N>function TFileDescWebPage.GetLocalizedDescription: string;<N>begin<N>  Result := SWebPageDescription;<N>end;<N><N><N>{ TCGIApplicationDescriptor }<N><N>constructor TCGIApplicationDescriptor.Create;<N>begin<N>  inherited Create;<N>  Name := 'CoolWeb CGI Application';<N>end;<N><N>
function TCGIApplicationDescriptor.GetLocalizedName: string;<N>begin<N>  Result := SCGIAppTitle;<N>end;<N><N>function TCGIApplicationDescriptor.GetLocalizedDescription: string;<N>begin<N>  Result := SCGIAppDescription;<N>end;<N><N>function TCGIApplicationDescriptor.InitProject(AProject: TLazProject): TModalResult;<N>var<N>  le: string;<N>  NewSource: TStringList;<N>  MainFile: TLazProjectFile;<N>begin<N>  inherited InitProject(AProject);<N><N>
unit UUser;<N><N>{$mode Delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, synacode, USqlDatabase, UCommon, UHTTPServer;<N><N>const<N>  AnonymousUserId = 1;<N><N>type<N>  EDuplicateItem = class(Exception);<N>  ENotFound = class(Exception);<N><N>  { TWebUser }<N><N>
  TWebUser = class<N>    Id: Integer;<N>    Name: string;<N>    FullName: string;<N>    Email: string;<N>    Database: TSqlDatabase;<N>    HandlerData: THTTPHandlerData;<N>    procedure Delete(Id: Integer);<N>    procedure Add(Name, Password, Email: string);<N>    function GetIdByName(Name: string): Integer;<N>    function GetIdByNamePassword(Name: string; PassWord: string): Integer;<N>    procedure Load;<N>  end;<N><N>
  { TWebOnlineUser }<N><N>  TWebOnlineUser = class<N>    Database: TSqlDatabase;<N>    HandlerData: THTTPHandlerData;<N>    Id: Integer;<N>    User: Integer;<N>    procedure Update;<N>    procedure Login(User: Integer);<N>    procedure Logout;<N>  end;<N><N>
unit UPageList;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, UHtmlClasses;<N><N>type<N>  TPageList = class<N>    TotalCount: Integer;<N>    Page: Integer;<N>    PageCount: Integer;<N>    Output: string;<N>    SQLLimit: string;<N>    ItemPerPage: Integer;<N>    VisiblePageItems: Integer;<N>    HTMLId: string;<N>    QueryItems: TQueryString;<N>    Around: Integer;<N>    constructor Create;<N>    function Hyperlink: string;<N>    function Process: string;<N>  end;<N><N>
unit UWebApp;<N><N>{$mode Delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, CustApp, SpecializedList, UWebPage, UHTTPSessionFile,<N>  UHTTPServer, Forms, FileUtil;<N><N>type<N>  THTTPServerType = (stCGI, stTCP, stTurboPower);<N><N>  TRegistredPage = class<N>    Name: string;<N>    Page: TWebPage;<N>  end;<N><N>
  { TPageList }<N><N>  TPageList = class(TListObject)<N>    RootDir: string;<N>    function FindByName(Name: string): TRegistredPage;<N>    procedure RegisterPage(PageClass: TWebPageClass; out Reference; Path: string);<N>    function ProducePage(HandlerData: THTTPHandlerData): Boolean;<N>  end;<N><N>
unit UHTTPServerTurboPower;<N><N>{$mode delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Forms, UHTTPServer, IpHtml;<N><N>type<N><N>  { THTTPServerTurboPower }<N><N>  THTTPServerTurboPower = class(THTTPServer)<N>  public<N>    procedure Run; override;<N>    constructor Create(AOwner: TComponent); override;<N>    destructor Destroy; override;<N>  end;<N><N>
unit UHTTPServer;<N><N>{$mode Delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, UTCPServer, UCommon, UMemoryStreamEx, UMIMEType,<N>  Synautil, SpecializedList, SpecializedDictionary;<N><N>type<N>  THTTPServer = class;<N>  EEmptyHTTPHandler = class(Exception);<N><N>
  TQueryParameterList = class(TStringList)<N>    procedure Parse(Text: string);<N>    function Syntetize: string;<N>  end;<N><N>  { TCookieList }<N><N>  TCookieList = class(TStringList)<N>    procedure Parse(Text: string);<N>    function Syntetize: string;<N>  end;<N><N>
  { THTTPRequest }<N><N>  THTTPRequest = class<N>    ContentType: string;<N>    Content: TMemoryStreamEx;<N>    Query: TQueryParameterList;<N>    Path: TListString;<N>    Method: string;<N>    Headers: TDictionaryStringString;<N>    Cookies: TCookieList;<N>    Post: TQueryParameterList;<N>    procedure Assign(Source: THTTPRequest);<N>    procedure Clear;<N>    constructor Create;<N>    destructor Destroy; override;<N>  end;<N><N>
  { THTTPResponse }<N><N>  THTTPResponse = class<N>    ContentType: string;<N>    Content: TMemoryStreamEx;<N>    Headers: TDictionaryStringString;<N>    Cookies: TCookieList;<N>    procedure Assign(Source: THTTPResponse);<N>    procedure Clear;<N>    constructor Create;<N>    destructor Destroy; override;<N>  end;<N><N>
  { THTTPHandlerData }<N><N>  THTTPHandlerData = class<N>    Server: THTTPServer;<N>    Request: THTTPRequest;<N>    Response: THTTPResponse;<N>    SessionId: string;<N>    Session: TStringList;<N>    procedure Assign(Source: THTTPHandlerData);<N>    constructor Create; virtual;<N>    destructor Destroy; override;<N>  end;<N><N>
  TRequestEvent = procedure(HandlerData: THTTPHandlerData) of object;<N><N>  TRequestHandler = class<N>    Name: string;<N>    Handler: TRequestEvent;<N>  end;<N><N>  { TRequestHandlerList }<N><N>  TRequestHandlerList = class(TListObject)<N>    procedure Add(AName: string; AHandler: TRequestEvent);<N>    function IndexOfName(AName: string): TRequestHandler;<N>  end;<N><N>
  { THTTPSessionStorage }<N><N>  THTTPSessionStorage = class(TComponent)<N>  public<N>    procedure Load(HandlerData: THTTPHandlerData); virtual;<N>    procedure Save(HandlerData: THTTPHandlerData); virtual;<N>    constructor Create(AOwner: TComponent); override;<N>    destructor Destroy; override;<N>  end;<N><N>
unit UWebPage;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, UHTTPServer, Controls;<N><N>type<N>  TOnProduceEvent = procedure(HandlerData: THTTPHandlerData) of object;<N><N><N>  { TWebPage }<N><N>  TWebPage = class(TDataModule)<N>  private<N>    FCaption: string;<N>    FOnProduce: TOnProduceEvent;<N>  published<N>    property Caption: string read FCaption write FCaption;<N>    property OnProduce: TOnProduceEvent read FOnProduce write FOnProduce;<N>  end;<N><N>
unit UHTTPServerCGI;<N><N>{$mode delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, UHTTPServer, SpecializedList, IOStream;<N><N>type<N><N>  { THTTPServerCGI }<N><N>  THTTPServerCGI = class(THTTPServer)<N>  public<N>    EnvVars: TStringList;<N>    procedure Run; override;<N>    constructor Create(AOwner: TComponent); override;<N>    destructor Destroy; override;<N>    procedure ServerInfo(HandlerData: THTTPHandlerData); override;<N>  end;<N><N>
<N>procedure Register;<N><N>implementation<N><N>resourcestring<N>  SEnvironmentVariables = 'Environment variables:';<N><N>procedure Register;<N>begin<N>  RegisterComponents('CoolWeb', [THTTPServerCGI]);<N>end;<N><N><N>{ THTTPServerCGI }<N><N>constructor THTTPServerCGI.Create(AOwner: TComponent);<N>begin<N>  inherited;<N>  EnvVars := TStringList.Create;<N>end;<N><N>
unit UTCPServer;<N><N>{$mode Delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils,<N>  {$IFDEF WINDOWS}<N>  WinSock,<N>  {$ELSE}<N>  baseunix, sockets,<N>  //LibC,<N>  {$ENDIF}<N>  BlckSock, UPool, UResetableThread;<N><N>type<N>  TTCPServer = class;<N><N>
  { TTCPClientThread }<N><N>  TTCPClientThread = class(TResetableThread)<N>    Parent: TTCPServer;<N>    Socket: TTCPBlockSocket;<N>    procedure Execute;<N>    constructor Create;<N>    destructor Destroy; override;<N>  end;<N><N>  { TClientThreadedPool }<N><N>
  TClientThreadedPool = class(TThreadPool)<N>  protected<N>    function NewItemObject: TObject; override;<N>  private<N>    FActive: Boolean;<N>    procedure SetActive(const AValue: Boolean);<N>  public<N>    property Active: Boolean read FActive write SetActive;<N>  end;<N><N>
unit UHtmlClasses;<N><N>{$mode delphi}{$H+}<N><N>interface<N><N>uses<N>  UXmlClasses, Classes, SysUtils, SpecializedList;<N><N>type<N><N>  { TDomainAddress }<N><N>  TDomainAddress = class(TPersistent)<N>  private<N>    function GetAsString: string;<N>    procedure SetAsString(const Value: string);<N>  public<N>    Levels: TListString;<N>    constructor Create;<N>    destructor Destroy; override;<N>    property AsString: string read GetAsString write SetAsString;<N>  end;<N><N>
unit UMIMEType;<N><N>{$mode Delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>function GetMIMEType(FileExtension: string): string;<N><N>var<N>  MIMETypeList: TStringList;<N><N>implementation<N><N>function GetMIMEType(FileExtension: string): string;<N>begin<N>  Result := MIMETypeList.Values[FileExtension];<N>  if Result = '' then Result := 'application/octet-stream';<N>end;<N><N>
initialization<N><N>MIMETypeList := TStringList.Create;<N>with MIMETypeList do begin<N>  Values['html'] := 'text/html';<N>  Values['png'] := 'image/png';<N>  Values['htm'] := 'text/html';<N>  Values['txt'] := 'text/text';<N>  Values['xml'] := 'text/xml';<N>  Values['jpeg'] := 'image/jpeg';<N>  Values['jpg'] := 'image/jpeg';<N>  Values['bmp'] := 'image/bmp';<N>  Values['css'] := 'text/css';<N>end;<N><N>
unit UPDServer;<N><N>interface<N><N>uses<N>  Classes, SysUtils, UPDClient;<N><N>type<N>  TPDServer = class<N>  end;<N><N><N>implementation<N><N>end.<N><N>
unit UPersistentData;<N><N>interface<N><N>uses<N>  Classes, SysUtils, UPDClient, Generics.Collections;<N><N>type<N>  TPDManagerItem = class<N>    Name: string;<N>    ClientClass: TPDClientClass;<N>  end;<N><N>  TPDManagerItems = class(TObjectList<TPDManagerItem>)<N>  end;<N><N>
  { TPDManager }<N><N>  TPDManager = class(TComponent)<N>  public<N>    Items: TPDManagerItems;<N>    procedure Register(ClientClass: TPDClientClass);<N>    procedure LoadToStrings(Strings: TStrings);<N>    constructor Create(AOwner: TComponent); override;<N>    destructor Destroy; override;<N>  end;<N><N>
var<N>  DefaultManager: TPDManager;<N><N>procedure Register;<N><N><N>implementation<N><N>uses<N>  UPDClientXMLRPC, UPDClientMemory, UPDClientMySQL, UPDClientRegistry,<N>  UPDClientINI;<N><N>procedure Register;<N>begin<N>  RegisterComponents('PersistentData', [TPDManager, TPDClientXMLRPC, TPDClientMemory,<N>    TPDClientMySQL, TPDClientRegistry, TPDClientINI]);<N>end;<N><N>
{ TPDManager }<N><N>procedure TPDManager.Register(ClientClass: TPDClientClass);<N>var<N>  NewItem : TPDManagerItem;<N>  TempClass: TPDClient;<N>begin<N>  try<N>    TempClass := ClientClass.Create(nil);<N>    NewItem := TPDManagerItem.Create;<N>    NewItem.Name := TempClass.BackendName;<N>    NewItem.ClientClass := ClientClass;<N>    Items.Add(NewItem);<N>  finally<N>    TempClass.Free;<N>  end;<N>end;<N><N>
procedure TPDManager.LoadToStrings(Strings: TStrings);<N>var<N>  I: Integer;<N>begin<N>  try<N>    Strings.BeginUpdate;<N>    Strings.Clear;<N>    for I := 0 to Items.Count - 1 do<N>      Strings.AddObject(TPDManagerItem(Items[I]).Name, TObject(TPDManagerItem(Items[I]).ClientClass));<N>  finally<N>    Strings.EndUpdate;<N>  end;<N>end;<N><N>
constructor TPDManager.Create(AOwner: TComponent);<N>begin<N>  inherited;<N>  Items := TPDManagerItems.Create;<N>end;<N><N>destructor TPDManager.Destroy;<N>begin<N>  FreeAndNil(Items);<N>  inherited;<N>end;<N><N><N>initialization<N><N>DefaultManager := TPDManager.Create(nil);<N>DefaultManager.Register(TPDClientINI);<N>DefaultManager.Register(TPDClientRegistry);<N>DefaultManager.Register(TPDClientMemory);<N>DefaultManager.Register(TPDClientXMLRPC);<N>DefaultManager.Register(TPDClientMySQL);<N><N>
unit UPDClientXMLRPC;<N><N>interface<N><N>uses<N>  Classes, SysUtils, UPDClient;<N><N>type<N><N>  { TPDClientXMLRPC }<N><N>  TPDClientXMLRPC = class(TPDClient)<N>    constructor Create(AOwner: TComponent); override;<N>  end;<N><N><N>implementation<N><N>{ TPDClientXMLRPC }<N><N>constructor TPDClientXMLRPC.Create(AOwner: TComponent);<N>begin<N>  inherited Create(AOwner);<N>  BackendName := 'XMLRPC';<N>end;<N><N>end.<N><N>
unit UCDResource;<N><N>{$mode delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Controls;<N><N>type<N><N>  { TDataModule2 }<N><N>  TDataModule2 = class(TDataModule)<N>  published<N>    ImageList1: TImageList;<N>    { private declarations }<N>  public<N>    { public declarations }<N>  end; <N><N>var<N>  DataModule2: TDataModule2; <N><N>implementation<N><N>{$R *.lfm}<N><N>initialization<N><N>DataModule2 := TDataModule2.Create(nil);<N><N>finalization<N><N>DataModule2.Free;<N><N>end.<N><N>
unit UThreadStatusForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, ComCtrls,<N>  UCDClient;<N><N>type<N><N>  { TThreadStatusForm }<N><N>  TThreadStatusForm = class(TForm)<N>  published<N>    CoolDockClient1: TCDClient;<N>    ListView1: TListView;<N>    { private declarations }<N>  public<N>    { public declarations }<N>  end; <N><N>var<N>  ThreadStatusForm: TThreadStatusForm;<N><N>implementation<N><N>{$R *.lfm}<N><N>end.<N><N>
unit UObjectInspectorForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs,<N>  PopupNotifier, Grids, UCDClient;<N><N>type<N><N>  { TObjectInspectorForm }<N><N>  TObjectInspectorForm = class(TForm)<N>  published<N>    CoolDockClient1: TCDClient;<N>    StringGrid1: TStringGrid;<N>    { private declarations }<N>  public<N>    { public declarations }<N>  end; <N><N>var<N>  ObjectInspectorForm: TObjectInspectorForm;<N><N>implementation<N><N>{$R *.lfm}<N><N>end.<N><N>
unit UCallStackForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, ComCtrls,<N>  UCDClient;<N><N>type<N><N>  { TCallStackForm }<N><N>  TCallStackForm = class(TForm)<N>  published<N>    CoolDockClient1: TCDClient;<N>    ListView1: TListView;<N>    { private declarations }<N>  public<N>    { public declarations }<N>  end; <N><N>var<N>  CallStackForm: TCallStackForm;<N><N>implementation<N><N>{$R *.lfm}<N><N>end.<N><N>
unit ULocalVariablesForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  UCDClient;<N><N>type<N><N>  { TLocalVariablesForm }<N><N>  TLocalVariablesForm = class(TForm)<N>  published<N>    Memo1: TMemo;<N>    CoolDockClient1: TCDClient;<N>    { private declarations }<N>  public<N>    { public declarations }<N>  end; <N><N>var<N>  LocalVariablesForm: TLocalVariablesForm;<N><N>implementation<N><N>{$R *.lfm}<N><N>end.<N><N>
unit UToolPaletteForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, ComCtrls,<N>  UCDClient;<N><N>type<N><N>  { TToolPaletteForm }<N><N>  TToolPaletteForm = class(TForm)<N>  published<N>    CoolDockClient1: TCDClient;<N>    TreeView1: TTreeView;<N>    { private declarations }<N>  public<N>    { public declarations }<N>  end; <N><N>var<N>  ToolPaletteForm: TToolPaletteForm;<N><N>implementation<N><N>{$R *.lfm}<N><N>end.<N><N>
unit UMessagesForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs,<N>  StdCtrls, UCDClient;<N><N>type<N><N>  { TMessagesForm }<N><N>  TMessagesForm = class(TForm)<N>  published<N>    CoolDockClient1: TCDClient;<N>    Memo1: TMemo;<N>    { private declarations }<N>  public<N>    { public declarations }<N>  end; <N><N>var<N>  MessagesForm: TMessagesForm;<N><N>implementation<N><N>{$R *.lfm}<N><N>end.<N><N>
unit UWatchListForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs,<N>  StdCtrls, UCDClient;<N><N>type<N><N>  { TWatchListForm }<N><N>  TWatchListForm = class(TForm)<N>  published<N>    Memo1: TMemo;<N>    CoolDockClient1: TCDClient;<N>    { private declarations }<N>  public<N>    { public declarations }<N>  end; <N><N>var<N>  WatchListForm: TWatchListForm;<N><N>implementation<N><N>{$R *.lfm}<N><N>end.<N><N>
unit UStructureForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, ComCtrls,<N>  UCDClient;<N><N>type<N><N>  { TStructureForm }<N><N>  TStructureForm = class(TForm)<N>  published<N>    CoolDockClient1: TCDClient;<N>    TreeView1: TTreeView;<N>    { private declarations }<N>  public<N>    { public declarations }<N>  end; <N><N>var<N>  StructureForm: TStructureForm;<N><N>implementation<N><N>{$R *.lfm}<N><N>end.<N><N>
unit UToDoListForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, ComCtrls,<N>  UCDClient;<N><N>type<N><N>  { TToDoListForm }<N><N>  TToDoListForm = class(TForm)<N>  published<N>    CoolDockClient1: TCDClient;<N>    ListView1: TListView;<N>    { private declarations }<N>  public<N>    { public declarations }<N>  end; <N><N>var<N>  ToDoListForm: TToDoListForm;<N><N>implementation<N><N>{$R *.lfm}<N><N>end.<N><N>
unit UProjectManagerForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs,<N>  ComCtrls, UCDClient;<N><N>type<N><N>  { TProjectManagerForm }<N><N>  TProjectManagerForm = class(TForm)<N>  published<N>    CoolDockClient1: TCDClient;<N>    TreeView1: TTreeView;<N>    { private declarations }<N>  public<N>    { public declarations }<N>  end; <N><N>var<N>  ProjectManagerForm: TProjectManagerForm;<N><N>implementation<N><N>{$R *.lfm}<N><N>end.<N><N>
unit UPlatform;<N><N>{$mode delphi}{$H+}<N><N>interface<N><N>uses<N>  {$IFDEF Windows}Windows,{$ENDIF}<N>  {$IFDEF Linux}BaseUnix, UnixUtil, Unix,{$ENDIF}<N>  Classes, SysUtils, DateUtils, SyncObjs;<N><N>function NowPrecise: TDateTime;<N>function GetLogicalProcessorCount: Integer;<N><N>
unit UMethodCanvasPixels;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, UDrawMethod, UFastBitmap, Graphics;<N><N>type<N>  { TMethodCanvasPixels }<N><N>  TMethodCanvasPixels = class(TDrawMethodCanvas)<N>    constructor Create; override;<N>    procedure DrawFrame(FastBitmap: TFastBitmap); override;<N>  end;<N><N>
<N>implementation<N><N>{ TMethodCanvasPixels }<N><N>constructor TMethodCanvasPixels.Create;<N>begin<N>  inherited;<N>  Caption := 'TBitmap.Canvas.Pixels';<N>  Description.Add('This is simple naive approach to copy image by accessing Pixels property. ' +<N>  'Method is slow because of much of overhead in access methods like multiple nested method calls, ' +<N>  'pixel format conversion, update notification, etc.');<N>end;<N><N>
procedure TMethodCanvasPixels.DrawFrame(FastBitmap: TFastBitmap);<N>var<N>  Y, X: Integer;<N>begin<N>  with FastBitmap do begin<N>    for Y := 0 to Size.Y - 1 do<N>      for X := 0 to Size.X - 1 do<N>        Canvas.Pixels[X, Y] := TColor(SwapBRComponent(Pixels[X, Y]));<N>  end;<N>end;<N><N>
unit UMethodBitmapRawImageDataMove;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, UDrawMethod, UFastBitmap, Graphics, GraphType;<N><N>type<N>  { TMethodBitmapRawImageDataMove }<N><N>  TMethodBitmapRawImageDataMove = class(TDrawMethodImage)<N>    constructor Create; override;<N>    procedure DrawFrame(FastBitmap: TFastBitmap); override;<N>  end;<N><N>
<N>implementation<N><N>{ TMethodBitmapRawImageDataMove }<N><N>constructor TMethodBitmapRawImageDataMove.Create;<N>begin<N>  inherited;<N>  Caption := 'TBitmap.RawImage.Data Move';<N>  Description.Add('This is same as BitmapRawImageData but data is not converted from different format. ' +<N>   'But only moved to TImage raw data. ' +<N>    'Then TImage is responsible for show loaded data.');<N>end;<N><N>
unit BGRAGradientOriginal;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRALayerOriginal, BGRABitmap, BGRABitmapTypes, BGRAGradientScanner;<N><N>type<N>  TBGRAColorInterpolation = BGRAGradientScanner.TBGRAColorInterpolation;<N>  TBGRAGradientRepetition = BGRAGradientScanner.TBGRAGradientRepetition;<N><N>
unit BGRAUnits;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRABitmapTypes;<N><N>type<N>  TCSSUnit = (cuCustom, cuPixel,<N>              cuCentimeter, cuMillimeter,<N>              cuInch, cuPica, cuPoint,<N>              cuFontEmHeight, cuFontXHeight, cuPercent);<N>  TFloatWithCSSUnit = record<N>    value: single;<N>    CSSUnit: TCSSUnit;<N>  end;<N><N>
function FloatWithCSSUnit(AValue: single; AUnit: TCSSUnit): TFloatWithCSSUnit;<N><N>const<N>  CSSUnitShortName: array[TCSSUnit] of string =<N>        ('','px',<N>         'cm','mm',<N>         'in','pc','pt',<N>         'em','ex','%');<N><N>type<N>  { TCSSUnitConverter }<N><N>
{ This unit provides some optimisations of TFPReaderPCX: decompression using a read buffer.<N>  It also fixes the progress message and the InternalCheck. }<N><N>unit BGRAReadPCX;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses FPImage, Classes, SysUtils, FPReadPCX;<N><N>
unit BGRAGradients;<N><N>{$mode objfpc}{$H+}<N>{$i bgrabitmap.inc}<N>{$i bgrasse.inc}<N><N>interface<N><N>{ Here are various functions that draw gradients, shadow and lighting }<N><N>uses<N>  Classes, BGRAGraphics, BGRABitmapTypes, BGRABitmap, BGRABlend, BGRAPhongTypes, BGRASSE;<N><N>
{$IFDEF BGRABITMAP_USE_LCL}{ Creates a bitmap with the specified text horizontally centered and with a shadow }<N>function TextShadow(AWidth,AHeight: Integer; AText: String; AFontHeight: Integer; ATextColor,AShadowColor: TBGRAPixel;<N>  AOffSetX,AOffSetY: Integer; ARadius: Integer = 0; AFontStyle: TFontStyles = []; AFontName: String = 'Default'; AShowText: Boolean = True): TBGRABitmap;<N>{$ENDIF}<N><N>
{----------------------------------------------------------------------}<N>{ Functions to draw multiple gradients.<N>  See : http://wiki.lazarus.freepascal.org/Double_Gradient#nGradient }<N>type<N>  TnGradientInfo = record<N>    StartColor,StopColor: TBGRAPixel;<N>    Direction: TGradientDirection;<N>    EndPercent : single; // Position from 0 to 1<N>  end;<N><N>
unit BGRAGraphics;<N>{=== Types imported from Graphics ===}<N>{$mode objfpc}{$H+}<N><N>interface<N><N>{$I bgrabitmap.inc}<N><N>{$IFDEF BGRABITMAP_USE_LCL}<N>uses Graphics, GraphType, FPImage;<N><N>type<N>  PColor = Graphics.PColor;<N>  TColor = Graphics.TColor;<N>  TAntialiasingMode = Graphics.TAntialiasingMode;<N>  TGradientDirection = Graphics.TGradientDirection;<N>  TPenEndCap = Graphics.TPenEndCap;<N>  TPenJoinStyle = Graphics.TPenJoinStyle;<N>  TPenStyle = Graphics.TPenStyle;<N><N>
const<N>  amDontCare = Graphics.amDontCare;<N>  amOn = Graphics.amOn;<N>  amOff = Graphics.amOff;<N><N>  gdVertical = Graphics.gdVertical;<N>  gdHorizontal = Graphics.gdHorizontal;<N><N>  pecRound = Graphics.pecRound;<N>  pecSquare = Graphics.pecSquare;<N>  pecFlat = Graphics.pecFlat;<N><N>
  pjsRound = Graphics.pjsRound;<N>  pjsBevel = Graphics.pjsBevel;<N>  pjsMiter = Graphics.pjsMiter;<N><N>  psSolid = Graphics.psSolid;<N>  psDash = Graphics.psDash;<N>  psDot = Graphics.psDot;<N>  psDashDot = Graphics.psDashDot;<N>  psDashDotDot = Graphics.psDashDotDot;<N>  psClear = Graphics.psClear;<N>  psInsideframe = Graphics.psInsideframe;<N>  psPattern = Graphics.psPattern;<N><N>
  tmAuto = Graphics.tmAuto;<N>  tmFixed = Graphics.tmFixed;<N><N>type<N>  TPen = Graphics.TPen;<N>  TTextLayout = Graphics.TTextLayout;<N>  TTextStyle = Graphics.TTextStyle;<N><N>  TFillStyle = Graphics.TFillStyle;<N>  TFillMode = Graphics.TFillMode;<N>  TBrushStyle = Graphics.TBrushStyle;<N><N>
const<N>  tlTop = Graphics.tlTop;<N>  tlCenter = Graphics.tlCenter;<N>  tlBottom = Graphics.tlBottom;<N><N>  fsSurface = GraphType.fsSurface;<N>  fsBorder = GraphType.fsBorder;<N><N>  fmAlternate = Graphics.fmAlternate;<N>  fmWinding = Graphics.fmWinding;<N><N>
  bsSolid = Graphics.bsSolid;<N>  bsClear = Graphics.bsClear;<N>  bsHorizontal = Graphics.bsHorizontal;<N>  bsVertical = Graphics.bsVertical;<N>  bsFDiagonal = Graphics.bsFDiagonal;<N>  bsBDiagonal = Graphics.bsBDiagonal;<N>  bsCross = Graphics.bsCross;<N>  bsDiagCross = Graphics.bsDiagCross;<N><N>
type<N>  TBrush = Graphics.TBrush;<N>  TCanvas = Graphics.TCanvas;<N>  TGraphic = Graphics.TGraphic;<N>  TRawImage = GraphType.TRawImage;<N>  TBitmap = Graphics.TBitmap;<N><N>  TRasterImage = Graphics.TRasterImage;<N><N>  TFontStyle = Graphics.TFontStyle;<N>  TFontStyles = Graphics.TFontStyles;<N>  TFontQuality = Graphics.TFontQuality;<N><N>
type<N>  TFont = Graphics.TFont;<N><N>const<N>  fsBold = Graphics.fsBold;<N>  fsItalic = Graphics.fsItalic;<N>  fsStrikeOut = Graphics.fsStrikeOut;<N>  fsUnderline = Graphics.fsUnderline;<N><N>  fqDefault = Graphics.fqDefault;<N>  fqDraft = Graphics.fqDraft;<N>  fqProof = Graphics.fqProof;<N>  fqNonAntialiased = Graphics.fqNonAntialiased;<N>  fqAntialiased = Graphics.fqAntialiased;<N>  fqCleartype = Graphics.fqCleartype;<N>  fqCleartypeNatural = Graphics.fqCleartypeNatural;<N><N>
unit BGRAGradientScanner;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>{ This unit contains scanners that generate gradients }<N><N>uses<N>  Classes, SysUtils, BGRABitmapTypes, BGRATransform;<N><N>type<N>  TBGRAColorInterpolation = (ciStdRGB, ciLinearRGB, ciLinearHSLPositive, ciLinearHSLNegative, ciGSBPositive, ciGSBNegative);<N>  TBGRAGradientRepetition = (grPad, grRepeat, grReflect, grSine);<N><N>
unit BGRAPhongTypes;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRABitmapTypes;<N><N>type TCustomPhongShading = class<N><N>   LightPosition : TPoint;<N><N>   { Render the specified map on the destination bitmap with one solid color. Map altitude<N>     indicate the global height of the map. }<N>   procedure Draw(dest: TBGRACustomBitmap; map: TBGRACustomBitmap; mapAltitude: integer; ofsX,ofsY: integer;<N>                  Color : TBGRAPixel);  overload; virtual; abstract;<N><N>
   { Render with a color map of the same size as the height map. Map altitude<N>     indicate the global height of the map. }<N>   procedure Draw(dest: TBGRACustomBitmap; map: TBGRACustomBitmap; mapAltitude: integer; ofsX,ofsY: integer;<N>                  ColorMap : TBGRACustomBitmap);  overload; virtual; abstract;<N><N>
   { Render with a scanner. Map altitude<N>     indicate the global height of the map. }<N>   procedure DrawScan(dest: TBGRACustomBitmap; map: TBGRACustomBitmap; mapAltitude: integer; ofsX,ofsY: integer;<N>                  ColorScan : IBGRAScanner); virtual; abstract;<N><N>
unit BGRAFilterType;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, BGRABitmapTypes;<N><N>const<N>    FilterScannerChunkSize = 16;<N><N>type<N>  TCheckShouldStopFunc = function(ACurrentY: integer) : boolean of object;<N><N>  { TFilterTask }<N><N>
unit BGRADNetDeserial;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>{ This unit allow to read .Net serialized classes with BinaryFormatter of<N>  namespace System.Runtime.Serialization.Formatters.Binary.<N><N>  Serialization is a process by which objects in memory are saved according<N>  to their structure.<N><N>
  This unit is used by BGRAPaintNet to read Paint.NET images. }<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>  arrayOfLongword = array of longword;<N><N>  TTypeCategory = (ftPrimitiveType = 0, ftString = 1, ftObjectType =<N>    2, ftRuntimeType = 3,<N>    ftGenericType = 4, ftArrayOfObject = 5, ftArrayOfString = 6,<N>    ftArrayOfPrimitiveType = 7);<N><N>
  TPrimitiveType = (ptNone = 0, ptBoolean = 1, ptByte = 2, ptChar = 3, ptDecimal = 5,<N>    ptDouble = 6, ptInt16 = 7, ptInt32 = 8, ptInt64 = 9, ptSByte = 10, ptSingle = 11,<N>    ptDateTime = 13, ptUInt16 = 14, ptUInt32 = 15, ptUInt64 = 16, ptString = 18);<N><N>
  TGenericArrayType = (gatSingleDimension, gatJagged, gatMultidimensional);<N><N>  TDotNetDeserialization = class;<N><N>  ArrayOfNameValue = array of record<N>    Name: string;<N>    Value, valueType: string;<N>  end;<N><N>  TFieldType = record<N>    category: TTypeCategory;<N>    primitiveType: TPrimitiveType;<N>    refAssembly: longword;<N>    Name: string;<N>  end;<N><N>
  TSerializedType = record<N>    ClassName:   string;<N>    nbFields:    integer;<N>    fieldNames:  array of string;<N>    fieldTypes:  array of TFieldType;<N>    refAssembly: longword;<N>  end;<N><N>  TAssemblyReference = record<N>    idAssembly: longword;<N>    Name: string;<N>  end;<N><N>
{<N> /**************************************************************************\<N>                             bgrawinbitmap.pas<N>                             -----------------<N>                 This unit should NOT be added to the 'uses' clause.<N>                 It contains accelerations for Windows. Notably, it<N>                 provides direct access to bitmap data.<N><N>
{<N>    The original file before tweaking is:<N><N>    This file is part of the Free Pascal run time library.<N>    Copyright (c) 2003 by the Free Pascal development team<N><N>    PNG writer class.<N><N>    See the file COPYING.FPC, included in this distribution,<N>    for details about the copyright.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.<N><N> **********************************************************************<N><N>
 Fix for images with grayscale and alpha,<N> and for images with transparent pixels<N> }<N>unit BGRAWritePNG;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N><N>uses sysutils, classes, FPImage, FPImgCmn, PNGcomn, ZStream;<N><N>type<N>  THeaderChunk = packed record<N>    Width, height : longword;<N>    BitDepth, ColorType, Compression, Filter, Interlace : byte;<N>  end;<N><N>
{<N>    This file is part of the Free Pascal run time library.<N>    Copyright (c) 2012-2013 by the Free Pascal development team<N><N>    Tiff reader for fpImage.<N><N>    See the file COPYING.FPC, included in this distribution,<N>    for details about the copyright.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.<N><N> **********************************************************************<N><N>
 Working:<N>   Sample bitdepth: 1, 4, 8, 12, 16<N>   Color format: black and white, grayscale, RGB, colormap<N>   Alpha channel: none, premultiplied, separated<N>   Compression: packbits, LZW, deflate<N>   Endian-ness: little endian and big endian<N>   Orientation: any corner can be (0,0) and x/y can be flipped<N>   Planar configuration: 1 (channels together)<N>   Fill order: any (for 1 bit per sample images)<N>   Skipping thumbnail by reading biggest image<N>   Multiple images<N>   Strips and tiles<N><N>
 ToDo:<N>   Compression: FAX, Jpeg...<N>   Color format: YCbCr, Lab...<N>   PlanarConfiguration: 2 (one chunk for each channel)<N>   bigtiff 64bit offsets<N>   XMP tag 700<N>   ICC profile tag 34675<N><N> Not to do:<N>   Separate mask (deprecated)<N><N>}<N>unit BGRAReadTiff;<N><N>
{$mode objfpc}{$H+}<N><N>{$inline on}<N><N>interface<N><N>uses<N>  Math, Classes, SysUtils, ctypes, zinflate, zbase, FPimage, FPTiffCmn,<N>  BGRABitmapTypes;<N><N>type<N>  TBGRAReaderTiff = class;<N><N>  TTiffCreateCompatibleImgEvent = procedure(Sender: TBGRAReaderTiff;<N>                                            ImgFileDir: TTiffIFD) of object;<N><N>
{<N> /**************************************************************************\<N>                                bgrabitmaptypes.pas<N>                                -------------------<N>                   This unit defines basic types and it must be<N>                   included in the 'uses' clause.<N><N>
unit BGRAFillInfo;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRABitmapTypes;<N><N>const<N>  AntialiasPrecision = 16;<N>  AntialiasPrecisionShift = 4;<N><N>type<N>  TDensity = word;<N>  PDensity = ^TDensity;<N><N>type<N>  { TFillShapeInfo }<N><N>
unit BGRARenderer3D;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses BGRABitmapTypes,<N>  BGRASceneTypes, BGRASSE,<N>  BGRAPolygon, BGRAColorInt,<N>  Classes, BGRAMatrix3D,<N>  BGRAPolygonAliased;<N><N>type<N>  TInt65536ShaderFunction3D = function (Context: PBasicLightingContext; Color: TBGRAPixel): TColorInt65536 of object;<N><N>
  { TBGRAShader3D }<N><N>  TBGRAShader3D = class<N>  protected<N>    FAmbiantLightness: integer;<N>    FAmbiantLightColor: TColorInt65536;<N>    FUseAmbiantColor: boolean;<N>    FLights: TList;<N>    FContextBlock: TMemoryBlockAlign128;<N>    FShaderFunc: TShaderFunction3D;<N>    FInt65536ShaderFunc: TInt65536ShaderFunction3D;<N>    FContext: PBasicLightingContext;<N>    FOnlyDirectionalLights: boolean;<N>    FWhiteMaterial: boolean;<N><N>
unit BGRAMemDirectory;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRAMultiFileType, fgl;<N><N>const<N>  MemDirectoryFileHeader = 'TMemDirectory'#26#0#0;<N>  MemDirectoryEntry_FlagDirectory = 1;   //entry is a directory<N>  MemDirectoryEntry_FlagCompressed = 2;  //the stream is compressed<N>  MemDirectoryEntry_FlagSmallEntryPacked = $8000; //name and size <= 255<N><N>
unit BGRASSE;<N><N>{$mode objfpc}{$H+}<N><N>{$i bgrasse.inc}<N><N>interface<N><N>{begin  //param: eax, edx, ecx  //float: eax ecx edx<N>  //flds $d9<N>  //fadds $d8<N>  //fstps $d9 +$18<N>  //fmuls $d8 +$08<N>  //fsubrs $d8 +$28<N>  //offset +$40 $..}<N>uses<N>  BGRABitmapTypes {$ifdef CPUI386}, cpu, mmx{$endif};<N><N>
const FLAG_ENABLED_SSE = true;<N><N>var UseSSE, UseSSE2, UseSSE3 : boolean;<N><N>{$ifdef CPUI386}<N>  {$asmmode intel}<N>{$ENDIF}<N>{$ifdef cpux86_64}<N>  {$asmmode intel}<N>{$ENDIF}<N><N>{$ifdef BGRASSE_AVAILABLE}<N>  //SSE rotate singles<N>  const Shift231 = 1 + 8;<N>        Shift312 = 2 + 16;<N>{$endif}<N><N>
unit BGRATypewriter;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, AvgLvlTree, BGRABitmapTypes, BGRACanvas2D, BGRATransform;<N><N>type<N>  TGlyphBoxes = array of record<N>    Glyph: string;<N>    Box: TAffineBox;<N>  end;<N><N>  { TBGRAGlyph }<N><N>
unit BGRALazPaint;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRALayers, BGRABitmapTypes, BGRAReadLzp, BGRAWriteLzp,<N>  BGRALzpCommon, FPimage;<N><N>type<N>  TLzpCompression = BGRALzpCommon.TLzpCompression;<N><N>  { TBGRALazPaintImage }<N><N>
unit BGRABlend;<N><N>{ This unit contains pixel blending functions. They take a destination adress as parameter,<N>  and draw pixels at this address with different blending modes. These functions are used<N>  by many functions in BGRABitmap library to do the low level drawing. }<N><N>
unit BGRAColorspace;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRABitmapTypes;<N><N>type<N>  { TCIERGB }<N><N>  TCIERGB = packed record<N>    //components are between 0 and 1<N>    R,G,B,A: single;<N>    function ToBGRA: TBGRAPixel;<N>    procedure FromBGRA(AValue: TBGRAPixel);<N>    function ToExpanded: TExpandedPixel;<N>    procedure FromExpanded(AValue: TExpandedPixel);<N>  end;<N><N>
  { TCIEXYZ }<N><N>  TCIEXYZ = packed record<N>    //components are between 0 and 1<N>    X, Y, Z,<N>    A: single;<N>    function ToRGB: TCIERGB;<N>    procedure FromRGB(AValue: TCIERGB);<N>  end;<N><N>  { TBGRAPixelColorspaceHelper }<N><N>  TBGRAPixelColorspaceHelper = record helper(TBGRAPixelHelper) for TBGRAPixel<N>    function ToXYZ: TCIEXYZ;<N>    procedure FromXYZ(const AValue: TCIEXYZ);<N>  end;<N><N>
  { TExpandedPixelColorspaceHelper }<N><N>  TExpandedPixelColorspaceHelper = record helper(TExpandedPixelHelper) for TExpandedPixel<N>    function ToXYZ: TCIEXYZ;<N>    procedure FromXYZ(const AValue: TCIEXYZ);<N>  end;<N><N>procedure RGBToXYZ(R, G, B: single; out X, Y, Z: single);<N>procedure XYZToRGB(X, Y, Z: single; out R, G, B: single);<N><N>
implementation<N><N>function ClampF(AValue,AMin,AMax: single): single;<N>begin<N>  if AValue <= AMin then result := AMin<N>  else if AValue >= AMax then result := AMax<N>  else result := AValue;<N>end;<N><N>procedure RGBToXYZ(R, G, B: single; out X, Y, Z: single);<N>begin<N>  // Observer= 2°, Illuminant= D65<N>  X := R * 0.4124 + G * 0.3576 + B * 0.1805;<N>  Y := R * 0.2126 + G * 0.7152 + B * 0.0722;<N>  Z := R * 0.0193 + G * 0.1192 + B * 0.9505;<N>end;<N><N>
procedure XYZToRGB(X, Y, Z: single; out R, G, B: single);<N>begin<N>  R := ClampF(X * 3.2406 + Y * (-1.5372) + Z * (-0.49), 0, 1);<N>  G := ClampF(X * (-0.969) + Y * 1.8758 + Z * 0.0415, 0, 1);<N>  B := ClampF(X * 0.0557 + Y * (-0.2040) + Z * 1.0570, 0, 1);<N>end;<N><N>
{ TCIERGB }<N><N>function TCIERGB.ToBGRA: TBGRAPixel;<N>var<N>  redF,greenF,blueF: single;<N>begin<N>  if r > 0.00313 then<N>    redF := 1.055 * Power(r, 1 / 2.4) - 0.055<N>  else<N>    redF := 12.92 * r;<N>  if g > 0.00313 then<N>    greenF := 1.055 * Power(g, 1 / 2.4) - 0.055<N>  else<N>    greenF := 12.92 * g;<N>  if b > 0.00313 then<N>    blueF := 1.055 * Power(b, 1 / 2.4) - 0.055<N>  else<N>    blueF := 12.92 * b;<N><N>
  result.red := round(clampF(redF,0,1)*255);<N>  result.green := round(clampF(greenF,0,1)*255);<N>  result.blue := round(clampF(blueF,0,1)*255);<N>  result.alpha := round(clampF(A,0,1)*255);<N>end;<N><N>procedure TCIERGB.FromBGRA(AValue: TBGRAPixel);<N>begin<N>  R := AValue.red/255;<N>  G := AValue.green/255;<N>  B := AValue.blue/255;<N>  A := AValue.alpha/255;<N><N>
  if R > 0.04045 then<N>    R := Power((R + 0.055) / 1.055, 2.4)<N>  else<N>    R := R / 12.92;<N>  if G > 0.04045 then<N>    G := Power((G + 0.055) / 1.055, 2.4)<N>  else<N>    G := G / 12.92;<N>  if B > 0.04045 then<N>    B := Power((B + 0.055) / 1.055, 2.4)<N>  else<N>    B := B / 12.92;<N>end;<N><N>
function TCIERGB.ToExpanded: TExpandedPixel;<N>begin<N>  result.red := round(ClampF(R,0,1)*65535);<N>  result.green := round(ClampF(G,0,1)*65535);<N>  result.blue := round(ClampF(B,0,1)*65535);<N>  result.alpha := round(ClampF(A,0,1)*65535);<N>end;<N><N>procedure TCIERGB.FromExpanded(AValue: TExpandedPixel);<N>begin<N>  R := AValue.red/65535;<N>  G := AValue.green/65535;<N>  B := AValue.blue/65535;<N>  A := AValue.alpha/65535;<N>end;<N><N>
{ TCIEXYZ }<N><N>function TCIEXYZ.ToBGRA: TBGRAPixel;<N>begin<N>  result.FromXYZ(self);<N>end;<N><N>procedure TCIEXYZ.FromBGRA(AValue: TBGRAPixel);<N>begin<N>  self := AValue.ToXYZ;<N>end;<N><N>function TCIEXYZ.ToExpanded: TExpandedPixel;<N>begin<N>  result.FromXYZ(self);<N>end;<N><N>
procedure TCIEXYZ.FromExpanded(AValue: TExpandedPixel);<N>begin<N>  self := AValue.ToXYZ;<N>end;<N><N>function TCIEXYZ.ToRGB: TCIERGB;<N>begin<N>  XYZToRGB(X,Y,Z, result.R,result.G,result.B);<N>  result.A := A;<N>end;<N><N>procedure TCIEXYZ.FromRGB(AValue: TCIERGB);<N>begin<N>  RGBToXYZ(AValue.R,AValue.G,AValue.B, X,Y,Z);<N>  A := AValue.A;<N>end;<N><N>
{ TExpandedPixelColorspaceHelper }<N><N>function TExpandedPixelColorspaceHelper.ToXYZ: TCIEXYZ;<N>var RGB: TCIERGB;<N>begin<N>  RGB.FromExpanded(Self);<N>  result.FromRGB(RGB);<N>end;<N><N>procedure TExpandedPixelColorspaceHelper.FromXYZ(const AValue: TCIEXYZ);<N>var redF,greenF,blueF: single;<N>begin<N>  self := AValue.ToRGB.ToExpanded;<N>end;<N><N>
{ TBGRAPixelColorspaceHelper }<N><N>function TBGRAPixelColorspaceHelper.ToXYZ: TCIEXYZ;<N>var RGB: TCIERGB;<N>begin<N>  RGB.FromBGRA(Self);<N>  result.FromRGB(RGB);<N>end;<N><N>procedure TBGRAPixelColorspaceHelper.FromXYZ(const AValue: TCIEXYZ);<N>begin<N>  self := AValue.ToRGB.ToBGRA;<N>end;<N><N>
unit BGRACanvasGL;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRAGraphics, BGRABitmapTypes,<N>  BGRAOpenGLType, BGRATransform, BGRAPath,<N>  BGRASSE, BGRAMatrix3D;<N><N>type<N>  TBGLPath = class;<N>  TBGLCustomCanvas = class;<N><N>
{*****************************************************************************}<N>{<N>    This original file was part of the Free Pascal's "Free Components Library".<N>    Copyright (c) 2003 by Mazen NEIFER of the Free Pascal development team<N><N>    BMP reader implementation.<N><N>
unit BGRALayers;<N><N>{$mode objfpc}{$H+}<N>{$MODESWITCH ADVANCEDRECORDS}<N><N>interface<N><N>uses<N>  BGRAGraphics, Classes, SysUtils, Types, BGRABitmapTypes, BGRABitmap,<N>  BGRAMemDirectory, BGRATransform, fgl, BGRALayerOriginal;<N><N>type<N>  TBGRACustomLayeredBitmap = class;<N>  TBGRACustomLayeredBitmapClass = class of TBGRACustomLayeredBitmap;<N><N>
  { TBGRALayerOriginalEntry }<N><N>  TBGRALayerOriginalEntry = record<N>     Guid: TGuid;<N>     Instance: TBGRALayerCustomOriginal;<N>     class operator = (const AEntry1,AEntry2: TBGRALayerOriginalEntry): boolean;<N>  end;<N><N>function BGRALayerOriginalEntry(AGuid: TGuid): TBGRALayerOriginalEntry;<N>function BGRALayerOriginalEntry(AInstance: TBGRALayerCustomOriginal): TBGRALayerOriginalEntry;<N><N>
unit BGRAMacBitmap;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRALCLBitmap, BGRAGraphics, BGRABitmapTypes;<N><N>type<N><N>  { TBGRAMacBitmap }<N><N>  TBGRAMacBitmap = class(TBGRALCLBitmap)<N>     procedure DataDrawOpaque(ACanvas: TCanvas; Rect: TRect; AData: Pointer;<N>       ALineOrder: TRawImageLineOrder; AWidth, AHeight: integer); override;<N>  end;<N><N>
implementation<N><N>uses LCLType, GraphType, LCLIntf, FPimage;<N><N>procedure DataDrawOpaqueImplementation(ACanvas: TCanvas; Rect: TRect;<N>  AData: Pointer; ALineOrder: TRawImageLineOrder; AWidth, AHeight: integer);<N>type<N>  PARGB = ^TARGB;<N>  TARGB = packed record<N>    alpha,red,green,blue: byte;<N>  end;<N><N>
unit BGRAPolygon;<N><N>{$mode objfpc}{$H+}<N><N>{ This unit contains polygon drawing functions and spline functions.<N><N>  Shapes are drawn using a TBGRACustomFillInfo object, which calculates the<N>  intersection of an horizontal line and the polygon.<N><N>
  Various shapes are handled :<N>  - TFillPolyInfo : polygon scanned in any order<N>  - TOnePassFillPolyInfo : polygon scanned from top to bottom<N>  - TFillEllipseInfo : ellipse<N>  - TFillBorderEllipseInfo : ellipse border<N>  - TFillRoundRectangleInfo : round rectangle (or other corners)<N>  - TFillBorderRoundRectInfo : round rectangle border<N><N>
  Various fill modes :<N>  - Alternate : each time there is an intersection, it enters or go out of the polygon<N>  - Winding : filled when the sum of ascending and descending intersection is non zero<N>  - Color : fill with a color defined as a TBGRAPixel argument<N>  - Erase : erase with an alpha in the TBGRAPixel argument<N>  - Texture : draws a texture with the IBGRAScanner argument<N><N>
  Various border handling :<N>  - aliased : one horizontal line intersection is calculated per pixel in the vertical loop<N>  - antialiased : more lines are calculated and a density is computed by adding them together<N>  - multi-polygon antialiasing and superposition (TBGRAMultiShapeFiller) : same as above but<N>    by combining multiple polygons at the same time, and optionally subtracting top polygons<N>  }<N><N>
unit BGRAPen;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>{ This unit handles pen style and width, as well as line caps and join styles.<N><N>  A line consists in two points.<N>  A polyline consists in one or more lines, defined by two points or more than two points<N>  A poly-polyline consists in a series of polylines, defined by polyline points separated by empty points (see EmptyPointF) }<N><N>
uses<N>  SysUtils, BGRAGraphics, BGRABitmapTypes, BGRATransform;<N><N>var   //predefined pen styles<N>  SolidPenStyle, DashPenStyle, DotPenStyle, DashDotPenStyle, DashDotDotPenStyle, ClearPenStyle: TBGRAPenStyle;<N><N>type<N>  TPenJoinStyle = BGRAGraphics.TPenJoinStyle;<N>  TPenEndCap = BGRAGraphics.TPenEndCap;<N><N>
unit BGRACanvas2D;<N><N>{ To do :<N><N>  draw text with a different precision if the matrix is scaled<N>  drawImage(in image, in double sx, in double sy, in double sw, in double sh, in double dx, in double dy, in double dw, in double dh)<N>  -> using FillPoly with texture coordinates<N>  linear gradient any transformation<N>  clearPath clipping<N>  createRadialGradient<N>  globalCompositeOperation<N>  image data functions<N>}<N><N>
{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRAGraphics, BGRABitmapTypes, BGRATransform,<N>  BGRAGradientScanner, BGRAPath, BGRAPen;<N><N>type<N>  IBGRACanvasTextureProvider2D = interface<N>    function getTexture: IBGRAScanner;<N>    property texture: IBGRAScanner read GetTexture;<N>  end;<N><N>
unit BGRAReadBmpMioMap;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FPimage, BGRABitmapTypes;<N><N>const<N>  MioMapMagicValue = 'RL';<N>  MioMapTransparentColor = $F81F;<N><N>type<N>  TMioHeader = packed record<N>    magic: packed array[1..2] of char;<N>    format: word;<N>    width,height,nbColors,nbChunks: word;<N>  end;<N><N>
{<N> /**************************************************************************\<N>                             bgradefaultbitmap.pas<N>                             ---------------------<N>                 This unit defines basic operations on bitmaps.<N>                 It should NOT be added to the 'uses' clause.<N>                 Some operations may be slow, so there are<N>                 accelerated versions for some routines.<N><N>
unit BGRAColorQuantization;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRAPalette, BGRABitmapTypes;<N><N>type<N>  TBGRAColorBox = class;<N>  TBGRAColorTree = class;<N>  TBGRAApproxPalette = class;<N>  TBiggestLeafMethod = (blMix, blApparentInterval, blWeight);<N><N>
  { TDimensionMinMax }<N><N>  TDimensionMinMax = object<N>    Minimum: UInt32;<N>    Maximum: UInt32;<N>    function Size: UInt32;<N>    function Contains(AValue: UInt32): boolean;<N>    function PointLike: boolean;<N>    procedure SetAsPoint(AValue: UInt32);<N>    function GetCenter: UInt32;<N>    procedure GrowToInclude(AValue: UInt32);<N>  end;<N><N>
{<N> /**************************************************************************\<N>                             bgragtkbitmap.pas<N>                             -----------------<N>                 This unit should NOT be added to the 'uses' clause.<N>                 It contains patches for Gtk.<N><N>
unit BGRAOpenGL;<N><N>{$mode objfpc}{$H+}<N>{$I bgrabitmap.inc}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FPimage, BGRAGraphics,<N>  BGRAOpenGLType, BGRASpriteGL, BGRACanvasGL, GL, GLext, GLU, BGRABitmapTypes,<N>  BGRAFontGL, BGRASSE, BGRAMatrix3D;<N><N>
unit BGRASceneTypes;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses BGRABitmapTypes, BGRASSE, BGRAMatrix3D, BGRAColorInt;<N><N>type<N>  TLightingNormal3D = (lnNone, lnFace, lnVertex, lnFaceVertexMix);<N>  TLightingInterpolation3D = (liLowQuality, liSpecularHighQuality, liAlwaysHighQuality);<N>  TAntialiasingMode3D = (am3dNone, am3dMultishape, am3dResample);<N>  TPerspectiveMode3D = (pmLinearMapping, pmPerspectiveMapping, pmZBuffer);<N><N>
  TRenderingOptions = record<N>    LightingInterpolation: TLightingInterpolation3D;<N>    AntialiasingMode: TAntialiasingMode3D;<N>    AntialiasingResampleLevel: integer;<N>    PerspectiveMode: TPerspectiveMode3D;<N>    TextureInterpolation: boolean;<N>    MinZ: single;<N>  end;<N><N>
{<N> /**************************************************************************\<N>                             bgraqtbitmap.pas<N>                             -----------------<N>                 This unit should NOT be added to the 'uses' clause.<N>                 It contains patches for Qt.<N><N>
unit BGRAGifFormat;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRAGraphics, BGRABitmap, BGRABitmapTypes,<N>  BGRAPalette;<N><N>type<N>  //what to do when finishing a frame and starting the next one<N>  TDisposeMode = (dmNone,        //undefined value<N>                  dmKeep,        //keep the changes done by the frame<N>                  dmErase,       //clear everything after the frame<N>                  dmRestore);    //restore to how it was before the frame<N><N>
  //one image in the array<N>  TGifSubImage = record<N>    Image:    TBGRABitmap;       //image to draw at the beggining of the frame<N>    Position: TPoint;            //relative position of the image in the frame<N>    DelayMs:    integer;         //time in milliseconds to wait before going to next frame<N>    DisposeMode: TDisposeMode;   //what do do when going to next frame<N>    HasLocalPalette: boolean;    //the image has its own palette<N>  end;<N>  TGifSubImageArray = array of TGifSubImage;<N><N>
  TGIFSignature = packed array[1..6] of char; //'GIF87a' or 'GIF89a'<N><N>  TGIFScreenDescriptor = packed record<N>    Width, Height: word;<N>    flags,                    //screen bit depth  = ((flags shr 4) and 7) + 1<N>                              //palette bit depth = (flags and 7) + 1<N>    BackgroundColorIndex,     //index of background color in global palette<N>    AspectRatio64 : byte;     //0 if not specified, otherwise aspect ratio is (AspectRatio64 + 15) / 64<N>  end;<N><N>
  TGIFImageDescriptor = packed record<N>    x, y, Width, Height: word;<N>    flags: byte;<N>  end;<N><N>  TGIFImageDescriptorWithHeader = packed record<N>    ImageIntroducer: byte;<N>    Image: TGIFImageDescriptor;<N>  end;<N><N>  TGIFExtensionBlock = packed record<N>    FunctionCode: byte;<N>  end;<N><N>
  TGIFGraphicControlExtension = packed record<N>    flags: byte;<N>    DelayHundredthSec: word;<N>    TransparentColorIndex: byte;<N>  end;<N><N>  TGIFGraphicControlExtensionWithHeader = packed record<N>    ExtensionIntroducer: byte;<N>    FunctionCode: byte;<N>    BlockSize: byte;<N>    GraphicControl: TGIFGraphicControlExtension;<N>    BlockTerminator: byte;<N>  end;<N><N>
  TPackedRGBTriple = packed record<N>    r, g, b: byte;<N>  end;<N><N>  TGIFData = record<N>    Width, Height: integer;<N>    AspectRatio: single;<N>    BackgroundColor: TColor;<N>    LoopCount: Word;<N>    Images: array of TGifSubImage;<N>  end;<N><N>  { EColorQuantizerMissing }<N><N>
  EColorQuantizerMissing = class(Exception)<N>    constructor Create;<N>    constructor Create(AMessage: string);<N>  end;<N><N>const<N>  GIFScreenDescriptor_GlobalColorTableFlag = $80;    //global palette is present<N>  GIFScreenDescriptor_GlobalColorSortFlag  = $08;    //global palette colors are sorted by importance<N><N>
  GIFImageIntroducer     = $2c;<N>  GIFExtensionIntroducer = $21;<N>  GIFBlockTerminator     = $00;<N>  GIFFileTerminator      = $3B;<N><N>  GIFGraphicControlExtension_TransparentFlag = $01;  //transparent color index is provided<N>  GIFGraphicControlExtension_UserInputFlag = $02;    //wait for user input at this frame (ignored)<N>  GIFGraphicControlExtension_FunctionCode = $f9;<N>  GIFGraphicControlExtension_DisposeModeShift = 2;<N><N>
  GIFImageDescriptor_LocalColorTableFlag = $80;      //local palette is present<N>  GIFImageDescriptor_InterlacedFlag = $40;           //image data is interlaced<N>  GIFImageDescriptor_LocalColorSortFlag = $20;       //local palette colors are sorted by importance<N><N>
  GIFInterlacedStart: array[1..4] of longint = (0, 4, 2, 1);<N>  GIFInterlacedStep: array[1..4] of longint = (8, 8, 4, 2);<N><N>  GIFCodeTableSize = 4096;<N><N>  NetscapeApplicationIdentifier = 'NETSCAPE2.0';<N>  NetscapeSubBlockIdLoopCount = 1;<N>  NetscapeSubBlockIdBuffering = 2;<N><N>
unit BGRACompressableBitmap;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>{ This unit contains the TBGRACompressableBitmap class, which<N>  can be used to temporarily compress bitmaps in memory.<N>  To use it, create an instance with the bitmap you want<N>  to compress. You can then free the original bitmap because<N>  TBGRACompressableBitmap contains all information necessary<N>  to build it again. To construct again your bitmap, call<N>  the GetBitmap function.<N><N>
  When you have your bitmap in TBGRACompressableBitmap,<N>  you can call Compress function as many times as necessary<N>  until all data is compressed. It does only a part of the<N>  work at each call, so you can put it in a loop or in<N>  a timer. When it's done, Compress returns false to<N>  notify that it did nothing, which means you can<N>  stop calling Compress.<N><N>
  In this implementation, the memory usage grows during<N>  the compression process and is lower only after it is<N>  finished. So it is recommended to compress one bitmap<N>  at a time. }<N><N>uses<N>  Classes, SysUtils, BGRABitmapTypes, BGRABitmap, zstream;<N><N>
unit BGRAPath;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>//todo: tangent interpolation<N><N>{ There are different conventions for angles.<N><N>  First is about the unit. It can be one of the following:<N>  - degrees (0..360)<N>  - radian (0..2*Pi)<N>  - tenth of degrees (0..3600)<N>  - from 0 to 65536<N><N>
  Second is about the origin. It can be one of the following:<N>  - right-most position (this is the default origin for radian and 65536)<N>  - top-most position (this is the default origin for degrees)<N><N>  Third is about the sign. It can be one of the following:<N>  - positive is clockwise (this is the default for degrees)<N>  - positive is counterclockwise (this is the default for radian and 65536)<N><N>
  TBGRAPath and TBGRACanvas2D follow HTML5 convention which is:<N>    (radian, right-most, clockwise) that can be shortened to (radian, clockwise)<N>    because right-most is the default for radian. This is abbreviated as "radCW".<N><N>  When radian are CCW, it is also specified in order to make it clear, even<N>  if it is the default convention in mathematics.<N><N>
  In order to make things easier, there are some functions that accept angles<N>  in degrees. The convention used here is the usual degree convention:<N>    (degrees, top-most, clockwise) that can be shortened to (degree)<N>    because top-most and clockwise is the default for degrees.<N><N>
  }<N><N>uses<N>  Classes, BGRABitmapTypes, BGRATransform;<N><N>type<N>  TBGRAPathElementType = (peNone, peMoveTo, peLineTo, peCloseSubPath,<N>    peQuadraticBezierTo, peCubicBezierTo, peArc, peOpenedSpline,<N>    peClosedSpline);<N><N>  TBGRAPathDrawProc = procedure(const APoints: array of TPointF; AClosed: boolean; AData: Pointer) of object;<N>  TBGRAPathFillProc = procedure(const APoints: array of TPointF; AData: pointer) of object;<N><N>
  TBGRAPath = class;<N><N>  { TBGRAPathCursor }<N><N>  TBGRAPathCursor = class(TBGRACustomPathCursor)<N>  protected<N>    FPath: TBGRAPath;<N>    FDataPos: IntPtr;<N>    FAcceptedDeviation: single;<N>    FPathLength: single;<N>    FPathLengthComputed: boolean;<N>    FBounds: TRectF;<N>    FBoundsComputed: boolean;<N>    FArcPos: Single;<N><N>
unit BGRALzpCommon;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>const<N>  LAZPAINT_COMPRESSION_MODE_ZSTREAM = 1;<N>  LAZPAINT_COMPRESSION_MODE_RLE = 2;<N>  LAZPAINT_COMPRESSION_MASK = 255;<N>  LAZPAINT_THUMBNAIL_PNG = 256;<N>  LAZPAINT_MAGIC_HEADER : array[0..7] of char = 'LazPaint';<N><N>
  LazpaintChannelGreenFromRed  = 1;<N>  LazpaintChannelBlueFromRed   = 2;<N>  LazpaintChannelBlueFromGreen = 4;<N>  LazpaintChannelNoAlpha       = 8;<N>  LazpaintPalettedRGB          = 16;<N><N>  LazPaintThumbMaxWidth = 128;<N>  LazPaintThumbMaxHeight = 128;<N><N>
type<N>  TLzpCompression = (lzpZStream, //slower and not necessarily better<N>                     lzpRLE);    //custom RLE for lzp files<N><N>  { TLazPaintImageHeader }<N><N>  TLazPaintImageHeader = packed record<N>    magic: packed array[0..7] of char;<N>    zero1, headerSize: DWord;<N>    width, height, nbLayers, previewOffset: DWord;<N>    zero2, compressionMode, reserved1, layersOffset: DWord;<N>  end;<N><N>
procedure LazPaintImageHeader_SwapEndianIfNeeded(AHeader: TLazPaintImageHeader);<N><N>//routines to compress and uncompress byte-sized values (you need to<N>//separate the channels to obtain any compression)<N><N>procedure EncodeLazRLE(var sourceBuffer; size:PtrInt; ADest: TStream);<N>function DecodeLazRLE(ASource: TStream; var destBuffer; availableOutputSize: PtrInt; availableInputSize: int64 = -1): PtrInt;<N><N>
unit BGRACoordPool3D;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRABitmapTypes, BGRASSE, BGRAMatrix3D;<N><N>type<N>  PBGRACoordData3D = ^TBGRACoordData3D;<N>  TBGRACoordData3D = packed record<N>    {0} sceneCoord: TPoint3D_128;<N>    {16} viewCoord: TPoint3D_128;<N>    {32} projectedCoord: TPointF;<N>    {40} InvZ: single;<N>    {44} used: wordbool; customNormalUsed: wordbool;<N>    {48} viewNormal: TPoint3D_128;<N>    {64} customNormal: TPoint3D_128;<N>  end; {80}<N><N>
  PBGRANormalData3D = ^TBGRANormalData3D;<N>  TBGRANormalData3D = packed record<N>    {0} customNormal: TPoint3D_128;<N>    {16} viewNormal: TPoint3D_128;<N>    {32} used: longbool;<N>    {36} filler1,filler2,filler3: longword;<N>  end; {48}<N><N>  { TBGRAGenericPool }<N><N>
unit BGRAFilterScanner;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, BGRABitmapTypes, BGRAFilterType;<N><N>type<N>  { TBGRAFilterScannerGrayscale }<N>  { Grayscale converts colored pixel into grayscale with same luminosity }<N>  TBGRAFilterScannerGrayscale = class(TBGRAFilterScannerPixelwise)<N>    class procedure ComputeFilterAt(ASource: PBGRAPixel; ADest: PBGRAPixel;<N>      ACount: integer; AGammaCorrection: boolean); override;<N>  end;<N><N>
  { TBGRAFilterScannerNegative }<N><N>  TBGRAFilterScannerNegative = class(TBGRAFilterScannerPixelwise)<N>    class procedure ComputeFilterAt(ASource: PBGRAPixel; ADest: PBGRAPixel;<N>      ACount: integer; AGammaCorrection: boolean); override;<N>  end;<N><N>
  { TBGRAFilterScannerSwapRedBlue }<N><N>  TBGRAFilterScannerSwapRedBlue = class(TBGRAFilterScannerPixelwise)<N>    class procedure ComputeFilterAt(ASource: PBGRAPixel; ADest: PBGRAPixel;<N>      ACount: integer; {%H-}AGammaCorrection: boolean); override;<N>  end;<N><N>
unit BGRAWinResource;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRAMultiFileType, BGRABitmapTypes, BGRAReadBMP;<N><N>const<N>  RT_CURSOR = 1;<N>  RT_BITMAP = 2;<N>  RT_ICON = 3;<N><N>  RT_MENU = 4;<N>  RT_DIALOG = 5;<N>  RT_STRING = 6;<N>  RT_FONTDIR = 7;<N>  RT_FONT = 8;<N>  RT_ACCELERATOR = 9;<N>  RT_RCDATA = 10;<N>  RT_MESSAGETABLE = 11;<N><N>
  RT_GROUP = 11;<N>  RT_GROUP_CURSOR = RT_GROUP + RT_CURSOR;<N>  RT_GROUP_ICON = RT_GROUP + RT_ICON;<N><N>  RT_VERSION = 16;<N>  RT_ANICURSOR = 21;<N>  RT_ANIICON = 22;<N>  RT_HTML = 23;<N>  RT_MANIFEST = 24;<N><N>  ICON_OR_CURSOR_FILE_ICON_TYPE = 1;<N>  ICON_OR_CURSOR_FILE_CURSOR_TYPE = 2;<N><N>
type<N>  TNameOrId = record<N>    Id: integer;<N>    Name: utf8string;<N>  end;<N><N>  { TResourceInfo }<N><N>  TResourceInfo = object<N>    DataVersion: DWord;<N>    MemoryFlags: Word;<N>    LanguageId: Word;<N>    Version: DWord;<N>    Characteristics: DWord;<N>    procedure SwapIfNecessary;<N>  end;<N><N>
unit BGRADithering;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRAFilterType, BGRAPalette, BGRABitmapTypes;<N><N>type<N>  TOutputPixelProc = procedure(X,Y: NativeInt; AColorIndex: NativeInt; AColor: TBGRAPixel) of object;<N><N>
unit BGRAOpenGL3D;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses BGRABitmapTypes,<N>  BGRASceneTypes, BGRASSE,<N>  Classes, BGRAMatrix3D,<N>  BGRACanvasGL,<N>  BGRAScene3D,<N>  BGRAOpenGLType,<N>  BGRATransform,<N>  BGRARenderer3D;<N><N>type<N>  TAttributeVariable = BGRACanvasGL.TAttributeVariable;<N><N>
unit UUnitTest;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRABitmapTypes;<N><N>implementation<N><N>procedure Test(AExpression: boolean; ADescription: string);<N>begin<N>  if not AExpression then<N>    raise EAssertionFailed.Create('Assertion failed: '+ADescription);<N>end;<N><N>
{<N>    This original file was part of the Free Pascal run time library.<N>    Copyright (c) 2008 by the Free Pascal development team<N><N>    Psd reader for fpImage.<N><N>    See the file COPYING.FPC, included in this distribution,<N>    for details about the copyright.<N><N>
    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.<N><N> **********************************************************************<N><N>
    03/2014 changes by circular :<N>    - added MinifyHeight,WantedHeight and OutputHeight (useful for thumbnails)<N>}<N>unit BGRAReadPSD;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FPimage, FPReadPSD;<N><N>type<N>  { TBGRAReaderPSD }<N><N>
{ This unit provides some optimisations of TFPReaderGif: decompression algorithm and direct pixel access of TBGRABitmap.<N>  Note: to read an animation use TBGRAAnimatedGif instead. }<N><N>unit BGRAReadGif;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FPimage, FPReadGif;<N><N>
type<N>  PGifRGB = ^TGifRGB;<N><N>  { TBGRAReaderGif }<N><N>  TBGRAReaderGif = class(TFPReaderGif)<N>  protected<N>    procedure ReadPaletteAtOnce(Stream: TStream; Size: integer);<N>    procedure InternalRead(Stream: TStream; Img: TFPCustomImage); override;<N>    function ReadScanLine(Stream: TStream): boolean; override;<N>    function WriteScanLineBGRA(Img: TFPCustomImage): Boolean; virtual;<N>  end;<N><N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit BGLControls;<N><N>interface<N><N>uses<N>  BGLVirtualScreen, LazarusPackageIntf;<N><N>implementation<N><N>procedure Register;<N>begin<N>  RegisterUnit('BGLVirtualScreen', @BGLVirtualScreen.Register);<N>end;<N><N>initialization<N>  RegisterPackage('BGLControls', @Register);<N>end.<N>
{<N> /**************************************************************************\<N>                                bgrabitmap.pas<N>                                --------------<N>                 Free easy-to-use memory bitmap 32-bit,<N>                 8-bit for each channel, transparency.<N>                 Channels can be in the following orders:<N>                 - B G R A (recommended for Windows, required for fpGUI)<N>                 - R G B A (recommended for Gtk and MacOS)<N><N>
                 - Drawing primitives<N>                 - Resample<N>                 - Reference counter<N>                 - Drawing on LCL canvas<N>                 - Loading and saving images<N><N>                 Note : line order can change, so if you access<N>                 directly to bitmap data, check LineOrder value<N>                 or use Scanline to compute position.<N><N>
unit BGRAColorInt;<N><N>{$mode objfpc}{$H+}<N>{$ifdef CPUI386}<N>  {$define BGRACOLORINT_USEASM}<N>{$endif}<N>{$ifdef DARWIN}<N>  {$undef BGRACOLORINT_USEASM}<N>{$endif}<N><N>interface<N><N>uses<N>  BGRABitmapTypes;<N><N>type<N>  TColorInt65536 = packed record<N>    r,g,b,a: integer;<N>  end;<N><N>
unit BGRAReadXPM;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FPReadXPM, FPimage;<N><N>type<N><N>  { TBGRAReaderXPM }<N><N>  TBGRAReaderXPM = class(TFPReaderXPM)<N>    protected<N>      procedure InternalRead(Str: TStream; Img: TFPCustomImage); override;<N>      function InternalCheck(Str: TStream): boolean; override;<N>    public<N>      class procedure ConvertToXPM3(ASource: TStream; ADestination: TStream);<N>  end;<N><N>
implementation<N><N>uses BGRABitmapTypes;<N><N>{ TBGRAReaderXPM }<N><N>procedure TBGRAReaderXPM.InternalRead(Str: TStream; Img: TFPCustomImage);<N>var tempStream: TMemoryStream;<N>begin<N>  tempStream := TMemoryStream.Create;<N>  try<N>    ConvertToXPM3(Str, tempStream);<N>    tempStream.Position:= 0;<N>    try<N>      img.UsePalette := true;<N>      inherited InternalRead(tempStream, Img);<N>    finally<N>    end;<N>  finally<N>    tempStream.free;<N>  end;<N>end;<N><N>
function TBGRAReaderXPM.InternalCheck(Str: TStream): boolean;<N>var {%H-}magic : array[0..5] of char;<N>    l : integer;<N>    prevPos: int64;<N>begin<N>  try<N>    prevPos := str.Position;<N>    l := str.Read ({%H-}magic[0],sizeof(magic));<N>    str.Position:= prevPos;<N>    result := (l = sizeof(magic)) and (magic = '! XPM2');<N>    if not result then result := inherited InternalCheck(Str)<N>  except<N>    result := false;<N>  end;<N>end;<N><N>
unit BGRAFilters;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>{ Here are some filters that can be applied to a bitmap. The filters<N>  take a source image as a parameter and gives a filtered image as<N>  a result. }<N><N>uses<N>  Classes, BGRABitmapTypes, BGRAFilterType, BGRAFilterBlur;<N><N>
type<N>  TFilterTask = BGRAFilterType.TFilterTask;<N><N>/////////////////////// PIXELWISE FILTERS ////////////////////////////////<N>type<N>  { TGrayscaleTask }<N>  { Grayscale converts colored pixel into grayscale with same luminosity }<N>  TGrayscaleTask = class(TFilterTask)<N>  private<N>    FBounds: TRect;<N>  public<N>    constructor Create(bmp: TBGRACustomBitmap; ABounds: TRect);<N>  protected<N>    procedure DoExecute; override;<N>  end;<N><N>
{ Grayscale converts colored pixel into grayscale with same luminosity }<N>function FilterGrayscale(bmp: TBGRACustomBitmap): TBGRACustomBitmap; overload;<N>function FilterGrayscale(bmp: TBGRACustomBitmap; ABounds: TRect): TBGRACustomBitmap; overload;<N>function CreateGrayscaleTask(bmp: TBGRACustomBitmap; ABounds: TRect): TFilterTask;<N><N>
{ Normalize use the whole available range of values, making dark colors darkest possible<N>  and light colors lightest possible }<N>function FilterNormalize(bmp: TBGRACustomBitmap;<N>  eachChannel: boolean = True): TBGRACustomBitmap; overload;<N>function FilterNormalize(bmp: TBGRACustomBitmap; ABounds: TRect;<N>  eachChannel: boolean = True): TBGRACustomBitmap; overload;<N><N>
////////////////////// 3X3 FILTERS ////////////////////////////////////////////<N><N>{ Sharpen filter add more contrast between pixels }<N>function FilterSharpen(bmp: TBGRACustomBitmap; AAmount: integer = 256): TBGRACustomBitmap; overload;<N>function FilterSharpen(bmp: TBGRACustomBitmap; ABounds: TRect; AAmount: integer = 256): TBGRACustomBitmap; overload;<N><N>
unit BGRAVectorize;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>{<N>  Font rendering units : BGRAText, BGRATextFX, BGRAVectorize, BGRAFreeType<N><N>  This unit provides vectorizers :<N>  - VectorizeMonochrome function vectorizes a back'n'white image<N>  - TBGRAVectorizedFont allows to vectorize and to load vectorized font and draw them<N><N>
  TBGRAVectorizedFontRenderer class works like other font renderers, i.e., it can<N>  be assigned to the FontRenderer property. You can use it in two different modes :<N>  - if you supply a directory, it will look for *.glyphs files in it to load fonts<N>  - if you don't supply a directory, fonts will be vectorized from LCL<N><N>
  Note that unless you want to supply your own glyphs files, you don't need<N>  to use explicitely this renderer, because TBGRATextEffectFontRenderer will<N>  make use of it if necessary, according to effects parameters used.<N>}<N><N>uses<N>  Types, Classes, SysUtils, Graphics, BGRABitmapTypes, BGRATypewriter, BGRATransform, BGRACanvas2D, BGRAText;<N><N>
//vectorize a monochrome bitmap<N>function VectorizeMonochrome(ASource: TBGRACustomBitmap; zoom: single; PixelCenteredCoordinates: boolean): ArrayOfTPointF;<N><N>type<N>  TBGRAVectorizedFont = class;<N><N>  //this is the class to assign to FontRenderer property of TBGRABitmap<N>  { TBGRAVectorizedFontRenderer }<N><N>
unit BGRAPaintNet;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>{ This unit reads Paint.NET files. It needs BGRADNetDeserial to deserialize binary .Net objects.<N><N>  A Paint.NET image consists in three parts :<N>  - Xml header<N>  - Binary serialized information (contains layer information)<N>  - Compressed data (pixel data)<N><N>
  The class TPaintDotNetFile do not read the Xml header. ComputeFlatImage builds the resulting image<N>  by using blending operations to merge layers.<N><N>  The unit registers a TFPCustomImageReader so that it can be read by any image reading function of FreePascal,<N>  and also registers a reader for BGRALayers }<N><N>
unit BGRAReadJpeg;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FPReadJPEG;<N><N>type<N>  TJPEGScale = FPReadJPEG.TJPEGScale;<N>  TJPEGReadPerformance = FPReadJPEG.TJPEGReadPerformance;<N><N>const<N>  jsFullSize = FPReadJPEG.jsFullSize;<N>  jsHalf = FPReadJPEG.jsHalf;<N>  jsQuarter = FPReadJPEG.jsQuarter;<N>  jsEighth = FPReadJPEG.jsEighth;<N><N>
  jpBestQuality = FPReadJPEG.jpBestQuality;<N>  jpBestSpeed = FPReadJPEG.jpBestSpeed;<N><N>type<N>  { TBGRAReaderJpeg }<N><N>  TBGRAReaderJpeg = class(TFPReaderJPEG)<N>    constructor Create; override;<N>  protected<N>    function InternalCheck(Str: TStream): boolean; override;<N>  end;<N><N>
unit BGRAOpenRaster;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRALayers, zipper, DOM, BGRABitmap, FPImage;<N><N>const<N>  OpenRasterMimeType = 'image/openraster'; //do not change, it's part of the file format<N><N>type<N><N>
unit BGRATextBidi;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRABitmapTypes, BGRAUTF8, BGRAUnicode, BGRATransform;<N><N>type<N>  TBidiCaretPos = record<N>    PartIndex: integer;<N><N>    Top, Bottom: TPointF;<N>    RightToLeft: boolean;<N><N>
unit BGRATransform;<N><N>{$mode objfpc}<N><N>interface<N><N>{ This unit contains bitmap transformations as classes and the TAffineMatrix record and functions. }<N><N>uses<N>  Classes, SysUtils, BGRABitmapTypes;<N><N>type<N>  { Contains an affine matrix, i.e. a matrix to transform linearly and translate TPointF coordinates }<N>  TAffineMatrix = BGRABitmapTypes.TAffineMatrix;<N>  { Contains an affine base and information on the resulting box }<N>  TAffineBox = BGRABitmapTypes.TAffineBox;<N><N>
  { TBGRAAffineScannerTransform allow to transform any scanner. To use it,<N>    create this object with a scanner as parameter, call transformation<N>    procedures, and finally, use the newly created object as a scanner.<N><N>    You can transform a gradient or a bitmap. See TBGRAAffineBitmapTransform<N>    for bitmap specific transformation. }<N><N>
unit BGRANoGUIBitmap;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  SysUtils, Classes, BGRAGraphics, BGRABitmapTypes, BGRADefaultBitmap,<N>  BGRAFreeType, EasyLazFreeType, LazFreeTypeFontCollection,<N>  BGRACanvas;<N><N>type<N><N>  { TBGRANoGUIBitmap }<N><N>
unit BGRAPolygonAliased;<N><N>{$mode objfpc}{$H+}<N><N>{$i bgrasse.inc}<N><N>interface<N><N>{ This unit provides fast aliased polygon routines.<N><N>  To do aliased drawing, only one line is intersected with polygons for each output scanline.<N>  Along with intersection coordinates, color and texture coordinates are computed using<N>  linear interpolation. Inverse values are used for projective transform. }<N><N>
uses<N>  Classes, SysUtils, BGRABitmapTypes, BGRAFillInfo, BGRASSE;<N><N>type<N>  //segment information for linear color<N>  TLinearColorInfo = record<N>    Color, ColorSlopes: TColorF;<N>  end;<N>  PLinearColorInfo = ^TLinearColorInfo;<N>  ArrayOfTColorF = array of TColorF;<N><N>
unit BGRAfpGUIBitmap;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  SysUtils, Classes, BGRAGraphics, BGRABitmapTypes, BGRADefaultBitmap,<N>  BGRAFreeType, EasyLazFreeType, LazFreeTypeFontCollection,<N>  BGRACanvas;<N><N>type<N><N>  { TBGRAfpGUIBitmap }<N><N>
unit BGRAPhoxo;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  BGRABitmapTypes, FPImage, BGRALayers, BGRABitmap, Classes, SysUtils, BMPcomn;<N><N>const<N>  PhoxoHeaderMagic : packed array[1..4] of char = 'oXo ';<N>  PhoxoBlock_CanvasSize = 1;<N>  PhoxoBlock_Layer = 2;<N>  PhoxoBlock_TextLayer = 3;<N>  PhoxoBlock_DPI = 4;<N>  PhoxoBlock_LayerCaption = 5;<N>  PhoxoBlock_LazPaintBlendMode = 128;<N>  PhoxoBlock_EndOfFile = 255;<N><N>
type<N>  TPhoxoHeader = packed record<N>    magic: packed array[1..4] of char;<N>    version: longword;<N>  end;<N><N>  TPhoxoBlockHeader = packed record<N>    blockType : longword;<N>    blockSize : longword;<N>  end;<N><N>  TPhoxoLayerHeader = packed record<N>    layerVisible: longword;<N>    layerLimited: longword;<N>    opacityPercent: longword;<N>    bmpHeader: TBitMapInfoHeader;<N>    redMask,greenMask,blueMask: longword;<N>  end;<N><N>
{<N>    The original file before tweaking is:<N><N>    $Id: fpreadpng.pp,v 1.10 2003/10/19 21:09:51 luk Exp $<N>    This file is part of the Free Pascal run time library.<N>    Copyright (c) 2003 by the Free Pascal development team<N><N>    PNG reader implementation<N><N>
    See the file COPYING.FPC, included in this distribution,<N>    for details about the copyright.<N><N>    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.<N><N>
 **********************************************************************<N><N>  Optimisations applied:<N>  - using "const" parameter for TColorData<N>  - direct pixel access with TBGRABitmap when possible<N>  - some fixes of hints and of initializations<N>  - vertical shrink option with MinifyHeight, OriginalHeight and VerticalShrinkFactor (useful for thumbnails)<N> }<N>{$mode objfpc}{$h+}<N>unit BGRAReadPng;<N><N>
interface<N><N>uses<N>  SysUtils,Classes, FPImage, FPImgCmn, PNGComn, ZStream, BGRABitmapTypes;<N><N>Type<N><N>  TSetPixelProc = procedure (x,y:integer; const CD : TColordata) of object;<N>  TConvertColorProc = function (const CD:TColorData) : TFPColor of object;<N>  TBGRAConvertColorProc = function (const CD:TColorData) : TBGRAPixel of object;<N>  THandleScanLineProc = procedure (const y : integer; const ScanLine : PByteArray) of object;<N><N>
{*****************************************************************************}<N>{<N>    This file is part of the Free Pascal's "Free Components Library".<N>    Copyright (c) 2003 by Mazen NEIFER of the Free Pascal development team<N><N>    Targa reader implementation.<N><N>
    See the file COPYING.FPC, included in this distribution,<N>    for details about the copyright.<N><N>    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.<N>}<N>{*****************************************************************************}<N><N>
unit BGRAReadIco;<N><N>{$mode objfpc}{$H+}<N>{$i bgrabitmap.inc}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FPimage{$IFDEF BGRABITMAP_USE_LCL}, Graphics{$ENDIF};<N><N>type<N>  {$IFDEF BGRABITMAP_USE_LCL}TCustomIconClass = class of TCustomIcon;{$ENDIF}<N>  TByteSet = set of byte;<N><N>
  { TBGRAReaderIcoOrCur }<N><N>  TBGRAReaderIcoOrCur = class(TFPCustomImageReader)<N>  protected<N>    procedure InternalRead({%H-}Str: TStream; {%H-}Img: TFPCustomImage); override;<N>    function InternalCheck(Str: TStream): boolean; override;<N>    function ExpectedMagic: TByteSet; virtual; abstract;<N>    {$IFDEF BGRABITMAP_USE_LCL}function LazClass: TCustomIconClass; virtual; abstract;{$ENDIF}<N>  public<N>    WantedWidth, WantedHeight : integer;<N>  end;<N><N>
  TBGRAReaderIco = class(TBGRAReaderIcoOrCur)<N>  protected<N>    function ExpectedMagic: TByteSet; override;<N>    {$IFDEF BGRABITMAP_USE_LCL}function LazClass: TCustomIconClass; override;{$ENDIF}<N>  end;<N><N>  { TBGRAReaderCur }<N><N>  TBGRAReaderCur = class(TBGRAReaderIcoOrCur)<N>  protected<N>    function ExpectedMagic: TByteSet; override;<N>    {$IFDEF BGRABITMAP_USE_LCL}function LazClass: TCustomIconClass; override;{$ENDIF}<N>  end;<N><N>
implementation<N><N>uses BGRABitmapTypes{$IFNDEF BGRABITMAP_USE_LCL}, BGRAIconCursor{$ENDIF};<N><N>{ TBGRAReaderCur }<N><N>function TBGRAReaderCur.ExpectedMagic: TByteSet;<N>begin<N>  result := [2];<N>end;<N><N>{$IFDEF BGRABITMAP_USE_LCL}function TBGRAReaderCur.LazClass: TCustomIconClass;<N>begin<N>  result := TCursorImage;<N>end;{$ENDIF}<N><N>
{ TBGRAReaderIco }<N><N>function TBGRAReaderIco.ExpectedMagic: TByteSet;<N>begin<N>  result := [1,2];<N>end;<N><N>{$IFDEF BGRABITMAP_USE_LCL}function TBGRAReaderIco.LazClass: TCustomIconClass;<N>begin<N>  result := TIcon;<N>end;{$ENDIF}<N><N>{ TBGRAReaderIcoOrCur }<N><N>
unit BGRAAnimatedGif;<N><N>{$mode objfpc}{$H+}<N>{$i bgrabitmap.inc}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRAGraphics, FPImage, BGRABitmap, BGRABitmapTypes,<N>  BGRAPalette, BGRAGifFormat;<N><N>type<N>  TDisposeMode = BGRAGifFormat.TDisposeMode;<N>  TGifSubImage = BGRAGifFormat.TGifSubImage;<N>  TGifSubImageArray = BGRAGifFormat.TGifSubImageArray;<N><N>
  //how to deal with the background under the GIF animation<N>  TGifBackgroundMode = (gbmSimplePaint, gbmEraseBackground,<N>    gbmSaveBackgroundOnce, gbmUpdateBackgroundContinuously);<N><N>  { TBGRAAnimatedGif }<N><N>  TBGRAAnimatedGif = class(TGraphic)<N>  private<N>    FAspectRatio: single;<N>    FWidth, FHeight:  integer;<N>    FBackgroundColor: TColor;<N><N>
    FPrevDate: TDateTime;<N>    FPaused:   boolean;<N>    FTimeAccumulator: double;<N>    FCurrentImage, FWantedImage: integer;<N>    FTotalAnimationTime: int64;<N>    FPreviousDisposeMode: TDisposeMode;<N><N>    FBackgroundImage, FPreviousVirtualScreen, FStretchedVirtualScreen,<N>    FInternalVirtualScreen, FRestoreImage: TBGRABitmap;<N>    FImageChanged: boolean;<N><N>
unit BGRAImageManipulation;<N><N>{ ============================================================================<N>  BGRAImageManipulation Unit<N><N>  Copyright (C) 2011 - Emerson Cavalcanti <emersoncavalcanti at googlesites><N><N>  This library is free software; you can redistribute it and/or modify it<N>  under the terms of the GNU Library General Public License as published by<N>  the Free Software Foundation; either version 2 of the License, or (at your<N>  option) any later version.<N><N>
  This program is distributed in the hope that it will be useful, but WITHOUT<N>  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or<N>  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Library General Public License<N>  for more details.<N><N>
  You should have received a copy of the GNU Library General Public License<N>  along with this library; if not, write to the Free Software Foundation,<N>  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.<N><N>  ============================================================================<N>  Description:<N><N>
  TBGRAImageManipulation is a component designed to make simple changes in an<N>  image while maintaining the aspect ratio of the final image and allow it to<N>  cut to reduce the unnecessary edges. The selected area is painted with a<N>  different transparency level for easy viewing of what will be cut.<N><N>
{ This component partialy solve problem with no alpha in lazarus GTK.<N>  It is using BGRABitmap library for drawing icons.<N><N>  Copyright (C) 2011 Krzysztof Dibowski dibowski at interia.pl<N><N>  This library is free software; you can redistribute it and/or modify it<N>  under the terms of the GNU Library General Public License as published by<N>  the Free Software Foundation; either version 2 of the License, or (at your<N>  option) any later version with the following modification:<N><N>
{<N>This unit is deprecated use BGRASliceScaling in the BGRABitmap package instead.<N>}<N><N>unit bgrabitmapthemeutils;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, Graphics,<N>  bgrabitmap, bgrabitmaptypes;<N><N>type<N>  TBGRABitmapArray = array of TBGRABitmap;<N>  TBGRABitmapArrays = array of TBGRABitmapArray;<N><N>
{ TBGRABitmap functions }<N><N>function GetBGRABitmap(ABitmap: TBGRABitmap; Number: integer): TBGRABitmapArray;<N>function GetBGRABitmap(AFilename: string; Number: integer): TBGRABitmapArray;<N>function GetBGRABitmap(AStream: TStream; Number: integer): TBGRABitmapArray;<N><N>
function GetBGRABitmapPart(Source: TBGRABitmap;<N>  BorderWidth, BorderHeight: integer): TBGRABitmapArray;<N><N>function GetBGRABitmapElements(ABitmap: TBGRABitmap;<N>  Number, BorderWidth, BorderHeight: integer): TBGRABitmapArrays;<N>function GetBGRABitmapElements(AFilename: string;<N>  Number, BorderWidth, BorderHeight: integer): TBGRABitmapArrays;<N>function GetBGRABitmapElements(AStream: TStream;<N>  Number, BorderWidth, BorderHeight: integer): TBGRABitmapArrays;<N><N>
function DrawBGRABitmap(Source: TBGRABitmapArray;<N>  DestWidth, DestHeight, BorderWidth, BorderHeight: integer;<N>  FillLeft: boolean = False; FillTop: boolean = False; FillRight: boolean = False;<N>  FillBottom: boolean = False; FillCenter: boolean = False;<N>  DrawMode: TDrawMode = dmDrawWithTransparency;<N>  ResampleMode: TResampleMode = rmSimpleStretch;<N>  ResampleFilter: TResampleFilter = rfBestQuality): TBGRABitmap;<N><N>
unit BGRAWin7ToolBar;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, BGRABitmap, BGRABitmapTypes, Controls, Graphics,<N>  BGRAVirtualScreen, BGRASamples, LResources, Dialogs, Forms;<N><N>type<N><N>  { TCustomBGRAWin7ToolBar }<N><N>
  TCustomBGRAWin7ToolBar = class(TCustomBGRAVirtualScreen)<N>  private<N>    procedure SetFStyle(AValue: TBGRASampleStyle);<N>  protected<N>    FSmooth: boolean;<N>    FStyle: TBGRASampleStyle;<N>    procedure RedrawBitmapContent; override;<N>  public<N>    procedure StyleButtons;<N>    procedure SwitchAlign;<N>    constructor Create(TheOwner: TComponent); override;<N>  public<N>    property Style: TBGRASampleStyle Read FStyle Write SetFStyle;<N>  end;<N><N>
{ !! THIS CONTROL IS DEPRECATED! USE BCLABEL INSTEAD !!<N>  TBGRALabel 1.01v<N>  Description: Component TBGRALabel simulate TLabel<N>  This component is based on TBGRAButton of Dibo<N>  Create by Lucas Martín in 2011. codedeep at hotmail.com<N><N>  Functionality:<N>  - Caption with shadow or not<N>  - Full alpha and antialias support or not<N>  - WordWarp or not<N>  - Caption with Property Editor Multiline<N><N>
  Copyright (C) 2011 Krzysztof Dibowski dibowski at interia.pl<N><N>  This library is free software; you can redistribute it and/or modify it<N>  under the terms of the GNU Library General Public License as published by<N>  the Free Software Foundation; either version 2 of the License, or (at your<N>  option) any later version with the following modification:<N><N>
{ Styles form manager<N><N>  ------------------------------------------------------------------------------<N>  Copyright (C) 2012 Krzysztof Dibowski dibowski at interia.pl<N><N>  This library is free software; you can redistribute it and/or modify it<N>  under the terms of the GNU Library General Public License as published by<N>  the Free Software Foundation; either version 2 of the License, or (at your<N>  option) any later version with the following modification:<N><N>
{ Base framework classes<N><N>  Copyright (C) 2012 Krzysztof Dibowski dibowski at interia.pl<N><N>  This library is free software; you can redistribute it and/or modify it<N>  under the terms of the GNU Library General Public License as published by<N>  the Free Software Foundation; either version 2 of the License, or (at your<N>  option) any later version with the following modification:<N><N>
unit BGRASpriteAnimation;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, Controls, Dialogs, ExtCtrls, Forms, Graphics, LCLIntF, LResources,<N>  BGRABitmap, BGRABitmapTypes, BCTypes, BGRAAnimatedGif;<N><N>type<N><N>  TFlipMode     = (flNone, flHorizontal, flVertical, flBoth);<N>  TRotationMode = (rtNone, rtClockWise, rtCounterClockWise);<N><N>
{ Equivalent of standard lazarus TPanel but using BGRA Controls framework for render<N><N>  Functionality:<N>  - Customizable background (gradient etc.)<N>  - Customizable border (frame 3D or normal border, rounding etc)<N>  - FontEx (shadow etc.)<N><N>  Copyright (C) 2011 Krzysztof Dibowski dibowski at interia.pl<N><N>
  This library is free software; you can redistribute it and/or modify it<N>  under the terms of the GNU Library General Public License as published by<N>  the Free Software Foundation; either version 2 of the License, or (at your<N>  option) any later version with the following modification:<N><N>
{ !! THIS CONTROL IS DEPRECATED! USE BCBUTTON INSTEAD !!<N>  Customizable component which using BGRABitmap for drawing. Functionality:<N>  - Gradients<N>  - Double gradients<N>  - Rounding<N>  - Drop down list<N>  - Glyph<N>  - States (normal, hover, clicked)<N>  - Caption with shadow<N>  - Full alpha and antialias support<N><N>
  Copyright (C) 2011 Krzysztof Dibowski dibowski at interia.pl<N><N>  This library is free software; you can redistribute it and/or modify it<N>  under the terms of the GNU Library General Public License as published by<N>  the Free Software Foundation; either version 2 of the License, or (at your<N>  option) any later version with the following modification:<N><N>
{ General framework methods for rendering background, borders, text, etc.<N><N>  Copyright (C) 2012 Krzysztof Dibowski dibowski at interia.pl<N><N>  This library is free software; you can redistribute it and/or modify it<N>  under the terms of the GNU Library General Public License as published by<N>  the Free Software Foundation; either version 2 of the License, or (at your<N>  option) any later version with the following modification:<N><N>
unit BGRAShape;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, LResources, Forms, Controls, Graphics, Dialogs,<N>  BGRABitmap, BGRABitmapTypes, BCTypes;<N><N>type<N>  TBGRAShapeType = (stRegularPolygon, stEllipse);<N><N>  { TBGRAShape }<N><N>
{<N>BGRANeoButton 2011 - 2012 by Lainz<N><N>This is a control that can be modified to create your own graphic button.<N>By default it has very limited functionality, but you can extend the code to<N>get the result you want.<N><N>* TGraphicButton *<N>TGraphicControl descendant. It handles mouse events and<N>ModalResult. It uses TGraphicButtonState to indicate the current button stage.<N><N>
* TBGRANeoTextStyle *<N>BGRABitmap font style and alpha.<N><N>* TBGRANeoShadowStyle *<N>Usefull to general shadow purposes.<N><N>* TBGRANeoGradientStyle *<N>Gradient with alpha.<N><N>* TBGRANeoBorderStyle *<N>Round rectangle options, inner and outer border.<N>It uses TBGRANeoRoundRectangleOption.<N><N>
* TBGRANeoButtonStyle *<N>A combination of TBGRANeoTextStyle, TBGRANeoShadowStyle, TBGRANeoGradientStyle<N>and TBGRANeoBorderStyle. Is the style of each TBGRANeoButton states.<N><N>* TCustomBGRANeoButton *<N>A button that can be overriden. TSampleBGRANeoButton show how<N>to do that. With 4 states, each of them read the style properties<N>from TBGRANeoButtonStyle.<N><N>
* TBGRANeoButton *<N>TSampleBGRANeoButton descendant. It show how to publish all the properties that<N>are visible in the object inspector.<N>}<N><N>unit BGRANeoButton;<N><N>{$mode objfpc}{$H+}<N>{off $DEFINE DEBUG}<N><N>interface<N><N>uses<N>  Classes, LResources, Forms, Controls, Graphics, Dialogs, types,<N>  BGRABitmap, BGRABitmapTypes, BGRAPolygon, BGRAGradients;<N><N>
unit CustomBGRAImageButton;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, Controls, Graphics{, Buttons}, Forms, LMessages, BGRABitmap, BGRABitmapTypes,<N>  BGRATextFXTypes, types, ExtCtrls;<N><N>{off $DEFINE DEBUG}<N><N>type<N><N>  TButtonState =<N>    (<N>    bsUp,       // button is up<N>    bsDisabled, // button disabled (grayed)<N>    bsDown,     // button is down<N>    bsExclusive,// button is the only down in his group<N>    bsHot       // button is under mouse<N>    );<N><N>
  TCustomBGRAImageButtonRedraw = procedure(Sender: TObject;<N>    const ABGRA: TBGRABitmap; AState: TButtonState) of object;<N><N>  TCustomBGRAImageButtonPlaySound = procedure(Sender: TObject;<N>    const AFileName: string; AState: TButtonState) of object;<N><N>
{ Equivalent of standard lazarus TLabel but using BGRA Controls framework for text<N>  render.<N><N>  Functionality:<N>  - Customizable background (gradients etc.)<N>  - Customizable border (rounding etc.)<N>  - FontEx (shadow, word wrap, etc.)<N><N>  Copyright (C) 2012 Krzysztof Dibowski dibowski at interia.pl<N><N>
  This library is free software; you can redistribute it and/or modify it<N>  under the terms of the GNU Library General Public License as published by<N>  the Free Software Foundation; either version 2 of the License, or (at your<N>  option) any later version with the following modification:<N><N>
{ Useful tools for RTTI. Functions are used expecialy for save/load styles.<N>  Styles has construction similar to INI files:<N><N>  [Header]<N>  Author=Krzysztof Dibowski<N>  Description=My test style<N>  ControlClass=TBCButton<N><N>  [Properties]<N>  State.Border.Width=2<N>  .....<N><N>
{ Common types for BGRA Controls package<N><N>  Copyright (C) 2011 Krzysztof Dibowski dibowski at interia.pl<N><N>  This library is free software; you can redistribute it and/or modify it<N>  under the terms of the GNU Library General Public License as published by<N>  the Free Software Foundation; either version 2 of the License, or (at your<N>  option) any later version with the following modification:<N><N>
{ This component partialy solve problem with no alpha in lazarus GTK.<N>  It is using BGRABitmap library for drawing icons.<N><N>  Copyright (C) 2011 Krzysztof Dibowski dibowski at interia.pl<N><N>  This library is free software; you can redistribute it and/or modify it<N>  under the terms of the GNU Library General Public License as published by<N>  the Free Software Foundation; either version 2 of the License, or (at your<N>  option) any later version with the following modification:<N><N>
{ Customizable component which using BGRABitmap for drawing. Control mostly rendered<N>  using framework.<N><N>  Functionality:<N>  - Gradients<N>  - Double gradients<N>  - Rounding<N>  - Drop down list<N>  - Glyph<N>  - States (normal, hover, clicked)<N>  - Caption with shadow<N>  - Full alpha and antialias support<N><N>
  Copyright (C) 2012 Krzysztof Dibowski dibowski at interia.pl<N><N>  This library is free software; you can redistribute it and/or modify it<N>  under the terms of the GNU Library General Public License as published by<N>  the Free Software Foundation; either version 2 of the License, or (at your<N>  option) any later version with the following modification:<N><N>
unit utest;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Forms, SysUtils,<N>  { Custom Drawn }<N>  customdrawncontrols, customdrawndrawers, StdCtrls,<N>  { BGRABitmap }<N>  BGRAVirtualScreen, BGRABitmap, BGRABitmapTypes, BGRASamples,<N>  { Custom Drawn + BGRABitmap }<N>  customdrawn_windows7;<N><N>
unit customdrawn_windows7;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, Graphics, types, Math,<N>  { Custom Drawn }<N>  customdrawn_common, customdrawndrawers, FPCanvas,<N>  { BGRABitmap }<N>  bgrabitmap, bgrabitmaptypes, bgraslicescaling;<N><N>
unit umain;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Forms, Graphics, Dialogs, Spin, StdCtrls, ExtCtrls,<N>  BGRAVirtualScreen, BGRAGraphicControl, BGRABitmap, BGRASamples,<N>  BGRABitmapTypes, BGRATextFX, FileUtil, IniFiles, SysUtils;<N><N>type<N><N>
unit uscaledpi;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Forms, Graphics, Controls;<N><N>procedure HighDPI(FromDPI: integer);<N>procedure ScaleDPI(Control: TControl; FromDPI: integer);<N><N>implementation<N><N>uses BGRABitmap, BGRABitmapTypes;<N><N>
procedure HighDPI(FromDPI: integer);<N>var<N>  i: integer;<N>begin<N>  for i := 0 to Screen.FormCount - 1 do<N>    ScaleDPI(Screen.Forms[i], FromDPI);<N>end;<N><N>procedure ScaleDPI(Control: TControl; FromDPI: integer);<N>var<N>  i: integer;<N>  WinControl: TWinControl;<N>begin<N>  if Screen.PixelsPerInch = FromDPI then<N>    exit;<N><N>
  with Control do<N>  begin<N>    Left := ScaleX(Left, FromDPI);<N>    Top  := ScaleY(Top, FromDPI);<N>    Width := ScaleX(Width, FromDPI);<N>    Height := ScaleY(Height, FromDPI);<N>    //Font.Height := ScaleY(Font.GetTextHeight('Hg'),FromDPI);<N>  end;<N><N>
  if Control is TWinControl then<N>  begin<N>    WinControl := TWinControl(Control);<N>    if WinControl.ControlCount = 0 then<N>      exit;<N>    for i := 0 to WinControl.ControlCount - 1 do<N>      ScaleDPI(WinControl.Controls[i], FromDPI);<N>  end;<N>end;<N><N>
unit bgraribbon;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Controls, Graphics, BGRABitmap, BGRABitmapTypes, BGRAButton;<N><N>type<N>  TBGRARibbonStyle = (rsTab, rsButton, rsSeparator, rsMenu);<N><N>{ StyleButtons }<N><N>procedure StyleRibbonButtonsSample(AControl: TControl; AStyle: TBGRARibbonStyle);<N>procedure StyleRibbonBody(AControl: TControl);<N><N>
{ Drawings }<N><N>procedure DrawTabGradient(ABitmap: TBGRABitmap);<N>procedure DrawBodyGradient(ABitmap: TBGRABitmap);<N>procedure DrawFormGradient(ABitmap: TBGRABitmap);<N><N>{ Buttons }<N><N>procedure RibbonTab(AButton: TBGRAButton);<N>procedure RibbonButton(AButton: TBGRAButton);<N>procedure RibbonSeparator(AButton: TBGRAButton);<N>procedure RibbonMenu(AButton: TBGRAButton);<N><N>
implementation<N><N>{ StyleButtons }<N><N>procedure StyleButtons(AControl: TControl; AButton: TBGRAButton);<N>var<N>  i: integer;<N>  WinControl: TWinControl;<N>begin<N>  if AControl is TBGRAButton then<N>    AControl.Assign(AButton);<N>  if AControl is TWinControl then<N>  begin<N>    WinControl := TWinControl(AControl);<N>    if WinControl.ControlCount = 0 then<N>      exit;<N>    for i := 0 to WinControl.ControlCount - 1 do<N>      StyleButtons(WinControl.Controls[i], AButton);<N>  end;<N>end;<N><N>
procedure StyleRibbonButtonsSample(AControl: TControl; AStyle: TBGRARibbonStyle);<N>var<N>  tempBGRAButton: TBGRAButton;<N>begin<N>  tempBGRAButton := TBGRAButton.Create(nil);<N>  case AStyle of<N>    rsTab: RibbonTab(tempBGRAButton);<N>    rsButton: RibbonButton(tempBGRAButton);<N>    rsSeparator: RibbonSeparator(tempBGRAButton);<N>    rsMenu: RibbonMenu(tempBGRAButton);<N>  end;<N>  StyleButtons(AControl, tempBGRAButton);<N>  tempBGRAButton.Free;<N>end;<N><N>
unit uwin7toolbar;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Forms, SysUtils, StdCtrls, Spin, BGRAButton, BGRASamples, BGRAWin7ToolBar,<N>  Classes, types, Controls, BGRABitmap, BGRABitmapTypes, Graphics, LCLType;<N><N>type<N><N>  { TfrmWin7ToolBar }<N><N>
unit uallofthem;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, BGRAButton,<N>  BGRAFlashProgressBar, BGRAGraphicControl, BGRAImageButton, BGRAKnob,<N>  BGRALabel, BGRALabelFX, BCPanel, BGRAShape, BGRASpeedButton,<N>  BGRAVirtualScreen, BGRAWin7ToolBar, BGRABitmap,<N>  BGRABitmapThemeUtils, BGRAImageList, BGRABitmapTypes;<N><N>
{<N>READ BGRANeoButton.pas unit before using!<N>}<N><N>unit utestbgraneobutton;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Forms, Graphics, BGRANeoButton;<N><N>procedure Windows7StyleButton(AButton: TBGRANeoButton);<N><N>type<N><N>  { TForm1 }<N><N>
  TForm1 = class(TForm)<N>    BGRANeoButton1: TBGRANeoButton;<N>    BGRANeoButton2: TBGRANeoButton;<N>    procedure FormCreate(Sender: TObject);<N>  private<N>    { private declarations }<N>  public<N>    { public declarations }<N>  end;<N><N>var<N>  Form1: TForm1;<N><N>
implementation<N><N>procedure Windows7StyleButton(AButton: TBGRANeoButton);<N>begin<N><N>  { Common }<N>  with AButton.StyleNormal do<N>  begin<N>    Border.RoundX := 3;<N>    Border.RoundY := 3;<N>    Border.OuterWidth := 1;<N>    Border.InnerColorAlpha := 175;<N>    Border.InnerWidth := 1;<N>    Text.Font.Height := 20;<N>    Text.Font.Color := clBlack;<N>    Shadow.OffsetX := 1;<N>    Shadow.OffsetY := 1;<N>    Shadow.Radius := 1;<N>  end;<N><N>
  AButton.StyleHover.Assign(AButton.StyleNormal);<N>  AButton.StyleActive.Assign(AButton.StyleNormal);<N>  AButton.StyleDisabled.Assign(AButton.StyleNormal);<N><N>  with AButton.StyleNormal do<N>  begin<N>    Border.OuterColor := RGBToColor(112, 112, 112);<N>    Gradient1.Color1 := RGBToColor(242, 242, 242);<N>    Gradient1.Color2 := RGBToColor(235, 235, 235);<N>    Gradient2.Color1 := RGBToColor(221, 221, 221);<N>    Gradient2.Color2 := RGBToColor(207, 207, 207);<N>  end;<N><N>
  with AButton.StyleHover do<N>  begin<N>    Border.OuterColor := RGBToColor(60, 127, 177);<N>    Gradient1.Color1 := RGBToColor(234, 246, 253);<N>    Gradient1.Color2 := RGBToColor(217, 240, 252);<N>    Gradient2.Color1 := RGBToColor(190, 230, 253);<N>    Gradient2.Color2 := RGBToColor(167, 217, 245);<N>  end;<N><N>
  with AButton.StyleActive do<N>  begin<N>    Border.OuterColor := RGBToColor(44, 98, 139);<N>    Border.InnerColorAlpha := 100;<N>    Gradient1.Color1 := RGBToColor(229, 244, 252);<N>    Gradient1.Color2 := RGBToColor(196, 229, 246);<N>    Gradient2.Color1 := RGBToColor(152, 209, 239);<N>    Gradient2.Color2 := RGBToColor(104, 179, 219);<N>    GradientPosition := 0.55;<N>  end;<N><N>
  with AButton.StyleDisabled do<N>  begin<N>    Border.OuterColor := RGBToColor(173, 178, 181);<N>    Gradient1.Color1 := RGBToColor(244, 244, 244);<N>    Gradient1.Color2 := RGBToColor(244, 244, 244);<N>    Gradient2.Color1 := RGBToColor(244, 244, 244);<N>    Gradient2.Color2 := RGBToColor(244, 244, 244);<N>    Text.Font.Color := $006D6D6D;<N>  end;<N><N>
unit UnitBGRAImageManipulationDemo;<N><N>{ ============================================================================<N>  BGRAImageManipulation Demon Unit<N><N>  Copyright (C) 2011 - Emerson Cavalcanti<N><N>  This program is free software; you can redistribute it and/or modify it<N>  under the terms of the GNU Library General Public License as published by<N>  the Free Software Foundation; either version 2 of the License, or (at your<N>  option) any later version.<N><N>
  This program is distributed in the hope that it will be useful, but WITHOUT<N>  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or<N>  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Library General Public License<N>  for more details.<N><N>
  You should have received a copy of the GNU Library General Public License<N>  along with this library; if not, write to the Free Software Foundation,<N>  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.<N><N>  ============================================================================<N>  Description:<N><N>
  TFormBGRAImageManipulationDemo is a sample form to use the component<N>  TBGRAImageManipulation.<N><N>  ============================================================================<N>  History:<N><N>  2011-05-06 - Emerson Cavalcanti<N>             - Initial version<N><N>
  2011-06-01 - Emerson Cavalcanti<N>             - Relayout of form.<N>             - Add control to toggle the option 'Keep Aspect Ratio' in<N>               component<N><N>  2011-06-18 - Emerson Cavalcanti<N>             - Relayout of form for expand component on resize.<N>             - Add control to rotate image<N><N>
  ============================================================================<N>}<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  Buttons, ExtDlgs, ComCtrls, ExtCtrls, BGRAImageManipulation, BGRABitmap,<N>  BGRABitmapTypes, BGRAPanel, BGRAButton{, BGRATrackBar};<N><N>
unit GR32_Gamma;<N><N>interface<N><N>uses<N>  GR32;<N><N>{ Gamma bias for line/pixel antialiasing }<N><N>type<N>  TGammaTable8Bit = array [Byte] of Byte;<N><N>var<N>  GAMMA_VALUE: Double;<N>  GAMMA_ENCODING_TABLE: TGammaTable8Bit;<N>  GAMMA_DECODING_TABLE: TGammaTable8Bit;<N><N>
const<N>  DEFAULT_GAMMA: Double = 2.2;<N><N>// set gamma<N>procedure SetGamma; overload;  {$IFDEF USEINLINING} inline; {$ENDIF}<N>procedure SetGamma(Gamma: Double); overload;  {$IFDEF USEINLINING} inline; {$ENDIF}<N>procedure SetGamma(Gamma: Double; var GammaTable: TGammaTable8Bit); overload;<N><N>
procedure Set_sRGB; overload;<N>procedure Set_sRGB(var GammaTable: TGammaTable8Bit); overload;<N>procedure SetInv_sRGB(var GammaTable: TGammaTable8Bit);<N><N>// apply gamma<N>function ApplyGamma(Color: TColor32): TColor32; overload; {$IFDEF USEINLINING} inline; {$ENDIF}<N>function ApplyInvGamma(Color: TColor32): TColor32; overload; {$IFDEF USEINLINING} inline; {$ENDIF}<N>function ApplyCustomGamma(Color: TColor32; GammaTable: TGammaTable8Bit): TColor32; overload; {$IFDEF USEINLINING} inline; {$ENDIF}<N><N>
procedure ApplyGamma(Color: PColor32Array; Length: Integer); overload;<N>procedure ApplyInvGamma(Color: PColor32Array; Length: Integer); overload;<N>procedure ApplyCustomGamma(Color: PColor32Array; Length: Integer; GammaTable: TGammaTable8Bit); overload;<N><N>
procedure ApplyGamma(Bitmap: TBitmap32); overload;<N>procedure ApplyInvGamma(Bitmap: TBitmap32); overload;<N>procedure ApplyCustomGamma(Bitmap: TBitmap32; GammaTable: TGammaTable8Bit); overload;<N>procedure ApplyCustomGamma(Bitmap: TBitmap32; Gamma: Double); overload;<N><N>
implementation<N><N>uses<N>  Math;<N><N>function ApplyGamma(Color: TColor32): TColor32;<N>var<N>  C: TColor32Entry absolute Color;<N>  R: TColor32Entry absolute Result;<N>begin<N>  C.R := GAMMA_ENCODING_TABLE[C.R];<N>  C.G := GAMMA_ENCODING_TABLE[C.G];<N>  C.B := GAMMA_ENCODING_TABLE[C.B];<N>end;<N><N>
function ApplyInvGamma(Color: TColor32): TColor32;<N>var<N>  C: TColor32Entry absolute Color;<N>  R: TColor32Entry absolute Result;<N>begin<N>  C.R := GAMMA_DECODING_TABLE[C.R];<N>  C.G := GAMMA_DECODING_TABLE[C.G];<N>  C.B := GAMMA_DECODING_TABLE[C.B];<N>end;<N><N>
function ApplyCustomGamma(Color: TColor32; GammaTable: TGammaTable8Bit): TColor32;<N>var<N>  C: TColor32Entry absolute Color;<N>  R: TColor32Entry absolute Result;<N>begin<N>  C.R := GammaTable[C.R];<N>  C.G := GammaTable[C.G];<N>  C.B := GammaTable[C.B];<N>end;<N><N>
<N>procedure ApplyGamma(Color: PColor32Array; Length: Integer);<N>var<N>  Index: Integer;<N>begin<N>  for Index := 0 to Length - 1 do<N>  begin<N>    PColor32Entry(Color)^.R := GAMMA_ENCODING_TABLE[PColor32Entry(Color)^.R];<N>    PColor32Entry(Color)^.G := GAMMA_ENCODING_TABLE[PColor32Entry(Color)^.G];<N>    PColor32Entry(Color)^.B := GAMMA_ENCODING_TABLE[PColor32Entry(Color)^.B];<N>    Inc(Color);<N>  end;<N>end;<N><N>
procedure ApplyInvGamma(Color: PColor32Array; Length: Integer);<N>var<N>  Index: Integer;<N>begin<N>  for Index := 0 to Length - 1 do<N>  begin<N>    PColor32Entry(Color)^.R := GAMMA_DECODING_TABLE[PColor32Entry(Color)^.R];<N>    PColor32Entry(Color)^.G := GAMMA_DECODING_TABLE[PColor32Entry(Color)^.G];<N>    PColor32Entry(Color)^.B := GAMMA_DECODING_TABLE[PColor32Entry(Color)^.B];<N>    Inc(Color);<N>  end;<N>end;<N><N>
procedure ApplyCustomGamma(Color: PColor32Array; Length: Integer;<N>  GammaTable: TGammaTable8Bit);<N>var<N>  Index: Integer;<N>begin<N>  for Index := 0 to Length - 1 do<N>  begin<N>    PColor32Entry(Color)^.R := GammaTable[PColor32Entry(Color)^.R];<N>    PColor32Entry(Color)^.G := GammaTable[PColor32Entry(Color)^.G];<N>    PColor32Entry(Color)^.B := GammaTable[PColor32Entry(Color)^.B];<N>    Inc(Color);<N>  end;<N>end;<N><N>
<N>procedure ApplyGamma(Bitmap: TBitmap32);<N>begin<N>  ApplyGamma(Bitmap.Bits, Bitmap.Width * Bitmap.Height);<N>end;<N><N>procedure ApplyInvGamma(Bitmap: TBitmap32);<N>begin<N>  ApplyInvGamma(Bitmap.Bits, Bitmap.Width * Bitmap.Height);<N>end;<N><N>procedure ApplyCustomGamma(Bitmap: TBitmap32; GammaTable: TGammaTable8Bit);<N>begin<N>  ApplyCustomGamma(Bitmap.Bits, Bitmap.Width * Bitmap.Height, GammaTable);<N>end;<N><N>
procedure ApplyCustomGamma(Bitmap: TBitmap32; Gamma: Double);<N>var<N>  GammaTable: TGammaTable8Bit;<N>begin<N>  if GAMMA_VALUE = Gamma then<N>    ApplyGamma(Bitmap.Bits, Bitmap.Width * Bitmap.Height)<N>  else<N>  begin<N>    SetGamma(Gamma, GammaTable);<N>    ApplyCustomGamma(Bitmap.Bits, Bitmap.Width * Bitmap.Height, GammaTable);<N>  end;<N>end;<N><N>
<N>{ Gamma / Pixel Shape Correction table }<N><N>procedure SetGamma;<N>begin<N>  SetGamma(DEFAULT_GAMMA);<N>end;<N><N>procedure SetGamma(Gamma: Double);<N>begin<N>  GAMMA_VALUE := Gamma;<N><N>  // calculate default gamma tables<N>  SetGamma(1 / Gamma, GAMMA_ENCODING_TABLE);<N>  SetGamma(Gamma, GAMMA_DECODING_TABLE);<N>end;<N><N>
procedure SetGamma(Gamma: Double; var GammaTable: TGammaTable8Bit);<N>var<N>  i: Integer;<N>begin<N>  for i := 0 to $FF do<N>    GammaTable[i] := Round($FF * Power(i * COne255th, Gamma));<N>end;<N><N>procedure Set_sRGB;<N>begin<N>  Set_sRGB(GAMMA_ENCODING_TABLE);<N>  SetInv_sRGB(GAMMA_DECODING_TABLE);<N>end;<N><N>
procedure Set_sRGB(var GammaTable: TGammaTable8Bit);<N>var<N>  i: Integer;<N>  Value: Double;<N>const<N>  CExp = 1 / 2.4;<N>begin<N>  for i := 0 to $FF do<N>  begin<N>    Value := i * COne255th;<N>    if (Value < 0.0031308) then<N>        GammaTable[i] := Round($FF * Value * 12.92)<N>    else<N>        GammaTable[i] := Round($FF * (1.055 * Power(Value, CExp) - 0.055));<N>  end;<N>end;<N><N>
procedure SetInv_sRGB(var GammaTable: TGammaTable8Bit);<N>var<N>  i: Integer;<N>  Value: Double;<N>begin<N>  for i := 0 to $FF do<N>  begin<N>    Value := i * COne255th;<N>    if (Value < 0.004045) then<N>        GammaTable[i] := Round($FF * Value / 12.92)<N>    else<N>        GammaTable[i] := Round($FF * Power((Value + 0.055) / 1.055, 2.4));<N>  end;<N>end;<N><N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit GR32_Lazarus;<N><N>interface<N><N>uses<N>  GR32, GR32_Blend, GR32_Containers, GR32_ExtImage, GR32_Filters, GR32_Image, <N>  GR32_Layers, GR32_LowLevel, GR32_Math, GR32_MicroTiles, GR32_OrdinalMaps, <N>  GR32_Polygons, GR32_RangeBars, GR32_Rasterizers, GR32_RepaintOpt, <N>  GR32_Resamplers, GR32_System, GR32_Transforms, GR32_VectorMaps;<N><N>implementation<N><N>end.<N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit GR32_DSGN_Lazarus;<N><N>interface<N><N>uses<N>  GR32_Reg, GR32_Dsgn_Misc, GR32_Dsgn_Color, GR32_Dsgn_Bitmap, <N>  LazarusPackageIntf;<N><N>implementation<N><N>procedure Register;<N>begin<N>  RegisterUnit('GR32_Reg', @GR32_Reg.Register);<N>end;<N><N>initialization<N>  RegisterPackage('GR32_DSGN_Lazarus', @Register);<N>end.<N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit DpiControls;<N><N>{$warn 5023 off : no warning about unused units}<N>interface<N><N>uses<N>  UDpiControls, LazarusPackageIntf;<N><N>implementation<N><N>procedure Register;<N>begin<N>  RegisterUnit('UDpiControls', @UDpiControls.Register);<N>end;<N><N>initialization<N>  RegisterPackage('DpiControls', @Register);<N>end.<N>
unit UDpiControls;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, LCLProc, LResources, Forms, FormEditingIntf, ProjectIntf,<N>  Controls, StdCtrls, fgl, Graphics, ComCtrls, ExtCtrls, LCLType, GraphType,<N>  Types, CustApp, LMessages, LCLIntf;<N><N>
type<N>  TMessageEvent = procedure (var TheMessage : TLMessage) of object;<N><N>  { TFormEx }<N><N>  TFormEx = class(TForm)<N>  private<N>    FOnMessage: TMessageEvent;<N>  protected<N>    procedure WndProc(var TheMessage : TLMessage); override;<N>    property OnMessage: TMessageEvent read FOnMessage write FOnMessage;<N>  end;<N><N>
  { TGraphicControlEx }<N><N>  TGraphicControlEx = class(TGraphicControl)<N>  public<N>    property OnPaint;<N>    property OnMouseDown;<N>    property OnMouseUp;<N>    property OnMouseMove;<N>    procedure Paint; override;<N>  end;<N><N>  { TDpiFormFileDesc }<N><N>
  TDpiFormFileDesc = class(TFileDescPascalUnitWithResource)<N>  public<N>    constructor Create; override;<N>    function GetInterfaceUsesSection: string; override;<N>    function GetLocalizedName: string; override;<N>    function GetLocalizedDescription: string; override;<N>  end;<N><N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit ModularSystem;<N><N>interface<N><N>uses<N>  UModularSystem, UFormModuleList, LazarusPackageIntf;<N><N>implementation<N><N>procedure Register;<N>begin<N>  RegisterUnit('UModularSystem', @UModularSystem.Register);<N>end;<N><N>initialization<N>  RegisterPackage('ModularSystem', @Register);<N>end.<N>
unit ULogForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls;<N><N>type<N><N>  { TLogForm }<N><N>  TLogForm = class(TForm)<N>    Memo1: TMemo;<N>  private<N>    { private declarations }<N>  public<N>    { public declarations }<N>  end;<N><N>var<N>  LogForm: TLogForm;<N><N>implementation<N><N>{$R *.lfm}<N><N>end.<N><N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit CoolStreaming; <N><N>interface<N><N>uses<N>    UStreamHelper, USubStream, UVarBlockSerializer, UBufferedFileStream, <N>  UTextFileStream, UBitStream, UDynNumber, LazarusPackageIntf;<N><N>implementation<N><N>procedure Register; <N>begin<N>end; <N><N>initialization<N>  RegisterPackage('CoolStreaming', @Register); <N>end.<N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit CoolTranslator; <N><N>interface<N><N>uses<N>  UCoolTranslator, ULanguages, LazarusPackageIntf;<N><N>implementation<N><N>procedure Register; <N>begin<N>  RegisterUnit('UCoolTranslator', @UCoolTranslator.Register); <N>end; <N><N>initialization<N>  RegisterPackage('CoolTranslator', @Register); <N>end.<N>
unit UFileSystem;<N><N>interface<N><N>uses<N>  SysUtils;<N><N>type<N>  TDirectory = class<N>    Path: string;<N>    procedure Make;<N>    procedure Remove;<N>    function Exists: Boolean;<N>  end;<N><N>implementation<N><N>{ TDirectory }<N><N>function TDirectory.Exists: Boolean;<N>begin<N>  Result := DirectoryExists(Path);<N>end;<N><N>procedure TDirectory.Make;<N>begin<N>  MkDir(Path);<N>end;<N><N>procedure TDirectory.Remove;<N>begin<N>  RmDir(Path);<N>end;<N><N>end.<N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit GeneralRegistry;<N><N>{$warn 5023 off : no warning about unused units}<N>interface<N><N>uses<N>  UGeneralRegistry, LazarusPackageIntf;<N><N>implementation<N><N>procedure Register;<N>begin<N>  RegisterUnit('UGeneralRegistry', @UGeneralRegistry.Register);<N>end;<N><N>initialization<N>  RegisterPackage('GeneralRegistry', @Register);<N>end.<N>
unit UCoolAudio; <N><N>{$I UCoolAudioConfig.inc}<N><N>{$mode Delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils,<N>  {$IFDEF AudioSystemWindows}UAudioSystemWindows,{$ENDIF}<N>  {$IFDEF AudioSystemMPlayer}UAudioSystemMPlayer,{$ENDIF}<N>  {$IFDEF AudioSystemFMOD}UAudioSystemFMOD,{$ENDIF}<N>  {$IFDEF AudioSystemMAD}UAudioSystemMAD,{$ENDIF}<N>  {$IFDEF AudioSystemDSP}UAudioSystemDSP,{$ENDIF}<N>  UAudioSystem;<N><N>
unit UAudioSystem;<N><N>{$mode delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Contnrs;<N><N>type<N>  TMediaPlayerDriverClass = class of TMediaPlayerDriver;<N>  TOutputDriver = (omAlsa, omOSS, omDirectX, omWin32);<N><N>  EOpenOutputFailed = class(Exception);<N><N>
  { TAudioSystem }<N><N>  TAudioSystem = class(TComponent)<N>  protected<N>    FOutputDriver: TOutputDriver;<N>    procedure SetOutputMode(AValue: TOutputDriver); virtual;<N>  public<N>    constructor Create(AOwner: TComponent); override;<N>    destructor Destroy; override;<N>    function GetMediaPlayerDriverClass: TMediaPlayerDriverClass; virtual;<N>    property OutputMode: TOutputDriver read FOutputDriver write SetOutputMode;<N>  end;<N><N>
// MPlayer slave command list: http://www.mplayerhq.hu/DOCS/tech/slave.txt<N><N>unit UAudioSystemMPlayer;<N><N>{$I UCoolAudioConfig.inc}<N>{$mode Delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, UAudioSystem, Process, Math, Dialogs, DateUtils;<N><N>
unit UAudioSystemFMOD;<N><N>{$I UCoolAudioConfig.inc}<N>{$mode delphi}{$H+}<N><N>interface<N><N>{$UNDEF AudioSystemFMOD}<N>{$IFDEF AudioSystemFMOD}<N>uses<N>  Classes, SysUtils, fmoddyn, fmodtypes, UAudioSystem, DateUtils;<N><N>type<N><N>  { TAudioSystemFMOD }<N><N>
  TAudioSystemFMOD = class(TAudioSystem)<N>  private<N>    procedure SetOutputMode(AValue: TOutputDriver); override;<N>  public<N>    function GetMediaPlayerDriverClass: TMediaPlayerDriverClass; override;<N>    constructor Create(AOwner: TComponent); override;<N>    destructor Destroy; override;<N>  end;<N><N>
{ =============================================================================================== }<N>{ FMOD Main header file. Copyright (c), Firelight Technologies Pty, Ltd. 1999-2004.               }<N>{ =============================================================================================== }<N>{<N>  NOTE: For the demos to run you must have either fmod.dll (in Windows)<N>  or libfmod-3.75.so (in Linux) installed.<N><N>
{================================================================================================ }<N>{ FMOD Types header file. Copyright (c), Firelight Technologies Pty, Ltd. 1999-2004.              }<N>{ =============================================================================================== }<N>{<N>  NOTE: For the demos to run you must have either fmod.dll (in Windows)<N>  or libfmod-3.75.so (in Linux) installed.<N><N>
{============================================================================================ }<N>{ FMOD Main header file. Copyright (c), FireLight Technologies Pty, Ltd. 1999-2003.           }<N>{ =========================================================================================== }<N>{<N>  NOTE: For the demos to run you must have either fmod.dll (in Windows)<N>  or libfmod-3.75.so (in Linux) installed.<N><N>
{ =============================================================================================== }<N>{ FMOD Main header file. Copyright (c), Firelight Technologies Pty, Ltd. 1999-2004.               }<N>{ =============================================================================================== }<N>{<N>  NOTE: For the demos to run you must have either fmod.dll (in Windows)<N>  or libfmod-3.75.so (in Linux) installed.<N><N>
{ =============================================================================================== }<N>{ FMOD presets header file. Copyright (c), FireLight Technologies Pty, Ltd. 1999-2004.            }<N>{ =============================================================================================== }<N>{<N>  NOTE: For the demos to run you must have either fmod.dll (in Windows)<N>  or libfmod-3.75.so (in Linux) installed.<N><N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit UpdateChecker;<N><N>interface<N><N>uses<N>  UUpdateChecker, UFormDownloadProgress, UFormNewVersionOffer, <N>  LazarusPackageIntf;<N><N>implementation<N><N>procedure Register;<N>begin<N>  RegisterUnit('UUpdateChecker', @UUpdateChecker.Register);<N>end;<N><N>initialization<N>  RegisterPackage('UpdateChecker', @Register);<N>end.<N>
unit UStackTrace;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Contnrs, CustomLineInfo;<N><N>type<N>  TStackFrameInfo = class<N>    Index: Integer;<N>    LineNumber: Integer;<N>    Address: Integer;<N>    FunctionClassName: string;<N>    FunctionName: string;<N>    Source: string;<N>    procedure GetFrameInfo(Addr: Pointer);<N>  end;<N><N>
  { TStackTrace }<N><N>  TStackTrace = class(TObjectList)<N>    Frames: array of Pointer;<N>    MaxDepth: Integer;<N>    procedure GetExceptionBackTrace;<N>    procedure GetCallStack(BP: Pointer);<N>    procedure GetCurrentCallStack;<N>    procedure GetInfo;<N>    constructor Create;<N>  end;<N><N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit ExceptionLogger; <N><N>interface<N><N>uses<N>    CustomLineInfo, UStackTrace, UExceptionForm, UExceptionLogger, <N>  LazarusPackageIntf;<N><N>implementation<N><N>procedure Register; <N>begin<N>  RegisterUnit('UExceptionLogger', @UExceptionLogger.Register); <N>end; <N><N>initialization<N>  RegisterPackage('ExceptionLogger', @Register); <N>end.<N>
unit UExceptionForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  CustomLineInfo, ComCtrls, ExtCtrls, UStackTrace, UExceptionLogger;<N><N>type<N><N>  { TExceptionForm }<N><N>
{<N>    This file is part of the Free Pascal run time library.<N>    Copyright (c) 2000 by Peter Vreman<N><N>    Stabs Line Info Retriever<N><N>    See the file COPYING.FPC, included in this distribution,<N>    for details about the copyright.<N><N>    This program is distributed in the hope that it will be useful,<N>    but WITHOUT ANY WARRANTY; without even the implied warranty of<N>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.<N><N>
 **********************************************************************}<N>{<N>  This unit should not be compiled in objfpc mode, since this would make it<N>  dependent on objpas unit.<N>}<N>unit CustomLineInfo;<N>interface<N><N>{$S-}<N>{$Q-}<N><N>function GetLineInfo(addr:ptruint;var func,source:shortstring;var line:longint) : boolean;<N>function StabBackTraceStr(addr:Pointer):shortstring;<N><N>
implementation<N><N>uses<N>  exeinfo,strings;<N><N>const<N>  N_Function    = $24;<N>  N_TextLine    = $44;<N>  N_DataLine    = $46;<N>  N_BssLine     = $48;<N>  N_SourceFile  = $64;<N>  N_IncludeFile = $84;<N><N>  maxstabs = 40; { size of the stabs buffer }<N><N>
var<N>  { GDB after 4.18 uses offset to function begin<N>    in text section but OS/2 version still uses 4.16 PM }<N>  StabsFunctionRelative: boolean;<N><N>type<N>  pstab=^tstab;<N>  tstab=packed record<N>    strpos  : longint;<N>    ntype   : byte;<N>    nother  : byte;<N>    ndesc   : word;<N>    nvalue  : dword;<N>  end;<N><N>
unit UMainForm;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  UExceptionLogger;<N><N>type<N><N>  { TSampleThread }<N><N>  TSampleThread = class(TThread)<N>    procedure Execute; override;<N>  end;<N><N>
  { TMainForm }<N><N>  TMainForm = class(TForm)<N>    Button1: TButton;<N>    Button2: TButton;<N>    ExceptionLogger1: TExceptionLogger;<N>    procedure Button1Click(Sender: TObject);<N>    procedure Button2Click(Sender: TObject);<N>  private<N>    { private declarations }<N>  public<N>    Thread: TSampleThread;<N>  end; <N><N>
var<N>  MainForm: TMainForm;<N><N>implementation<N><N>{ TSampleThread }<N><N>procedure TSampleThread.Execute;<N>begin<N>  try<N>    raise Exception.Create('Exception inside thread');<N><N>  except<N>    on E: Exception do<N>      MainForm.ExceptionLogger1.ExceptionHandler(Self, E);<N>  end;<N>end;<N><N>
{$R *.lfm}<N><N>{ TMainForm }<N><N>procedure TMainForm.Button1Click(Sender: TObject);<N>begin<N>  raise Exception.Create('Simple exception');<N>end;<N><N>procedure TMainForm.Button2Click(Sender: TObject);<N>begin<N>  Thread := TSampleThread.Create(True);<N>  Thread.FreeOnTerminate := True;<N>  Thread.Start;<N>end;<N><N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit TEditExtensions; <N><N>interface<N><N>uses<N>  UTimeEdit, UIPv4Edit, LazarusPackageIntf;<N><N>implementation<N><N>procedure Register; <N>begin<N>  RegisterUnit('UTimeEdit', @UTimeEdit.Register); <N>  RegisterUnit('UIPv4Edit', @UIPv4Edit.Register); <N>end; <N><N>initialization<N>  RegisterPackage('TEditExtensions', @Register); <N>end.<N>
unit UTheme;<N><N>interface<N><N>uses<N>  Classes, SysUtils, Graphics, ComCtrls, Controls, ExtCtrls, Menus, StdCtrls,<N>  Spin, Forms, Generics.Collections, Grids;<N><N>type<N>  TTheme = class<N>    Name: string;<N>    ColorWindow: TColor;<N>    ColorWindowText: TColor;<N>    ColorControl: TColor;<N>    ColorControlText: TColor;<N>    ColorControlSelected: TColor;<N>  end;<N><N>
unit UResetableThread;<N><N>interface<N><N>uses<N>  Classes, SysUtils, syncobjs, UThreading, UPool;<N><N>type<N>  TResetableThread = class;<N><N>  { TResetableThreadExecute }<N><N>  TResetableThreadExecute = class(TTermThread)<N>    Parent: TResetableThread;<N>    procedure Execute; override;<N>  end;<N><N>
unit UGenerics;<N><N>interface<N><N>uses<N>  Classes, SysUtils, Generics.Collections;<N><N>type<N><N>  { TListString }<N><N>  TListString = class(TList<string>)<N>    procedure Assign(Source: TListString);<N>    procedure Explode(Separator: Char; Text: string; MaxCount: Integer = -1);<N>    function Implode(Separator: Char): string;<N>  end;<N><N>
  { TDictionaryStringString }<N><N>  TDictionaryStringString = class(TDictionary<string, string>)<N>    procedure Assign(Source: TDictionaryStringString);<N>  end;<N><N><N>implementation<N><N>{ TListString }<N><N>procedure TListString.Assign(Source: TListString);<N>var<N>  I: Integer;<N>begin<N>  Count := Source.Count;<N>  for I := 0 to Source.Count - 1 do<N>    Items[I] := Source[I];<N>end;<N><N>
unit UMetaCanvas;<N><N>interface<N><N>uses<N>  Classes, SysUtils, Graphics, Types, Generics.Collections;<N><N>type<N>  TArrayOfPoint = array of TPoint;<N><N>  { TCanvasObject }<N><N>  TCanvasObject = class<N>    procedure Paint(Canvas: TCanvas); virtual;<N>    procedure Zoom(Factor: Double); virtual;<N>    procedure Move(Delta: TPoint); virtual;<N>  end;<N><N>
  TCanvasObjects = class(TObjectList<TCanvasObject>)<N>  end;<N><N>  { TCanvasText }<N><N>  TCanvasText = class(TCanvasObject)<N>    Brush: TBrush;<N>    Font: TFont;<N>    Position: TPoint;<N>    Text: string;<N>    procedure Paint(Canvas: TCanvas); override;<N>    procedure Zoom(Factor: Double); override;<N>    procedure Move(Delta: TPoint); override;<N>    constructor Create;<N>    destructor Destroy; override;<N>  end;<N><N>
  { TCanvasRectangle }<N><N>  TCanvasRectangle = class(TCanvasObject)<N>    Pen: TPen;<N>    Brush: TBrush;<N>    BoundingRect: TRect;<N>    Rounded: TPoint;<N>    procedure Paint(Canvas: TCanvas); override;<N>    procedure Zoom(Factor: Double); override;<N>    procedure Move(Delta: TPoint); override;<N>    constructor Create;<N>    destructor Destroy; override;<N>  end;<N><N>
  { TCanvasLine }<N><N>  TCanvasLine = class(TCanvasObject)<N>    Pen: TPen;<N>    P1, P2: TPoint;<N>    procedure Paint(Canvas: TCanvas); override;<N>    procedure Zoom(Factor: Double); override;<N>    procedure Move(Delta: TPoint); override;<N>    constructor Create;<N>    destructor Destroy; override;<N>  end;<N><N>
  { TCanvasPolygon }<N><N>  TCanvasPolygon = class(TCanvasObject)<N>    Pen: TPen;<N>    Brush: TBrush;<N>    Points: array of TPoint;<N>    procedure Paint(Canvas: TCanvas); override;<N>    procedure Zoom(Factor: Double); override;<N>    procedure Move(Delta: TPoint); override;<N>    constructor Create;<N>    destructor Destroy; override;<N>  end;<N><N>
  { TCanvasEllipse }<N><N>  TCanvasEllipse = class(TCanvasObject)<N>    Pen: TPen;<N>    Brush: TBrush;<N>    BoundingRect: TRect;<N>    procedure Paint(Canvas: TCanvas); override;<N>    procedure Zoom(Factor: Double); override;<N>    procedure Move(Delta: TPoint); override;<N>    constructor Create;<N>    destructor Destroy; override;<N>  end;<N><N>
  { TCanvasPie }<N><N>  TCanvasPie = class(TCanvasObject)<N>    Pen: TPen;<N>    Brush: TBrush;<N>    BoundingRect: TRect;<N>    StartPoint: TPoint;<N>    EndPoint: TPoint;<N>    procedure Paint(Canvas: TCanvas); override;<N>    procedure Zoom(Factor: Double); override;<N>    procedure Move(Delta: TPoint); override;<N>    constructor Create;<N>    destructor Destroy; override;<N>  end;<N><N>
  { TCanvasStretchDraw }<N><N>  TCanvasStretchDraw = class(TCanvasObject)<N>    SrcGraphic: TGraphic;<N>    DestRect: TRect;<N>    procedure Paint(Canvas: TCanvas); override;<N>    procedure Zoom(Factor: Double); override;<N>    procedure Move(Delta: TPoint); override;<N>    constructor Create;<N>    destructor Destroy; override;<N>  end;<N><N>
unit Unit1;<N><N>{$mode delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, XMLConf, FileUtil, Forms, Controls, Graphics, Dialogs,<N>  Buttons, StdCtrls, ExtCtrls, ComCtrls, Menus, XMLPropStorage, UPersistentForm;<N><N>type<N><N>  { TForm1 }<N><N>
  TForm1 = class(TForm)<N>    ListView1: TListView;<N>    PersistentForm1: TPersistentForm;<N>    Timer1: TTimer;<N>    XMLConfig1: TXMLConfig;<N>    procedure FormClose(Sender: TObject; var CloseAction: TCloseAction);<N>    procedure FormResize(Sender: TObject);<N>    procedure FormShow(Sender: TObject);<N>    procedure Timer1Timer(Sender: TObject);<N>  private<N>    procedure AddValue(Name, Value: string);<N>  public<N>    { public declarations }<N>    procedure ShowDimensions;<N>  end;<N><N>
var<N>  Form1: TForm1;<N><N>const<N>  WindowStateText: array[TWindowState] of string = ('wsNormal', 'wsMinimized',<N>    'wsMaximized', 'wsFullScreen');<N><N>implementation<N><N>{$R *.lfm}<N><N>{ TForm1 }<N><N>procedure TForm1.FormShow(Sender: TObject);<N>begin<N>  PersistentForm1.Load(Self);<N>end;<N><N>
procedure TForm1.Timer1Timer(Sender: TObject);<N>begin<N>  ShowDimensions;<N>end;<N><N>procedure TForm1.AddValue(Name, Value: string);<N>var<N>  NewItem: TListItem;<N>begin<N>  NewItem := ListView1.Items.Add;<N>  NewItem.Caption := Name;<N>  NewItem.SubItems.Add(Value);<N>end;<N><N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit TemplateGenerics;<N><N>interface<N><N>uses<N>  SpecializedList, SpecializedDictionary, SpecializedStack, SpecializedTree, <N>  SpecializedQueue, SpecializedSet, SpecializedPoint, SpecializedMatrix, <N>  SpecializedBitmap, SpecializedStream, SpecializedRectangle, <N>  UBinarySerializer, LazarusPackageIntf;<N><N>
unit UGenericShared;<N><N>{$mode Delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils; <N><N>function FastCompareMem(P1, P2: Pointer; Length: cardinal): Boolean; inline;<N>function FastCompareMem2(P1, P2: Pointer; Length: cardinal): Boolean; inline;<N><N>
implementation<N><N>function FastCompareMem(P1, P2: Pointer; Length: cardinal): Boolean;<N>var<N>  i: cardinal;<N>begin<N>  Result:=True;<N>  I:=0;<N>  If (P1)<>(P2) then<N>    While Result and (i<Length) do<N>      begin<N>      Result:=PByte(P1)^=PByte(P2)^;<N>      Inc(I);<N>      Inc(pchar(P1));<N>      Inc(pchar(P2));<N>      end;<N>end;<N><N>
function FastCompareMem2(P1, P2: Pointer; Length: cardinal): Boolean;<N>var<N>  i: cardinal;<N>begin<N>  Result:=True;<N>  I:=0;<N>  If (P1)<>(P2) then<N>    While Result and (i<Length) do<N>      begin<N>      Result:=PByte(P1)^=PByte(P2)^;<N>      Inc(I);<N>      Inc(pchar(P1));<N>      Inc(pchar(P2));<N>      end;<N>end;<N><N>
unit UMainForm;<N><N>{$mode delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,<N>  ComCtrls, SpecializedList, SpecializedDictionary, SpecializedQueue,<N>  DateUtils, SpecializedMatrix, SpecializedStream;<N><N>
unit SpecializedStream;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils, SpecializedList, DateUtils;<N><N>type<N>  TSeekOrigin = (soBegin, soCurrent, soEnd);<N><N>{$MACRO ON}<N><N>// TStreamInteger<Integer, Integer><N>{$DEFINE TGStreamIndex := Integer}<N>{$DEFINE TGStreamItem := Integer}<N>{$DEFINE TGStreamList := TListStreamInteger}<N>{$DEFINE TGStream := TStreamInteger}<N>{$DEFINE INTERFACE}<N>{$I 'GenericStream.inc'}<N><N>
// TStreamByte<Integer, Byte><N>{$DEFINE TGStreamIndex := Integer}<N>{$DEFINE TGStreamItem := Byte}<N>{$DEFINE TGStreamList := TListStreamByte}<N>{$DEFINE TGStream := TBaseStreamByte}<N>{$DEFINE INTERFACE}<N>{$I 'GenericStream.inc'}<N><N>// TStreamPointer<Integer, Pointer><N>{$DEFINE TGStreamIndex := Integer}<N>{$DEFINE TGStreamItem := Pointer}<N>{$DEFINE TGStreamList := TListStreamPointer}<N>{$DEFINE TGStream := TStreamPointer}<N>{$DEFINE INTERFACE}<N>{$I 'GenericStream.inc'}<N><N>
unit SpecializedTree;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>{$MACRO ON}<N>// TTreeInteger<Integer, Integer><N>{$DEFINE TGTreeIndex := Integer}<N>{$DEFINE TGTreeItem := Integer}<N>{$DEFINE TGTree := TTreeInteger}<N>{$DEFINE TGTreeNode := TTreeNodeInteger}<N>{$DEFINE TGTreeNodeList := TTreeNodeListInteger}<N>{$DEFINE INTERFACE}<N>{$I 'GenericTree.inc'}<N><N>
// TTreeString<Integer, string><N>{$DEFINE TGTreeIndex := Integer}<N>{$DEFINE TGTreeItem := string}<N>{$DEFINE TGTree := TTreeString}<N>{$DEFINE TGTreeNode := TTreeNodeString}<N>{$DEFINE TGTreeNodeList := TTreeNodeListString}<N>{$DEFINE INTERFACE}<N>{$I 'GenericTree.inc'}<N><N>
// TTreePointer<Integer, Pointer><N>{$DEFINE TGTreeIndex := Integer}<N>{$DEFINE TGTreeItem := Pointer}<N>{$DEFINE TGTree := TTreePointer}<N>{$DEFINE TGTreeNode := TTreeNodePointer}<N>{$DEFINE TGTreeNodeList := TTreeNodeListPointer}<N>{$DEFINE INTERFACE}<N>{$I 'GenericTree.inc'}<N><N>
implementation<N><N>{$DEFINE IMPLEMENTATION_USES}<N>{$I 'GenericTree.inc'}<N><N>// TTreeInteger<Integer, Integer><N>{$DEFINE TGTreeIndex := Integer}<N>{$DEFINE TGTreeItem := Integer}<N>{$DEFINE TGTree := TTreeInteger}<N>{$DEFINE TGTreeNode := TTreeNodeInteger}<N>{$DEFINE TGTreeNodeList := TTreeNodeListInteger}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericTree.inc'}<N><N>
// TTreeString<Integer, string><N>{$DEFINE TGTreeIndex := Integer}<N>{$DEFINE TGTreeItem := string}<N>{$DEFINE TGTree := TTreeString}<N>{$DEFINE TGTreeNode := TTreeNodeString}<N>{$DEFINE TGTreeNodeList := TTreeNodeListString}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericTree.inc'}<N><N>
// TTreePointer<Integer, Pointer><N>{$DEFINE TGTreeIndex := Integer}<N>{$DEFINE TGTreeItem := Pointer}<N>{$DEFINE TGTree := TTreePointer}<N>{$DEFINE TGTreeNode := TTreeNodePointer}<N>{$DEFINE TGTreeNodeList := TTreeNodeListPointer}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericTree.inc'}<N><N>
unit SpecializedQueue;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>{$MACRO ON}<N><N>// TQueueInteger<Integer, Integer><N>{$DEFINE TGQueueIndex := Integer}<N>{$DEFINE TGQueueItem := Integer}<N>{$DEFINE TGQueue := TQueueInteger}<N>{$DEFINE TGQueueList := TQueueListInteger}<N>{$DEFINE INTERFACE}<N>{$I 'GenericQueue.inc'}<N><N>
// TQueueInteger<Integer, Pointer><N>{$DEFINE TGQueueIndex := Integer}<N>{$DEFINE TGQueueItem := Pointer}<N>{$DEFINE TGQueue := TQueuePointer}<N>{$DEFINE TGQueueList := TQueueListPointer}<N>{$DEFINE INTERFACE}<N>{$I 'GenericQueue.inc'}<N><N>// TQueueByte<Integer, Byte><N>{$DEFINE TGQueueIndex := Integer}<N>{$DEFINE TGQueueItem := Byte}<N>{$DEFINE TGQueue := TQueueByte}<N>{$DEFINE TGQueueList := TQueueListByte}<N>{$DEFINE INTERFACE}<N>{$I 'GenericQueue.inc'}<N><N>
implementation<N><N>{$DEFINE IMPLEMENTATION_USES}<N>{$I 'GenericQueue.inc'}<N><N>// TQueueInteger<Integer, Integer><N>{$DEFINE TGQueueIndex := Integer}<N>{$DEFINE TGQueueItem := Integer}<N>{$DEFINE TGQueue := TQueueInteger}<N>{$DEFINE TGQueueList := TQueueListInteger}<N>{$DEFINE IMPLEMENTATION}<N>{$I '..\Generic\GenericQueue.inc'}<N><N>
// TQueueInteger<Integer, Pointer><N>{$DEFINE TGQueueIndex := Integer}<N>{$DEFINE TGQueueItem := Pointer}<N>{$DEFINE TGQueue := TQueuePointer}<N>{$DEFINE TGQueueList := TQueueListPointer}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericQueue.inc'}<N><N>// TQueueByte<Integer, Byte><N>{$DEFINE TGQueueIndex := Integer}<N>{$DEFINE TGQueueItem := Byte}<N>{$DEFINE TGQueue := TQueueByte}<N>{$DEFINE TGQueueList := TQueueListByte}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericQueue.inc'}<N><N>
unit SpecializedStack;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>{$MACRO ON}<N><N>// TStackInteger<Integer, Integer><N>{$DEFINE TGStackIndex := Integer}<N>{$DEFINE TGStackItem := Integer}<N>{$DEFINE TGStackList := TListStackInteger}<N>{$DEFINE TGStack := TStackInteger}<N>{$DEFINE INTERFACE}<N>{$I 'GenericStack.inc'}<N><N>
// TStackInteger<Integer, Pointer><N>{$DEFINE TGStackIndex := Integer}<N>{$DEFINE TGStackItem := Pointer}<N>{$DEFINE TGStackList := TListStackPointer}<N>{$DEFINE TGStack := TStackPointer}<N>{$DEFINE INTERFACE}<N>{$I 'GenericStack.inc'}<N><N><N>implementation<N><N>
{$DEFINE IMPLEMENTATION_USES}<N>{$I 'GenericStack.inc'}<N><N>// TStackInteger<Integer, Integer><N>{$DEFINE TGStackIndex := Integer}<N>{$DEFINE TGStackItem := Integer}<N>{$DEFINE TGStackList := TListStackInteger}<N>{$DEFINE TGStack := TStackInteger}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericStack.inc'}<N><N>
// TStackInteger<Integer, Pointer><N>{$DEFINE TGStackIndex := Integer}<N>{$DEFINE TGStackItem := Pointer}<N>{$DEFINE TGStackList := TListStackPointer}<N>{$DEFINE TGStack := TStackPointer}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericStack.inc'}<N>end.<N><N><N>
unit SpecializedDictionary;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>{$MACRO ON}<N><N>// TDictionaryStringString<Integer, TPair<string, string>><N>{$DEFINE TGDictionaryIndex := Integer}<N>{$DEFINE TGPair := TPairStringString}<N>{$DEFINE TGPairKey := string}<N>{$DEFINE TGPairValue := string}<N>{$DEFINE TGDictionary := TDictionaryStringString}<N>{$DEFINE TGDictionaryList := TDictionaryStringStringList}<N>{$DEFINE INTERFACE}<N>{$I 'GenericDictionary.inc'}<N><N>
// TDictionaryIntegerString<Integer, TPair<Integer, string>><N>{$DEFINE TGDictionaryIndex := Integer}<N>{$DEFINE TGPair := TPairIntegerString}<N>{$DEFINE TGPairKey := Integer}<N>{$DEFINE TGPairValue := string}<N>{$DEFINE TGDictionary := TDictionaryIntegerString}<N>{$DEFINE TGDictionaryList := TDictionaryIntegerStringList}<N>{$DEFINE INTERFACE}<N>{$I 'GenericDictionary.inc'}<N><N>
<N>implementation<N><N>{$DEFINE IMPLEMENTATION_USES}<N>{$I '..\Generic\GenericDictionary.inc'}<N><N><N>// TDictionaryStringString<Integer, TPair<string, string>><N>{$DEFINE TGDictionaryIndex := Integer}<N>{$DEFINE TGPair := TPairStringString}<N>{$DEFINE TGPairKey := string}<N>{$DEFINE TGPairValue := string}<N>{$DEFINE TGDictionary := TDictionaryStringString}<N>{$DEFINE TGDictionaryList := TDictionaryStringStringList}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericDictionary.inc'}<N><N>
// TDictionaryIntegerString<Integer, TPair<Integer, string>><N>{$DEFINE TGDictionaryIndex := Integer}<N>{$DEFINE TGPair := TPairIntegerString}<N>{$DEFINE TGPairKey := Integer}<N>{$DEFINE TGPairValue := string}<N>{$DEFINE TGDictionary := TDictionaryIntegerString}<N>{$DEFINE TGDictionaryList := TDictionaryIntegerStringList}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericDictionary.inc'}<N><N>
unit SpecializedSet;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>{$MACRO ON}<N><N>// TSetInteger<Integer, Integer><N>{$DEFINE TGSetIndex := Integer}<N>{$DEFINE TGSetItem := Integer}<N>{$DEFINE TGSetList := TSetListInteger}<N>{$DEFINE TGSet := TSetInteger}<N>{$DEFINE INTERFACE}<N>{$I 'GenericSet.inc'}<N><N>
// TSetPointer<Integer, Pointer><N>{$DEFINE TGSetIndex := Integer}<N>{$DEFINE TGSetItem := Pointer}<N>{$DEFINE TGSetList := TSetListPointer}<N>{$DEFINE TGSet := TSetPointer}<N>{$DEFINE INTERFACE}<N>{$I 'GenericSet.inc'}<N><N>implementation<N><N>{$DEFINE IMPLEMENTATION_USES}<N>{$I 'GenericSet.inc'}<N><N>
// TSetInteger<Integer, Integer><N>{$DEFINE TGSetIndex := Integer}<N>{$DEFINE TGSetItem := Integer}<N>{$DEFINE TGSetList := TSetListInteger}<N>{$DEFINE TGSet := TSetInteger}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericSet.inc'}<N><N>// TSetPointer<Integer, Pointer><N>{$DEFINE TGSetIndex := Integer}<N>{$DEFINE TGSetItem := Pointer}<N>{$DEFINE TGSetList := TSetListPointer}<N>{$DEFINE TGSet := TSetPointer}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericSet.inc'}<N><N>
unit SpecializedList;<N><N>{$mode delphi}<N><N>interface<N><N>uses<N>  Classes, SysUtils;<N><N>type<N>{$MACRO ON}<N><N>// TListInteger<Integer, Integer><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Integer}<N>{$DEFINE TGList := TListInteger}<N>{$DEFINE INTERFACE}<N>{$I 'GenericList.inc'}<N><N>
// TListBoolean<Integer, Boolean><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Boolean}<N>{$DEFINE TGList := TListBoolean}<N>{$DEFINE INTERFACE}<N>{$I 'GenericList.inc'}<N><N>// TListSmallInt<Integer, SmallInt><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := SmallInt}<N>{$DEFINE TGList := TListSmallInt}<N>{$DEFINE INTERFACE}<N>{$I 'GenericList.inc'}<N><N>
// TListDouble<Integer, Double><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Double}<N>{$DEFINE TGList := TListDouble}<N>{$DEFINE INTERFACE}<N>{$INCLUDE '..\Generic\GenericList.inc'}<N><N>// TListPointer<Integer, Pointer><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Pointer}<N>{$DEFINE TGList := TListPointer}<N>{$DEFINE INTERFACE}<N>{$I 'GenericList.inc'}<N><N>
// TListString<Integer, string><N>{$DEFINE TGListStringIndex := Integer}<N>{$DEFINE TGListStringItem := string}<N>{$DEFINE TGListString := TListString}<N>{$DEFINE INTERFACE}<N>{$I 'GenericListString.inc'}<N><N>// TListByte<Integer, Byte><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Byte}<N>{$DEFINE TGList := TListByteBase}<N>{$DEFINE INTERFACE}<N>{$I 'GenericList.inc'}<N><N>
TListByte = class(TListByteBase)<N>  procedure WriteToStream(Stream: TStream);<N>  procedure WriteToStreamPart(Stream: TStream; ItemIndex, ItemCount: TGListIndex);<N>  procedure ReplaceStream(Stream: TStream);<N>  procedure ReplaceStreamPart(Stream: TStream; ItemIndex, ItemCount: TGListIndex);<N>  procedure AddStream(Stream: TStream);<N>  procedure AddStreamPart(Stream: TStream; ItemCount: TGListIndex);<N>end;<N><N>
// TListChar<Integer, Char><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Char}<N>{$DEFINE TGList := TListCharBase}<N>{$DEFINE INTERFACE}<N>{$I 'GenericList.inc'}<N><N>// TListObject<Integer, TObject><N>{$DEFINE TGListObjectIndex := Integer}<N>{$DEFINE TGListObjectItem := TObject}<N>{$DEFINE TGListObjectList := TListObjectList}<N>{$DEFINE TGListObject := TListObject}<N>{$DEFINE INTERFACE}<N>{$I 'GenericListObject.inc'}<N><N>
<N>{ TListChar }<N><N>// TListByte<Integer, Char><N>TListChar = class(TListCharBase)<N>  procedure UpperCase;<N>  procedure LowerCase;<N>  procedure Trim;<N>  procedure TrimLeft;<N>  procedure TrimRight;<N>end;<N><N>// TListMethodBase<Integer, TMethod><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := TMethod}<N>{$DEFINE TGList := TListMethodBase}<N>{$DEFINE INTERFACE}<N>{$I 'GenericList.inc'}<N><N>
// TListMethod<Integer, TMethod><N>TListMethod = class(TListMethodBase)<N>  procedure CallAll;<N>end;<N><N>// TListNotifyEventBase<Integer, TNotifyEvent><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := TNotifyEvent}<N>{$DEFINE TGList := TListNotifyEventBase}<N>{$DEFINE INTERFACE}<N>{$I 'GenericList.inc'}<N><N>
// TListNotifyEvent<Integer, TNotifyEvent><N>TListNotifyEvent = class(TListNotifyEventBase)<N>  procedure CallAll(Sender: TObject);<N>end;<N><N><N>TBaseEvent = procedure of object;<N><N>// TListSimpleEventBase<Integer, TBaseEvent><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := TBaseEvent}<N>{$DEFINE TGList := TListSimpleEventBase}<N>{$DEFINE INTERFACE}<N>{$I 'GenericList.inc'}<N><N>
// TListSimpleEvent<Integer, TSimpleEvent><N>TListSimpleEvent = class(TListSimpleEventBase)<N>  procedure CallAll;<N>end;<N><N><N>// TFileListByte<Integer, Byte><N>{$DEFINE TGFileListIndex := Integer}<N>{$DEFINE TGFileListItem := Byte}<N>{$DEFINE TGFileListList := TFileListListByte}<N>{$DEFINE TGFileList := TFileListByte}<N>{$DEFINE INTERFACE}<N>{$I 'GenericFileList.inc'}<N><N>
function StrToStr(Value: string): string;<N><N><N><N><N><N>implementation<N><N>{$DEFINE IMPLEMENTATION_USES}<N>{$I 'GenericList.inc'}<N><N>// TListInteger<Integer, Integer><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Integer}<N>{$DEFINE TGList := TListInteger}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>
// TListSmallInt<Integer, SmallInt><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := SmallInt}<N>{$DEFINE TGList := TListSmallInt}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>// TListBoolean<Integer, Boolean><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Boolean}<N>{$DEFINE TGList := TListBoolean}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>
// TListDouble<Integer, Double><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Double}<N>{$DEFINE TGList := TListDouble}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>// TListPointer<Integer, Pointer><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Pointer}<N>{$DEFINE TGList := TListPointer}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>
// TListString<Integer, string><N>{$DEFINE TGListStringIndex := Integer}<N>{$DEFINE TGListStringItem := string}<N>{$DEFINE TGListString := TListString}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericListString.inc'}<N><N>// TListByte<Integer, Byte><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Byte}<N>{$DEFINE TGList := TListByteBase}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>
// TListByte<Integer, Char><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := Char}<N>{$DEFINE TGList := TListCharBase}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>// TListObject<Integer, TObject><N>{$DEFINE TGListObjectIndex := Integer}<N>{$DEFINE TGListObjectItem := TObject}<N>{$DEFINE TGListObjectList := TListObjectList}<N>{$DEFINE TGListObject := TListObject}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericListObject.inc'}<N><N>
// TListMethod<Integer, TMethod><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := TMethod}<N>{$DEFINE TGList := TListMethodBase}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>// TListNotifyEventBase<Integer, TNotifyEvent><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := TNotifyEvent}<N>{$DEFINE TGList := TListNotifyEventBase}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>
// TListSimpleEventBase<Integer, TBaseEvent><N>{$DEFINE TGListIndex := Integer}<N>{$DEFINE TGListItem := TBaseEvent}<N>{$DEFINE TGList := TListSimpleEventBase}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericList.inc'}<N><N>// TFileListByte<Integer, Byte><N>{$DEFINE TGFileListIndex := Integer}<N>{$DEFINE TGFileListItem := Byte}<N>{$DEFINE TGFileListList := TFileListListByte}<N>{$DEFINE TGFileList := TFileListByte}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericFileList.inc'}<N><N>
<N>function StrToStr(Value: string): string;<N>begin<N>  Result := Value;<N>end;<N><N>{ TListSimpleEvent }<N><N>procedure TListSimpleEvent.CallAll;<N>var<N>  I: TGListIndex;<N>begin<N>  I := 0;<N>  while (I < Count) do begin<N>    TBaseEvent(Items[I])();<N>    I := I + 1;<N>  end;<N>end;<N><N>
<N>{ TListChar }<N><N>procedure TListChar.UpperCase;<N>var<N>  I: TGListIndex;<N>begin<N>  for I := 0 to Count - 1 do<N>    if (FItems[I] in ['a'..'z']) then<N>      FItems[I] := Char(Byte(FItems[I]) - 32);<N>end;<N><N>procedure TListChar.LowerCase;<N>var<N>  I: TGListIndex;<N>begin<N>  for I := 0 to Count - 1 do<N>    if (FItems[I] in ['A'..'Z']) then<N>      FItems[I] := Char(Byte(FItems[I]) + 32);<N>end;<N><N>
procedure TListChar.Trim;<N>begin<N>  TrimLeft;<N>  TrimRight;<N>end;<N><N>procedure TListChar.TrimLeft;<N>var<N>  I: TGListIndex;<N>begin<N>  I := 0;<N>  while (I < Count) and (FItems[I] = ' ') do<N>    I := I + 1;<N>  if I < Count then<N>    DeleteItems(0, I);<N>end;<N><N>
procedure TListChar.TrimRight;<N>var<N>  I: TGListIndex;<N>begin<N>  I := Count - 1;<N>  while (I >= 0) and (FItems[I] = ' ') do<N>    I := I - 1;<N>  if I >= 0 then<N>    DeleteItems(I + 1, Count - I - 1);<N>end;<N><N>procedure TListMethod.CallAll;<N>var<N>  I: TGListIndex;<N>begin<N>  I := 0;<N>  while (I < Count) do begin<N>    Items[I];<N>    I := I + 1;<N>  end;<N>end;<N><N>
procedure TListNotifyEvent.CallAll(Sender: TObject);<N>var<N>  I: TGListIndex;<N>begin<N>  I := Count - 1;<N>  while (I >= 0) do begin<N>    TNotifyEvent(Items[I])(Sender);<N>    I := I - 1;<N>  end;<N>end;<N><N>{ TListByte }<N><N>procedure TListByte.WriteToStream(Stream: TStream);<N>var<N>  I: Integer;<N>begin<N>  Stream.Position := 0;<N>  I := 0;<N>  while I < Count do begin<N>    Stream.WriteByte(Items[I]);<N>    I := I + 1;<N>  end;<N>end;<N><N>
procedure TListByte.WriteToStreamPart(Stream: TStream; ItemIndex, ItemCount: Integer);<N>var<N>  I: Integer;<N>begin<N>  I := ItemIndex;<N>  while I < ItemCount do begin<N>    Stream.WriteByte(Items[I]);<N>    I := I + 1;<N>  end;<N>end;<N><N>procedure TListByte.ReplaceStream(Stream: TStream);<N>var<N>  I: Integer;<N>begin<N>  Stream.Position := 0;<N>  I := 0;<N>  while I < Count do begin<N>    Items[I] := Stream.ReadByte;<N>    I := I + 1;<N>  end;<N>end;<N><N>
procedure TListByte.ReplaceStreamPart(Stream: TStream; ItemIndex,<N>  ItemCount: Integer);<N>var<N>  I: Integer;<N>begin<N>  I := ItemIndex;<N>  while I < ItemCount do begin<N>    Items[I] := Stream.ReadByte;<N>    I := I + 1;<N>  end;<N>end;<N><N>procedure TListByte.AddStream(Stream: TStream);<N>var<N>  I: Integer;<N>begin<N>  Stream.Position := 0;<N>  I := Count;<N>  Count := Count + Stream.Size;<N>  while I < Count do begin<N>    Items[I] := Stream.ReadByte;<N>    I := I + 1;<N>  end;<N>end;<N><N>
procedure TListByte.AddStreamPart(Stream: TStream; ItemCount: Integer);<N>var<N>  I: Integer;<N>begin<N>  I := Count;<N>  Count := Count + ItemCount;<N>  while I < Count do begin<N>    Items[I] := Stream.ReadByte;<N>    I := I + 1;<N>  end;<N>end;<N><N><N>end.<N><N><N>
unit SpecializedMatrix;<N><N>{$mode Delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils; <N><N>type<N>  {$MACRO ON}<N><N>// TMatrixInteger<Integer, Integer, Integer><N>{$DEFINE TGMatrixIndexX := Integer}<N>{$DEFINE TGMatrixIndexY := Integer}<N>{$DEFINE TGMatrixItem := Integer}<N>{$DEFINE TGMatrixIndex := TMatrixIntegerIndex}<N>{$DEFINE TGMatrixRow := TMatrixIntegerRow}<N>{$DEFINE TGMatrix := TMatrixInteger}<N>{$DEFINE INTERFACE}<N>{$I 'GenericMatrix.inc'}<N><N>
// TMatrixByte<Integer, Integer, Byte><N>{$DEFINE TGMatrixIndexX := Integer}<N>{$DEFINE TGMatrixIndexY := Integer}<N>{$DEFINE TGMatrixItem := Byte}<N>{$DEFINE TGMatrixIndex := TMatrixByteIndex}<N>{$DEFINE TGMatrixRow := TMatrixByteRow}<N>{$DEFINE TGMatrix := TMatrixByte}<N>{$DEFINE INTERFACE}<N>{$I 'GenericMatrix.inc'}<N><N>
// TMatrixObject<Integer, Integer, TObject><N>{$DEFINE TGMatrixIndexX := Integer}<N>{$DEFINE TGMatrixIndexY := Integer}<N>{$DEFINE TGMatrixItem := TObject}<N>{$DEFINE TGMatrixIndex := TMatrixObjectIndex}<N>{$DEFINE TGMatrixRow := TMatrixObjectRow}<N>{$DEFINE TGMatrix := TMatrixObject}<N>{$DEFINE INTERFACE}<N>{$I 'GenericMatrix.inc'}<N><N>
implementation<N><N>{$DEFINE IMPLEMENTATION_USES}<N>{$I 'GenericMatrix.inc'}<N><N>// TMatrixInteger<Integer, Integer, Integer><N>{$DEFINE TGMatrixIndexX := Integer}<N>{$DEFINE TGMatrixIndexY := Integer}<N>{$DEFINE TGMatrixItem := Integer}<N>{$DEFINE TGMatrixIndex := TMatrixIntegerIndex}<N>{$DEFINE TGMatrixRow := TMatrixIntegerRow}<N>{$DEFINE TGMatrix := TMatrixInteger}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericMatrix.inc'}<N><N>
// TMatrixByte<Integer, Integer, Byte><N>{$DEFINE TGMatrixIndexX := Integer}<N>{$DEFINE TGMatrixIndexY := Integer}<N>{$DEFINE TGMatrixItem := Byte}<N>{$DEFINE TGMatrixIndex := TMatrixByteIndex}<N>{$DEFINE TGMatrixRow := TMatrixByteRow}<N>{$DEFINE TGMatrix := TMatrixByte}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericMatrix.inc'}<N><N>
// TMatrixObject<Integer, Integer, TObject><N>{$DEFINE TGMatrixIndexX := Integer}<N>{$DEFINE TGMatrixIndexY := Integer}<N>{$DEFINE TGMatrixItem := TObject}<N>{$DEFINE TGMatrixIndex := TMatrixObjectIndex}<N>{$DEFINE TGMatrixRow := TMatrixObjectRow}<N>{$DEFINE TGMatrix := TMatrixObject}<N>{$DEFINE IMPLEMENTATION}<N>{$I 'GenericMatrix.inc'}<N><N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit CoolTranslator;<N><N>interface<N><N>uses<N>  UCoolTranslator, ULanguages, LazarusPackageIntf;<N><N>implementation<N><N>procedure Register;<N>begin<N>  RegisterUnit('UCoolTranslator', @UCoolTranslator.Register);<N>end;<N><N>initialization<N>  RegisterPackage('CoolTranslator', @Register);<N>end.<N>
unit UTheme;<N><N>interface<N><N>uses<N>  Classes, SysUtils, Graphics, ComCtrls, Controls, ExtCtrls, Menus, StdCtrls,<N>  Spin, Forms, Contnrs, Grids;<N><N>type<N>  TTheme = class<N>    Name: string;<N>    ColorWindow: TColor;<N>    ColorWindowText: TColor;<N>    ColorControl: TColor;<N>    ColorControlText: TColor;<N>    ColorControlSelected: TColor;<N>  end;<N><N>
unit UResetableThread;<N><N>{$mode Delphi}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, syncobjs, UThreading, UPool;<N><N>type<N>  TResetableThread = class;<N><N>  { TResetableThreadExecute }<N><N>  TResetableThreadExecute = class(TTermThread)<N>    Parent: TResetableThread;<N>    procedure Execute; override;<N>  end;<N><N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit CoolBar;<N><N>interface<N><N>uses<N>  UCoolBar, LazarusPackageIntf;<N><N>implementation<N><N>procedure Register;<N>begin<N>  RegisterUnit('UCoolBar', @UCoolBar.Register);<N>end;<N><N>initialization<N>  RegisterPackage('CoolBar', @Register);<N>end.<N>
unit UnitFormMain;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, ExtCtrls, StdCtrls,<N>  QlpIQrCode, QlpQrCode, QlpQrSegment, QlpQRCodeGenLibTypes;<N><N>type<N><N>  { TFormMain }<N><N>  TFormMain = class(TForm)<N>    ImageQRCode: TImage;<N>    MemoInput: TMemo;<N>    PanelTop: TPanel;<N>    PanelBottom: TPanel;<N>    Splitter: TSplitter;<N>    procedure MemoInputChange(Sender: TObject);<N>  private<N>    procedure GenerateQR();<N>  public<N><N>
unit uMain;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls,<N>  Vcl.ComCtrls, VirtualTrees;<N><N>const<N>  MaxPostMsgLength = 2048;<N><N>
type<N>  PDebugMessage = ^TDebugMessage;<N>  TDebugMessage = record<N>    Time : string;<N>    Level1 : string;<N>    Level2 : string;<N>    InspTime : string;<N>    FuncType : string;<N>    Mode : string;<N>    OkNg: String;<N>    DebugMsg : String;<N>    OkNgFontColor : TColor;<N>    FuncFontColor : TColor;<N>  end;<N><N>
  PDefectData = ^TDefectData;<N>  TDefectData = record<N>    MachineNo : Integer;<N>    Time : TDateTime;<N>    Level1 : Integer;//ThreadNo<N>    Level2 : Integer;//Level<N>    InspTime : Integer;<N>    FuncType : array [0..255] of AnsiChar;//DefectName<N>    Mode : array [0..30] of AnsiChar;<N>    OkNg : array [0..30] of AnsiChar;<N>    DebugMsg : array [0..1024] of AnsiChar;<N>  end;<N><N>
var<N>x, y: text;<N>z: integer;<N>n: array of integer;<N>i: integer;<N>begin<N>assign(x, 'Pressf.txt');<N>reset(x);<N>while not eof(x) do<N>begin<N>read(x, z);<N>setLength(n, length(n) + 1);<N>n[high(n)] := z;<N>end;<N>close(x);<N>assign(y, 'press.txt');<N>rewrite(y);<N>for i := high(n) downto 0 do<N>begin<N>write(y, n[i]);<N>writeln(y);<N>end;<N>close(y);<N>end.
﻿var<N>  i_ptr: ^integer;<N>  i: integer;<N> <N>begin<N>  i := 2;<N>  i_ptr := @i;<N>  writeln(i_ptr^);<N>end.
procedure row(n:integer);<N>begin<N>     if n >=0 then begin<N>        write (n, ' ');<N>        row(n-2)<N>     end;<N>end;<N>begin<N>    row(25);<N>end.
procedure fib (count,v,v0:integer);<N>  begin<N>       if count=0 then Exit;<N>       write(v, ' ');<N>           fib(count-1,v+v0,v);<N>  end;<N>begin<N>  fib(10,1,0);<N>end.
var a,b:longint;<N>    f1,f2:Text;<N>function Nod(x,y:longint):longint;<N>begin<N>  if x<>0 then Nod:=Nod(y mod x,x) else Nod:=y;<N>end;<N>begin<N>read(a,b);<N>writeln(Nod(a,b));<N>end.
﻿program Calculator;<N><N>var<N>  num1, num2, result: real;<N>  op: char;<N><N>begin<N>  write('Введите первое число: ');<N>  readln(num1);<N>  <N>  write('Введите второе число: ');<N>  readln(num2);<N>  <N>  write('Введите знак (+, -, *, /): ');<N>  readln(x);<N>  <N>  case x of<N>    '+': result := num1 + num2;<N>    '-': result := num1 - num2;<N>    '*': result := num1 * num2;<N>    '/': result := num1 / num2;<N>  end;<N>  <N>  writeln('Результат: ', result:0:2);<N>  <N>  readln;<N>end.<N>
unit uFrmCadastroEndereco;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs;<N><N>type<N>  TForm1 = class(TForm)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form1: TForm1;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit MultiLineBitBtn;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, StdCtrls, LCLType, Windows;<N><N>type<N><N>  { TMultiLineBitBtn }<N><N>  TMultiLineBitBtn = class(TButton)<N>  protected<N>    procedure CreateParams(var Params: TCreateParams); override;<N>  end;<N><N>
procedure Register;<N><N>implementation<N><N>procedure Register;<N>begin<N>  RegisterComponents('teste',[TMultiLineBitBtn]);<N>end;<N><N>{ TMultiLineBitBtn }<N><N>procedure TMultiLineBitBtn.CreateParams(var Params: TCreateParams);<N>begin<N>  inherited CreateParams(Params);<N>  Params.Style := Params.Style or BS_MULTILINE;<N>end;<N><N>
unit ShapeGridFila;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, LResources, Forms, Controls, Graphics, Dialogs, ExtCtrls;<N><N>type<N>  TShapeGridFila = class(TShape)<N>  private<N><N>  protected<N><N>  public<N><N>  published<N><N>  end;<N><N>procedure Register;<N><N>implementation<N><N>procedure Register;<N>begin<N>  RegisterComponents('Fabricio',[TShapeGridFila]);<N>end;<N><N>end.<N>
unit GraphicControl1;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, LResources, Forms, Controls, Graphics, Dialogs;<N><N>type<N>  TGraphicControl1 = class(TGraphicControl)<N>  private<N><N>  protected<N><N>  public<N><N>  published<N><N>  end;<N><N>procedure Register;<N><N>implementation<N><N>procedure Register;<N>begin<N>  RegisterComponents('',[TGraphicControl1]);<N>end;<N><N>end.<N>
{ This file was automatically created by Lazarus. Do not edit!<N>  This source is only used to compile and install the package.<N> }<N><N>unit TurbinaPack;<N><N>{$warn 5023 off : no warning about unused units}<N>interface<N><N>uses<N>  parametros, LazarusPackageIntf;<N><N>implementation<N><N>procedure Register;<N>begin<N>  RegisterUnit('parametros', @parametros.Register);<N>end;<N><N>initialization<N>  RegisterPackage('TurbinaPack', @Register);<N>end.<N>
unit uFormaPagamentoBoleto;<N><N>interface<N><N>uses System.Classes, System.SysUtils, uFormaPagamento;<N><N>type<N>  TFormaPagamentoBoleto = class(TFormaPagamento)<N>  public<N>    procedure RealizarPagamento(Valor: Currency); override;<N>  end;<N><N>implementation<N><N>{ TFormaPagamentoBoleto }<N><N>procedure TFormaPagamentoBoleto.RealizarPagamento(Valor: Currency);<N>begin<N>  // Implemente a lógica para realizar o pagamento com boleto<N>end;<N><N>end.<N>
unit uFormaPagamentoPix;<N><N>interface<N><N>uses System.Classes, System.SysUtils, uFormaPagamento;<N><N>type<N>  TFormaPagamentoPix = class(TFormaPagamento)<N>  public<N>    TipoChave: ShortInt;<N>    Chave: string;<N>    procedure RealizarPagamento(Valor: Currency); override;<N>  end;<N><N>implementation<N><N>{ TFormaPagamentoPix }<N><N>procedure TFormaPagamentoPix.RealizarPagamento(Valor: Currency);<N>begin<N>  // Implemente a lógica para realizar o pagamento com Pix<N>end;<N><N>end.
unit uFormaPagamento;<N><N>interface<N><N>uses System.Classes, System.SysUtils;<N><N>type<N>  TFormaPagamento = class abstract<N>  public<N>    procedure RealizarPagamento(Valor: Currency); virtual; abstract;<N>  end;<N><N>implementation<N><N>end.
unit uTranslate;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  System.JSON, System.Net.HTTPClient,<N>  System.NetEncoding;<N><N>function GoogleTranslate(const AValue, ConstSourceLang, ConstTargetLang: String): String;<N><N>
unit uMain;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs;<N><N>type<N>  TForm1 = class(TForm)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form1: TForm1;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit fmProfile;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs;<N><N>type<N>  TProfileForm = class(TForm)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  ProfileForm: TProfileForm;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit uPrincipal;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.StdCtrls,<N>  FMX.Controls.Presentation, uDWAbout, uRESTDWBase, FMX.Edit, FMX.ScrollBox,<N>  FMX.Memo, FMX.Objects;<N><N>
unit RestServerController;<N><N>interface<N><N>uses<N>  uRESTDWMasterDetailData, uRESTDWServerEvents;<N><N>type<N>  TRestServerController = class<N>    private<N>    FRestServer: TDWServerEvents;<N><N>    public<N>      property RestServer : TDWServerEvents read FRestServer write FRestServer;<N><N>
      constructor Create; overload;<N>  end;<N><N>implementation<N><N>uses<N>  System.Classes, uDWConsts;<N><N>{ TRestClientController }<N>constructor TRestServerController.Create;<N>var<N>  eventList : TDWEventList;<N>  event : TDWEvent;<N>  teste : TCollection;<N>  teste2 : TCollectionItem;<N>begin<N>  FRestServer := TDWServerEvents.Create(Nil);<N><N>
  with event do<N>  begin<N>    TDWEvent.Create(Nil);<N>    event.EventName := 'NovoCliente';<N>    event.JsonMode  := jmPureJSON;<N>    event.NeedAuthorization := True;<N>    event.Routes    := [crGet];<N>  end;<N><N>  eventList := TDWEventList.Create(Nil, Nil);<N>  teste2 :=  eventList.Add;<N>  FRestServer.Events := eventList;<N>end;<N><N>
unit ClienteController;<N><N>interface<N><N>uses Firedac.Comp.Client, System.SysUtils, Firedac.DApt, FMX.Graphics, Classe.Conexao,<N>  ClienteModel;<N><N>type<N>  TClienteController = class<N><N>  private<N>    FConn : TConecta;<N><N><N>  public<N>    constructor Create();<N>    function NovoCliente(out erro : String; cliente : TPessoa): Boolean;<N>  end;<N><N>
implementation<N><N>{ TEntrada }<N><N>uses uPrincipal, System.Classes, Data.DB, System.StrUtils;<N><N>constructor TClienteController.Create;<N>begin<N>  FConn := TConecta.Create;<N>end;<N><N>function TClienteController.NovoCliente(out erro : String; cliente : TPessoa): Boolean;<N>var<N>  qry : TFDQuery;<N>  SQL_, VALUES : String;<N>begin<N>  try<N>    qry            := TFDQuery.Create(nil);<N>    qry.Connection := FConn.Conectar;<N><N>
unit EnderecoModel;<N><N>interface<N><N>type<N>  TEndereco = class<N><N>    private<N>      FIdEndereco: Integer;<N>      FDsCep: String;<N>      FIdPessoa: Integer;<N>      procedure setDsCep(const Value: String);<N>      procedure setIdEndereco(const Value: Integer);<N>      procedure setIdPessoa(const Value: Integer);<N><N>
    public<N>      property IdEndereco : Integer read FIdEndereco write setIdEndereco;<N>      property IdPessoa   : Integer read FIdPessoa   write setIdPessoa;<N>      property DsCep      : String  read FDsCep      write setDsCep;<N>  end;<N><N>implementation<N><N>
{ TEndereco }<N><N>procedure TEndereco.setDsCep(const Value: String);<N>begin<N>  FDsCep := Value;<N>end;<N><N>procedure TEndereco.setIdEndereco(const Value: Integer);<N>begin<N>  FIdEndereco := Value;<N>end;<N><N>procedure TEndereco.setIdPessoa(const Value: Integer);<N>begin<N>  FIdPessoa := Value;<N>end;<N><N>
unit CepConsulta;<N><N>interface<N><N>uses<N>  ClienteModel, System.Json, REST.Client, EnderecoIntegracaoModel;<N><N>type<N>  TCepConsulta = class<N><N>  private<N><N>  public<N>    procedure ConsultarCEP(cep : String);<N>  end;<N><N>implementation<N><N>uses<N>  System.Classes, System.SysUtils, Vcl.Dialogs, System.Variants, frmCadPessoa;<N><N>
procedure TCepConsulta.ConsultarCEP(cep : String);<N>var<N>  jsonObj : TJsonObject;<N>  json : String;<N>  request : TRESTRequest;<N>  restClient : TRESTClient;<N>  enderecoIntegracao : TEnderecoIntegracao;<N>begin<N>  TThread.CreateAnonymousThread(procedure<N>  begin<N>    try<N>      restClient := TRESTClient.Create('viacep.com.br/ws/' + cep + '/json');<N><N>
      request := TRESTRequest.Create(Nil);<N>      request.Client := restClient;<N>      request.Params.Clear;<N>      request.Execute;<N><N>      if request.Response.JSONValue = nil then<N>      begin<N>        raise Exception.Create('Erro ao consultar API cep');<N>      end<N>      else<N>      begin<N>        json    := request.Response.JSONValue.ToString;<N>        jsonObj := TJSONObject.ParseJSONValue(TEncoding.UTF8.GetBytes(json), 0) as TJSONObject;<N><N>
        if jsonObj <> Nil then<N>        begin<N>          try<N>            enderecoIntegracao := TEnderecoIntegracao.Create;<N>            enderecoIntegracao.DsUf         := jsonObj.GetValue('uf').Value;<N>            enderecoIntegracao.NmCidade     := jsonObj.GetValue('localidade').Value;<N>            enderecoIntegracao.NmBairro     := jsonObj.GetValue('bairro').Value;<N>            enderecoIntegracao.NmLogradouro := jsonObj.GetValue('logradouro').Value;<N><N>
            fCadPessoa.EnderecoIntegracao := enderecoIntegracao;<N>          finally<N>            FreeAndNil(enderecoIntegracao);<N>          end;<N>        end;<N>      end;<N><N>      jsonObj.DisposeOf;<N>    except on e : exception do<N>      begin<N>        ShowMessage(e.message);<N>      end;<N>    end;<N>  end).Start;<N>end;<N>end.<N><N><N>
unit EnderecoController;<N><N>interface<N><N>uses<N>  System.Json, REST.Client;<N><N>type<N>  TEnderecoController = class<N><N>  private<N>    procedure EnviarServidor;<N><N>  public<N>    procedure AtualizarEndIntegracao();<N>  end;<N><N>implementation<N><N>
unit PessoaController;<N><N>interface<N><N>uses<N>  ClienteModel, System.Json, REST.Client;<N><N>type<N>  TPessoaController = class<N><N>  private<N>    FPessoa : TPessoa;<N>    FPessoaController : TPessoaController;<N>    procedure EnviarServidor(pessoa : TPessoa);<N><N>
  public<N>    procedure Insert(pessoa: TPessoa; pessoaController : TPessoaController);<N>  end;<N><N>implementation<N><N>uses<N>  System.Classes, System.SysUtils, Vcl.Dialogs, frmCadPessoa;<N><N>procedure TPessoaController.Insert(pessoa : TPessoa; pessoaController : TPessoaController);<N>begin<N>  FPessoa := pessoa;<N>  FPessoaController := pessoaController;<N>  EnviarServidor(pessoa);<N>end;<N><N>
procedure TPessoaController.EnviarServidor(pessoa : TPessoa);<N>var<N>  jsonObj : TJsonObject;<N>  json : String;<N>  request : TRESTRequest;<N>  restClient : TRESTClient;<N>begin<N>   TThread.CreateAnonymousThread(procedure<N>   begin<N>     try<N>       try<N>         restClient := TRESTClient.Create('http://localhost:8084');<N><N>
unit EnderecoModel;<N><N>interface<N><N>type<N>  TEndereco = class<N><N>    private<N>      FIdEndereco: Integer;<N>      FDsCep: String;<N>      FIdPessoa: Integer;<N>      procedure setDsCep(const Value: String);<N>      procedure setIdEndereco(const Value: Integer);<N>      procedure setIdPessoa(const Value: Integer);<N><N>
    public<N>      property IdEndereco : Integer read FIdEndereco write setIdEndereco;<N>      property IdPessoa   : Integer read FIdPessoa   write setIdPessoa;<N>      property DsCep      : String  read FDsCep      write setDsCep;<N>  end;<N><N>implementation<N><N>
{ TEndereco }<N><N>procedure TEndereco.setDsCep(const Value: String);<N>begin<N>  FDsCep := Value;<N>end;<N><N>procedure TEndereco.setIdEndereco(const Value: Integer);<N>begin<N>  FIdEndereco := Value;<N>end;<N><N>procedure TEndereco.setIdPessoa(const Value: Integer);<N>begin<N>  FIdPessoa := Value;<N>end;<N><N>
unit UFraLogin;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects,<N>  FMX.Layouts, FMX.StdCtrls, FMX.Controls.Presentation, FMX.Edit;<N><N>
type<N>  TfrmLogin = class(TForm)<N>    lytPrincipal: TLayout;<N>    lytBluMopLogo: TLayout;<N>    imgBlumopLogo: TImage;<N>    RectPrincipal: TRectangle;<N>    lblSaldo: TLabel;<N>    btnAutenticar: TButton;<N>    rectAutenticar: TRectangle;<N>    lytBotoes: TLayout;<N>    lytLogoOnibus: TLayout;<N>    imgOnibus: TImage;<N>    RectConsulta: TRectangle;<N>    EdtNumero: TEdit;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit UFraCatraca;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects,<N>  FMX.Layouts, FMX.StdCtrls, FMX.Controls.Presentation;<N><N>
type<N>  TUfraSaldo = class(TForm)<N>    lytPrincipal: TLayout;<N>    lytBluMopLogo: TLayout;<N>    imgBlumopLogo: TImage;<N>    RectPrincipal: TRectangle;<N>    lblSaldo: TLabel;<N>    btnCatraca: TButton;<N>    rectCatraca: TRectangle;<N>    lytBotoes: TLayout;<N>    lblOutroCartao: TLabel;<N>    lytLogoOnibus: TLayout;<N>    imgOnibus: TImage;<N>    Label1: TLabel;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit unitIFftView1;<N><N>{$mode ObjFPC}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, ExtCtrls, TAGraph,<N>  TASeries;<N><N>type<N><N>  { TForm_IFftView }<N><N>  TForm_IFftView = class(TForm)<N>    Chart1_I_FFT: TChart;<N>    Chart1_I_FFTLineSeries1Ifft_Q: TLineSeries;<N>    Chart1_I_FFTLineSeries1Ifft_I: TLineSeries;<N>    Timer1: TTimer;<N>    procedure FormCreate(Sender: TObject);<N>    procedure Timer1Timer(Sender: TObject);<N>  private<N><N>
  public<N>  chart_I_FFTdata: array of array of double ; //  value stored as a double requires 64 bits;<N>  end;<N><N>var<N>  Form_IFftView: TForm_IFftView;<N><N>implementation<N><N>{$R *.lfm}<N><N>{ TForm_IFftView }<N><N>procedure TForm_IFftView.Timer1Timer(Sender: TObject);<N>var<N>i: Integer;<N>x: Double;<N>begin<N>   Chart1_I_FFTLineSeries1Ifft_I.Clear;<N>   Chart1_I_FFTLineSeries1Ifft_Q.Clear;<N><N>
<N>      for i:=0 to 1024 -1 do begin<N>         Chart1_I_FFTLineSeries1Ifft_I.AddXY(i, chart_I_FFTdata[0,i]);<N>         Chart1_I_FFTLineSeries1Ifft_Q.AddXY(i, chart_I_FFTdata[1,i] );<N><N>       // version test<N>      end;<N>end;<N><N>procedure TForm_IFftView.FormCreate(Sender: TObject);<N>begin<N>    setLength( chart_I_FFTdata , 8 , 2048 )  ;<N>end;<N><N>
unit uDM;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf, FireDAC.Stan.Def,<N>  FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys, FireDAC.Phys.PG,<N>  FireDAC.Phys.PGDef, FireDAC.VCLUI.Wait, FireDAC.Stan.Param, FireDAC.DatS,<N>  FireDAC.DApt.Intf, FireDAC.DApt, Data.DB, FireDAC.Comp.DataSet,<N>  FireDAC.Comp.Client;<N><N>
type<N>  TDM = class(TDataModule)<N>    Conexao: TFDConnection;<N>    FDPhysPgDriverLink1: TFDPhysPgDriverLink;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  DM: TDM;<N><N>implementation<N><N>{%CLASSGROUP 'Vcl.Controls.TControl'}<N><N>
unit uPesquisa;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.Buttons, Vcl.ExtCtrls,<N>  Data.DB, Vcl.Grids, Vcl.DBGrids, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf,<N>  FireDAC.DApt.Intf, FireDAC.Stan.Async, FireDAC.DApt, FireDAC.Comp.DataSet,<N>  FireDAC.Comp.Client;<N><N>
unit UfrmCadastrar;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes,<N>  System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects,<N>  FMX.StdCtrls, FMX.Controls.Presentation, FMX.Layouts, FMX.Edit;<N><N>
unit UfrmEnviar;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes,<N>  System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects,<N>  FMX.Controls.Presentation, FMX.StdCtrls, FMX.Layouts, FMX.ListBox,<N>  FMX.MultiView;<N><N>
unit UfrmSistema;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes,<N>  System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects,<N>  FMX.StdCtrls, FMX.ListBox, FMX.Edit, FMX.Controls.Presentation, FMX.Layouts,<N>  FMX.MultiView, UService.Imagem;<N><N>
unit UUtils.Enum;<N><N>interface<N><N>type<N>  TEnumMenu = (mnuHome, mnuCadastrar, mnuSair);<N><N>implementation<N><N>end.<N>
unit Cryptographer;<N>{$MODE OBJFPC}<N>interface<N> type<N>  PTCryptographer = ^TCryptographer;<N>  TCryptographer = Class<N>  private<N>   _Size :Integer;<N>  public<N>   CodeArray :Array of double;<N><N>   Constructor Create(var x:TCryptographer);overload;<N>   Destructor Destroy;override;<N><N>
   Procedure GetMemory;<N>   Procedure FreeMemory;<N><N>   Procedure Assign(var x:TCryptographer);<N><N>   Function MakeCode(var x : array of double):double;overload;<N>   Function MakeCode(var x : array of integer):double;overload;<N><N><N>   Function GetSize_:Integer;<N>   Procedure SetSize(x:Integer);<N><N>
unit Solver;<N><N>{$MODE Delphi}<N><N>interface<N> uses<N>  SysUtils,<N>  Classes,<N>  VarType,<N>  Solution,<N>  Problem,<N>  BAPReduceLine;<N>const<N> a1 = 'Current operation: ';<N> a2 = 'Best solution: ';<N> a3 = 'Best solution value: ';<N> a4 = 'Run number: ';<N> a5 = 'Iteration namber: ';<N> a6 = 'Time: ';<N><N>
 type<N>  PTSolver = ^TSolver;<N>  TSolver = Class<N>  protected<N>   FRunQuantity             :TInt;<N>   Function GetRunQuantity_ :TInt;<N>   Function GetSolutionSize :TInt;<N>   Function GetSolutionSize_:TInt;<N>  public<N><N>//-----Statistic-----//<N>   LastChangeRecord                 :integer;<N><N>
   CurrentIteration                 :integer;<N>   CurrentRun                       :integer;<N><N>   BeginTime                        :TDateTime;<N>//-----Files-----//<N>   NameRecordFile                   :TString;<N>   NameDebugFile                   :TString;<N>   NameParameterFile                :TString;<N><N>
   TerminationIndex              :integer;<N>   TerminationParameter              :double;<N><N>   Constructor Create;overload;<N>   Constructor Create(var x:TSolver);overload;<N>   Destructor Destroy;override;<N><N>   Procedure GetMemory;virtual;abstract;<N>   Procedure FreeMemory;virtual;abstract;<N><N>
   Procedure Load(var f : TStringList);<N>   Procedure Assign(var x : TSolver);<N><N>   Function StopIterations:TBool;virtual;<N>   Procedure Iteration;virtual; abstract;<N>   Procedure FirstApproximation;virtual; abstract;<N>   Procedure ShowRecord;virtual; abstract;   <N>   Procedure ShowDebug;virtual; abstract;<N>   Procedure SaveRecord;virtual; abstract;<N>   Procedure SaveDebug;virtual; abstract;<N>   Procedure Run;virtual;<N>   Procedure Algoritm;virtual;<N><N>
unit BAPReduceLine;<N>{$MODE OBJFPC}<N>interface<N> uses<N>  classes,<N>  Problem,<N>  Solution,<N>  BAPSolution,<N>  MachineLine,<N>  Cryptographer,<N>  BAPHashList,<N>  FPlin;<N> type<N><N>  PTBAPReduceLine = ^TBAPReduceLine;<N>  TBAPReduceLine = Class(TProblem)<N>  public<N>   RememberMachineLine             :TMachineLine;<N>   UseMachineLine                  :TMachineLine;<N><N>
   RememberSimpleMachineLine       :TMachineLine;<N>   UseSimpleMachineLine            :TMachineLine;<N><N>   CodeMaker                       :TCryptographer;<N><N>   Hash                            :TBAPHashList;<N><N>   UpBoundary                      :Array of Integer;<N><N>
   revenuefunction                 :a_function;<N>   alloc_costfunction              :a_function;<N>   amort                           :Double;<N>   inv_coef                        :Double;<N>   det_cost                        :Array of Double;<N><N>   Constructor Create;overload;<N>   Constructor Create(x : TProblem);overload;<N>   Destructor Destroy;override;<N><N>
   Procedure GetMemory;overload;<N>   Procedure FreeMemory;overload;<N><N>   Procedure Load(f : TStringList);<N>   Procedure Assign(x:TProblem);<N><N>   Procedure SetValue(x:TSolution); overload;<N>   Procedure ProblemFunction(var x:TBAPSolution);overload;<N>//   Procedure BottleneckProblemFunction(var x:TRealArray;var Revenue:TReal);<N>//   Procedure ProblemFunctionHelp(var lamda,mu,debit:TReal);<N><N>
unit BAPHashList;<N>{$mode objfpc}{$H+}<N>interface<N> uses<N>  Hash,<N>  BAPSolution,<N>  TwoConnectList;<N> type<N>  PTBAPHashList = ^TBAPHashList;<N>  TBAPHashList = Class(THash)<N>  public<N>   Capacity :Integer;<N>   List :TTwoConnectList;<N><N>   Constructor Create;<N>   Destructor Destroy;override;<N><N>
   Procedure GetMemory;virtual;<N>   Procedure FreeMemory;virtual;<N><N>   procedure Add(x:PTObject);<N>   function Find(x:PTObject):PTObject;<N>   function Equal(const x,y:PTObject):boolean;<N><N>   Function GetMaxSize:Integer;<N>   Procedure SetMaxSize(s:integer);<N>   Property MaxSize:Integer read GetMaxSize write SetMaxSize;<N><N>
unit CodeObject;<N>interface<N> {$mode objfpc}{$H+}<N>{$interfaces corba}<N>  uses<N>  Cryptographer;<N> type<N>  PICodeObject = ^ICodeObject;<N>  ICodeObject = Interface<N>       Procedure SetCode(var x:TCryptographer);<N>       Function GetCode:Double;<N>       Property Code:Double read GetCode;<N>  end;<N>implementation<N>end.<N><N>
unit BBMIRs;<N>interface<N> uses<N>  VarType,<N>  IterRs;<N> type<N>  TBBMIterationResults = Class<N>  private<N>   FAmountIterationMean        :TReal;<N>   FAmountTimeMean             :TReal;<N>   FExpectation                :TReal;<N>   FDispersion                 :TReal;<N>   FTrustInterval              :TReal;<N><N>
   FBestRecordNumber           :TInt;<N>   FWorseRecordNumber          :TInt;<N><N>   FQuantity                   :TInt;<N>   FRealQuantity               :TInt;<N>   FSize                       :TInt;<N><N>   Function GetSize_:TInt;<N>   Procedure SetQuantity(x:TInt);<N>   Function GetQuantity_:TInt;<N>   Function GetRealQuantity_:TInt;   <N>  public<N>   RunResult                  :ResultArray;<N><N>
   Constructor Create(var x:TIterationResults);overload;<N>   Destructor Destroy;override;<N><N>   Procedure GetMemory;<N>   Procedure FreeMemory;<N>   Procedure Assign(var x:TIterationResults);<N><N>   Procedure AppendInFile(name : TString);<N>   Procedure RewriteFile(name : TString);<N><N>
   Procedure GetStatistic;<N>   Procedure FindBest;<N>   Procedure FindWorse;<N>   Procedure FindAll;<N><N>   Property AmountIterationMean :TReal read FAmountIterationMean write FAmountIterationMean;<N>   Property AmountTimeMean :TReal read FAmountTimeMean write FAmountTimeMean;<N>   Property Expectation :TReal read FExpectation write FExpectation;<N>   Property Dispersion :TReal read FDispersion write FDispersion;<N>   Property TrustInterval :TReal read FTrustInterval write FTrustInterval;<N><N>
   Property Size:TInt read FSize write FSize;<N>   Property Size_:TInt read GetSize_;<N><N>   Property Quantity:TInt read FQuantity write SetQuantity;<N>   Property Quantity_:TInt read GetQuantity_;<N><N>   Property RealQuantity:TInt read FRealQuantity write FRealQuantity;<N>   Property RealQuantity_:TInt read GetRealQuantity_;<N><N>
   Property BestRecordNumber :TInt read FBestRecordNumber;<N>   Property WorseRecordNumber:TInt read FWorseRecordNumber;<N>  end;<N>implementation<N> uses Sysutils;<N>{******************************************************************************}<N> Procedure TIterationResults.GetStatistic;<N> var<N>   i:TInt;<N>   sum:TReal;<N> begin<N>  sum:=0;<N>  for i:=0 to RealQuantity_ do<N>   sum:=sum+RunResult[i].RunTime;<N>  AmountTimeMean:=sum/(RealQuantity*1.0);<N><N>
   sum:=0;<N>   for i:=0 to RealQuantity_ do<N>    sum:=sum+RunResult[i].Getvalue;<N>   Expectation:=sum/(RealQuantity*1.0);<N><N>   sum:=0;<N>   for i:=0 to RealQuantity_ do<N>    sum:=sum+(Expectation-RunResult[i].Getvalue)*(Expectation-RunResult[i].Getvalue);<N>   if RealQuantity = 1 then<N>    Dispersion:=0<N>   else<N>    Dispersion:=sum/(1.0*RealQuantity-1.0);<N><N>
   sum:=Dispersion/(Quantity*1.0);<N>   TrustInterval:=1.96*sqrt(sum);<N><N>   AmountIterationMean:=0;<N>   for i:=0 to RealQuantity_ do<N>    AmountIterationMean:=AmountIterationMean+Runresult[i].AmountIteration;<N>   AmountIterationMean:=AmountIterationMean/(RealQuantity*1.0);<N><N>
 end;<N>{******************************************************************************}<N> Procedure TIterationResults.AppendInFile(name : TString);<N> var<N>  s:TString;<N>  f:TextFile;<N>  i,j:TInt;<N> begin<N>  if name<> '' then<N>  begin<N>   AssignFile(f,name);<N>   Append(f);<N><N>
   writeln(f,Name);<N><N>   FindAll;<N><N>   s:=b1;<N>   for i:=0 to Size_ do<N>    s:=s+IntToStr(RunResult[BestRecordNumber].Element[i])+' ';<N>   writeln(f,s);<N><N>   s:=b2+FloatToStr(RunResult[BestRecordNumber].GetValue);<N>   writeln(f,s);<N><N>   s:=b3;<N>   for i:=0 to size_ do<N>    s:=s+IntToStr(RunResult[WorseRecordNumber].Element[i])+' ';<N>   writeln(f,s);<N><N>
   s:=b4+FloatToStr(RunResult[WorseRecordNumber].GetValue);<N>   writeln(f,s);<N><N>   s:=b5+FloatToStr(Expectation);<N>   writeln(f,s);<N><N>   s:=b6+FloatToStr(Dispersion);<N>   writeln(f,s);<N><N>   s:=b7+FloatToStr(TrustInterval);<N>   writeln(f,s);<N><N>
unit Problem;<N>{$mode objfpc}{$H+}<N>{$interfaces corba}<N>interface<N>uses<N>  Classes<N>  ,SysUtils<N>  ,Solution;<N>type<N>  PTProblem = ^TProblem;<N>  TProblem = class<N>  public<N>   Procedure GetMemory;virtual;abstract;<N>   Procedure FreeMemory;virtual;abstract;<N>   Function GetSize :Integer;virtual;abstract;<N>   Function GetSize_:Integer;virtual;abstract;<N>   Procedure SetValue(x:TSolution);virtual;abstract;<N>   Function GetUpBoundary(i:Integer):Integer;virtual;abstract;<N><N>
unit MachineLine;<N>interface<N> uses<N>  VarType,<N>  Buffer,<N>  Classes;<N> const<N>  MS = 2147483647;<N>  eps = 1e-6;<N> type<N><N>  PTMachineLine = ^TMachineLine;<N>  TMachineLine = Class<N>  private<N>   FCMQuantity : TInt; //Considered machine quantity<N>   FCBQuantity : TInt; //Considered buffer quantity<N><N>
   FMachineQuantity : TInt;<N>   FBufferQuantity : TInt;<N><N><N>   Procedure SetMachineQuantity(x:TInt);<N>   Procedure SetBufferQuantity(x:TInt);<N><N>   Function GetMachineQuantity_: TInt;<N>   Function GetBufferQuantity_: TInt;<N>  public<N>   Machine : array of TMachine;<N>   Buffer : array of TBuffer;<N><N>
   CMachine : TBoolArray; //machine that we use<N>   CBuffer : TBoolArray; //buffer that we use<N><N>   Constructor Create(var x : TMachineLine);overload;<N>   Destructor Destroy;override;<N><N>   Procedure GetMachineMemory;<N>   Procedure GetBufferMemory;<N>   Procedure FreeMachineMemory;<N>   Procedure FreeBufferMemory;<N><N>
   Procedure Load(var f : TStringList);overload;<N>   Procedure Assign(var x:TMachineLine);<N><N>   Function R1:TIndex;<N>   Function R1f:TIndex;<N><N>   procedure parl(var l1,m1,u1,l2,m2,u2:TReal);<N><N>   Procedure ReduceLine(<N>             var l1,m1,u1,stock_cost:TReal;<N>             var inv_coef:TReal;<N>             var det_cost:TRealArray<N>                       );<N>   procedure equiv(var lam1r,mu1r,deb1r,lam2r,mu2r,deb2r,hr,avg_stockr:TReal);<N><N>
   Property CMQuantity: TInt read FCMQuantity write FCMQuantity;<N>   Property CBQuantity: TInt read FCBQuantity write FCBQuantity;<N><N>   Property MachineQuantity: TInt read FMachineQuantity write SetMachineQuantity;<N>   Property BufferQuantity: TInt read FBufferQuantity write SetBufferQuantity;<N><N>
unit TwoConnectList;{Two connect list}<N>{$MODE OBJFPC}<N>interface<N> type<N>  PTObject = ^TObject;<N>  TEqualFunction = function(const x,y:PTObject):boolean of object;<N><N>  PTElement = ^TElement;<N>  TElement = Class<N>   Next : PTElement;<N>   Previous : PTElement;<N>   Data:PTObject;<N>  end;<N><N>
  PTTwoConnectList = ^TTwoConnectList;<N>  TTwoConnectList = Class<N>  protected<N>   First    :PTElement;<N>   Last    :PTElement;<N><N>   _MaxSize:Integer;<N>   Size   :Integer;<N><N>   EqualFunction:TEqualFunction;<N><N>  public<N>   Constructor Create(func:TEqualFunction; MaxSizeList:Integer = 100);<N>   Destructor Destroy;override;<N><N>
   Procedure GetMemory;<N>   Procedure FreeMemory;<N><N>   Procedure PushInEnd(d:PTObject);<N>   Procedure PushInBegin(d:PTObject);<N>   Procedure PushOutFirst;<N>   Procedure PushOutLast;<N><N>   procedure Add(x:PTObject);overload;<N><N>   function Find(x:PTObject):PTObject;<N><N>
   Property MaxSize:Integer read _MaxSize write _MaxSize;<N><N>  end;<N>implementation<N>uses<N> Sysutils;<N>{******************************************************************************}<N> Constructor TTwoConnectList.Create(func:TEqualFunction; MaxSizeList:Integer = 100);<N> begin<N>  EqualFunction:=func;<N><N>
unit SetEvaluation;<N><N>{$MODE Delphi}<N><N>interface<N>uses<N> VarType,<N> Solution;<N> type<N>  PTSetEvaluation = ^TSetEvaluation;<N>  TSetEvaluation = Class<N>  private<N>   Function GetEvaluation :TReal;<N>   Function GetSize :TInt;<N>   Procedure SetSize(x:TInt);<N>  public<N>   BuffersFull:TSolution;<N>   BuffersEmpty:TSolution;<N><N>
unit LocalSearch;<N>interface<N> uses<N>  Solver,<N>  Solution,<N>  Classes;<N> type<N>  PTLS = ^TLS;<N>  TLS = class(TSolver)<N>  private<N>   _order_vector                    :Array of integer;<N>   _NewRecord                       :TSolution;<N>   _NewSolution                     :TSolution;<N><N>
  public<N>   OderIndexBP                      :Integer;<N>   FirstRecordList                  :TStringList;<N><N>   Constructor Create;overload;<N>   Destructor Destroy;overload;<N><N>   Procedure GetMemory;override;<N>   Procedure FreeMemory;override;<N><N>
   Procedure Load(var f : TStringList);<N><N>   Procedure Iteration;override;<N>   Procedure FirstApproximation;override;<N><N>   Procedure LocalSearch_Hamming();<N><N>   Procedure ShowResults;override;<N>   Procedure SaveStatistic;override;<N>   Function StopIterations:boolean;override;<N><N>
  end;<N>implementation<N> uses<N>  SysUtils,<N>  Math,<N>  FOrder;<N>{******************************************************************************}<N> Constructor TLS.Create;<N> begin<N>  inherited;<N>  _NewRecord:=TSolution.Create;<N>  _NewSolution:=TSolution.Create;<N>  FirstRecordList := TStringList.Create;<N>  FirstRecordList.Duplicates:=dupIgnore;<N>  FirstRecordList.Sorted:=false;<N><N>
unit TCList;{Two connect list}<N>{$MODE OBJFPC}<N>interface<N>uses Equalable;<N> type<N>  PTObject = ^TObject;<N>  TEqualFunction = function(x,y:PTObject):boolean;<N>  PTElement = ^TElement;<N>  TElement = Class<N>   Next : PTElement;<N>   Previous : PTElement;<N>   data:PTObject;<N>  end;<N><N>
  PTTCList = ^TTCList;<N>  TTCList = Class<N>  public<N>   EqualFunction:TEqualFunction;<N><N>   First    :PTElement;<N>   CurrentLast    :PTElement;<N>   Last    :PTElement;<N><N>   MaxCapacity     :Integer;<N>   CurentCapacity  :Integer;<N>   Size  :Integer;<N><N>
   Constructor Create(func:TEqualFunction);<N>   Destructor Destroy;override;<N><N>   Procedure GetMemory;<N>   Procedure FreeMemory;<N><N>   function CreateNewElement:PTElement;<N><N>   Procedure PushInListEnd(d:PTObject);<N>   Procedure PushOutFirst;<N><N>
   procedure Add(s:PTObject);overload;<N><N>   function Find(x:PTObject):PTObject;<N><N>  end;<N>implementation<N>uses<N> Sysutils;<N>{******************************************************************************}<N> Constructor TTCList.Create(func:TEqualFunction);<N> begin<N>  EqualFunction:=func;<N><N>
unit TabuList;<N>interface<N>uses<N> VarType,<N> Solution;<N> type<N>  PTEData = ^TEData;<N>  TEData = Class<N>   Index:TInt;<N>   Tabu:TInt;<N>   Constructor Create(var x:TEData);overload;<N>   Procedure Assign(var x:TEData);<N>   Function Equal(var x:TEData):TBool;overload;<N>   Function Equal(x:TInt;i:TInt):TBool;overload;<N>  end;<N><N>
  PTElement = ^TElement;<N>  TElement = Class(TEData)<N>   Next : PTElement;<N>   Previous : PTElement;<N>   Constructor Create(var x:TEData);overload;<N>  end;<N><N>  PTTabuList = ^TTabuList;<N>  TTabuList = Class<N>  private<N>   FCurentCapacity  :TInt;<N>   procedure ChangeCapacity(s:TInt);<N>  public<N><N>
   First    :PTElement;<N>   CurrentLast    :PTElement;<N>   Last    :PTElement;<N><N>   MaxCapacity     :TInt;<N>   Size  :TInt;<N><N>   Constructor Create;<N>   Destructor Destroy;<N><N>   Procedure GetMemory;<N>   Procedure FreeMemory;<N><N>   Procedure PushInListEnd(var x:PTElement);<N>   Procedure PushOutFirst;<N><N>
unit BAPSolution;<N><N>{$mode ObjFPC}<N><N>interface<N> uses<N>  Cryptographer,<N>  Solution,<N>  CodeObject;<N> type<N>  T = Integer;<N>{$DEFINE INTERFACE}<N>{$INCLUDE 'Vector.inc'}<N><N>  PTBAPSolution = ^TBAPSolution;<N>  TBAPSolution = Class(TSolution,ICodeObject)<N>  protected<N>   Code_            :Double;<N>   Revenue_         :Double;<N>   Expense_         :Double;<N>   Throughput_      :Double;<N>   Volume_          :Integer;<N>   StorageCost_     :Double;<N>   _Buffer          :TVector;<N><N>
  public<N>   Constructor Create;overload;<N>   Constructor Create(const x : TBAPSolution);overload;<N>   Destructor Destroy;<N><N>   Procedure Assign(const x:TBAPSolution);<N>   Procedure Assign(const x:TObject);overload;<N><N>   Procedure SetCode(var x:TCryptographer);<N>   Function GetCode:Double;<N><N>
   Procedure GetMemory;override;<N>   Procedure FreeMemory;override;<N><N>   Function IsIdentical(const x:TObject):boolean;overload;<N>   Function IsEqual(const x:TObject):boolean;overload;<N>   Function IsNotEqual(const x:TObject):boolean;overload;<N>   Function IsBetter(const x:TObject):boolean;overload;<N>   Function IsBetterOrEqual(const x:TObject):boolean;overload;<N>   Function IsWorseOrEqual(const x:TObject):boolean;overload;<N>   Function IsWorse(const x:TObject):boolean;overload;<N><N>
   Function ToString:ansistring;overload;<N><N>   Property Volume:Integer read Volume_ write Volume_;<N>   Property Revenue:Double read Revenue_ write Revenue_;<N>   Property Expense:Double read Expense_ write Expense_;<N>   Property Throughput:Double read Throughput_ write Throughput_;<N>   Property StorageCost:Double read StorageCost_ write StorageCost_;<N>   Property Code:Double read GetCode;<N><N>
   Function GetValue:Double;<N>   Property Value:Double read GetValue;<N>   Function GetElement(Index:integer):T;<N>   Procedure SetElement(Index:integer;Val:T);<N>   Function GetSize :Integer;<N>   Function GetSize_ :Integer;<N>   Procedure SetSize(x:Integer);<N><N>
unit BAPGA;<N>interface<N> uses<N>  Solver,<N>  Solution,<N>  Problem,<N>  BAPSolution,<N>  BAPReduceLine,<N>  Population,<N>  Classes;<N> type<N>  PTBAPGA = ^TBAPGA;<N>  TBAPGA = class(TSolver)<N>  private<N>   _order_vector                    :array of integer;<N>   _Task                          :TBAPReduceLine;<N>   _NewRecord                       :TBAPSolution;<N>   _NewSolution                     :TBAPSolution;<N>   _NowRecord                       :TBAPSolution;<N><N>
   Function GetPopulationQuantity_  :integer;<N>  public<N><N><N>   Population                       :Array of TPopulation;<N>   PopulationQuantity               :integer;<N>   PopulationSize                   :array of integer;<N><N>   MutationIndex                    :integer;<N>   MutationParameter                :double;<N><N>
   AdderMutationIndex               :integer;<N>   AdderMutationParameter           :double;<N><N>   LocalSearchIndex                 :integer;<N>   LocalSearchParameter             :integer;<N><N>   AdderLocalSearchIndex                 :integer;<N>   AdderLocalSearchParameter             :integer;<N><N>
   OderIndex                        :integer;<N><N>   CrossoverIndex                   :integer;<N>   CrossoverParameter               :double;<N><N>   SelectionIndex                   :integer;<N>   SelectionParameter               :double;<N><N>   Constructor Create;overload;<N>   Destructor Destroy;overload;<N><N>
unit Population;<N>interface<N> uses<N>  VarType,<N>  BAPSolution;<N> type<N>  IndividualArray = array of TBAPSolution;<N>  PTPopulation = ^TPopulation;<N>  TPopulation = Class<N>  private<N>   FQuantity            :TInt;<N>   FSize                :TInt;<N><N>
   FBestSolutionNumber  :TInt;<N>   FWorseSolutionNumber :TInt;<N><N>   Function GetSize_:TInt;<N>   Procedure SetQuantity(x:TInt);<N>   Function GetQuantity_:TInt;<N>  public<N>   Individual          :IndividualArray;<N><N>   Constructor Create(var x:TPopulation);overload;<N>   Destructor Destroy;<N><N>
   Procedure GetMemory;virtual;<N>   Procedure FreeMemory;virtual;<N><N>   Procedure Assign(var x:TPopulation);overload;<N><N>   Procedure FindBest;<N>   Procedure FindWorse;<N>   Procedure FindAll;<N><N>   Function FindTheSameIndividual( var x:TBAPSolution; var q:TInt):TBool;<N><N>
unit Hash;<N>interface<N>{$mode objfpc}{$H+}<N>{$interfaces corba}<N><N> type<N>  PTObject = ^TObject;<N>  PTHash = ^THash;<N>  THash = class<N>  public<N>    procedure Add(x:PTObject);virtual;abstract;<N>    function Find(x:PTObject):PTObject;virtual;abstract;<N>    function Equal(const x,y:PTObject):boolean;virtual;abstract;<N>  end;<N>implementation<N>end.<N><N><N>
unit VarType;<N>interface<N>const<N>  am=255;<N>  an=255;<N>  mx=1.0e+37;<N>  max=255;<N>  min=-1e30;<N> type<N>{MAIN--------------------------------------------------------------------------}<N>  TIndex = Integer;<N>  TPointer = Pointer;<N>//  TVariant = Variant;<N>  TInt = Integer;<N>  TReal = Double;<N>  TBool = Boolean;<N>  TString = string;<N>  TChar = char;<N><N>
  PTInt = ^TInt;<N>  PTReal = ^TReal;<N><N>  PTBool = ^TBool;<N>  PTString = ^TString;<N>  PTChar = ^TChar;<N><N>//  TVariantArray = array of TVariant;<N>  TIntArray = array of TInt;<N>  TRealArray = array of TReal;<N>  TBoolArray = array of TBool;<N>  TStringArray = array of TString;<N>  TCharArray = array of TChar;<N><N>
  TPIntArray = array of PTInt;<N>  TPRealArray = array of PTReal;<N><N>  TPBoolArray = array of PTBool;<N>  TPStringArray = array of PTString;<N>  TPCharArray = array of PTChar;<N><N>  PTIntArray = ^TIntArray;<N>  PTRealArray = ^TRealArray;<N>  PTBoolArray = ^TBoolArray;<N><N>
unit Buffer;<N>{$MODE OBJFPC}<N>interface<N> uses<N>  VarType;<N> type<N><N>  PTBuffer = ^TBuffer;<N>  PTMachine = ^TMachine;<N><N>  TMachine = Record<N><N>   Number : TInt; //Machine number<N>   ListNumberGDB : TInt; //Number in list of giving detail buffer<N>   ListNumberTDB : TInt; //Number in list of taking detail buffer<N><N>
   Lambda : TReal;<N>   Mu : TReal;<N>   C : TReal;<N><N>   NumberGDB : TInt; //Number giving detail buffer<N>   NumberTDB : TInt; //Number taking detail buffer<N>  end;<N><N>  TBuffer = Class<N>  private<N>   FNumber : TInt; //Buffer number<N>   FSize : TReal;<N>   FMachineQuantity : TInt;<N>   FPDMQuantity : TInt; //Puting detail machine quantity<N>   FTDMQuantity : TInt; //Taking detail machine quantity<N>   Procedure SetMachineQuantity(x:TInt);<N>   Function GetMachineQuantity_:TInt;<N>  public<N><N>
   NumberPDM : array of TInt; //Puting detail machine<N>   NumberTDM : array of TInt; //Taking detail machine<N><N>   Constructor Create(var x : TBuffer);overload;<N>   Destructor Destroy;override;<N>   Procedure GetMemory;<N>   Procedure FreeMemory;<N><N>
unit MachineLine;<N>{$MODE OBJFPC}<N>interface<N> uses<N>  VarType,<N>  Buffer,<N>  Classes;<N> const<N>  MS = 2147483647;<N>  eps = 1e-6;<N> type<N><N>  PTMachineLine = ^TMachineLine;<N>  TMachineLine = Class<N>  private<N>   FCMQuantity : TInt; //Considered machine quantity<N>   FCBQuantity : TInt; //Considered buffer quantity<N><N>
   FMachineQuantity : TInt;<N>   FBufferQuantity : TInt;<N><N>   Procedure SetMachineQuantity(x:TInt);<N>   Procedure SetBufferQuantity(x:TInt);<N><N>   Function GetMachineQuantity_: TInt;<N>   Function GetBufferQuantity_: TInt;<N>  public<N>   Machine : array of TMachine;<N>   Buffer : array of TBuffer;<N><N>
   CMachine : TBoolArray; //machine that we use<N>   CBuffer : TBoolArray; //buffer that we use<N><N>   Constructor Create(var x : TMachineLine);overload;<N>   Destructor Destroy;override;<N><N>   Procedure GetMachineMemory;<N>   Procedure GetBufferMemory;<N>   Procedure FreeMachineMemory;<N>   Procedure FreeBufferMemory;<N><N>
   Procedure Load(var f : TStringList);overload;<N>   Procedure Assign(var x:TMachineLine);<N><N>   Function R1:TIndex;<N>   Function R1(ind:TIndex):TIndex;<N>   Function R1f:TIndex;<N><N>   procedure parl(var l1,m1,u1,l2,m2,u2:TReal);<N>   Procedure AverageStock();<N>   Procedure ReduceLine(<N>             var l1,m1,u1,stock_cost:TReal;<N>             var inv_coef:TReal;<N>             var det_cost:TRealArray<N>                       );<N>   Function GetAverageStockForBuffer(ind:TIndex):TReal;<N><N>
   procedure equiv(var lam1r,mu1r,deb1r,lam2r,mu2r,deb2r,hr,avg_stockr:TReal);<N><N>   Property CMQuantity: TInt read FCMQuantity write FCMQuantity;<N>   Property CBQuantity: TInt read FCBQuantity write FCBQuantity;<N><N>   Property MachineQuantity: TInt read FMachineQuantity write SetMachineQuantity;<N>   Property BufferQuantity: TInt read FBufferQuantity write SetBufferQuantity;<N><N>
unit Cryptographer;<N>interface<N> uses<N>  VarType;<N> type<N><N>  PTCryptographer = ^TCryptographer;<N>  TCryptographer = Class<N>  private<N>   FSize :TInt;<N>   Function GetSize_:TInt;<N>   Procedure SetSize(x:TInt);<N>  public<N>   CodeArray :TRealArray;<N><N>
   Constructor Create(var x:TCryptographer);overload;<N>   Destructor Destroy;override;<N><N>   Procedure GetMemory;<N>   Procedure FreeMemory;<N><N>   Procedure Assign(var x:TCryptographer);<N><N>   Function MakeCode(var x : TRealArray):TReal;overload;<N>   Function MakeCode(var x : TIntArray):TReal;overload;<N><N>
unit Solver;<N><N>{$MODE Delphi}<N><N>interface<N> uses<N>  SysUtils,<N>  Classes,<N>  VarType,<N>  Solution,<N>// IterRs,<N>  Statistic,<N>  Problem;<N>const<N> a1 = 'Current operation: ';<N> a2 = 'Best solution: ';<N> a3 = 'Best solution value: ';<N> a4 = 'Run number: ';<N> a5 = 'Iteration namber: ';<N> a6 = 'Time: ';<N><N>
unit RunStatistic;<N>interface<N> uses<N>  VarType,<N>  Classes,<N>  Solution;<N> type<N>  PTRunStatistic = ^TRunStatistic;<N>  TRunStatistic = Class<N>  private<N>   __RunTime                  :TReal;<N>   __AmountIteration          :TInt;<N>   FStrForLocalDesent   :TString;<N>  public<N>   Result                   :TSolution;<N>   IterationStatistic       :TStringList;<N><N>
unit BBMIRs;<N>interface<N> uses<N>  VarType,<N>  IterRs;<N> type<N>  TBBMIterationResults = Class<N>  private<N>   FAmountIterationMean        :TReal;<N>   FAmountTimeMean             :TReal;<N>   FExpectation                :TReal;<N>   FDispersion                 :TReal;<N>   FTrustInterval              :TReal;<N><N>
   FBestRecordNumber           :TInt;<N>   FWorseRecordNumber          :TInt;<N><N>   FQuantity                   :TInt;<N>   FRealQuantity               :TInt;<N>   FSize                       :TInt;<N><N>   Function GetSize_:TInt;<N>   Procedure SetQuantity(x:TInt);<N>   Function GetQuantity_:TInt;<N>   Function GetRealQuantity_:TInt;   <N>  public<N>   RunResult                  :ResultArray;<N><N>
   Constructor Create(var x:TIterationResults);overload;<N>   Destructor Destroy;override;<N><N>   Procedure GetMemory;<N>   Procedure FreeMemory;<N>   Procedure Assign(var x:TIterationResults);<N><N>   Procedure AppendInFile(name : TString);<N>   Procedure RewriteFile(name : TString);<N><N>
   Procedure GetStatistic;<N>   Procedure FindBest;<N>   Procedure FindWorse;<N>   Procedure FindAll;<N><N>   Property AmountIterationMean :TReal read FAmountIterationMean write FAmountIterationMean;<N>   Property AmountTimeMean :TReal read FAmountTimeMean write FAmountTimeMean;<N>   Property Expectation :TReal read FExpectation write FExpectation;<N>   Property Dispersion :TReal read FDispersion write FDispersion;<N>   Property TrustInterval :TReal read FTrustInterval write FTrustInterval;<N><N>
   Property Size:TInt read FSize write FSize;<N>   Property Size_:TInt read GetSize_;<N><N>   Property Quantity:TInt read FQuantity write SetQuantity;<N>   Property Quantity_:TInt read GetQuantity_;<N><N>   Property RealQuantity:TInt read FRealQuantity write FRealQuantity;<N>   Property RealQuantity_:TInt read GetRealQuantity_;<N><N>
   Property BestRecordNumber :TInt read FBestRecordNumber;<N>   Property WorseRecordNumber:TInt read FWorseRecordNumber;<N>  end;<N>implementation<N> uses Sysutils;<N>{******************************************************************************}<N> Procedure TIterationResults.GetStatistic;<N> var<N>   i:TInt;<N>   sum:TReal;<N> begin<N>  sum:=0;<N>  for i:=0 to RealQuantity_ do<N>   sum:=sum+RunResult[i].RunTime;<N>  AmountTimeMean:=sum/(RealQuantity*1.0);<N><N>
   sum:=0;<N>   for i:=0 to RealQuantity_ do<N>    sum:=sum+RunResult[i].Getvalue;<N>   Expectation:=sum/(RealQuantity*1.0);<N><N>   sum:=0;<N>   for i:=0 to RealQuantity_ do<N>    sum:=sum+(Expectation-RunResult[i].Getvalue)*(Expectation-RunResult[i].Getvalue);<N>   if RealQuantity = 1 then<N>    Dispersion:=0<N>   else<N>    Dispersion:=sum/(1.0*RealQuantity-1.0);<N><N>
   sum:=Dispersion/(Quantity*1.0);<N>   TrustInterval:=1.96*sqrt(sum);<N><N>   AmountIterationMean:=0;<N>   for i:=0 to RealQuantity_ do<N>    AmountIterationMean:=AmountIterationMean+Runresult[i].AmountIteration;<N>   AmountIterationMean:=AmountIterationMean/(RealQuantity*1.0);<N><N>
 end;<N>{******************************************************************************}<N> Procedure TIterationResults.AppendInFile(name : TString);<N> var<N>  s:TString;<N>  f:TextFile;<N>  i,j:TInt;<N> begin<N>  if name<> '' then<N>  begin<N>   AssignFile(f,name);<N>   Append(f);<N><N>
   writeln(f,Name);<N><N>   FindAll;<N><N>   s:=b1;<N>   for i:=0 to Size_ do<N>    s:=s+IntToStr(RunResult[BestRecordNumber].Element[i])+' ';<N>   writeln(f,s);<N><N>   s:=b2+FloatToStr(RunResult[BestRecordNumber].GetValue);<N>   writeln(f,s);<N><N>   s:=b3;<N>   for i:=0 to size_ do<N>    s:=s+IntToStr(RunResult[WorseRecordNumber].Element[i])+' ';<N>   writeln(f,s);<N><N>
   s:=b4+FloatToStr(RunResult[WorseRecordNumber].GetValue);<N>   writeln(f,s);<N><N>   s:=b5+FloatToStr(Expectation);<N>   writeln(f,s);<N><N>   s:=b6+FloatToStr(Dispersion);<N>   writeln(f,s);<N><N>   s:=b7+FloatToStr(TrustInterval);<N>   writeln(f,s);<N><N>
unit Problem;<N>interface<N> uses<N>  Classes,<N>  Solution,<N>  VarType,<N>  MachineLine,<N>  TCList,<N>  Cryptographer,<N>  HashTable,<N>  FPlin;<N> type<N><N>  PTProblem = ^TProblem;<N>  TProblem = Class<N>  Private<N>   Function GetSize :TInt;<N>   Function GetSize_ :TInt;<N>  public<N>   RememberMachineLine             :TMachineLine;<N>   UseMachineLine                  :TMachineLine;<N><N>
   RememberSimpleMachineLine       :TMachineLine;<N>   UseSimpleMachineLine            :TMachineLine;<N><N>   CodeMaker                       :TCryptographer;<N><N>   List                            :THashTable;<N>//   List                            :TTCList;<N><N>
   UpBoundary                      :TIntArray;<N><N>   revenuefunction                 :a_function;<N>   alloc_costfunction              :a_function;<N>   amort                           :TReal;<N>   inv_coef                        :TReal;<N>   det_cost                        :TRealArray;<N><N>
   CalcValueCount                  :integer;<N><N>   Constructor Create;overload;<N>   Constructor Create(var x : TProblem);overload;<N>   Destructor Destroy;override;<N><N>   Procedure GetMemory;<N>   Procedure FreeMemory;<N><N>   Procedure Load(var f : TStringList);<N>   Procedure Assign(var x:TProblem);<N><N>
   Procedure GetSolutionValue(var x:TSolution);<N>   Procedure ProblemFunction(var x:TIntArray;var Value:TValue);overload;<N>   Procedure ProblemFunction(var x:TIntArray;var Revenue,Expense,Throughput,Volume,StorageCost:TReal);overload;<N>   Procedure ProblemFunction(var x:TRealArray;var Revenue,Expense,Throughput,Volume,StorageCost:TReal);overload;<N>   Procedure BottleneckProblemFunction(var x:TRealArray;var Revenue:TReal);<N>   Procedure ProblemFunctionHelp(var lamda,mu,debit:TReal);<N><N>
   Procedure SetMachineLine(var x:TMachineLine);<N>   Function MethodTime:TDateTime;<N><N>   Property Size :TInt read GetSize;<N>   Property Size_ :TInt read GetSize_;<N>  end;<N>implementation<N>uses SysUtils;<N>{******************************************************************************}<N> Constructor TProblem.Create;<N> var i:TInt;<N> begin<N>  CalcValueCount:=0;<N><N>
  RememberMachineLine:=TMachineLine.Create;<N>  UseMachineLine:=TMachineLine.Create;<N>  RememberSimpleMachineLine:=TMachineLine.Create;<N>  RememberSimpleMachineLine.MachineQuantity:=2;<N>  RememberSimpleMachineLine.BufferQuantity:=3;<N><N>  RememberSimpleMachineLine.Buffer[0].MachineQuantity:=2;<N>  RememberSimpleMachineLine.Buffer[1].MachineQuantity:=2;<N>  RememberSimpleMachineLine.Buffer[2].MachineQuantity:=2;<N><N>
  RememberSimpleMachineLine.Buffer[0].Size:=2147483647;<N>  RememberSimpleMachineLine.Buffer[2].Size:=2147483647;<N><N>  RememberSimpleMachineLine.Machine[0].Number:=0;<N>  RememberSimpleMachineLine.Machine[0].NumberGDB:=0;<N>  RememberSimpleMachineLine.Machine[0].ListNumberGDB:=RememberSimpleMachineLine.Buffer[0].AddTDMachine(0);<N>  RememberSimpleMachineLine.Machine[0].NumberTDB:=1;<N>  RememberSimpleMachineLine.Machine[0].ListNumberTDB:=RememberSimpleMachineLine.Buffer[1].AddPDMachine(0);<N><N>
  RememberSimpleMachineLine.Machine[1].Number:=1;<N>  RememberSimpleMachineLine.Machine[1].NumberGDB:=1;<N>  RememberSimpleMachineLine.Machine[1].ListNumberGDB:=RememberSimpleMachineLine.Buffer[1].AddTDMachine(1);<N>  RememberSimpleMachineLine.Machine[1].NumberTDB:=2;<N>  RememberSimpleMachineLine.Machine[1].ListNumberTDB:=RememberSimpleMachineLine.Buffer[2].AddPDMachine(1);<N><N>
unit MachineLine;<N>interface<N> uses<N>  VarType,<N>  Buffer,<N>  Classes;<N> const<N>  MS = 2147483647;<N>  eps = 1e-6;<N> type<N><N>  PTMachineLine = ^TMachineLine;<N>  TMachineLine = Class<N>  private<N>   FCMQuantity : TInt; //Considered machine quantity<N>   FCBQuantity : TInt; //Considered buffer quantity<N><N>
   FMachineQuantity : TInt;<N>   FBufferQuantity : TInt;<N><N><N>   Procedure SetMachineQuantity(x:TInt);<N>   Procedure SetBufferQuantity(x:TInt);<N><N>   Function GetMachineQuantity_: TInt;<N>   Function GetBufferQuantity_: TInt;<N>  public<N>   Machine : array of TMachine;<N>   Buffer : array of TBuffer;<N><N>
   CMachine : TBoolArray; //machine that we use<N>   CBuffer : TBoolArray; //buffer that we use<N><N>   Constructor Create(var x : TMachineLine);overload;<N>   Destructor Destroy;override;<N><N>   Procedure GetMachineMemory;<N>   Procedure GetBufferMemory;<N>   Procedure FreeMachineMemory;<N>   Procedure FreeBufferMemory;<N><N>
   Procedure Load(var f : TStringList);overload;<N>   Procedure Assign(var x:TMachineLine);<N><N>   Function R1:TIndex;<N>   Function R1f:TIndex;<N><N>   procedure parl(var l1,m1,u1,l2,m2,u2:TReal);<N><N>   Procedure ReduceLine(<N>             var l1,m1,u1,stock_cost:TReal;<N>             var inv_coef:TReal;<N>             var det_cost:TRealArray<N>                       );<N>   procedure equiv(var lam1r,mu1r,deb1r,lam2r,mu2r,deb2r,hr,avg_stockr:TReal);<N><N>
   Property CMQuantity: TInt read FCMQuantity write FCMQuantity;<N>   Property CBQuantity: TInt read FCBQuantity write FCBQuantity;<N><N>   Property MachineQuantity: TInt read FMachineQuantity write SetMachineQuantity;<N>   Property BufferQuantity: TInt read FBufferQuantity write SetBufferQuantity;<N><N>
unit IterRs;<N>interface<N> uses<N>  VarType,<N>  IterR;<N> const<N>  b1 = 'Best solve: ';<N>  b2 = 'Best solve value: ';<N>  b3 = 'Worse solve: ';<N>  b4 = 'Worse solve value: ';<N>  b5 = 'Expectation: ';<N>  b6 = 'Variance: ';<N>  b7 = 'Confidence segment: ';<N>  b8 = 'Amount iteration mean at one run: ';<N>  b9 = 'Amount time mean one run: ';<N><N>
 type<N>  ResultArray = array of TIterationResult;<N>  PTIterationResults = ^TIterationResults;<N>  TIterationResults = Class<N>  private<N>   FAmountIterationMean        :TReal;<N>   FAmountTimeMean             :TReal;<N>   FExpectation                :TReal;<N>   FDispersion                 :TReal;<N>   FTrustInterval              :TReal;<N><N>
   FBestRecordNumber           :TInt;<N>   FWorseRecordNumber          :TInt;<N><N>   FQuantity                   :TInt;<N>   FRealQuantity               :TInt;<N>   FSize                       :TInt;<N><N>   Function GetSize_:TInt;<N>   Procedure SetQuantity(x:TInt);<N>   Function GetQuantity_:TInt;<N>   Function GetRealQuantity_:TInt;<N>   Procedure WriteInFile(var f:TextFile);<N>  public<N>   RunResult                  :ResultArray;<N><N>
   Constructor Create(var x:TIterationResults);overload;<N>   Destructor Destroy;override;<N><N>   Procedure GetMemory;<N>   Procedure FreeMemory;<N>   Procedure Assign(var x:TIterationResults);<N><N>   Procedure AppendInFile(name : TString);<N>   Procedure RewriteFile(name : TString);<N><N>
   Procedure GetStatistic;<N>   Procedure FindBest;<N>   Procedure FindWorse;<N>   Procedure FindAll;<N><N>   Property AmountIterationMean :TReal read FAmountIterationMean write FAmountIterationMean;<N>   Property AmountTimeMean :TReal read FAmountTimeMean write FAmountTimeMean;<N>   Property Expectation :TReal read FExpectation write FExpectation;<N>   Property Dispersion :TReal read FDispersion write FDispersion;<N>   Property TrustInterval :TReal read FTrustInterval write FTrustInterval;<N><N>
   Property Size:TInt read FSize write FSize;<N>   Property Size_:TInt read GetSize_;<N><N>   Property Quantity:TInt read FQuantity write SetQuantity;<N>   Property Quantity_:TInt read GetQuantity_;<N><N>   Property RealQuantity:TInt read FRealQuantity write FRealQuantity;<N>   Property RealQuantity_:TInt read GetRealQuantity_;<N><N>
   Property BestRecordNumber :TInt read FBestRecordNumber;<N>   Property WorseRecordNumber:TInt read FWorseRecordNumber;<N>  end;<N>implementation<N> uses Sysutils;<N>{******************************************************************************}<N> Procedure TIterationResults.GetStatistic;<N> var<N>   i:TInt;<N>   sum:TReal;<N> begin<N>  if RealQuantity_ > 0 then<N>  begin<N>    sum:=0;<N>    for i:=0 to RealQuantity_ do<N>     sum:=sum+RunResult[i].RunTime;<N><N>
    AmountTimeMean:=sum/(RealQuantity*1.0);<N><N>     sum:=0;<N>     for i:=0 to RealQuantity_ do<N>      sum:=sum+RunResult[i].Getvalue;<N>     Expectation:=sum/(RealQuantity*1.0);<N><N>     sum:=0;<N>     for i:=0 to RealQuantity_ do<N>      sum:=sum+(Expectation-RunResult[i].Getvalue)*(Expectation-RunResult[i].Getvalue);<N>     if RealQuantity = 1 then<N>      Dispersion:=0<N>     else<N>      Dispersion:=sum/(1.0*RealQuantity-1.0);<N><N>
unit SetEvaluation;<N><N>{$MODE Delphi}<N><N>interface<N>uses<N> VarType,<N> Solution;<N> type<N>  PTSetEvaluation = ^TSetEvaluation;<N>  TSetEvaluation = Class<N>  private<N>   Function GetEvaluation :TReal;<N>   Function GetSize :TInt;<N>   Procedure SetSize(x:TInt);<N>  public<N>   BuffersFull:TSolution;<N>   BuffersEmpty:TSolution;<N><N>
unit LocalSearch;<N>interface<N> uses<N>  VarType,<N>  Solver,<N>  Solution,<N>  Classes;<N> type<N>  PTLS = ^TLS;<N>  TLS = class(TSolver)<N>  private<N>   _order_vector                    :TIntArray;<N>   _NewRecord                        :TSolution;<N>   _NewSolution                      :TSolution;<N><N>
  public<N>   OderIndexBP                      :TInt;<N><N>   Constructor Create;overload;<N>   Destructor Destroy;overload;<N><N>   Procedure GetMemory;override;<N>   Procedure FreeMemory;override;<N><N>   Procedure Load(var f : TStringList);<N><N>   Procedure Iteration;override;<N>   Procedure FirstApproximation;override;<N><N>
unit TCList;{Two connect list}<N>interface<N>uses<N> VarType,<N> Solution;<N> type<N>  PTEData = PTSolution;<N>  TEData = TSolution;<N><N>  PTElement = ^TElement;<N>  TElement = Class(TEData)<N>   Next : PTElement;<N>   Previous : PTElement;<N>   Constructor Create(var x:TEData);overload;<N>  end;<N><N>
  PTTCList = ^TTCList;<N>  TTCList = Class<N>  public<N><N>   First    :PTElement;<N>   CurrentLast    :PTElement;<N>   Last    :PTElement;<N><N>   MaxCapacity     :TInt;<N>   CurentCapacity  :TInt;<N>   Size  :TInt;<N><N>   Constructor Create;<N>   Destructor Destroy;override;<N><N>
unit TabuList;<N>interface<N>uses<N> VarType,<N> Solution;<N> type<N>  PTEData = ^TEData;<N>  TEData = Class<N>   Index:TInt;<N>   Tabu:TInt;<N>   Constructor Create(var x:TEData);overload;<N>   Procedure Assign(var x:TEData);<N>   Function Equal(var x:TEData):TBool;overload;<N>   Function Equal(x:TInt;i:TInt):TBool;overload;<N>  end;<N><N>
  PTElement = ^TElement;<N>  TElement = Class(TEData)<N>   Next : PTElement;<N>   Previous : PTElement;<N>   Constructor Create(var x:TEData);overload;<N>  end;<N><N>  PTTabuList = ^TTabuList;<N>  TTabuList = Class<N>  private<N>   FCurentCapacity  :TInt;<N>   procedure ChangeCapacity(s:TInt);<N>  public<N><N>
   First    :PTElement;<N>   CurrentLast    :PTElement;<N>   Last    :PTElement;<N><N>   MaxCapacity     :TInt;<N>   Size  :TInt;<N><N>   Constructor Create;<N>   Destructor Destroy;<N><N>   Procedure GetMemory;<N>   Procedure FreeMemory;<N><N>   Procedure PushInListEnd(var x:PTElement);<N>   Procedure PushOutFirst;<N><N>
unit clearga;<N>interface<N> uses<N>  VarType,<N>  Solver,<N>  Solution,<N>  Population,<N>  Classes;<N> type<N>  PTClearGA = ^TClearGA;<N>  TClearGA = class(TSolver)<N>  private<N>   _order_vector                    :TIntArray;<N><N>   va                               :TIntArray;<N>   vb                               :TIntArray;<N>   vga                              :TRealArray;<N>   vhb                              :TRealArray;<N><N>
   Function GetPopulationQuantity_  :TInt;<N>  public<N>   NamePopulationFile               :TString;<N><N>   Population                       :Array of TPopulation;<N>   PopulationQuantity               :TInt;<N>   PopulationSize                   :TIntArray;<N><N>
   MutationIndexBP                  :TInt;//BP - begin population<N>   MutationParameterBP              :TReal;<N>   LocalSearchIndexBP               :TInt;<N>   OderIndexBP                      :TInt;<N><N>   MutationIndexDI                 :TInt;//DI - duplicate individual<N>   MutationParameterDI              :TReal;<N>   LocalSearchIndexDI               :TInt;<N>   OderIndexDI                      :TInt;<N><N>
   MutationIndex                    :TInt;<N>   MutationParameter                :TReal;<N>   LocalSearchIndex                 :TInt;<N>   LocalSearchParameter             :TInt;<N>   OderIndex                        :TInt;<N>   CrossoverIndex                   :TInt;<N>   CrossoverParameter               :TReal;<N>   SelectionIndex                   :TInt;<N>   SelectionParameter               :TReal;<N>   SelectionRadius                  :TInt;<N><N>
   OnlyBestAdd                      :TInt;<N>   PopulationSaved                  :boolean;<N><N>   PrevPopulationIndex              :integer;<N>   NextPopulationIndex              :integer;<N>   NextPopulationSize               :integer;<N>   ChildPopulationIndex             :integer;<N><N>
<N>//help<N>   h,h_                             :TSolution;<N>   Constructor Create;overload;<N>   Destructor Destroy;overload;<N><N>   Procedure GetMemory;override;<N>   Procedure FreeMemory;override;<N><N>   Procedure Load(var f : TStringList);<N><N>   Procedure Iteration;override;<N>   Procedure Run;override;<N>   Procedure FirstApproximation;override;<N><N>
unit Vector;<N>interface<N> uses<N>  VarType,<N>  Cryptographer;<N> type<N><N>  PTVector = ^TVector;<N>  TVector = Class<N>  private<N>   FCode             :TReal;<N>   FSize             :TInt;<N>   Function GetVolume:TInt;<N>   Function GetSize_ :TInt;<N>   Procedure SetSize(x:TInt);<N>  public<N>   Element          :TIntArray;<N><N>
   Constructor Create();overload;<N>   Constructor Create(var x : TVector);overload;<N>   Destructor Destroy;override;<N><N>   Procedure GetMemory;<N>   Procedure FreeMemory;<N><N>   Procedure FillBy(x: TInt);<N>   Procedure Assign(var x:TVector);overload;<N><N>
unit Solution;<N><N>{$MODE Delphi}<N><N>interface<N> uses<N>  VarType,<N>  Vector;<N> type<N><N>  TValue = Record<N>   Revenue         :TReal;<N>   Expense         :TReal;<N>   Throughput      :TReal;<N>   Volume          :TReal;<N>   StorageCost     :TReal;<N>  end;<N><N>
<N>  PTSolution = ^TSolution;<N>  TSolution = Class(TVector)<N>  public<N>   Revenue          :TReal;<N>   Expense          :TReal;<N>   Throughput       :TReal;<N>   Volume           :TReal;<N>   StorageCost      :TReal;<N>   CalcFunctionCount:TInt;<N><N>
unit Population;<N>interface<N> uses<N>  VarType,<N>  Solution;<N> type<N>  IndividualArray = array of TSolution;<N>  PTPopulation = ^TPopulation;<N>  TPopulation = Class<N>  private<N>   FQuantity            :TInt;<N>   FSize                :TInt;<N><N>   FBestSolutionNumber  :TInt;<N>   FWorseSolutionNumber :TInt;<N><N>
   Function GetSize_:TInt;<N>   Procedure SetQuantity(x:TInt);<N>   Function GetQuantity_:TInt;<N>  public<N>   Individual          :IndividualArray;<N><N>   Constructor Create(var x:TPopulation);overload;<N>   Destructor Destroy;<N><N>   Procedure GetMemory;virtual;<N>   Procedure FreeMemory;virtual;<N><N>
   Procedure Assign(var x:TPopulation);overload;<N><N>   Procedure FindBest;<N>   Procedure FindWorse;<N>   Procedure FindAll;<N><N>   Function FindTheSameIndividual( var x:TSolution; var q:TInt):TBool;<N><N>   Property Size:TInt read FSize write FSize;<N>   Property Size_:TInt read GetSize_;<N><N>
unit VarType;<N>interface<N>const<N>  am=255;<N>  an=255;<N>  mx=1.0e+37;<N>  max=255;<N>  min=-1e30;<N> type<N>{MAIN--------------------------------------------------------------------------}<N>  TIndex = Integer;<N>  TPointer = Pointer;<N>//  TVariant = Variant;<N>  TInt = Integer;<N>  TReal = Double;<N>  TBool = Boolean;<N>  TString = string;<N>  TChar = char;<N><N>
  PTInt = ^TInt;<N>  PTReal = ^TReal;<N><N>  PTBool = ^TBool;<N>  PTString = ^TString;<N>  PTChar = ^TChar;<N><N>//  TVariantArray = array of TVariant;<N>  TIntArray = array of TInt;<N>  TRealArray = array of TReal;<N>  TBoolArray = array of TBool;<N>  TStringArray = array of TString;<N>  TCharArray = array of TChar;<N><N>
  TPIntArray = array of PTInt;<N>  TPRealArray = array of PTReal;<N><N>  TPBoolArray = array of PTBool;<N>  TPStringArray = array of PTString;<N>  TPCharArray = array of PTChar;<N><N>  PTIntArray = ^TIntArray;<N>  PTRealArray = ^TRealArray;<N>  PTBoolArray = ^TBoolArray;<N><N>
unit Buffer;<N>interface<N> uses<N>  VarType;<N> type<N><N>  PTBuffer = ^TBuffer;<N>  PTMachine = ^TMachine;<N><N>  TMachine = Record<N><N>   Number : TInt; //Machine number<N>   ListNumberGDB : TInt; //Number in list of giving detail buffer<N>   ListNumberTDB : TInt; //Number in list of taking detail buffer<N><N>
   Lambda : TReal;<N>   Mu : TReal;<N>   C : TReal;<N><N>   NumberGDB : TInt; //Number giving detail buffer<N>   NumberTDB : TInt; //Number taking detail buffer<N>  end;<N><N>  TBuffer = Class<N>  private<N>   FNumber : TInt; //Buffer number<N>   FSize : TReal;<N>   FMachineQuantity : TInt;<N>   FPDMQuantity : TInt; //Puting detail machine quantity<N>   FTDMQuantity : TInt; //Taking detail machine quantity<N>   Procedure SetMachineQuantity(x:TInt);<N>   Function GetMachineQuantity_:TInt;<N>  public<N><N>
   NumberPDM : array of TInt; //Puting detail machine<N>   NumberTDM : array of TInt; //Taking detail machine<N><N>   Constructor Create(var x : TBuffer);overload;<N>   Destructor Destroy;override;<N>   Procedure GetMemory;<N>   Procedure FreeMemory;<N><N>
unit IterR;<N>interface<N> uses<N>  VarType,<N>  Solution;<N> type<N>  PTIterationResult = ^TIterationResult;<N>  TIterationResult = Class(TSolution)<N>  private<N>   FRunTime             :TReal;<N>   FAmountIteration     :TInt;<N>   FStrForLocalDesent   :TString;<N>  public<N>   Constructor Create(var x : TIterationResult);overload;<N>   Procedure Assign(var x:TIterationResult);overload;<N><N>
unit Statistic;<N>interface<N> uses<N>  VarType,<N>  RunStatistic;<N> const<N>  b1 = 'Best solve: ';<N>  b2 = 'Best solve value: ';<N>  b3 = 'Worse solve: ';<N>  b4 = 'Worse solve value: ';<N>  b5 = 'Expectation: ';<N>  b6 = 'Variance: ';<N>  b7 = 'Confidence segment: ';<N>  b8 = 'Amount iteration mean at one run: ';<N>  b9 = 'Amount time mean one run: ';<N><N>
 type<N>  ResultArray = array of TRunStatistic;<N>  PTRunStatistic = ^TRunStatistic;<N>  TStatistic = Class<N>  private<N>   FAmountIterationMean        :TReal;<N>   FAmountTimeMean             :TReal;<N>   FExpectation                :TReal;<N>   FDispersion                 :TReal;<N>   FTrustInterval              :TReal;<N><N>
   FBestRecordNumber           :TInt;<N>   FWorseRecordNumber          :TInt;<N><N>   FQuantity                   :TInt;<N>   FRealQuantity               :TInt;<N>   FSize                       :TInt;<N><N>   Function GetSize_:TInt;<N>   Procedure SetQuantity(x:TInt);<N>   Function GetQuantity_:TInt;<N>   Function GetRealQuantity_:TInt;<N>   Procedure WriteInFile(var f:TextFile; use_iter_stat:TBool);<N>  public<N>   RunStatistic                :ResultArray;<N><N>
   Constructor Create;overload;<N>   Destructor Destroy;override;<N><N>   Procedure GetMemory;<N>   Procedure FreeMemory;<N><N>   Procedure AppendInFile(name : TString; use_iter_stat:TBool);<N>   Procedure RewriteFile(name : TString; use_iter_stat:TBool);<N><N>
   Procedure GetStatistic;<N>   Procedure FindBest;<N>   Procedure FindWorse;<N>   Procedure FindAll;<N><N>   Property AmountIterationMean :TReal read FAmountIterationMean write FAmountIterationMean;<N>   Property AmountTimeMean :TReal read FAmountTimeMean write FAmountTimeMean;<N>   Property Expectation :TReal read FExpectation write FExpectation;<N>   Property Dispersion :TReal read FDispersion write FDispersion;<N>   Property TrustInterval :TReal read FTrustInterval write FTrustInterval;<N><N>
   Property Size:TInt read FSize write FSize;<N>   Property Size_:TInt read GetSize_;<N><N>   Property Quantity:TInt read FQuantity write SetQuantity;<N>   Property Quantity_:TInt read GetQuantity_;<N><N>   Property RealQuantity:TInt read FRealQuantity write FRealQuantity;<N>   Property RealQuantity_:TInt read GetRealQuantity_;<N><N>
   Property BestRecordNumber :TInt read FBestRecordNumber;<N>   Property WorseRecordNumber:TInt read FWorseRecordNumber;<N>  end;<N>implementation<N> uses Sysutils;<N>{******************************************************************************}<N> Procedure TStatistic.GetStatistic;<N> var<N>   i:TInt;<N>   sum:TReal;<N> begin<N>  if RealQuantity_ > 0 then<N>  begin<N>    sum:=0;<N>    for i:=0 to RealQuantity_ do<N>     sum:=sum+RunStatistic[i].RunTime;<N><N>
    AmountTimeMean:=sum/(RealQuantity*1.0);<N><N>     sum:=0;<N>     for i:=0 to RealQuantity_ do<N>      sum:=sum+RunStatistic[i].Result.Getvalue;<N>     Expectation:=sum/(RealQuantity*1.0);<N><N>     sum:=0;<N>     for i:=0 to RealQuantity_ do<N>      sum:=sum+(Expectation-RunStatistic[i].Result.Getvalue)*(Expectation-RunStatistic[i].Result.Getvalue);<N>     if RealQuantity = 1 then<N>      Dispersion:=0<N>     else<N>      Dispersion:=sum/(1.0*RealQuantity-1.0);<N><N>
unit MachineLine;<N>interface<N> uses<N>  VarType,<N>  Buffer,<N>  Classes;<N> const<N>  MS = 2147483647;<N>  eps = 1e-6;<N> type<N><N>  PTMachineLine = ^TMachineLine;<N>  TMachineLine = Class<N>  private<N>   FCMQuantity : TInt; //Considered machine quantity<N>   FCBQuantity : TInt; //Considered buffer quantity<N><N>
   FMachineQuantity : TInt;<N>   FBufferQuantity : TInt;<N><N><N>   Procedure SetMachineQuantity(x:TInt);<N>   Procedure SetBufferQuantity(x:TInt);<N><N>   Function GetMachineQuantity_: TInt;<N>   Function GetBufferQuantity_: TInt;<N>  public<N>   Machine : array of TMachine;<N>   Buffer : array of TBuffer;<N><N>
   CMachine : TBoolArray; //machine that we use<N>   CBuffer : TBoolArray; //buffer that we use<N><N>   Constructor Create(var x : TMachineLine);overload;<N>   Destructor Destroy;override;<N><N>   Procedure GetMachineMemory;<N>   Procedure GetBufferMemory;<N>   Procedure FreeMachineMemory;<N>   Procedure FreeBufferMemory;<N><N>
   Procedure Load(var f : TStringList);overload;<N>   Procedure Assign(var x:TMachineLine);<N><N>   Function R1:TIndex;<N>   Function R1f:TIndex;<N><N>   procedure parl(var l1,m1,u1,l2,m2,u2:TReal);<N><N>   Procedure ReduceLine(<N>             var l1,m1,u1,stock_cost:TReal;<N>             var inv_coef:TReal;<N>             var det_cost:TRealArray<N>                       );<N>   procedure equiv(var lam1r,mu1r,deb1r,lam2r,mu2r,deb2r,hr,avg_stockr:TReal);<N><N>
   Property CMQuantity: TInt read FCMQuantity write FCMQuantity;<N>   Property CBQuantity: TInt read FCBQuantity write FCBQuantity;<N><N>   Property MachineQuantity: TInt read FMachineQuantity write SetMachineQuantity;<N>   Property BufferQuantity: TInt read FBufferQuantity write SetBufferQuantity;<N><N>
{********************************************}<N>{        EMSI System Info                    }<N>{    Base Objects Unit                       }<N>{Last modified:                              }<N>{Revision:                                   }<N>{Author:         Shadi AJAM                  }<N>{********************************************}<N><N>
unit EMSI.SysInfo.Base;<N><N>interface<N><N>uses<N>  System.SysUtils,<N>  Winapi.Windows,<N>  System.Generics.Collections,<N><N>  EMSI.SysInfo.Consts<N>  ;<N><N>type<N>  TEMSI_ObjectChangeStatus = (ocsNewObject,ocsNoChange,ocsChanged,ocsDeleted,ocsDeleting);<N>  TEMSI_ListChangeStatus = (lcsNoChange,lcsChanged);<N><N>
  TEMSI_SysInfoObj = class(TObject)<N>  private<N>    FChangeStatus : TEMSI_ObjectChangeStatus;<N>  public<N>    procedure AfterConstruction; override;<N>    procedure BeforeDestruction; override;<N>    procedure Assign(Source:TEMSI_SysInfoObj);virtual;<N><N>
    function IsSameObject(Obj: TEMSI_SysInfoObj):boolean;virtual;<N><N>    property ChangeStatus : TEMSI_ObjectChangeStatus read FChangeStatus;<N>  end;<N><N>  TEMSI_SysInfoList<T:TEMSI_SysInfoObj> = class(TObjectList<T>)<N>  protected<N>    FChangeStatus : TEMSI_ListChangeStatus;<N>    function FillList:TEMSI_Result; virtual;<N><N>
<N><N>    procedure MergeWithNewList(NewList:TEMSI_SysInfoList<T>); virtual;<N><N>    function NewObject:T;virtual;abstract;<N>  public<N>    procedure AfterConstruction; override;<N>    procedure BeforeDestruction; override;<N>    property ChangeStatus : TEMSI_ListChangeStatus read FChangeStatus;<N>    function SearchObject(Obj: T):T;virtual;<N>  end;<N><N>
  EEMSI_SysInfo = class(Exception)<N>  public<N>    constructor Create(const EMSI_Result:TEMSI_Result); overload;<N><N>  end;<N><N>implementation<N><N><N>{ TEMSI_SysInfoObj }<N><N>procedure TEMSI_SysInfoObj.AfterConstruction;<N>begin<N>  inherited;<N>  FChangeStatus := ocsNewObject;<N>end;<N><N>
procedure TEMSI_SysInfoObj.Assign(Source: TEMSI_SysInfoObj);<N>begin<N><N>end;<N><N>procedure TEMSI_SysInfoObj.BeforeDestruction;<N>begin<N>  inherited;<N><N>end;<N><N>function TEMSI_SysInfoObj.IsSameObject(Obj: TEMSI_SysInfoObj): boolean;<N>begin<N>  Result := False;<N>end;<N><N>
{ TEMSI_SysInfoList<T> }<N><N>procedure TEMSI_SysInfoList<T>.AfterConstruction;<N>begin<N>  inherited;<N>end;<N><N>procedure TEMSI_SysInfoList<T>.BeforeDestruction;<N>begin<N>  inherited;<N><N>end;<N><N>procedure TEMSI_SysInfoList<T>.MergeWithNewList(NewList: TEMSI_SysInfoList<T>);<N>var AObj,BObj : T;<N>    DeletedCount : integer;<N>begin<N><N>
  DeletedCount := 0;<N>  Self.FChangeStatus := lcsNoChange;<N>  for AObj in Self do<N>  begin<N>    BObj := NewList.SearchObject(AObj);<N>    if Assigned(BObj) then<N>    begin<N>      AObj.Assign(BObj);<N>      AObj.FChangeStatus := ocsNoChange;<N>      BObj.FChangeStatus := ocsNoChange;<N>    end else<N>    begin<N>      if AObj.FChangeStatus = ocsDeleting then<N>        AObj.FChangeStatus := ocsDeleted else<N>        AObj.FChangeStatus := ocsDeleting;<N>      inc(DeletedCount);<N>    end;<N>  end;<N><N>
  if DeletedCount > 0  then<N>    Self.FChangeStatus := lcsChanged;<N><N>  for AObj in NewList do<N>  begin<N>    if AObj.FChangeStatus = ocsNewObject then<N>    begin<N>      BObj := Self.NewObject;<N>      BObj.Assign(AObj);<N>      Self.Add(BObj);<N>      Self.FChangeStatus := lcsChanged;<N>    end;<N><N>
  end;<N>end;<N><N>function TEMSI_SysInfoList<T>.FillList: TEMSI_Result;<N>begin<N>  Result := emsi_Unknown;<N>end;<N><N><N>function TEMSI_SysInfoList<T>.SearchObject(Obj: T): T;<N>var BObj : T;<N>begin<N>  Result := nil;<N>  for BObj in Self do<N>    if BObj.IsSameObject(Obj) then exit(BObj);<N><N>
unit EMSI.SysInfo.Consts;<N><N>interface<N><N>type<N>  TEMSI_Result = $0000..$FFFF;<N><N>const<N>  emsi_ValidResult = $0000;<N>  emsi_Unknown = $FFFF;<N><N>  /// Base Errors<N>  emsi_err_ListOutOfIndex = $0001;<N><N>  /// Processes Errors<N>  emsi_err_CreateToolhelp32Snapshot = $00A1;<N>  emsi_err_Process32First = $00A2;<N><N>
  emsi_err_NoProcesssID = $00A3;<N>  emsi_err_ProcesssOpenError = $00A4;<N><N><N>function emsi_ErrorText(ErrorCode:TEMSI_Result):string;<N>implementation<N><N>function emsi_ErrorText(ErrorCode:TEMSI_Result):string;<N>begin<N>  Result := '';<N>  case ErrorCode of<N>    emsi_Unknown : Result := 'Unknown Error/Result';<N>    emsi_err_ListOutOfIndex : Result := 'List index out of index';<N>  end;<N>end;<N><N>
{********************************************}<N>{        EMSI System Info                    }<N>{    Windows Processes Handle Unit           }<N>{Last modified:                              }<N>{Revision:                                   }<N>{Author:         Shadi AJAM                  }<N>{********************************************}<N><N>
<N>unit EMSI.SysInfo.Processes;<N><N>interface<N><N>uses<N>  System.SysUtils,<N>  Winapi.Windows,<N>  Winapi.PsAPI,<N>  Winapi.TlHelp32, {https://learn.microsoft.com/en-us/windows/win32/toolhelp/tool-help-library}<N>  EMSI.SysInfo.Base,<N>  EMSI.SysInfo.Consts<N><N>
unit EMSI.WMI.Sessions;<N><N>interface<N><N>uses<N>  SysUtils,<N>  ActiveX,<N>  ComObj,<N>  DateUtils,<N>  Variants,<N>  System.Generics.Collections,<N>  EMSI.WMI.Base;<N><N>type<N>  TEMSI_WMISession = class(TObject)<N>  private<N>    function GetLogonTypeStr: string;<N>  public<N>    AuthenticationPackage: string;<N>    LogonId: string;<N>    LogonType: integer;<N>    StartTime: TDateTime;<N>    Domain:string;<N>    User:string;<N>    property LogonTypeStr : string read GetLogonTypeStr;<N>  end;<N><N>
  TEMSI_WMISessionList = class(TObjectList<TEMSI_WMISession>)<N>  private<N>    procedure QueryGetData_LogonSessionInfo(WMIQuery:TEMSI_WMIQuery;WbemObject:OLEVariant);<N>    procedure QueryGetData_LoggedOnUserInfo(WMIQuery:TEMSI_WMIQuery;WbemObject:OLEVariant);<N>    function FindSessionByLogonID(LogonId: string):TEMSI_WMISession;<N>  public<N>    procedure AfterConstruction; override;<N>    procedure BeforeDestruction; override;<N>    procedure FillList;<N>  end;<N><N>
unit EMSI.WMI.Base;<N><N>interface<N><N>uses<N>  SysUtils,<N>  ActiveX,<N>  ComObj,<N>  DateUtils,<N>  Variants;<N><N>Type<N>  TEMSI_WMIQuery = class;<N><N>  TEMSI_WMIOnQueryStartEvent = procedure(WMIQuery:TEMSI_WMIQuery) of object;<N>  TEMSI_WMIOnQueryGetDataEvent = procedure(WMIQuery:TEMSI_WMIQuery;WbemObject:OLEVariant) of object;<N>  TEMSI_WMIOnQueryEndEvent = procedure(WMIQuery:TEMSI_WMIQuery) of object;<N><N>
  TEMSI_WMIQuery = class(TObject) {ToDo : inherit it from dataset}<N>  private<N>    FSWbemLocator : OLEVariant;<N>    FWMIService   : OLEVariant;<N>    FOnStartEvent : TEMSI_WMIOnQueryStartEvent;<N>    FOnGetDataEvent : TEMSI_WMIOnQueryGetDataEvent;<N>    FOnEndEvent : TEMSI_WMIOnQueryEndEvent;<N>    WbemUser            :string;<N>    WbemPassword        :string;<N>    WbemComputer        :string;<N>    WbemNameSpace : string;<N>    wbemFlagForwardOnly :integer;<N>    FQuery: String;<N><N>
unit EMSI.UI.MainForm;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,<N>  System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls,<N>  Vcl.ComCtrls,EMSI.UI.TreeNode, Vcl.ExtCtrls,<N>  EMSI.SysInfo.Threads, Vcl.Menus, EMSI.UI.ProcessFrame,<N>  EMSI.SysInfo.Processes,<N>  EMSI.WMI.Sessions, EMSI.UI.SessionFrame<N>  ;<N><N>
unit EMSI.UI.ProcessFrame;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,<N>  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls,<N>  EMSI.SysInfo.Processes;<N><N>
unit EMSI.UI.TreeNode;<N><N>interface<N><N>uses<N>  Winapi.Windows,  System.SysUtils, System.Classes, Vcl.ComCtrls,<N>  Vcl.Graphics,<N>  EMSI.SysInfo.Processes,<N>  EMSI.SysInfo.Consts,<N>  EMSI.SysInfo.Base,<N>  EMSI.WMI.Sessions<N>  ;<N><N>type<N>  TNodeType = (ntBaseSessions,ntBaseProcesses,ntSession,ntProcess);<N><N>
  TEMSI_TreeNode = class(TTreeNode)<N>  private<N>    FNodeType: TNodeType;<N>    FProcessObj:TEMSI_WinProcess;<N>    FSessionObj:TEMSI_WMISession;<N><N>  public<N>    BackColor : TColor;<N>    NodeHint : String;<N>    procedure AfterConstruction; override;<N>    procedure BeforeDestruction; override;<N><N>
unit uFPrimerPrograma;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls;<N><N>type<N>  TFPrimerPrograma = class(TForm)<N>    lblSaludar: TLabel;<N>    btnSaludar: TButton;<N>    procedure btnSaludarClick(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit UnitCadAgendamentos;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.DBCtrls, Vcl.StdCtrls, Vcl.ExtCtrls,<N>  Vcl.Mask, Data.DB, Vcl.Grids, Vcl.DBGrids;<N><N>
unit unitDM;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf, FireDAC.Stan.Def,<N>  FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys, FireDAC.VCLUI.Wait,<N>  FireDAC.Stan.Param, FireDAC.DatS, FireDAC.DApt.Intf, FireDAC.DApt, Data.DB,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, FireDAC.Phys.MySQL,<N>  FireDAC.Phys.MySQLDef;<N><N>
unit unitCadPacientes;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.Mask, Vcl.DBCtrls,<N>  Vcl.ExtCtrls, Vcl.DBCGrids, Data.DB, Vcl.Grids, Vcl.DBGrids;<N><N>
unit Unit2;<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, StdCtrls, Buttons;<N><N>type<N>  TInform = class(TForm)<N>    Memo: TMemo;<N>    BitBtn1: TBitBtn;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Inform: TInform;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit ugamegrid;<N><N>{$mode ObjFPC}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, Graphics, Controls, ExtCtrls, ugamecommon, Math,<N>  GR32_Image, GR32_Paths, GR32, GR32_Layers, GR32_Brushes;<N><N>type<N>  TLayerCollectionAccess = class(TLayerCollection);<N>//    public<N>//      function MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): TCustomLayer;<N>//  end;<N><N>
﻿unit OneGlobal;<N><N>// 一些共用的全局变量统一管理<N>interface<N><N>uses<N>  System.SysUtils, System.IOUtils, System.Generics.Collections, System.Classes,<N>  System.JSON, Rest.JSON, System.NetEncoding,<N>  OneHttpServer, OneZTManage, OneFileHelper,<N>  OneNeonHelper, OneTokenManage, OneVirtualFile,<N>  Neon.Core.Persistence, Neon.Core.Persistence.JSON,<N>  OneILog, OneLog;<N><N>
﻿unit OneFastLoginController;<N><N>interface<N><N>uses<N>  system.StrUtils, system.SysUtils, Math, system.JSON, system.Threading, system.Classes,<N>  OneHttpController, OneHttpRouterManage, OneHttpCtxtResult, OneTokenManage, OneHttpConst,<N>  system.Generics.Collections, OneControllerResult, FireDAC.Comp.Client, Data.DB, OneGuID,<N>  OneMultipart;<N><N>
﻿unit OneFastAdminController;<N><N>interface<N><N>uses<N>  system.StrUtils, system.SysUtils, Math, system.JSON, system.Threading, system.Classes,<N>  OneHttpController, OneHttpRouterManage, OneHttpCtxtResult, OneTokenManage, OneHttpConst,<N>  system.Generics.Collections, OneControllerResult, FireDAC.Comp.Client, Data.DB, OneGuID,<N>  OneMultipart;<N><N>
﻿unit OneLog;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, system.SysUtils, system.Variants,<N>  system.Classes, system.DateUtils, system.Generics.Collections, OneThread,<N>  OneILog;<N><N>type<N>  { 日记级别--All监听所有,OFF关闭所有 }<N>  TELogLevel = (DEBUG, INFO, WARN, ERROR, ALL, OFF);<N>  { 按分分文件记录,按小时分文件记录,按天分文件记录,按年分文件记录,一般是hour,day }<N>  TELogIntervalLevel = (Minute, hour, Day, Month);<N>  TLogCallBack = procedure(const QMsg: string) of object;<N><N>
type<N>  // 日记配置<N>  TOneLogSet = class<N>  private<N>    FHTTPLog: boolean;<N>    FSQLLog: boolean;<N>    FLogPath: string;<N>    FLogSec: Integer;<N>  public<N>    property HTTPLog: boolean read FHTTPLog write FHTTPLog;<N>    property SQLLog: boolean read FSQLLog write FSQLLog;<N>    property LogPath: string read FLogPath write FLogPath;<N>    property LogSec: Integer read FLogSec write FLogSec;<N>  end;<N><N>
﻿unit OneRttiHelper;<N><N>interface<N><N>uses system.Generics.Collections, system.Rtti, system.Classes, system.StrUtils,<N>  system.SysUtils, system.TypInfo, system.Contnrs;<N><N>type<N>  emResultType = (unknowResult, numberResult, stringResult, boolResult,<N>    objResult, listResult, objListResult, genericsListResult,<N>    genericsObjListResult, mapResult, arrayResult, recordResult);<N><N>
﻿unit OneTokenManage;<N><N>// token管理<N>// 客户端连上来后 生成一个GUID tokenID当标识身份,后续提交tokenID来确保用户身份<N>interface<N><N>uses<N>  system.Classes, system.StrUtils, system.SysUtils, system.Generics.Collections,<N>  FireDAC.Comp.Client, FireDAC.Stan.Intf, Data.DB,<N>  OneILog, system.DateUtils, OneThread;<N><N>
type<N>  IOneTokenItem = interface;<N>  TOneTokenItem = class;<N>  TOneTokenManage = class;<N>  // 角色权限 noneRegister:无需注册就能访问最低级别<N>  // noneRole:任何人可以访问<N>  // userRole:用户可以访问<N>  // sysUserRole:系统用户<N>  // sysAdminRole:系统用户且为管理员<N>  // superRole:超级管理员<N>  // platformRole:平台管理员<N>  TOneAuthorRole = (noneRegister, noneRole, userRole, sysUserRole, sysAdminRole, superRole, platformRole);<N><N>
﻿unit OneGUID;<N><N>interface<N>uses System.SysUtils,system.StrUtils;<N>function GetGUID32():string;<N>implementation<N>function GetGUID32():string;<N>var<N>  ii: TGUID;<N>begin<N>  CreateGUID(ii);<N>  Result := Copy(AnsiReplaceStr(GUIDToString(ii), '-',''), 2, 32);<N>end;<N>end.<N>
﻿unit OneVirtualFile;<N><N>interface<N><N>uses system.Generics.Collections, system.StrUtils, system.SysUtils, system.DateUtils,<N>  OneThread;<N><N>type<N>  TOneVirtualItem = class;<N>  TOneVirtualSet = class;<N>  TVirtualInfo = class;<N>  TVirtualTask = class;<N>  TOneVirtualManage = class;<N><N>
  TOneVirtualSet = class<N>  private<N>    FAutoWork: boolean;<N>    FVirtualSetList: TList<TOneVirtualItem>;<N>  public<N>    constructor Create();<N>    destructor Destroy; override;<N>  public<N>    property AutoWork: boolean read FAutoWork write FAutoWork;<N>    property VirtualSetList: TList<TOneVirtualItem> read FVirtualSetList<N>      write FVirtualSetList;<N>  end;<N><N>
﻿unit OneSQLCrypto;<N><N>interface<N><N>uses System.SysUtils, System.Classes, System.NetEncoding, EncdDecd;<N>// 交换打乱加密<N>function SwapCrypto(QStr: string): string;<N>// 交换打乱解密<N>function SwapDecodeCrypto(QStr: string): string;<N>// 判断是不是base64字符串<N>function IsBase64Str(QStr: string): Boolean;<N><N>
implementation<N><N>function IsBase64Str(QStr: string): Boolean;<N>// 每隔76个字符，就强制回车换行<N>const<N>  Base64Chars: Set of AnsiChar = ['A' .. 'Z', 'a' .. 'z', '0' .. '9', '+', '/',<N>    '=', #10, #13];<N>var<N>  i: integer;<N>begin<N>  Result := true;<N>  for i := Low('') to High(QStr) do<N>  begin<N>    if not(QStr[i] in Base64Chars) then<N>    begin<N>      Result := false;<N>      Break;<N>    end;<N>  end;<N>end;<N><N>
﻿unit OneThread;<N><N>interface<N><N>uses System.Classes, System.SyncObjs, System.SysUtils, System.StrUtils;<N><N>type<N>  TOneTimerThread = class;<N>  TOneSingleWorkThread = class;<N>  EventOneWorkSend = procedure(send: Tobject) of object;<N>  EventOneWork = procedure();<N><N>
﻿unit OneHttpServer;<N><N>interface<N><N>uses<N>  SysUtils, System.Net.URLClient, System.Classes, OneHttpCtxtResult,<N>  System.Diagnostics, Web.HTTPApp, System.ZLib,<N>  mormot.Net.server, mormot.Net.http, mormot.Net.async, mormot.core.os,<N>  mormot.Net.sock, mormot.core.buffers, oneILog, OneFileHelper, mormot.core.zip, mormot.core.base;<N><N>
﻿unit OneHttpConst;<N><N>interface<N><N>uses system.StrUtils, system.SysUtils;<N><N>const<N>  HTTP_ResultCode_True = '0001';<N>  HTTP_ResultCode_Fail = '0002';<N>  HTTP_ResultCode_TokenFail = 'TokenFail';<N>  HTTP_ResultCode_TokenSignFail = 'TokenSignFail';<N>  HTTP_URL_TokenName = 'token';<N>  HTTP_URL_TokenTime = 'time';<N>  HTTP_URL_TokenSign = 'sign';<N><N>
type<N>  emRowState = (unknowState, selectState, editState, insertState, delState);<N><N>  TOneOrmRowState = class<N>  private<N>    FRowState_sys: emRowState;<N>  public<N>    function GetRowState(): emRowState;<N>    procedure SetRowState(QRowState: emRowState); overload;<N>    procedure SetRowState(QID: string); overload;<N>  end;<N><N>
﻿unit OneHttpRouterManage;<N><N>interface<N><N>uses<N>  System.StrUtils, System.Generics.Collections, System.Classes, System.SysUtils,<N>  System.Variants, OneHttpControllerRtti, OneHttpCtxtResult;<N><N>// 路由挂载的模式 unknow=未知,pool=线程池,single=单例模式,even=事件<N>type<N>  emRouterMode = (unknow, pool, single, even);<N><N>
﻿unit OneHttpController;<N><N>// 控制器基类<N>interface<N><N>uses<N>  System.SysUtils, System.Classes, System.Generics.Collections, Web.HTTPApp,<N>  System.StrUtils, System.NetEncoding, System.Rtti, System.ObjAuto,<N>  System.TypInfo, OneHttpControllerRtti, OneHttpCtxtResult, OneHttpRouterManage,<N>  System.JSON, System.JSON.Serializers, Rest.JSON, System.Variants,<N>  Neon.Core.Persistence.JSON, System.Contnrs, OneNeonHelper, OneHttpConst, OneMultipart,<N>  OneTokenManage;<N><N>
﻿unit OneWebSocketServer;<N><N>interface<N><N>uses mormot.net.ws.async, system.StrUtils, system.Classes, system.SysUtils,<N>  mormot.net.ws.core;<N><N>type<N>  TOneWebSocketProtocol = class;<N>  TOneWebSocketServer = class;<N><N>  TOneWebSocketProtocol = class(TWebSocketProtocolChat)<N>  private<N>    FOwnerWebSocketMgr: TOneWebSocketServer;<N>  protected<N>    procedure OnIncomingFrame(Sender: TWebSocketProcess;<N>      const Frame: TWebSocketFrame);<N>  end;<N><N>
﻿unit OneHttpCtxtResult;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, Web.HTTPApp, System.Generics.Collections,<N>  System.StrUtils, System.JSON, System.JSON.Serializers, Rest.JSON,<N>  Rest.JsonReflect, Neon.Core.Persistence.JSON, Neon.Core.Persistence,<N>  System.Contnrs, OneHttpControllerRtti, Neon.Core.Serializers.DB,<N>  Neon.Core.Serializers.RTL, Neon.Core.Serializers.Nullables, OneNeonHelper,<N>  System.Rtti, OneRttiHelper, OneHttpConst, OneControllerResult, OneMultipart;<N><N>
﻿unit OneControllerResult;<N><N>interface<N><N>uses system.Generics.Collections, system.Rtti, OneRttiHelper, OneHttpConst;<N><N>type<N>  emOneResultMode = (resultString, OneGet, OnePost, OneForm, OneUpload, OneDownload);<N><N>type<N>  IActionResult = interface;<N><N>
﻿unit DataController;<N><N>// 此单元主要对接 oneClient的OneDataSet传统交互<N>interface<N><N>uses OneHttpController, OneHttpRouterManage, OneHttpCtxtResult, OneDataInfo,<N>  system.Generics.Collections, OneFileHelper, system.StrUtils, system.SysUtils,<N>  OneControllerResult;<N><N>
﻿unit TokenController;<N><N>interface<N><N>uses OneHttpController, OneHttpRouterManage, OneHttpCtxtResult, OneTokenManage,<N>  system.Generics.Collections, OneControllerResult;<N><N>type<N>  TClientConnect = record<N>  public<N>    ConnectSecretkey: string;<N>    ClientIP: string; // 客户端传上来的客户端IP<N>    ClientMac: string; // 客户端传上来的客户端Mac地址<N>    TokenID: string; // 服务端返回的TokenID<N>    PrivateKey: string; // 服务端返回的私钥<N>  end;<N><N>
﻿unit VirtualFileController;<N><N>// 此单元主要对接 oneClient文件上传下载<N>interface<N><N>uses OneHttpController, OneHttpCtxtResult, OneHttpRouterManage, System.SysUtils,<N>  System.Generics.Collections, System.Contnrs, System.Classes, System.IOUtils, System.NetEncoding,<N>  FireDAC.Comp.Client, Data.DB, System.JSON, OneControllerResult, System.ZLib, OneVirtualFile;<N><N>
﻿unit DemoVersionController;<N><N>interface<N><N>uses OneHttpController, OneHttpCtxtResult, OneHttpRouterManage, System.SysUtils,<N>  System.Generics.Collections, System.Contnrs, System.Classes, System.IOUtils,<N>  FireDAC.Comp.Client, Data.DB, System.JSON, OneControllerResult, OneFileHelper;<N><N>
type<N>  TDemoV1Controller = class(TOneControllerBase)<N>  public<N>    function test(): string;<N>  end;<N><N>  TDemoV2Controller = class(TOneControllerBase)<N>  public<N>    function test(): string;<N>  end;<N><N>implementation<N><N>function TDemoV1Controller.test(): string;<N><N>
begin<N>  result := '我是v1版本';<N>end;<N><N>function TDemoV2Controller.test(): string;<N><N>begin<N>  result := '我是v2版本';<N>end;<N><N>// 注册到路由<N>initialization<N><N>OneHttpRouterManage.GetInitRouterManage().AddHTTPPoolWork('v1/demo', TDemoV1Controller, 10, nil);<N>OneHttpRouterManage.GetInitRouterManage().AddHTTPPoolWork('v2/demo', TDemoV2Controller, 10, nil);<N><N>
﻿unit DemoMyController;<N><N>interface<N><N>uses OneHttpController, OneHttpCtxtResult, OneHttpRouterManage, System.SysUtils,<N>  System.Generics.Collections, System.Contnrs, System.Classes,<N>  FireDAC.Comp.Client, Data.DB, System.JSON;<N><N>type<N>  TMyClass = class<N>  public<N>    name: string;<N>    age: integer;<N>  end;<N><N>
  TDemoMyController = class(TOneControllerBase)<N>  private<N>  public<N>    function test(name: string; age: integer): string;<N>    function testClass(myInfo: TMyClass): string;<N>    function testJson(QJson: TJsonObject): string;<N>    function OneGetTest(name: string; age: integer): string;<N>    function testGet(name: string): TMyClass;<N>    function getData(): TFDMemtable;<N>  end;<N><N>
implementation<N><N>function CreateNewDemoMyController(QRouterItem: TOneRouterItem): TObject;<N>var<N>  lController: TDemoMyController;<N>begin<N>  // 自定义创建控制器类，否则会按 TPersistentclass.create<N>  // 最好自定义一个好<N>  lController := TDemoMyController.Create;<N>  // 挂载RTTI信息<N>  lController.RouterItem := QRouterItem;<N>  result := lController;<N>end;<N><N>
function TDemoMyController.test(name: string; age: integer): string;<N>var<N>  lSt: string;<N>begin<N>  result := '我接收到信息name:' + name + '年龄age:' + age.ToString;<N>end;<N><N>function TDemoMyController.testClass(myInfo: TMyClass): string;<N>begin<N>  result := '我接收到信息name:' + myInfo.name + '年龄age:' + myInfo.age.ToString;<N>end;<N><N>
function TDemoMyController.testJson(QJson: TJsonObject): string;<N>begin<N>  result := '我接收到信息name:' + QJson.GetValue<string>('name') + '年龄age:' + QJson.GetValue<integer>('age').ToString;<N>end;<N><N>function TDemoMyController.OneGetTest(name: string; age: integer): string;<N>begin<N>  result := '我接收到信息name:' + name + '年龄age:' + age.ToString;<N>end;<N><N>
﻿unit DemoJsonController;<N><N>// 结果返回是jsonobject,jsonArray事例<N>interface<N><N>uses OneHttpController, OneHttpCtxtResult, OneHttpRouterManage, System.SysUtils,<N>  System.Generics.Collections, System.Contnrs, System.Classes,<N>  FireDAC.Comp.Client, Data.DB, System.JSON;<N><N>
type<N>  TDemoJsonController = class(TOneControllerBase)<N>  public<N>    // 返回结果 {"name":"flm0"}<N>    function GetJsonObject(): TJsonObject;<N>    // 返回结果 [{"name":"flm0"},{"name":"flm1"},{"name":"flm2"}]<N>    function GetJsonArray(): TJsonArray;<N><N>    // 最好是 TJsonValue做参数,如果传进的是一个数组也能正常接收<N>    // 然后在逻辑判断是JSONOBJECT还是JSONARRAY<N>    function GetJsonParam(QJsonObj: TJsonObject): string;<N>  end;<N><N>
function CreateNewDemoJsonController(QRouterItem: TOneRouterItem): TObject;<N><N>implementation<N><N>function CreateNewDemoJsonController(QRouterItem: TOneRouterItem): TObject;<N>var<N>  lController: TDemoJsonController;<N>begin<N>  // 自定义创建控制器类，否则会按 TPersistentclass.create<N>  // 最好自定义一个好<N>  lController := TDemoJsonController.Create;<N>  // 挂载RTTI信息<N>  lController.RouterItem := QRouterItem;<N>  result := lController;<N>end;<N><N>
function TDemoJsonController.GetJsonObject(): TJsonObject;<N>begin<N>  result := TJsonObject.Create;<N>  result.AddPair('name', 'flm');<N>end;<N><N>function TDemoJsonController.GetJsonArray(): TJsonArray;<N>var<N>  lJsonObj: TJsonObject;<N>  i: integer;<N>begin<N>  result := TJsonArray.Create;<N>  for i := 0 to 9 do<N>  begin<N>    lJsonObj := TJsonObject.Create;<N>    lJsonObj.AddPair('name', 'flm' + i.ToString);<N>    result.Add(lJsonObj);<N>  end;<N>end;<N><N>
function TDemoJsonController.GetJsonParam(QJsonObj: TJsonObject): string;<N>begin<N>  result := QJsonObj.ToString;<N>end;<N><N>// 注册到路由<N>initialization<N><N>// 注意，路由名称 不要一样，否则会判定已注册过，跳过<N>// 多例模式注册<N>OneHttpRouterManage.GetInitRouterManage().AddHTTPPoolWork('DemoJson',<N>  TDemoJsonController, 10, CreateNewDemoJsonController);<N><N>
﻿unit DemoWebFileController;<N><N>interface<N><N>uses OneHttpController, OneHttpCtxtResult, OneHttpRouterManage, System.SysUtils,<N>  System.Generics.Collections, System.Contnrs, System.Classes, System.IOUtils,<N>  FireDAC.Comp.Client, Data.DB, System.JSON, OneControllerResult, OneFileHelper, Web.ReqMulti,<N>  OneMultipart, Web.ReqFiles;<N><N>
type<N>  TDemoWebFileController = class(TOneControllerBase)<N>  public<N>    // OneGet取url参数。通过web预览图片<N>    function OneGetFile(fileName: string): TActionResult<string>;<N>    // 解析 multipart/form-data提交的数据,只需要参数类型是 TOneMultipartDecode就行，其它的交给底程处理解析<N>    function WebPostFormData(QFormData: TOneMultipartDecode): TActionResult<string>;<N>  end;<N><N>
implementation<N><N>function CreateNewDemoWebFileController(QRouterItem: TOneRouterItem): TObject;<N>var<N>  lController: TDemoWebFileController;<N>begin<N>  // 自定义创建控制器类，否则会按 TPersistentclass.create<N>  // 最好自定义一个好<N>  lController := TDemoWebFileController.Create;<N>  // 挂载RTTI信息<N>  lController.RouterItem := QRouterItem;<N>  result := lController;<N>end;<N><N>
function TDemoWebFileController.OneGetFile(fileName: string): TActionResult<string>;<N>var<N>  lFileName: string;<N>begin<N>  result := TActionResult<string>.Create(true, false);<N>  // 比如 D:\test目录下<N>  lFileName := OneFileHelper.CombinePath('D:\test', fileName);<N>  if not TFile.Exists(lFileName) then<N>  begin<N>    result.ResultMsg := '文件不存在';<N>    exit;<N>  end;<N>  // 返回的文件物理路径放在这<N>  result.ResultData := lFileName;<N>  // 代表返回文件<N>  result.SetResultTrueFile();<N>end;<N><N>
﻿unit DemoEvenController;<N><N>interface<N><N>uses OneHttpController, OneHttpCtxtResult, OneHttpRouterManage, System.SysUtils,<N>  System.Generics.Collections, System.Contnrs, System.Classes,<N>  FireDAC.Comp.Client, Data.DB, System.JSON, Rtti;<N><N>type<N>{$M+}<N>  TMyProc = reference to procedure();<N>{$M-}<N><N>
procedure myTest;<N><N>implementation<N><N>procedure myTest;<N>begin<N><N>end;<N><N>// 注册到路由<N>initialization<N><N>// 注意，路由名称 不要一样，否则会判定已注册过，跳过<N>// 多例模式注册<N>OneHttpRouterManage.GetInitRouterManage().AddHTTPPointerWork('DemoMyEven', TValue.From<TMyProc>(myTest), 10);<N><N>
﻿unit DemoDataController;<N><N>// 结果返回是jsonobject,jsonArray事例<N>interface<N><N>uses OneHttpController, OneHttpCtxtResult, OneHttpRouterManage, System.SysUtils,<N>  System.Generics.Collections, System.Contnrs, System.Classes,<N>  FireDAC.Comp.Client, Data.DB, System.JSON;<N><N>
type<N>  TDemoDataController = class(TOneControllerBase)<N>  public<N>    // 返回结果 [{"name":"flm0"},{"name":"flm1"},{"name":"flm2"}]<N>    function GetData(): TFDMemtable;<N>    // 返回结果 [{"name":"flm0"},{"name":"flm1"},{"name":"flm2"}]<N>    function GetQuery(): TFDQuery;<N>  end;<N><N>
function CreateNewDemoDataController(QRouterItem: TOneRouterItem): TObject;<N><N>implementation<N><N>function CreateNewDemoDataController(QRouterItem: TOneRouterItem): TObject;<N>var<N>  lController: TDemoDataController;<N>begin<N>  // 自定义创建控制器类，否则会按 TPersistentclass.create<N>  // 最好自定义一个好<N>  lController := TDemoDataController.Create;<N>  // 挂载RTTI信息<N>  lController.RouterItem := QRouterItem;<N>  result := lController;<N>end;<N><N>
function TDemoDataController.GetData(): TFDMemtable;<N>var<N>  i: integer;<N>begin<N>  result := TFDMemtable.Create(nil);<N>  result.FieldDefs.Add('name', ftString, 20, false);<N>  result.FieldDefs.Add('age', ftInteger, 0, True);<N>  result.CreateDataSet();<N>  for i := 0 to 99999 do<N>  begin<N>    result.Append;<N>    result.FieldByName('name').AsString := 'flm' + i.ToString();<N>    result.FieldByName('age').AsInteger := i;<N>    result.Post;<N>  end;<N>end;<N><N>
﻿unit DemoZTController;<N><N>// 结果返回是jsonobject,jsonArray事例<N>interface<N><N>uses OneHttpController, OneHttpCtxtResult, OneHttpRouterManage, System.SysUtils,<N>  System.Generics.Collections, System.Contnrs, System.Classes,<N>  FireDAC.Comp.Client, Data.DB, System.JSON, OneControllerResult;<N><N>
type<N>  TDemoZTController = class(TOneControllerBase)<N>  public<N>    // 返回结果 [{"name":"flm0"},{"name":"flm1"},{"name":"flm2"}]<N>    function GetData(): TActionResult<TFDMemtable>;<N>    function SaveData(QPersons: TList<TPersonDemo>): TActionResult<string>;<N>  end;<N><N>
function CreateNewDemoZTController(QRouterItem: TOneRouterItem): TObject;<N><N>implementation<N><N>uses OneGlobal, OneZTManage;<N><N>function CreateNewDemoZTController(QRouterItem: TOneRouterItem): TObject;<N>var<N>  lController: TDemoZTController;<N>begin<N>  // 自定义创建控制器类，否则会按 TPersistentclass.create<N>  // 最好自定义一个好<N>  lController := TDemoZTController.Create;<N>  // 挂载RTTI信息<N>  lController.RouterItem := QRouterItem;<N>  result := lController;<N>end;<N><N>
﻿unit DemoBController;<N><N>interface<N><N>uses OneHttpController, OneHttpCtxtResult, OneHttpRouterManage, System.SysUtils,<N>  System.Generics.Collections, System.Contnrs, System.Classes,<N>  FireDAC.Comp.Client, Data.DB, System.JSON;<N><N>type<N>  TDemoBController = class(TOneControllerBase)<N>  private<N><N>
  public<N>    // 要对外访问的，方法全要放在pulibc部份,外面才可访问<N>    procedure DoTest();<N><N>  end;<N><N>implementation<N><N>function CreateNewDemoBController(QRouterItem: TOneRouterItem): TObject;<N>var<N>  lController: TDemoBController;<N>begin<N>  // 自定义创建控制器类，否则会按 TPersistentclass.create<N>  // 最好自定义一个好<N>  lController := TDemoBController.Create;<N>  // 挂载RTTI信息<N>  lController.RouterItem := QRouterItem;<N>  result := lController;<N>end;<N><N>
procedure TDemoBController.DoTest();<N>var<N>  lStr: string;<N>begin<N>  lStr := '1231345';<N>end;<N><N>// 注册到路由<N>initialization<N><N>// 注意，路由名称 不要一样，否则会判定已注册过，跳过<N>// 多例模式注册<N>OneHttpRouterManage.GetInitRouterManage().AddHTTPPoolWork('DemoB',<N>  TDemoBController, 10, CreateNewDemoBController);<N><N>
﻿unit DemoTestController;<N><N>interface<N><N>uses OneHttpController, OneHttpCtxtResult, OneHttpRouterManage, System.SysUtils,<N>  System.Generics.Collections, System.Contnrs, System.Classes,<N>  FireDAC.Comp.Client, Data.DB;<N><N>type<N>  TDemoController = class(TOneControllerBase)<N><N>  end;<N><N>implementation<N><N>end.<N>
﻿unit DemoOrmController;<N><N>interface<N><N>uses OneHttpController, OneHttpRouterManage, OneHttpCtxtResult, OneTokenManage,<N>  system.Generics.Collections, system.StrUtils, system.SysUtils, Data.DB,<N>  FireDAC.Comp.Client, OneControllerResult, OneAttribute;<N><N>
type<N>  emTest = (cmTestA, cmTestB);<N><N>  // 请自行创建一个表，包含以下字段，或者随意几个<N>  TTestOrm = class<N>  private<N>    FName: string;<N>    FAge: Integer;<N>  public<N>    constructor Create;<N>    destructor Destroy; override;<N>  public<N>    property Name: string read FName write FName;<N>    property Age: Integer read FAge write FAge;<N>  end;<N><N>
﻿unit DemoCustResult;<N><N>interface<N><N>uses OneHttpController, OneHttpRouterManage, OneHttpCtxtResult, OneTokenManage,<N>  system.Generics.Collections, system.StrUtils, system.SysUtils, Data.DB,<N>  FireDAC.Comp.Client, OneControllerResult;<N><N>type<N><N>
﻿unit DemoLogController;<N><N>// 结果返回是jsonobject,jsonArray事例<N>interface<N><N>uses OneHttpController, OneHttpCtxtResult, OneHttpRouterManage, System.SysUtils,<N>  System.Generics.Collections, System.Contnrs, System.Classes,<N>  FireDAC.Comp.Client, Data.DB, System.JSON, OneControllerResult;<N><N>
﻿unit UniGoodsController;<N><N>interface<N><N>uses<N>  system.StrUtils, system.SysUtils, Math, system.JSON, system.Threading, system.Classes,<N>  OneHttpController, OneHttpRouterManage, OneHttpCtxtResult, OneTokenManage, OneHttpConst,<N>  system.Generics.Collections, OneControllerResult, FireDAC.Comp.Client, Data.DB, OneGuID,<N>  OneMultipart, UniClass, system.IOUtils;<N><N>
﻿unit UniBillSendController;<N><N>interface<N><N>uses<N>  system.StrUtils, system.SysUtils, Math, system.JSON, system.Threading, system.Classes,<N>  OneHttpController, OneHttpRouterManage, OneHttpCtxtResult, OneTokenManage, OneHttpConst,<N>  system.Generics.Collections, OneControllerResult, FireDAC.Comp.Client, Data.DB, OneGuID,<N>  OneMultipart, UniClass;<N><N>
type<N><N>  TUniBillSendController = class(TOneControllerBase)<N>  public<N>    function GetBillSendList(QPageIndex: integer; QPageSize: integer; QStarTime: string; QEndTime: string; QCMFStatus: string): TActionResult<TList<TBillSendDemo>>;<N>    function GetBillSendInfo(QBillID: string): TActionResult<TBillSendInfo>;<N>    function SaveBillSendInfo(QBillInfo: TBillSendInfo): TActionResult<string>;<N>    function BillSendCmd(QBillID: string; QCmd: string): TActionResult<string>;<N>  end;<N><N>
function CreateNewBillSendController(QRouterItem: TOneRouterItem): TObject;<N><N>implementation<N><N>uses OneGlobal, OneZTManage;<N><N>function CreateNewBillSendController(QRouterItem: TOneRouterItem): TObject;<N>var<N>  lController: TUniBillSendController;<N>begin<N>  // 自定义创建控制器类，否则会按 TPersistentclass.create<N>  // 最好自定义一个好<N>  lController := TUniBillSendController.Create;<N>  // 挂载RTTI信息<N>  lController.RouterItem := QRouterItem;<N>  result := lController;<N>end;<N><N>
﻿unit UniSendReceivController;<N><N>interface<N><N>uses<N>  system.StrUtils, system.SysUtils, Math, system.JSON, system.Threading, system.Classes,<N>  OneHttpController, OneHttpRouterManage, OneHttpCtxtResult, OneTokenManage, OneHttpConst,<N>  system.Generics.Collections, OneControllerResult, FireDAC.Comp.Client, Data.DB, OneGuID,<N>  OneMultipart, UniClass;<N><N>
type<N><N>  TUniSendReceivController = class(TOneControllerBase)<N>  public<N>    function GetSendReceivList(pageIndex: integer; pageSize: integer; custtype: string; custInfo: string): TActionResult<TFDMemtable>;<N>    function GetSendReceiv(QCustomerID: string): TActionResult<TSendReceivDemo>;<N>    function SaveSendReceiv(QCustomer: TSendReceivDemo): TActionResult<string>;<N>  end;<N><N>
function CreateNewSendReceivController(QRouterItem: TOneRouterItem): TObject;<N><N>implementation<N><N>uses OneGlobal, OneZTManage;<N><N>function CreateNewSendReceivController(QRouterItem: TOneRouterItem): TObject;<N>var<N>  lController: TUniSendReceivController;<N>begin<N>  // 自定义创建控制器类，否则会按 TPersistentclass.create<N>  // 最好自定义一个好<N>  lController := TUniSendReceivController.Create;<N>  // 挂载RTTI信息<N>  lController.RouterItem := QRouterItem;<N>  result := lController;<N>end;<N><N>
﻿unit OneOrm;<N><N>interface<N><N>uses<N>  system.Generics.Collections, system.Variants, system.SysUtils, system.Classes,<N>  OneZTManage, FireDAC.Comp.Client, system.Rtti, Data.DB, system.NetEncoding, system.TypInfo;<N><N>type<N>  emOneOrmCmd = (cmdNull, cmdQuery, cmdExecSQL, cmdSelect, cmdInsert, cmdUpdate, cmdDelete);<N><N>
﻿unit OneClientDataSet;<N><N>// 数据集控件,继承TFDMemTable<N>interface<N><N>uses<N>  System.SysUtils, System.StrUtils, System.Classes, Data.DB,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Param, System.Threading,<N>  System.Generics.Collections, {$IFDEF MSWINDOWS} Vcl.Dialogs, {$ENDIF}<N>  OneClientConnect, OneClientDataInfo, OneClientConst;<N><N>
﻿unit OneThread;<N><N>interface<N><N>uses System.Classes, System.SyncObjs, System.SysUtils, System.StrUtils;<N><N>type<N>  TOneTimerThread = class;<N>  TOneSingleWorkThread = class;<N>  EventOneWorkSend = procedure(send: Tobject) of object;<N>  EventOneWork = procedure();<N><N>
﻿unit OneSQLCrypto;<N><N>interface<N><N>uses System.SysUtils, System.Classes, System.NetEncoding, EncdDecd;<N>// 交换打乱加密<N>function SwapCrypto(QStr: string): string;<N>// 交换打乱解密<N>function SwapDecodeCrypto(QStr: string): string;<N>// 判断是不是base64字符串<N>function IsBase64Str(QStr: string): Boolean;<N><N>
implementation<N><N>function IsBase64Str(QStr: string): Boolean;<N>// 每隔76个字符，就强制回车换行<N>const<N>  Base64Chars: Set of AnsiChar = ['A' .. 'Z', 'a' .. 'z', '0' .. '9', '+', '/',<N>    '=', #10, #13];<N>var<N>  i: integer;<N>begin<N>  Result := true;<N>  for i := Low('') to High(QStr) do<N>  begin<N>    if not(QStr[i] in Base64Chars) then<N>    begin<N>      Result := false;<N>      Break;<N>    end;<N>  end;<N>end;<N><N>
﻿unit OneLog;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, system.SysUtils, system.Variants,<N>  system.Classes, system.DateUtils, system.Generics.Collections, OneThread,<N>  OneILog;<N><N>type<N>  { 日记级别--All监听所有,OFF关闭所有 }<N>  TELogLevel = (DEBUG, INFO, WARN, ERROR, ALL, OFF);<N>  { 按分分文件记录,按小时分文件记录,按天分文件记录,按年分文件记录,一般是hour,day }<N>  TELogIntervalLevel = (Minute, hour, Day, Month);<N>  TLogCallBack = procedure(const QMsg: string) of object;<N><N>
type<N>  // 日记配置<N>  TOneLogSet = class<N>  private<N>    FHTTPLog: boolean;<N>    FSQLLog: boolean;<N>    FLogPath: string;<N>    FLogSec: Integer;<N>  public<N>    property HTTPLog: boolean read FHTTPLog write FHTTPLog;<N>    property SQLLog: boolean read FSQLLog write FSQLLog;<N>    property LogPath: string read FLogPath write FLogPath;<N>    property LogSec: Integer read FLogSec write FLogSec;<N>  end;<N><N>
﻿unit frmDemoCustTran;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,<N>  System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls,<N>  OneClientHelper, OneClientConnect, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf,<N>  FireDAC.DApt.Intf, Data.DB, FireDAC.Comp.DataSet, FireDAC.Comp.Client,<N>  OneClientDataSet;<N><N>
﻿unit frmDemoUpDownChunk;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls, System.Math,<N>  OneClientHelper, OneClientConnect, OneClientVirtualFile, Vcl.ComCtrls, OneClientConst;<N><N>
﻿unit frmDemoDatas;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,<N>  System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls,<N>  OneClientHelper, OneClientConnect, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf,<N>  FireDAC.DApt.Intf, Data.DB, FireDAC.Comp.DataSet, FireDAC.Comp.Client,<N>  OneClientDataSet, Vcl.Grids, Vcl.DBGrids;<N><N>
﻿unit frmDemoPostGet;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,<N>  System.Classes, Vcl.Graphics, System.JSON,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls,<N>  OneClientHelper, OneClientConnect;<N><N>
﻿unit frmDemoVirtualFile;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls,<N>  OneClientHelper, OneClientConnect, OneClientVirtualFile;<N><N>
unit Unit2;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf, FireDAC.Stan.Def,<N>  FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys, FireDAC.Phys.MySQL,<N>  FireDAC.Phys.MySQLDef, FireDAC.VCLUI.Wait, FireDAC.Stan.Param, FireDAC.DatS,<N>  FireDAC.DApt.Intf, FireDAC.DApt, Data.DB, Datasnap.Provider,<N>  Datasnap.DBClient, FireDAC.Comp.DataSet, FireDAC.Comp.Client;<N><N>
type<N>  TDataModuleExercicio1 = class(TDataModule)<N>    FDConnection1: TFDConnection;<N>    FDQuery1: TFDQuery;<N>    ClientDataSet1: TClientDataSet;<N>    DataSetProvider1: TDataSetProvider;<N>    ClientDataSet1id: TAutoIncField;<N>    ClientDataSet1cidade: TStringField;<N>    ClientDataSet1estado: TStringField;<N>    ScriptBanco: TFDQuery;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
// 6. Escreva um algoritmo para ler uma temperatura em graus Celsius,<N>// calcular e escrever o valor correspondente em graus Fahrenheit:<N>// F = C * 9 / 5 + 32<N><N><N>unit Unit5;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls;<N><N>
type<N>  TForm3 = class(TForm)<N>    Edit1: TEdit;<N>    Button1: TButton;<N>    Label1: TLabel;<N>    procedure Button1Click(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form3: TForm3;<N><N>
implementation<N><N>{$R *.dfm}<N><N>procedure TForm3.Button1Click(Sender: TObject);<N>var<N>  temperaturaEmFahrenheit: double;<N>  temperaturaEmCelsius: double;<N><N>begin<N>  temperaturaEmCelsius := StrToFloat(Edit1.Text);<N>  temperaturaEmFahrenheit :=   temperaturaEmCelsius * 9 / 5 + 32;<N>  Label1.Caption := FloatToStr(temperaturaEmFahrenheit);<N><N>
// 6. Escreva um algoritmo para ler uma temperatura em graus Celsius,<N>// calcular e escrever o valor correspondente em graus Fahrenheit:<N>// F = C * 9 / 5 + 32<N><N><N>unit Unit5;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls;<N><N>
type<N>  TFormTemperaturaF = class(TForm)<N>    EditCF: TEdit;<N>    converterF: TButton;<N>    Convertido: TLabel;<N>    procedure converterFClick(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
var<N>  FormTemperaturaF: TFormTemperaturaF;<N><N>implementation<N><N>{$R *.dfm}<N><N>procedure TFormTemperaturaF.converterFClick(Sender: TObject);<N>var<N>  temperaturaEmFahrenheit: double;<N>  temperaturaEmCelsius: double;<N><N>begin<N>  temperaturaEmCelsius := StrToFloat(EditCF.Text);<N>  temperaturaEmFahrenheit :=   temperaturaEmCelsius * 9 / 5 + 32;<N>  Convertido.Caption := FloatToStr(temperaturaEmFahrenheit);<N><N>
unit Unit2;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs;<N><N>type<N>  TForm2 = class(TForm)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Form2: TForm2;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit frmFuncionariosConsulta;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, frmConsulta, Data.DB, Vcl.StdCtrls,<N>  Vcl.ExtCtrls, Vcl.Grids, Vcl.DBGrids;<N><N>
type<N>  TformFuncionariosConsulta = class(TformConsulta)<N>    NomeFuncionario: TLabel;<N>    editNomeFuncionario: TEdit;<N>    ButtonProcurar: TButton;<N>    procedure ButtonProcurarClick(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit frmProdutosConsulta;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, frmConsulta, Data.DB, Vcl.StdCtrls,<N>  Vcl.ExtCtrls, Vcl.Grids, Vcl.DBGrids;<N><N>
type<N>  TformProdutosConsulta = class(TformConsulta)<N>    NomeProdutos: TLabel;<N>    editNomeProduto: TEdit;<N>    ValorProdutos: TLabel;<N>    EditValorProduto: TEdit;<N>    ButtonProcurar: TButton;<N>    procedure ButtonProcurarClick(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit frmOrdemServicoCadastro;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, frmCadastroDetalhe, Data.DB, Vcl.StdCtrls, Vcl.Grids, Vcl.DBGrids, Vcl.ExtCtrls,<N>  Vcl.Mask, Vcl.DBCtrls;<N><N>
unit dmOrdemServico;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, dmCadastro, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS,<N>  FireDAC.Phys.Intf, FireDAC.DApt.Intf, FireDAC.Stan.Async, FireDAC.DApt,<N>  Data.DB, Datasnap.DBClient, Datasnap.Provider, FireDAC.Comp.DataSet,<N>  FireDAC.Comp.Client, Vcl.Dialogs;<N><N>
unit frmClienteConsulta;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, frmConsulta, Data.DB, Vcl.StdCtrls,<N>  Vcl.ExtCtrls, Vcl.Grids, Vcl.DBGrids;<N><N>
type<N>  TformConsulta2 = class(TformConsulta)<N>    NomeCliente: TLabel;<N>    editNome: TEdit;<N>    CPFCliente: TLabel;<N>    EditCPF: TEdit;<N>    ButtonProcurar: TButton;<N>    procedure ButtonProcurarClick(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit frmCadastroDetalhe;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, frmCadastro, Data.DB, Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.Grids, Vcl.DBGrids,<N>  Vcl.DBCtrls;<N><N>
type<N>  TformCadastroDetalhe = class(TformCadastro)<N>    dsDetalhe: TDataSource;<N>    Panel3: TPanel;<N>    DBGrid1: TDBGrid;<N>    DBNavigator1: TDBNavigator;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
unit frmOrdemServicoConsulta;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, frmConsulta, Data.DB, Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.Grids, Vcl.DBGrids;<N><N>
type<N>  TformOrdemServicoConsulta = class(TformConsulta)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  formOrdemServicoConsulta: TformOrdemServicoConsulta;<N><N>implementation<N><N>{$R *.dfm}<N><N>
unit FormCliente;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs;<N><N>type<N>  TCliente = class(TForm)<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>var<N>  Cliente: TCliente;<N><N>implementation<N><N>{$R *.dfm}<N><N>end.<N>
unit DataModule.Global;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Classes, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf, FireDAC.Stan.Def,<N>  FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys, FireDAC.FMXUI.Wait,<N>  Data.DB, FireDAC.Comp.Client, FireDAC.Phys.FB, FireDAC.Phys.FBDef,<N>  FireDAC.Phys.IBBase, DataSet.Serialize.Config, System.JSON,<N>  DataSet.Serialize, FireDAC.DApt;<N><N>
unit Horse.Jhonson;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, HTTPDefs, fpjson, jsonparser,<N>{$ELSE}<N>  System.Classes, System.JSON, System.SysUtils, Web.HTTPApp,<N>{$ENDIF}<N>  Horse, Horse.Commons;<N><N>
function Jhonson: THorseCallback; overload;<N>function Jhonson(const ACharset: string): THorseCallback; overload;<N><N>procedure Middleware(Req: THorseRequest; Res: THorseResponse; Next: {$IF DEFINED(FPC)}TNextProc{$ELSE}TProc{$ENDIF});<N><N>implementation<N><N>
var<N>  Charset: string;<N><N>function Jhonson: THorseCallback; overload;<N>begin<N>  Result := Jhonson('UTF-8');<N>end;<N><N>function Jhonson(const ACharset: string): THorseCallback; overload;<N>begin<N>  Charset := ACharset;<N>  Result := Middleware;<N>end;<N><N>
unit Horse.BasicAuthentication;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils,<N>  base64,<N>  Classes,<N>{$ELSE}<N>  System.SysUtils,<N>  System.NetEncoding,<N>  System.Classes,<N>{$ENDIF}<N>  Horse,<N>  Horse.Commons;<N><N>
Library Apache;<N><N>{$DEFINE Apache2_4}<N>{$DEFINE FPCAPACHE_2_4}<N>{$MODE DELPHI}{$H+}<N><N>Uses<N>{$ifdef unix}<N>  cthreads,<N>{$endif}<N>  Horse, httpd24, fpApache24, custapache24;<N><N>const<N>  ModuleName = 'apache_horse_module';<N><N>var<N>  ApacheModuleData : module; {$ifdef unix} public name ModuleName;{$endif unix}<N><N>
exports ApacheModuleData name ModuleName;<N><N>procedure GetPing(Req: THorseRequest; Res: THorseResponse; Next: TNextProc);<N>begin<N>  Res.Send('pong');<N>end;<N><N>begin<N>  THorse.Get('/ping', GetPing);<N><N>  THorse.DefaultModule := @ApacheModuleData;<N>  THorse.HandlerName := 'apache_horse_module-handle';<N>  THorse.ModuleName := ModuleName;<N><N>
unit Views.Main;<N><N>{$MODE DELPHI}{$H+}<N><N>interface<N><N>uses Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, Buttons, Horse;<N><N>type<N><N>  { TFrmMain }<N><N>  TFrmMain = class(TForm)<N>    btnStart: TBitBtn;<N>    btnStop: TBitBtn;<N>    edtPort: TEdit;<N>    Label1: TLabel;<N>    procedure btnStartClick(Sender: TObject);<N>    procedure btnStopClick(Sender: TObject);<N>  private<N>    procedure Status;<N>    procedure Start;<N>    procedure Stop;<N>  end;<N><N>
var<N>  FrmMain: TFrmMain;<N><N>implementation<N><N>procedure DoPing(Req: THorseRequest; Res: THorseResponse; Next: TNextProc);<N>begin<N>  Res.Send('pong');<N>end;<N><N>{$R *.lfm}<N><N>procedure TFrmMain.btnStartClick(Sender: TObject);<N>begin<N>  Start;<N>  Status;<N>end;<N><N>
procedure TFrmMain.btnStopClick(Sender: TObject);<N>begin<N>  Stop;<N>  Status;<N>end;<N><N>procedure TFrmMain.Status;<N>begin<N>  btnStop.Enabled := THorse.IsRunning;<N>  btnStart.Enabled := not THorse.IsRunning;<N>  edtPort.Enabled := not THorse.IsRunning;<N>end;<N><N>
unit DaemonManager;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, DaemonApp;<N><N>type<N><N>  { TDaemon_Manager }<N><N>  TDaemon_Manager = class(TDaemonMapper)<N>    procedure Daemon_ManagerCreate(Sender: TObject);<N>  private<N><N>
  public<N><N>  end;<N><N>var<N>  Daemon_Manager: TDaemon_Manager;<N><N>implementation<N><N>procedure RegisterMapper;<N>begin<N>  RegisterDaemonMapper(TDaemon_Manager)<N>end;<N><N>{$R *.lfm}<N><N>{ TDaemon_Manager }<N><N>procedure TDaemon_Manager.Daemon_ManagerCreate(Sender: TObject);<N>begin<N><N>
unit DaemonMain;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses<N>  Classes, SysUtils, DaemonApp;<N><N>type<N>  TDaemon_Main = class(TDaemon)<N>    procedure DataModuleCreate(Sender: TObject);<N>    procedure DataModuleShutDown(Sender: TCustomDaemon);<N>    procedure DataModuleStart(Sender: TCustomDaemon; var OK: Boolean);<N>  end;<N><N>
var<N>  Daemon_Main: TDaemon_Main;<N><N>implementation<N><N>uses<N>  Horse;<N><N>procedure RegisterDaemon;<N>begin<N>  RegisterDaemonClass(TDaemon_Main)<N>end;<N><N>procedure RunHorse;<N>begin<N>  THorse.Listen(9000);<N>end;<N><N>procedure Ping(Req: THorseRequest; Res: THorseResponse; Next: TNextProc);<N>begin<N>  Res.Send('pong');<N>end;<N><N>
{$R *.lfm}<N><N>{ TDaemon_Main }<N><N>procedure TDaemon_Main.DataModuleCreate(Sender: TObject);<N>begin<N>  THorse.Get('ping', @Ping);<N>end;<N><N>procedure TDaemon_Main.DataModuleShutDown(Sender: TCustomDaemon);<N>begin<N>  THorse.StopListen;<N>end;<N><N>
unit Main.Form;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Horse, Vcl.StdCtrls, Vcl.Samples.Spin, Vcl.Mask, Vcl.ExtCtrls, Vcl.ComCtrls;<N><N>
unit Main.Service;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.SvcMgr, Vcl.Dialogs;<N><N>type<N>  TMainService = class(TService)<N>    procedure ServiceCreate(Sender: TObject);<N>    procedure ServiceStart(Sender: TService; var Started: Boolean);<N>    procedure ServiceStop(Sender: TService; var Stopped: Boolean);<N>  public<N>    function GetServiceController: TServiceController; override;<N>  end;<N><N>
var<N>  MainService: TMainService;<N><N>implementation<N><N>uses Horse;<N><N>{$R *.dfm}<N><N>procedure ServiceController(CtrlCode: DWord); stdcall;<N>begin<N>  MainService.Controller(CtrlCode);<N>end;<N><N>function TMainService.GetServiceController: TServiceController;<N>begin<N>  Result := ServiceController;<N>end;<N><N>
procedure TMainService.ServiceCreate(Sender: TObject);<N>begin<N>  THorse.Get('ping',<N>    procedure(Req: THorseRequest; Res: THorseResponse; Next: TProc)<N>    begin<N>      Res.Send('pong');<N>    end);<N>end;<N><N>procedure TMainService.ServiceStart(Sender: TService; var Started: Boolean);<N>begin<N>  THorse.Listen;<N>  Started := True;<N>end;<N><N>
unit Tests.Api.Vcl;<N><N>interface<N><N>uses<N>  DUnitX.TestFramework, System.JSON, RESTRequest4D.Request, System.Classes,<N>  Controllers.Api, Horse, Horse.Jhonson, SysUtils;<N><N>type<N>  [TestFixture]<N>  TApiTest = class(TObject)<N>  private<N>    FJSONObject: TJSONObject;<N>    FJSONArray: TJSONArray;<N><N>
    procedure CreateApi;<N>    procedure StartApiListen;<N>    procedure StartApiListenPort;<N>    procedure StartApiListenHost;<N>    procedure StartApiListens;<N>    procedure StartApiPortListens;<N>    procedure StopApiListen;<N>    procedure StopApi;<N>  public<N>    [TearDown]<N>    procedure TearDown;<N><N>
    [Test]<N>    procedure TestGet;<N>    [Test]<N>    [TestCase('Test01', 'POST request test')]<N>    procedure TestPost(const AValue: string);<N>    [Test]<N>    [TestCase('Test01', 'PUT request test')]<N>    procedure TestPut(const AValue: string);<N>    [Test]<N>    [TestCase('Test01', '1')]<N>    procedure TestDelete(const AValue: string);<N>    [Test]<N>    procedure TestGStartApiPortListens;<N>    [Test]<N>    procedure TestCreateApi;<N>    [Test]<N>    procedure TestToHorse;<N>  end;<N><N>
implementation<N><N>{ TApiTest }<N><N>procedure TApiTest.StartApiListen;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        THorse<N>          .Use(Jhonson);<N><N>        Controllers.Api.Registry;<N>        THorse.MaxConnections := 10;<N>        THorse.Listen;<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiListenPort;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen(9000);<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiListenHost;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen('0.0.0.0');<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiListens;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen(<N>          procedure(Horse: THorse)<N>          begin<N>          end);<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiPortListens;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen(9000,<N>          procedure(Horse: THorse)<N>          begin<N>          end);<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StopApiListen;<N>begin<N>  THorse.StopListen;<N>end;<N><N>procedure TApiTest.StopApi;<N>begin<N>  // Warnings have been disabled for this segment as the stop has been depreciated.<N>  {$WARNINGS OFF}<N>  THorse.StopListen;<N>  {$WARNINGS ON}<N>end;<N><N>
procedure TApiTest.TestGStartApiPortListens;<N>begin<N>  StartApiPortListens;<N>  StopApi;<N>end;<N><N>procedure TApiTest.TestGet;<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListen;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')<N>    .Accept('application/json')<N>    .Get;<N><N>
  FJSONArray := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONArray;<N><N>  Assert.AreEqual(9000, THorse.Port);<N>  Assert.AreEqual('0.0.0.0', THorse.Host);<N>  Assert.AreEqual(10, THorse.MaxConnections);<N>  Assert.AreEqual(LResponse.StatusCode, 200);<N>  Assert.AreEqual(FJSONArray.Count, 3);<N>  StopApiListen;<N>end;<N><N>
procedure TApiTest.TestPost(const AValue: string);<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListenPort;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')<N>    .Accept('application/json')<N>    .AddBody('{"value": "' + AValue + '"}')<N>    .Post;<N><N>
  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;<N>  Assert.AreEqual(LResponse.StatusCode, 201);<N><N>  if (not FJSONObject.GetValue('value').Null) then<N>    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)<N>  else<N>    Assert.Fail('The return is not without correct format.');<N>  StopApiListen;<N>end;<N><N>
procedure TApiTest.TestPut(const AValue: string);<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListenHost;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')<N>    .Accept('application/json')<N>    .AddBody('{"value": "' + AValue + '"}')<N>    .Put;<N><N>
  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;<N>  Assert.AreEqual(LResponse.StatusCode, 200);<N><N>  if (not FJSONObject.GetValue('value').Null) then<N>    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)<N>  else<N>    Assert.Fail('The return is not in the correct format.');<N>  StopApiListen;<N>end;<N><N>
procedure TApiTest.TestDelete(const AValue: string);<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListens;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test/' + AValue)<N>    .Accept('application/json')<N>    .Delete;<N><N>  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;<N>  Assert.AreEqual(LResponse.StatusCode, 200);<N><N>
  if (not FJSONObject.GetValue('value').Null) then<N>    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)<N>  else<N>    Assert.Fail('The return is not in the correct format.');<N>  StopApiListen;<N>end;<N><N>procedure TApiTest.CreateApi;<N>begin<N>  // Warnings have been disabled for this segment as the create has been depreciated.<N>  {$WARNINGS OFF}<N>  THorse.Create;<N>  {$WARNINGS ON}<N>end;<N><N>
procedure TApiTest.TearDown;<N>begin<N>  FreeAndNil(FJSONObject);<N>  FreeAndNil(FJSONArray);<N>end;<N><N>procedure TApiTest.TestCreateApi;<N>begin<N>  Assert.WillRaise(CreateApi, Exception, 'The Horse instance has already been created');<N>end;<N><N>procedure TApiTest.TestToHorse;<N>begin<N>  Assert.IsNotNull(THorse.ToModule.ToHorse, 'Module instance must not be null');<N>end;<N><N>
unit Tests.Horse.Core.Param;<N><N>interface<N><N>uses<N>  DUnitX.TestFramework,<N>  Horse.Exception,<N>  Horse.Core.Param,<N>  System.Generics.Collections,<N>  System.Classes,<N>  System.DateUtils,<N>  System.SysUtils;<N><N>type<N>  [TestFixture]<N>  TTestHorseCoreParam = class<N>  private<N>    FParams: TDictionary<string, String>;<N>    FHorseParam: THorseCoreParam;<N>    FData: TDateTime;<N>    FTime: TTime;<N>    FFormatSettings: TFormatSettings;<N>    FStream: TStream;<N><N>
    function RequiredMessage(const AKey: String): string;<N>    function ConvertErrorMessage(const AKey, AValue, AType: String): string;<N><N>  public<N>    [Setup]<N>    procedure Setup;<N><N>    [TearDown]<N>    procedure TearDown;<N><N>    [Test]<N>    procedure ContainsKey;<N><N>
    [Test]<N>    procedure NotContainsKey;<N><N>    [Test]<N>    procedure ContainsKeyDiferentCase;<N><N>    [Test]<N>    procedure ContainsValue;<N><N>    [Test]<N>    procedure NotContainsValue;<N><N>    [Test]<N>    procedure ToArray;<N><N>    [Test]<N>    procedure TryGetValueTrue;<N><N>
    [Test]<N>    procedure TryGetValueFalse;<N><N>    [Test]<N>    procedure TryGetValueDiferentCase;<N><N>    [Test]<N>    procedure Content;<N><N>    [Test]<N>    procedure Count;<N><N>    [Test]<N>    procedure List;<N><N>    [Test]<N>    procedure Index;<N><N>
    [Test]<N>    procedure IndexNotFound;<N><N>    [Test]<N>    procedure IndexDiferentCase;<N><N>    [Test]<N>    procedure AsBoolean;<N><N>    [Test]<N>    [TestCase('TrueValue1', 'True,true,true')]<N>    [TestCase('TrueValue2', '1,1,true')]<N>    [TestCase('FalseValue1', 'False,true,false')]<N>    [TestCase('FalseValue2', '5,1,false')]<N>    procedure AsBooleanParam(AParamValue, ATrueValue: string; AResult: Boolean);<N><N>
    [Test]<N>    procedure AsBooleanNotRequired;<N><N>    [Test]<N>    procedure AsBooleanRequired;<N><N>    [Test]<N>    procedure AsCurrency;<N><N>    [Test]<N>    procedure AsCurrencyDecimalSeparator;<N><N>    [Test]<N>    procedure AsCurrencyNotRequired;<N><N>
    [Test]<N>    procedure AsCurrencyRequired;<N><N>    [Test]<N>    procedure AsCurrencyErrorFormat;<N><N>    [Test]<N>    procedure AsDateTime;<N><N>    [Test]<N>    procedure AsDateTimeRequired;<N><N>    [Test]<N>    procedure AsDateTimeNotRequired;<N><N>
    [Test]<N>    procedure AsDateTimeOnlyData;<N><N>    [Test]<N>    procedure AsDateTimeChangeFormat;<N><N>    [Test]<N>    procedure AsDateTimeInvalidFormat;<N><N>    [Test]<N>    procedure AsDate;<N><N>    [Test]<N>    procedure AsDateRequired;<N><N>    [Test]<N>    procedure AsDateNotRequired;<N><N>
    [Test]<N>    procedure AsDateChangeFormat;<N><N>    [Test]<N>    procedure AsDateInvalidFormat;<N><N>    [Test]<N>    procedure AsExtended;<N><N>    [Test]<N>    procedure AsExtendedDecimalSeparator;<N><N>    [Test]<N>    procedure AsExtendedNotRequired;<N><N>
    [Test]<N>    procedure AsExtendedRequired;<N><N>    [Test]<N>    procedure AsExtendedErrorFormat;<N><N>    [Test]<N>    procedure AsFloat;<N><N>    [Test]<N>    procedure AsFloatDecimalSeparator;<N><N>    [Test]<N>    procedure AsFloatNotRequired;<N><N>
    [Test]<N>    procedure AsFloatRequired;<N><N>    [Test]<N>    procedure AsFloatErrorFormat;<N><N>    [Test]<N>    procedure AsInteger;<N><N>    [Test]<N>    procedure AsIntegerNotRequired;<N><N>    [Test]<N>    procedure AsIntegerRequired;<N><N>    [Test]<N>    procedure AsIntegerErrorFormat;<N><N>
    [Test]<N>    procedure AsInt64;<N><N>    [Test]<N>    procedure AsInt64NotRequired;<N><N>    [Test]<N>    procedure AsInt64Required;<N><N>    [Test]<N>    procedure AsInt64ErrorFormat;<N><N>    [Test]<N>    procedure AsISO8601DateTime;<N><N>    [Test]<N>    procedure AsISO8601DateTimeOnlyData;<N><N>
    [Test]<N>    procedure AsISO8601DateTimeNotRequired;<N><N>    [Test]<N>    procedure AsISO8601DateTimeRequired;<N><N>    [Test]<N>    procedure AsISO8601DateTimeErrorFormat;<N><N>    [Test]<N>    procedure AsStream;<N><N>    [Test]<N>    procedure AsStreamNotFoundNotRequired;<N><N>
    [Test]<N>    procedure AsStreamNotFoundRequired;<N><N>    [Test]<N>    procedure AsStreamSaveToFile;<N><N>    [Test]<N>    procedure AsStreamNotFoundSaveToFile;<N><N>    [Test]<N>    procedure AsString;<N><N>    [Test]<N>    procedure AsStringRequired;<N><N>
    [Test]<N>    procedure AsStringNotRequired;<N><N>    [Test]<N>    procedure AsStringDiferentCase;<N><N>    [Test]<N>    procedure AsTime;<N><N>    [Test]<N>    procedure AsTimeRequired;<N><N>    [Test]<N>    procedure AsTimeNotRequired;<N><N>    [Test]<N>    procedure AsTimeChangeFormat;<N><N>
    [Test]<N>    procedure AsTimeInvalidFormat;<N>  end;<N><N>implementation<N><N>{ TTestHorseCoreParam }<N><N>procedure TTestHorseCoreParam.AsBoolean;<N>begin<N>  FParams.AddOrSetValue('Key1', 'True');<N>  Assert.IsTrue(FHorseParam.Field('Key1').Required.AsBoolean);<N>end;<N><N>
procedure TTestHorseCoreParam.AsBooleanNotRequired;<N>begin<N>  Assert.IsFalse(FHorseParam.Field('Key1').AsBoolean);<N>end;<N><N>procedure TTestHorseCoreParam.AsBooleanParam(AParamValue, ATrueValue: string; AResult: Boolean);<N>begin<N>  FParams.AddOrSetValue('Key1', AParamValue);<N>  Assert.AreEqual(AResult, FHorseParam.Field('Key1').Required.TrueValue(ATrueValue).AsBoolean);<N>end;<N><N>
procedure TTestHorseCoreParam.AsBooleanRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsBoolean;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>procedure TTestHorseCoreParam.AsCurrency;<N>begin<N>  FParams.AddOrSetValue('Key1', '5.5');<N>  Assert.AreEqual('5,5', CurrToStr( FHorseParam.Field('Key1').AsCurrency));<N>end;<N><N>
procedure TTestHorseCoreParam.AsCurrencyDecimalSeparator;<N>begin<N>  FParams.AddOrSetValue('Key1', '5,5');<N>  Assert.AreEqual('5,5', CurrToStr( FHorseParam.Field('Key1').AsCurrency));<N>end;<N><N>procedure TTestHorseCoreParam.AsCurrencyErrorFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', '5a');<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsCurrency;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', '5a', 'numeric'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsCurrencyNotRequired;<N>begin<N>  Assert.AreEqual('0', CurrToStr(FHorseParam.Field('Key1').AsCurrency));<N>end;<N><N>procedure TTestHorseCoreParam.AsCurrencyRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsCurrency;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsDate;<N>begin<N>  FData := EncodeDate(2021, 11, 13);<N>  FParams.Add('Key1', '2021-11-13 10:25:32');<N><N>  Assert.AreEqual(DateToStr(FData), DateToStr(FHorseParam.Field('Key1').AsDate));<N>end;<N><N>procedure TTestHorseCoreParam.AsDateChangeFormat;<N>begin<N>  FData := EncodeDate(2021, 11, 13);<N>  FParams.Add('Key1', '13/11/2021');<N><N>
  Assert.AreEqual(DateToStr(FData), DateToStr(FHorseParam.Field('Key1').Required.DateFormat('dd/MM/yyyy').AsDate));<N>end;<N><N>procedure TTestHorseCoreParam.AsDateInvalidFormat;<N>begin<N>  FParams.Add('Key1', '2021/11-13');<N><N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsDate;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', '2021/11-13', 'date'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsDateNotRequired;<N>begin<N>  Assert.IsTrue(FHorseParam.Field('Key1').AsDate = 0);<N>end;<N><N>procedure TTestHorseCoreParam.AsDateRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsDate;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsDateTime;<N>begin<N>  FData := EncodeDateTime(2021, 11, 13, 10, 25, 32, 0);<N>  FParams.Add('Key1', '2021-11-13 10:25:32');<N><N>  Assert.AreEqual(DateToStr(FData), DateToStr(FHorseParam.Field('Key1').AsDateTime));<N>end;<N><N>
procedure TTestHorseCoreParam.AsDateTimeChangeFormat;<N>begin<N>  FData := EncodeDateTime(2021, 11, 13, 10, 25, 32, 0);<N>  FParams.Add('Key1', '13/11/2021 10:25:32');<N><N>  Assert.AreEqual(DateToStr(FData), DateToStr(FHorseParam.Field('Key1').Required.DateFormat('dd/MM/yyyy').AsDateTime));<N>end;<N><N>
procedure TTestHorseCoreParam.AsDateTimeInvalidFormat;<N>begin<N>  FParams.Add('Key1', '2021/11-13 10:25:32');<N><N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsDateTime;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', '2021/11-13 10:25:32', 'datetime'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsDateTimeNotRequired;<N>begin<N>  Assert.IsTrue(FHorseParam.Field('Key1').Required(False).AsDateTime = 0);<N>end;<N><N>procedure TTestHorseCoreParam.AsDateTimeOnlyData;<N>begin<N>  FData := EncodeDate(2021, 11, 13);<N>  FParams.Add('Key1', '2021-11-13');<N><N>
  Assert.AreEqual(DateToStr(FData), DateToStr(FHorseParam.Field('Key1').AsDateTime));<N>end;<N><N>procedure TTestHorseCoreParam.AsDateTimeRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsDateTime;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsExtended;<N>begin<N>  FParams.AddOrSetValue('Key1', '5.5');<N>  Assert.AreEqual('5,5', FHorseParam.Field('Key1').AsExtended.ToString(FFormatSettings));<N>end;<N><N>procedure TTestHorseCoreParam.AsExtendedDecimalSeparator;<N>begin<N>  FParams.AddOrSetValue('Key1', '5,5');<N>  Assert.AreEqual('5,5', FHorseParam.Field('Key1').AsExtended.ToString(FFormatSettings));<N>end;<N><N>
procedure TTestHorseCoreParam.AsExtendedErrorFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', '5a');<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsExtended;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', '5a', 'numeric'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsExtendedNotRequired;<N>begin<N>  Assert.AreEqual('0', FHorseParam.Field('Key1').AsExtended.ToString);<N>end;<N><N>procedure TTestHorseCoreParam.AsExtendedRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsExtended;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsFloat;<N>begin<N>  FParams.AddOrSetValue('Key1', '5.5');<N>  Assert.AreEqual('5,5', FHorseParam.Field('Key1').AsFloat.ToString(FFormatSettings));<N>end;<N><N>procedure TTestHorseCoreParam.AsFloatDecimalSeparator;<N>begin<N>  FParams.AddOrSetValue('Key1', '5,5');<N>  Assert.AreEqual('5,5', FHorseParam.Field('Key1').AsFloat.ToString(FFormatSettings));<N>end;<N><N>
procedure TTestHorseCoreParam.AsFloatErrorFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', '5a');<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsFloat;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', '5a', 'numeric'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsFloatNotRequired;<N>begin<N>  Assert.AreEqual('0', FHorseParam.Field('Key1').Required(False).AsFloat.ToString);<N>end;<N><N>procedure TTestHorseCoreParam.AsFloatRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required(True).AsFloat;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsInt64;<N>begin<N>  FParams.AddOrSetValue('Key1', '5');<N>  Assert.AreEqual('5', FHorseParam.Field('Key1').AsInt64.ToString);<N>end;<N><N>procedure TTestHorseCoreParam.AsInt64ErrorFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value');<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsInt64;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', 'Value', 'int64'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsInt64NotRequired;<N>begin<N>  Assert.AreEqual('0', FHorseParam.Field('Key1').Required(False).AsInt64.ToString);<N>end;<N><N>procedure TTestHorseCoreParam.AsInt64Required;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required(True).AsInt64;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsInteger;<N>begin<N>  FParams.AddOrSetValue('Key1', '5');<N>  Assert.AreEqual(5, FHorseParam.Field('Key1').AsInteger);<N>end;<N><N>procedure TTestHorseCoreParam.AsIntegerErrorFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value');<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsInteger;<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', 'Value', 'integer'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsIntegerNotRequired;<N>begin<N>  Assert.AreEqual(0, FHorseParam.Field('Key1').AsInteger);<N>end;<N><N>procedure TTestHorseCoreParam.AsIntegerRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required(True).AsInteger;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsISO8601DateTime;<N>begin<N>  FData := EncodeDateTime(2021, 11, 13, 10, 21, 22, 0);<N>  FParams.AddOrSetValue('Key1', '2021-11-13T10:21:22');<N><N>  Assert.AreEqual(DateToStr(FData), DateToStr(FHorseParam.Field('Key1').AsISO8601DateTime));<N>end;<N><N>
procedure TTestHorseCoreParam.AsISO8601DateTimeErrorFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', '2021-11-13 10:21:22');<N>  Assert.WillNotRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').AsISO8601DateTime;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsISO8601DateTimeNotRequired;<N>begin<N>  Assert.IsTrue(FHorseParam.Field('Key1').Required(False).AsISO8601DateTime = 0);<N>end;<N><N>procedure TTestHorseCoreParam.AsISO8601DateTimeOnlyData;<N>begin<N>  FData := EncodeDateTime(2021, 11, 13, 10, 21, 22, 0);<N>  FParams.AddOrSetValue('Key1', '2021-11-13');<N><N>
  Assert.AreEqual(FormatDateTime('dd/MM/yyyy', FData), FormatDateTime('dd/MM/yyyy', FHorseParam.Field('Key1').AsISO8601DateTime));<N>end;<N><N>procedure TTestHorseCoreParam.AsISO8601DateTimeRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsISO8601DateTime;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsStream;<N>begin<N>  FStream := TStringStream.Create('1234');<N>  FHorseParam.AddStream('Key1', FStream);<N><N>  Assert.IsNotNull(FHorseParam.Field('Key1').AsStream);<N>  Assert.AreEqual<Int64>(0, FHorseParam.Field('Key1').AsStream.Position);<N>end;<N><N>
procedure TTestHorseCoreParam.AsStreamNotFoundNotRequired;<N>begin<N>  Assert.IsNull(FHorseParam.Field('Key1').AsStream);<N>end;<N><N>procedure TTestHorseCoreParam.AsStreamNotFoundRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required(True).AsStream<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsStreamNotFoundSaveToFile;<N>var<N>  LFile: String;<N>begin<N>  LFile := 'test.txt';<N>  Assert.IsFalse(FileExists(LFile));<N><N>  FHorseParam.Field('Key1').SaveToFile(LFile);<N>  Assert.IsFalse(FileExists(LFile));<N>end;<N><N>
procedure TTestHorseCoreParam.AsStreamSaveToFile;<N>var<N>  LFile: String;<N>begin<N>  LFile := 'test.txt';<N>  Assert.IsFalse(FileExists(LFile));<N><N>  FStream := TStringStream.Create('1234');<N>  FHorseParam.AddStream('Key1', FStream);<N><N>  FHorseParam.Field('Key1').SaveToFile(LFile);<N>  Assert.IsTrue(FileExists(LFile));<N>  DeleteFile(LFile);<N>end;<N><N>
procedure TTestHorseCoreParam.AsString;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value');<N>  Assert.AreEqual('Value', FHorseParam.Field('Key1').AsString);<N>end;<N><N>procedure TTestHorseCoreParam.AsStringDiferentCase;<N>begin<N>  FParams.AddOrSetValue('key1', 'Value');<N>  Assert.AreEqual('Value', FHorseParam.Field('Key1').AsString);<N>end;<N><N>
procedure TTestHorseCoreParam.AsStringNotRequired;<N>begin<N>  Assert.IsEmpty(FHorseParam.Field('Key1').AsString);<N>end;<N><N>procedure TTestHorseCoreParam.AsStringRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseParam.Field('Key1').Required.AsString;<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsTime;<N>begin<N>  FTime := EncodeTime(10, 15, 54, 0);<N>  FParams.AddOrSetValue('Key1', '10:15:54');<N><N>  Assert.AreEqual(FTime, FHorseParam.Field('Key1').AsTime);<N>end;<N><N>procedure TTestHorseCoreParam.AsTimeChangeFormat;<N>begin<N>  FTime := EncodeTime(10, 15, 0, 0);<N>  FParams.AddOrSetValue('Key1', '10:15:54');<N><N>
  Assert.AreEqual(FTime, FHorseParam.Field('Key1').TimeFormat('hh:mm').AsTime);<N>end;<N><N>procedure TTestHorseCoreParam.AsTimeInvalidFormat;<N>begin<N>  FParams.AddOrSetValue('Key1', '10/00');<N><N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      Assert.AreEqual(FTime, FHorseParam.Field('Key1').AsTime);<N>    end,<N>    EHorseException,<N>    ConvertErrorMessage('Key1', '10/00', 'time'));<N>end;<N><N>
procedure TTestHorseCoreParam.AsTimeNotRequired;<N>begin<N>  Assert.IsTrue(FHorseParam.Field('Key1').AsTime = 0);<N>end;<N><N>procedure TTestHorseCoreParam.AsTimeRequired;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      Assert.AreEqual(FTime, FHorseParam.Field('Key1').Required.AsTime);<N>    end,<N>    EHorseException,<N>    RequiredMessage('Key1'));<N>end;<N><N>
procedure TTestHorseCoreParam.ContainsKey;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value');<N>  Assert.IsTrue(FHorseParam.ContainsKey('Key1'));<N>end;<N><N>procedure TTestHorseCoreParam.ContainsKeyDiferentCase;<N>begin<N>  FParams.AddOrSetValue('key1', 'Value');<N>  Assert.IsTrue(FHorseParam.ContainsKey('KEY1'));<N>end;<N><N>
procedure TTestHorseCoreParam.ContainsValue;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value');<N>  Assert.IsTrue(FHorseParam.ContainsValue('Value'));<N>end;<N><N>procedure TTestHorseCoreParam.Content;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value1');<N>  FParams.AddOrSetValue('Key2', 'Value2');<N><N>
  Assert.AreEqual(2, FHorseParam.Content.Count);<N>  Assert.AreEqual('Key1', FHorseParam.Content.Names[0]);<N>  Assert.AreEqual('Key2', FHorseParam.Content.Names[1]);<N>  Assert.AreEqual('Value1', FHorseParam.Content.ValueFromIndex[0]);<N>  Assert.AreEqual('Value2', FHorseParam.Content.ValueFromIndex[1]);<N>end;<N><N>
function TTestHorseCoreParam.ConvertErrorMessage(const AKey, AValue, AType: String): string;<N>begin<N>  result := Format('The %s param ''%s'' is not valid a %s type.', [AKey, AValue, AType]);<N>end;<N><N>procedure TTestHorseCoreParam.Count;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value1');<N>  FParams.AddOrSetValue('Key2', 'Value2');<N><N>
  Assert.AreEqual(2, FHorseParam.Count);<N>end;<N><N>procedure TTestHorseCoreParam.Index;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value1');<N>  Assert.AreEqual('Value1', FHorseParam['Key1']);<N>end;<N><N>procedure TTestHorseCoreParam.IndexDiferentCase;<N>begin<N>  FParams.AddOrSetValue('KEY1', 'Value1');<N>  Assert.AreEqual('Value1', FHorseParam['key1']);<N>end;<N><N>
procedure TTestHorseCoreParam.IndexNotFound;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value1');<N>  Assert.IsEmpty(FHorseParam.Items['Value1']);<N>end;<N><N>procedure TTestHorseCoreParam.List;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value1');<N>  FParams.AddOrSetValue('Key2', 'Value2');<N><N>
  Assert.AreEqual(2, FHorseParam.Count);<N>  Assert.AreEqual(FParams, FHorseParam.Dictionary);<N>end;<N><N>procedure TTestHorseCoreParam.NotContainsKey;<N>begin<N>  FParams.AddOrSetValue('Key', 'Value');<N>  Assert.IsFalse(FHorseParam.ContainsKey('Value'));<N>end;<N><N>
procedure TTestHorseCoreParam.NotContainsValue;<N>begin<N>  FParams.AddOrSetValue('Key', 'Value');<N>  Assert.IsFalse(FHorseParam.ContainsValue('Key'));<N>end;<N><N>function TTestHorseCoreParam.RequiredMessage(const AKey: String): string;<N>begin<N>  result := Format('The %s param is required.', [AKey]);<N>end;<N><N>
procedure TTestHorseCoreParam.Setup;<N>begin<N>  FParams := TDictionary<String, String>.Create;<N>  FHorseParam := THorseCoreParam.create(FParams);<N>  FFormatSettings := TFormatSettings.Create;<N>  FFormatSettings.DecimalSeparator := ',';<N>  FData := 0;<N>  FTime := 0;<N>end;<N><N>
procedure TTestHorseCoreParam.TearDown;<N>begin<N>  FreeAndNil(FHorseParam);<N>  FreeAndNil(FStream);<N>end;<N><N>procedure TTestHorseCoreParam.ToArray;<N>var<N>  LPairs: TArray<TPair<String, String>>;<N>begin<N>  FParams.AddOrSetValue('Key1', 'Value1');<N>  FParams.AddOrSetValue('Key2', 'Value2');<N><N>
  LPairs := FHorseParam.ToArray;<N><N>  Assert.AreEqual(2, Length(LPairs));<N>  Assert.AreEqual('Key1', LPairs[0].Key);<N>  Assert.AreEqual('Value1', LPairs[0].Value);<N>  Assert.AreEqual('Key2', LPairs[1].Key);<N>  Assert.AreEqual('Value2', LPairs[1].Value);<N>end;<N><N>
procedure TTestHorseCoreParam.TryGetValueDiferentCase;<N>var<N>  LValue: String;<N>begin<N>  FParams.AddOrSetValue('KEY1', 'Value1');<N>  Assert.IsTrue(FHorseParam.TryGetValue('key1', LValue));<N>  Assert.AreEqual('Value1', LValue);<N>end;<N><N>procedure TTestHorseCoreParam.TryGetValueFalse;<N>var<N>  LValue: String;<N>begin<N>  Assert.IsFalse(FHorseParam.TryGetValue('Key1', LValue));<N>end;<N><N>
unit Tests.Api.Console;<N><N>interface<N><N>uses<N>  DUnitX.TestFramework, System.JSON, RESTRequest4D.Request, System.Classes,<N>  Controllers.Api, Horse, Horse.Jhonson, SysUtils;<N><N>type<N>  [TestFixture]<N>  TApiTest = class(TObject)<N>  private<N>    FJSONObject: TJSONObject;<N>    FJSONArray: TJSONArray;<N><N>
    procedure CreateApi;<N>    procedure StartApiListen;<N>    procedure StartApiListenPort;<N>    procedure StartApiListenHost;<N>    procedure StartApiListens;<N>    procedure StartApiPortListens;<N>    procedure StopApiListen;<N>    procedure StopApi;<N>  public<N>    [TearDown]<N>    procedure TearDown;<N><N>
    [Test]<N>    procedure TestGet;<N>    [Test]<N>    [TestCase('Test01', 'POST request test')]<N>    procedure TestPost(const AValue: string);<N>    [Test]<N>    [TestCase('Test01', 'PUT request test')]<N>    procedure TestPut(const AValue: string);<N>    [Test]<N>    [TestCase('Test01', '1')]<N>    procedure TestDelete(const AValue: string);<N>    [Test]<N>    procedure TestGStartApiPortListens;<N>    [Test]<N>    procedure TestCreateApi;<N>    [Test]<N>    procedure TestToHorse;<N>  end;<N><N>
implementation<N><N>{ TApiTest }<N><N>procedure TApiTest.StartApiListen;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        THorse<N>          .Use(Jhonson);<N><N>        Controllers.Api.Registry;<N>        THorse.MaxConnections := 10;<N>        THorse.Listen;<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiListenPort;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen(9000);<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiListenHost;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen('0.0.0.0');<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiListens;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen(<N>          procedure(Horse: THorse)<N>          begin<N>          end,<N>          procedure(Horse: THorse)<N>          begin<N>          end);<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StartApiPortListens;<N>begin<N>  if (not THorse.IsRunning) then<N>  begin<N>    TThread.CreateAnonymousThread(<N>      procedure<N>      begin<N>        Controllers.Api.Registry;<N>        THorse.Listen(9000,<N>          procedure(Horse: THorse)<N>          begin<N>          end,<N>          procedure(Horse: THorse)<N>          begin<N>          end);<N>      end).Start;<N>  end;<N>end;<N><N>
procedure TApiTest.StopApiListen;<N>begin<N>  THorse.StopListen;<N>end;<N><N>procedure TApiTest.StopApi;<N>begin<N>  // Warnings have been disabled for this segment as the stop has been depreciated.<N>  {$WARNINGS OFF}<N>  THorse.StopListen;<N>  {$WARNINGS ON}<N>end;<N><N>
procedure TApiTest.TestGStartApiPortListens;<N>begin<N>  StartApiPortListens;<N>  StopApi;<N>end;<N><N>procedure TApiTest.TestGet;<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListen;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')<N>    .Accept('application/json')<N>    .Get;<N><N>
  FJSONArray := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONArray;<N>  Assert.AreEqual(9000, THorse.Port);<N>  Assert.AreEqual('0.0.0.0', THorse.Host);<N>  Assert.AreEqual(10, THorse.MaxConnections);<N>  Assert.AreEqual(LResponse.StatusCode, 200);<N>  Assert.AreEqual(FJSONArray.Count, 3);<N>  StopApiListen;<N>end;<N><N>
procedure TApiTest.TestPost(const AValue: string);<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListenPort;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')<N>    .Accept('application/json')<N>    .AddBody('{"value": "' + AValue + '"}')<N>    .Post;<N><N>
  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;<N>  Assert.AreEqual(LResponse.StatusCode, 201);<N><N>  if (not FJSONObject.GetValue('value').Null) then<N>    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)<N>  else<N>    Assert.Fail('The return is not without correct format.');<N>  StopApiListen;<N>end;<N><N>
procedure TApiTest.TestPut(const AValue: string);<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListenHost;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')<N>    .Accept('application/json')<N>    .AddBody('{"value": "' + AValue + '"}')<N>    .Put;<N><N>
  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;<N>  Assert.AreEqual(LResponse.StatusCode, 200);<N><N>  if (not FJSONObject.GetValue('value').Null) then<N>    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)<N>  else<N>    Assert.Fail('The return is not in the correct format.');<N>  StopApiListen;<N>end;<N><N>
procedure TApiTest.TestDelete(const AValue: string);<N>var<N>  LResponse: IResponse;<N>begin<N>  StartApiListens;<N>  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test/' + AValue)<N>    .Accept('application/json')<N>    .Delete;<N><N>  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;<N>  Assert.AreEqual(LResponse.StatusCode, 200);<N><N>
  if (not FJSONObject.GetValue('value').Null) then<N>    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)<N>  else<N>    Assert.Fail('The return is not in the correct format.');<N>  StopApiListen;<N>end;<N><N>procedure TApiTest.CreateApi;<N>begin<N>  // Warnings have been disabled for this segment as the create has been depreciated.<N>  {$WARNINGS OFF}<N>  THorse.Create;<N>  {$WARNINGS ON}<N>end;<N><N>
procedure TApiTest.TearDown;<N>begin<N>  FreeAndNil(FJSONObject);<N>  FreeAndNil(FJSONArray);<N>end;<N><N>procedure TApiTest.TestCreateApi;<N>begin<N>  Assert.WillRaise(CreateApi, Exception, 'The Horse instance has already been created');<N>end;<N><N>procedure TApiTest.TestToHorse;<N>begin<N>  Assert.IsNotNull(THorse.ToModule.ToHorse, 'Module instance must not be null');<N>end;<N><N>
unit Tests.Commons;<N><N>interface<N><N>uses<N>  DUnitX.TestFramework, Horse.Commons;<N><N>type<N>  [TestFixture]<N>  TCommonsTest = class(TObject)<N>  public<N>    [Test]<N>    procedure TestMimeTypesToString;<N>  end;<N><N>implementation<N><N>{ TCommonsTest }<N><N>
unit Tests.Horse.Core.Files;<N><N>interface<N><N>uses<N>  DUnitX.TestFramework,<N>  Horse.Core.Files,<N>  System.Classes,<N>  System.SysUtils;<N><N>type<N>  [TestFixture]<N>  TTestHorseCoreFile = class<N>  private<N>    FHorseFile: THorseCoreFile;<N>    FFileName: String;<N><N>
  public<N>    [Setup]<N>    procedure Setup;<N><N>    [Teardown]<N>    procedure Teardown;<N><N>    [Test]<N>    procedure EmptyFileName;<N><N>    [Test]<N>    procedure InvalidFileName;<N><N>    [Test]<N>    procedure DelphiFile;<N>  end;<N><N>implementation<N><N>
{ TTestHorseCoreFile }<N><N>procedure TTestHorseCoreFile.DelphiFile;<N>begin<N>  FFileName := ExtractFilePath(GetModuleName(HInstance));<N>  FFileName := FFileName.Replace('tests\', 'src\Horse.pas');<N><N>  FHorseFile := THorseCoreFile.Create(FFileName);<N><N>
  Assert.AreEqual('text/x-pascal', FHorseFile.ContentType);<N>  Assert.IsNotNull(FHorseFile.ContentStream);<N>  Assert.IsTrue(FHorseFile.Size > 0);<N>end;<N><N>procedure TTestHorseCoreFile.EmptyFileName;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseFile := THorseCoreFile.Create(EmptyStr);<N>    end,<N>    Exception,<N>    'Invalid FileName');<N>end;<N><N>
procedure TTestHorseCoreFile.InvalidFileName;<N>begin<N>  Assert.WillRaiseWithMessage(<N>    procedure<N>    begin<N>      FHorseFile := THorseCoreFile.Create('C:\InvalidFile.txt2');<N>    end,<N>    Exception,<N>    'File not exist');<N>end;<N><N>procedure TTestHorseCoreFile.Setup;<N>begin<N>  FFileName := EmptyStr;<N>end;<N><N>
unit Controllers.Api;<N><N>interface<N><N>uses<N>  Horse, System.JSON, Horse.Commons;<N><N>procedure Registry;<N>procedure DoGetApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>procedure DoPostApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>procedure DoPutApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>procedure DoDeleteApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N><N>
implementation<N><N>procedure Registry;<N>begin<N>  THorse<N>    .Group<N>      .Prefix('/Api')<N>        .Delete('/Test/:id', DoDeleteApi)<N>        .Route('/Test')<N>          .Get(DoGetApi)<N>          .Post(DoPostApi)<N>          .Put(DoPutApi)<N>end;<N><N>
procedure DoGetApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LList: TJSONArray;<N>  LObject01: TJSONObject;<N>  LObject02: TJSONObject;<N>  LObject03: TJSONObject;<N>begin<N>  LList := TJSONArray.Create;<N>  try<N>    LObject01 := TJSONObject.Create;<N>    LObject01.AddPair(TJSONPair.Create('value', 'test01'));<N>    LList.AddElement(LObject01);<N><N>
    LObject02 := TJSONObject.Create;<N>    LObject02.AddPair(TJSONPair.Create('value', 'test02'));<N>    LList.AddElement(LObject02);<N><N>    LObject03 := TJSONObject.Create;<N>    LObject03.AddPair(TJSONPair.Create('value', 'test03'));<N>    LList.AddElement(LObject03);<N><N>
    Res.Send(LList.ToString);<N>  finally<N>    LList.Free;<N>  end;<N>end;<N><N>procedure DoPostApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LValue: string;<N>  LRequest: TJSONObject;<N>  LResponse: TJSONObject;<N>begin<N>  LValue := '';<N>  LRequest := TJSONObject.ParseJSONValue(Req.Body) as TJSONObject;<N>  try<N>    if (not LRequest.GetValue('value').Null) then<N>      LValue := LRequest.GetValue('value').value;<N><N>
    LResponse := TJSONObject.Create;<N>    try<N>      LResponse.AddPair(TJSONPair.Create('value', LValue));<N><N>      Res.Send(LResponse.ToString).Status(THTTPStatus.Created);<N>    finally<N>      LResponse.Free;<N>    end;<N>  finally<N>    LRequest.Free;<N>  end;<N>end;<N><N>
procedure DoPutApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LValue: string;<N>  LRequest: TJSONObject;<N>  LResponse: TJSONObject;<N>begin<N>  LValue := '';<N>  LRequest := TJSONObject.ParseJSONValue(Req.Body) as TJSONObject;<N>  try<N>    if (not LRequest.GetValue('value').Null) then<N>      LValue := LRequest.GetValue('value').value;<N><N>
    LResponse := TJSONObject.Create;<N>    try<N>      LResponse.AddPair(TJSONPair.Create('value', LValue));<N><N>      Res.Send(LResponse.ToString);<N>    finally<N>      LResponse.Free;<N>    end;<N>  finally<N>    LRequest.Free;<N>  end;<N>end;<N><N>procedure DoDeleteApi(Req: THorseRequest; Res: THorseResponse; Next: TProc);<N>var<N>  LValue: string;<N>  LResponse: TJSONObject;<N>begin<N>  LValue := Req.Params['id'];<N><N>
unit Horse.Core.RouterTree.NextCaller;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections, fpHTTP, httpprotocol,<N>{$ELSE}<N>  System.NetEncoding, System.SysUtils, Web.HTTPApp, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Commons, Horse.Request, Horse.Response, Horse.Callback;<N><N>
﻿unit Web.WebConst;<N><N>interface<N><N>resourcestring<N>  sDuplicateActionName = 'Duplicate action name';<N>  sOnlyOneDispatcher = 'Only one WebDispatcher per form/data module';<N>  sHTTPItemName = 'Name';<N>  sHTTPItemURI = 'PathInfo';<N>  sHTTPItemEnabled = 'Enabled';<N>  sHTTPItemDefault = 'Default';<N>  sHTTPItemProducer = 'Producer';<N>  sHTTPItemMethod = 'Method';<N><N>
unit Horse.Proc;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF NOT DEFINED(FPC)}<N>uses System.SysUtils;<N>{$ENDIF}<N><N>type<N>  TNextProc = {$IF DEFINED(FPC)}procedure of object{$ELSE}System.SysUtils.TProc{$ENDIF};<N>  TProc = {$IF DEFINED(FPC)}procedure{$ELSE}System.SysUtils.TProc{$ENDIF};<N><N>{$IF DEFINED(FPC)}<N>  TProc<T> = procedure(Arg1: T);<N>{$ENDIF}<N><N>implementation<N><N>end.<N>
unit Horse.Provider.CGI;<N><N>interface<N><N>{$IF DEFINED(HORSE_CGI) AND NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, System.SysUtils;<N><N>type<N>  THorseProvider<T: class> = class(THorseProviderAbstract<T>)<N>  private<N>    class procedure InternalListen; static;<N>  public<N>    class procedure Listen; overload; override;<N>    class procedure Listen(const ACallback: TProc<T>); reintroduce; overload; static;<N>  end;<N>{$ENDIF}<N><N>
implementation<N><N>{$IF DEFINED(HORSE_CGI) AND NOT DEFINED(FPC)}<N>uses Web.WebBroker, Web.CGIApp, Horse.WebModule;<N><N>class procedure THorseProvider<T>.InternalListen;<N>begin<N>  Application.Initialize;<N>  Application.WebModuleClass := WebModuleClass;<N>  DoOnListen;<N>  Application.Run;<N>end;<N><N>
class procedure THorseProvider<T>.Listen;<N>begin<N>  inherited;<N>  InternalListen;<N>end;<N><N>class procedure THorseProvider<T>.Listen(const ACallback: TProc<T>);<N>begin<N>  inherited;<N>  SetOnListen(ACallback);<N>  InternalListen;<N>end;<N>{$ENDIF}<N><N>
unit Horse.Provider.FPC.Apache;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_APACHE) AND DEFINED(FPC)}<N>uses<N>{$IFDEF unix}<N>  cthreads,<N>{$ENDIF}<N>  fphttp, httpdefs, httpd24, fpApache24, custapache24, SysUtils, Classes, Horse.Provider.Abstract,<N>  Horse.Constants, Horse.Proc;<N><N>
unit Horse.Provider.FPC.Daemon;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_DAEMON)}<N>uses SysUtils, Classes, httpdefs, fpHTTP, fphttpserver, Horse.Request, Horse.Response, Horse.Core, Horse.Provider.Abstract, Horse.Constants,<N>  Horse.Proc, Horse.Commons, Horse.Exception;<N><N>
unit Horse.Core.Param.Field;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, DateUtils, Generics.Collections,<N>{$ELSE}<N>  System.SysUtils, System.Classes, System.DateUtils, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Exception, Horse.Commons, Horse.Core.Param.Field.Brackets,<N>  Horse.Core.Param.Config;<N><N>
type<N><N>  THorseCoreParamField = class<N>  private<N>    FContains: Boolean;<N>    FFieldName: string;<N>    FRequired: Boolean;<N>    FRequiredMessage: string;<N>    FInvalidFormatMessage: string;<N>    FDateFormat: string;<N>    FTimeFormat: string;<N>    FReturnUTC: Boolean;<N>    FTrueValue: string;<N>    FValue: string;<N>    FStream: TStream;<N>    FLhsBrackets: THorseCoreParamFieldLhsBrackets;<N><N>
    function GetFormatSettings: TFormatSettings;<N>    procedure RaiseHorseException(const AMessage: string); overload;<N>    procedure RaiseHorseException(const AMessage: string; const Args: array of const); overload;<N>    function TryISO8601ToDate(const AValue: string; out Value: TDateTime): Boolean;<N><N>
unit Horse.Provider.FPC.LCL;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(HORSE_LCL)}<N>uses SysUtils, Classes, httpdefs, fpHTTP, fphttpapp, Horse.Provider.Abstract, Horse.Constants, Horse.Proc;<N><N>type<N><N>
unit Horse.Session;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections;<N>{$ELSE}<N>  System.SysUtils, System.Generics.Collections;<N>{$ENDIF}<N><N>type<N>  TSession = class<N>  end;<N><N>
unit Horse.Callback;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  Generics.Collections, fpHTTP,<N>{$ELSE}<N>  Web.HTTPApp, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Request, Horse.Response, Horse.Proc, Horse.Commons;<N><N>
{ ****************************************************************************** }<N>{ }<N>{ Linux Daemon with Delphi }<N>{ }<N>{ Author: Paolo Rossi (2017) }<N>{ }<N>{ http://www.paolorossi.net }<N>{ http://blog.paolorossi.net }<N>{ https://github.com/paolo-rossi }<N>{ }<N>{ ****************************************************************************** }<N>unit ThirdParty.Posix.Syslog;<N><N>
unit Horse.Core.Group.Contract;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses Horse.Core.Route.Contract, Horse.Core.RouterTree, Horse.Callback;<N><N>type<N>  IHorseCoreGroup<T: class> = interface<N>    ['{5EB734D6-6944-473E-9C79-506647E2F5E8}']<N>    function Prefix(const APrefix: string): IHorseCoreGroup<T>;<N>    function Route(const APath: string): IHorseCoreRoute<T>;<N><N>
unit Horse.WebModule;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, httpdefs, fpHTTP, fpWeb,<N>{$ELSE}<N>  System.SysUtils, System.Classes, Web.HTTPApp,<N>{$ENDIF}<N>  Horse.Core, Horse.Commons;<N><N>
unit Horse.Provider.FPC.FastCGI;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>{$IF DEFINED(FPC) AND DEFINED(HORSE_FCGI)}<N>uses SysUtils, Classes, fpFCGI, httpdefs, fpHTTP, Horse.Provider.Abstract, Horse.Constants, Horse.Proc;<N><N>
unit Horse.Exception.Interrupted;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils;<N>{$ELSE}<N>  System.SysUtils;<N>{$ENDIF}<N><N>type<N>  EHorseCallbackInterrupted = class(Exception)<N>    constructor Create; reintroduce;<N>  end;<N><N>implementation<N><N>constructor EHorseCallbackInterrupted.Create;<N>begin<N>  inherited Create(EmptyStr);<N>end;<N><N>end.<N>
unit Horse.Core.Files;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, Generics.Collections;<N>{$ELSE}<N>  System.SysUtils, System.Classes, System.Generics.Collections;<N>{$ENDIF}<N><N>
unit Horse.Core.Param.Header;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, Generics.Collections, fpHTTP, fphttpserver, httpprotocol, HTTPDefs,<N>{$ELSE}<N>  System.Classes, System.SysUtils, System.Generics.Collections,<N>  Web.HTTPApp, IdCustomHTTPServer, IdHeaderList, Horse.Rtti,<N>{$ENDIF}<N>  Horse.Core.Param, Horse.Commons, Horse.Rtti.Helper;<N><N>
type<N>  THorseCoreParamHeader = class<N>  private<N>    class function GetHeadersList(const AWebRequest: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF}): TStrings;<N>  public<N>    class function GetHeaders(const AWebRequest: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF}): THorseList;<N>  end;<N><N>
unit Horse.Core.Route.Contract;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses Horse.Core.RouterTree, Horse.Callback;<N><N>type<N>  IHorseCoreRoute<T: class> = interface<N>    ['{8D593D98-44B3-4FD2-A21B-BA29F784B3AA}']<N>    function AddCallback(const ACallback: THorseCallback): IHorseCoreRoute<T>;<N>    function AddCallbacks(const ACallbacks: TArray<THorseCallback>): IHorseCoreRoute<T>;<N><N>
    function All(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const ACallbacks: array of THorseCallback; const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    function Get(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Get(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Get(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Get(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Put(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Put(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Put(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Put(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Head(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Head(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Head(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Head(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Post(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Post(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Post(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Post(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
unit Horse.Request;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, fpHTTP, HTTPDefs,<N>{$ELSE}<N>  System.SysUtils, System.Classes, Web.HTTPApp,<N>  {$IF CompilerVersion > 32.0}<N>    Web.ReqMulti,<N>  {$ENDIF}<N>{$ENDIF}<N>  Horse.Core.Param, Horse.Core.Param.Header, Horse.Commons, Horse.Session;<N><N>
unit Horse.Provider.ISAPI;<N><N>interface<N><N>{$IF DEFINED(HORSE_ISAPI) AND NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, System.SysUtils, Web.Win.ISAPIApp;<N><N>type<N>  THorseProvider<T: class> = class(THorseProviderAbstract<T>)<N>  private<N>    class procedure InternalListen; static;<N>  public<N>    class procedure Listen; overload; override;<N>    class procedure Listen(const ACallback: TProc<T>); reintroduce; overload; static;<N>  end;<N>{$ENDIF}<N><N>
implementation<N><N>{$IF DEFINED(HORSE_ISAPI) AND NOT DEFINED(FPC)}<N>uses Web.WebBroker, System.Win.ComObj, Winapi.ActiveX, Horse.WebModule;<N><N>exports<N>  GetExtensionVersion,<N>  HttpExtensionProc,<N>  TerminateExtension;<N><N>class procedure THorseProvider<T>.InternalListen;<N>begin<N>  CoInitFlags := COINIT_MULTITHREADED;<N>  Application.Initialize;<N>  Application.WebModuleClass := WebModuleClass;<N>  DoOnListen;<N>  Application.Run;<N>end;<N><N>
class procedure THorseProvider<T>.Listen;<N>begin<N>  inherited;<N>  InternalListen;<N>end;<N><N>class procedure THorseProvider<T>.Listen(const ACallback: TProc<T>);<N>begin<N>  inherited;<N>  SetOnListen(ACallback);<N>  InternalListen;<N>end;<N>{$ENDIF}<N><N>
unit Horse.Core.Group;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils,<N>{$ELSE}<N>  System.SysUtils,<N>{$ENDIF}<N>  Horse.Core.Group.Contract, Horse.Core.Route.Contract, Horse.Core.RouterTree, Horse.Callback;<N><N>
type<N>  THorseCoreGroup<T: class> = class(TInterfacedObject, IHorseCoreGroup<T>)<N>  private<N>    FHorseCore: TObject;<N>    FPrefix: string;<N>    function NormalizePath(const APath: string): string;<N>  public<N>    constructor Create;<N><N>    function Prefix(const APrefix: string): IHorseCoreGroup<T>;<N>    function Route(const APath: string): IHorseCoreRoute<T>;<N><N>
unit Horse.Provider.Daemon;<N><N>interface<N><N>{$IF DEFINED(HORSE_DAEMON) AND NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, Horse.Constants, Horse.Provider.IOHandleSSL, IdHTTPWebBrokerBridge, IdSSLOpenSSL, IdContext,<N>  System.SyncObjs, System.SysUtils, Posix.SysTypes;<N><N>
unit Horse.Constants;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>const<N>  DEFAULT_HOST = '0.0.0.0';<N>  DEFAULT_PORT = 9000;<N>  START_RUNNING = 'Server is runing on %s:%d';<N>  HORSE_VERSION = '3.0.2';<N><N>implementation<N><N>end.<N>
unit Horse.Commons;<N><N>{$IF DEFINED(FPC)}<N>{$MODE DELPHI}{$H+}<N>{$MODESWITCH TypeHelpers}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  Classes,<N>  SysUtils,<N>  StrUtils,<N>  RegExpr<N>{$ELSE}<N>    System.Classes,<N>  System.SysUtils,<N>  System.RegularExpressions<N>{$ENDIF}<N>    ;<N><N>
unit Horse.Core.RouterTree;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections, fpHTTP, httpprotocol,<N>{$ELSE}<N>  System.SysUtils, System.NetEncoding, Web.HTTPApp, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Request, Horse.Response, Horse.Proc, Horse.Commons, Horse.Callback;<N><N>
unit Horse.Rtti.Helper;<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  RTTI;<N>{$ELSE}<N>  System.Rtti;<N>{$ENDIF}<N><N>type<N>  THorseRttiTypeHelper = class helper for TRttiType<N>  public<N>    {$IF NOT DEFINED(FPC)}<N>    function FieldValueAsObject(const AInstance: Pointer; const AFieldName: string): TObject;<N>    {$ENDIF}<N>  end;<N><N>
implementation<N><N>{$IF NOT DEFINED(FPC)}<N>function THorseRttiTypeHelper.FieldValueAsObject(const AInstance: Pointer; const AFieldName: string): TObject;<N>var<N>  LField: TRttiField;<N>begin<N>  Result := nil;<N>  LField := GetField(AFieldName);<N>  if Assigned(LField) then<N>    Result := LField.GetValue(AInstance).AsObject;<N>end;<N>{$ENDIF}<N><N>
unit Horse.Response;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, fpHTTP, HTTPDefs,<N>{$ELSE}<N>  System.SysUtils, System.Classes, Web.HTTPApp,<N>  {$IF CompilerVersion > 32.0}<N>    Web.ReqMulti,<N>  {$ENDIF}<N>{$ENDIF}<N>  Horse.Commons, Horse.Core.Files;<N><N>
unit Horse.Provider.Console;<N><N>interface<N><N>{$IF NOT DEFINED(FPC)}<N>uses Horse.Provider.Abstract, Horse.Constants, Horse.Provider.IOHandleSSL, IdHTTPWebBrokerBridge, IdSSLOpenSSL, IdContext,<N>  System.Classes, System.SyncObjs, System.SysUtils;<N><N>
unit Horse.Core.Param;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Classes, DateUtils, Generics.Collections, fpHTTP, fphttpserver, HTTPDefs,<N>{$ELSE}<N>  System.SysUtils, System.Classes, System.DateUtils, System.Generics.Collections,<N>{$ENDIF}<N>  Horse.Exception, Horse.Commons, Horse.Core.Param.Field;<N><N>
unit Horse.Core;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils, Generics.Collections,<N>{$ELSE}<N>  System.SysUtils, System.Generics.Collections, Web.HTTPApp,<N>{$ENDIF}<N>  Horse.Core.RouterTree, Horse.Commons, Horse.Request, Horse.Response, Horse.Constants, Horse.Callback,<N>  Horse.Core.Group.Contract, Horse.Core.Route.Contract;<N><N>
unit Horse.Core.Route;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  SysUtils,<N>{$ELSE}<N>  System.SysUtils,<N>{$ENDIF}<N>  Horse.Core.Route.Contract, Horse.Core.RouterTree, Horse.Callback;<N><N>
type<N>  THorseCoreRoute<T: class> = class(TInterfacedObject, IHorseCoreRoute<T>)<N>  private<N>    FPath: string;<N>    FHorseCore: TObject;<N>  public<N>    constructor Create(const APath: string);<N><N>    function This: IHorseCoreRoute<T>;<N>    function AddCallback(const ACallback: THorseCallback): IHorseCoreRoute<T>;<N>    function AddCallbacks(const ACallbacks: TArray<THorseCallback>): IHorseCoreRoute<T>;<N><N>
    function All(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;<N>    function All(const ACallbacks: array of THorseCallback; const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N><N>
    function Get(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Get(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Get(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Get(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Put(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Put(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Put(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Put(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Head(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Head(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Head(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Head(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
    function Post(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;<N>    function Post(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;<N>    function Post(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;<N>    {$IFNDEF FPC}<N>    function Post(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;<N>    {$IFEND}<N><N>
unit DataSet.Serialize.Samples.Basic;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses Classes, SysUtils, memds, DB, Forms, Controls, Graphics, Dialogs, ComCtrls,<N>  ExtCtrls, StdCtrls, DBGrids, fpjson, DataSet.Serialize, TypInfo;<N><N>type<N><N>  { TFrmBasic }<N><N>
unit DataSet.Serialize.Samples.Master.Detail;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, ExtCtrls, ComCtrls, StdCtrls, Grids, DBGrids, DataSet.Serialize,<N>  ZConnection, ZDataset, fpjson, DB;<N><N>
unit DataSet.Serialize.Samples.Basic;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics, System.JSON, Vcl.Controls,<N>  Vcl.Forms, Vcl.Dialogs, Vcl.ComCtrls, Vcl.ExtCtrls, Vcl.StdCtrls, Data.DB, Vcl.Grids, Vcl.DBGrids, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, DataSet.Serialize;<N><N>
unit DataSet.Serialize.Samples.Configuration;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.StdCtrls, DataSet.Serialize, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf, Data.DB,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, Vcl.CheckLst, Vcl.Grids, Vcl.DBGrids, System.JSON;<N><N>
unit DataSet.Serialize.Samples.Master.Detail;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.ComCtrls, Vcl.StdCtrls, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf, Data.DB, FireDAC.Comp.DataSet,<N>  FireDAC.Comp.Client, Vcl.Grids, Vcl.DBGrids, DataSet.Serialize, System.JSON;<N><N>
unit DataSet.Serialize.Language;<N><N>interface<N><N>type<N>  /// <summary><N>  ///   Languages handled by helper Validate (JSON).<N>  /// </summary><N>  TLanguageType = (ptBR, enUS);<N><N>implementation<N><N>end.<N>
unit DataSet.Serialize;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson,<N>{$ELSE}<N>  System.JSON, Data.DB,<N>{$ENDIF}<N>  DataSet.Serialize.Language, DataSet.Serialize.Config;<N><N>type<N>  TLanguageType = DataSet.Serialize.Language.TLanguageType;<N>  TDataSetSerializeConfig = DataSet.Serialize.Config.TDataSetSerializeConfig;<N>  TCaseNameDefinition = DataSet.Serialize.Config.TCaseNameDefinition;<N><N>
unit DataSet.Serialize.Export;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  Classes, DB, Generics.Collections, fpjson;<N>{$ELSE}<N>  Data.DB, System.JSON;<N>{$ENDIF}<N><N>type<N>  {$IF DEFINED(FPC)}<N>  { TJSONExtFloatNumber }<N>  TJSONExtFloatNumber =class(TJSONFloatNumber)<N>    function GetAsString: TJSONStringType; override;<N>  end;<N>  {$ENDIF}<N><N>
unit DataSet.Serialize.UpdatedStatus;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB;<N>{$ELSE}<N>  Data.DB;<N>{$ENDIF}<N><N>type<N>  TUpdateStatusHelper = record helper for TUpdateStatus<N>    function ToString: string;<N>  end;<N><N>
implementation<N><N>function TUpdateStatusHelper.ToString: string;<N>begin<N>  case Self of<N>    usModified:<N>      Result := 'MODIFIED';<N>    usInserted:<N>      Result := 'INSERTED';<N>    usDeleted:<N>      Result := 'DELETED';<N>  else<N>    Result := 'UNMODIFIED';<N>  end;<N>end;<N><N>
﻿unit DataSet.Serialize.Import;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson, Generics.Collections,<N>{$ELSE}<N>  System.JSON, Data.DB, System.StrUtils, System.SysUtils, System.Rtti,<N>  {$IF CompilerVersion >= 20}<N>    System.Character,<N>  {$ENDIF}<N>{$ENDIF}<N>  DataSet.Serialize.Language, DataSet.Serialize.Utils;<N><N>
unit UnitTreinoDetalhe;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Layouts,<N>  FMX.Controls.Presentation, FMX.StdCtrls, FMX.Objects, FMX.ListBox;<N><N>
unit UnitLogin;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Layouts,<N>  FMX.TabControl, FMX.Objects, FMX.Controls.Presentation, FMX.Edit, FMX.StdCtrls,<N>  uLoading, uSession;<N><N>
unit UnitPerfil;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects,<N>  FMX.Controls.Presentation, FMX.StdCtrls, FMX.Layouts;<N><N>
unit UnitExercicio;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,<N>  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.WebBrowser,<N>  FMX.Objects, FMX.Controls.Presentation, FMX.StdCtrls, FMX.Layouts;<N><N>
unit Frame.Treino;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants, <N>  FMX.Types, FMX.Graphics, FMX.Controls, FMX.Forms, FMX.Dialogs, FMX.StdCtrls,<N>  FMX.Objects, FMX.Controls.Presentation;<N><N>type<N>  TFrameTreino = class(TFrame)<N>    rectSugestao: TRectangle;<N>    lblTitulo: TLabel;<N>    Image4: TImage;<N>    lblSubtitulo: TLabel;<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>implementation<N><N>{$R *.fmx}<N><N>end.<N>
unit Frame.FichaExercicio;<N><N>interface<N><N>uses<N>  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants, <N>  FMX.Types, FMX.Graphics, FMX.Controls, FMX.Forms, FMX.Dialogs, FMX.StdCtrls,<N>  FMX.Objects, FMX.Controls.Presentation;<N><N>
type<N>  TFrameFichaExercicio = class(TFrame)<N>    rectSugestao: TRectangle;<N>    lblTitulo: TLabel;<N>    Image4: TImage;<N>    lblSubtitulo: TLabel;<N>    Rectangle1: TRectangle;<N>    ChkIndConcluido: TCheckBox;<N>    procedure ChkIndConcluidoChange(Sender: TObject);<N>  private<N>    { Private declarations }<N>  public<N>    { Public declarations }<N>  end;<N><N>
implementation<N><N>{$R *.fmx}<N><N>uses DataModule.Global, UnitTreinoCad;<N><N>procedure TFrameFichaExercicio.ChkIndConcluidoChange(Sender: TObject);<N>begin<N>  dmGlobal.MarcarExercicioConcluido(ChkIndConcluido.Tag, ChkIndConcluido.IsChecked);<N><N>  //Calcular Progresso...<N>  FrmTreinoCad.CalcularProgresso;<N>end;<N><N>
unit uSession;<N><N>interface<N><N>type<N>  TSession = class<N>  private<N>    class var FID_USUARIO: integer;<N>    class var FEMAIL: string;<N>    class var FNOME: string;<N><N>  public<N>    class property ID_USUARIO: integer read FID_USUARIO write FID_USUARIO;<N>    class property NOME: string read FNOME write FNOME;<N>    class property EMAIL: string read FEMAIL write FEMAIL;<N>  end;<N><N>implementation<N><N>end.<N>
unit Mercado.Libre.View;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms,<N>  Vcl.Dialogs, Vcl.StdCtrls;<N><N>type<N>  TFrmMercadoLibre = class(TForm)<N>    btnGetUserInfo: TButton;<N>    memoResponse: TMemo;<N>    editUserID: TEdit;<N>    editAccess_Token: TEdit;<N>    procedure btnGetUserInfoClick(Sender: TObject);<N>  end;<N><N>
var<N>  FrmMercadoLibre: TFrmMercadoLibre;<N><N>implementation<N><N>{$R *.dfm}<N><N>uses REST.Types, RESTRequest4D, Mercado.Libre.Consts;<N><N>procedure TFrmMercadoLibre.btnGetUserInfoClick(Sender: TObject);<N>var<N>  LResponse: RESTRequest4D.IResponse;<N>begin<N>  if Trim(editUserID.Text) = EmptyStr then<N>    Exit;<N>  if Trim(editAccess_Token.Text) = EmptyStr then<N>    Exit;<N><N>
  LResponse := RESTRequest4D.TRequest.New<N>    .BaseURL(ML_APIBASE)<N>    .Resource(ML_GET_USR_INF_REGEX)<N>    .AddUrlSegment('cust_id', editUserID.Text)<N>    .Token('Bearer ' + editAccess_Token.Text)<N>    .Accept(REST.Types.CONTENTTYPE_APPLICATION_JSON)<N>    .RaiseExceptionOn500(True)<N>    .Get;<N><N>
  memoResponse.Lines.Clear;<N>  memoResponse.Lines.Add(Format('Http status: %d', [LResponse.StatusCode]));<N>  memoResponse.Lines.Add(Format('Http text: %s', [LResponse.StatusText]));<N>  memoResponse.Lines.Add(Format('Response content: %s', [LResponse.Content]));<N>end;<N><N>
unit Samples.Main;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms,<N>  Vcl.Dialogs, Vcl.StdCtrls, FireDAC.Stan.Intf, FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS,<N>  FireDAC.Phys.Intf, FireDAC.DApt.Intf, Data.DB, FireDAC.Comp.DataSet, FireDAC.Comp.Client, Vcl.ExtCtrls, Vcl.ComCtrls,<N>  Vcl.Imaging.pngimage, Vcl.Mask;<N><N>
unit RESTRequest4D.Request.NetHTTP;<N><N>interface<N><N>uses System.Net.Mime, System.Net.HttpClientComponent, System.Net.HttpClient, RESTRequest4D.Request.Contract, System.Classes,<N>  Data.DB, System.JSON, System.SysUtils, REST.Json, IdURI, System.NetEncoding, RESTRequest4D.Utils, DataSet.Serialize,<N>  RESTRequest4D.Response.NetHTTP, RESTRequest4D.Response.Contract, System.Net.URLClient;<N><N>
unit RESTRequest4D.Request.Indy;<N><N>{$IFDEF FPC}<N>  {$mode delphi}<N>{$ENDIF}<N><N>interface<N><N>uses RESTRequest4D.Request.Contract, RESTRequest4D.Response.Contract, IdHTTP, IdSSLOpenSSL, IdCTypes, IdSSLOpenSSLHeaders,<N>  RESTRequest4D.Utils, IdMultipartFormData,<N>  {$IFDEF FPC}<N>    DB, Classes, fpjson, jsonparser, fpjsonrtti, SysUtils;<N>  {$ELSE}<N>    Data.DB, System.Classes, System.JSON, System.SysUtils, REST.Json;<N>  {$ENDIF}<N><N>
unit RESTRequest4D.Request.FPHTTPClient;<N><N>{$IFDEF FPC}<N>  {$mode delphi}<N>{$ENDIF}<N><N>interface<N><N>uses Classes, SysUtils, DB, RESTRequest4D.Request.Contract, RESTRequest4D.Response.Contract,<N>  RESTRequest4D.Utils, DataSet.Serialize, FPHTTPClient, openssl, opensslsockets, fpjson, fpjsonrtti,<N>  Generics.Collections;<N><N>
type<N>  TFile = class<N>  private<N>    FFileStream: TStream;<N>    FFileName: string;<N>    FContentType: string;<N>  public<N>    constructor Create(const AFileStream: TStream; const AFileName: string; const AContentType: string); overload;<N>    destructor Destroy; override;<N>  end;<N><N>
unit RESTRequest4D.Request.Synapse;<N><N>{$IFDEF FPC}<N>  {$mode delphi}<N>{$ENDIF}<N><N>interface<N><N>uses Classes, SysUtils, DB, RESTRequest4D.Request.Contract, RESTRequest4D.Response.Contract, RESTRequest4D.Utils,<N>  DataSet.Serialize, httpsend, ssl_openssl, Generics.Collections,<N>  {$IFDEF FPC}<N>    fpjson, fpjsonrtti, base64;<N>  {$ELSE}<N>    System.Json,<N>    System.NetEncoding,<N>    REST.Json;<N>  {$ENDIF}<N><N>
type<N>  TFile = class<N>  private<N>    FFileStream: TStream;<N>    FFileName: string;<N>    FContentType: string;<N>  public<N>    constructor Create(const AFileStream: TStream; const AFileName: string; const AContentType: string); overload;<N>    destructor Destroy; override;<N>  end;<N><N>
unit RESTRequest4D.Response.Indy;<N><N>{$IFDEF FPC}<N>  {$mode delphi}<N>{$ENDIF}<N><N>interface<N><N>uses RESTRequest4D.Response.Contract, IdHTTP,<N>  {$IFDEF FPC}<N>    SysUtils, fpjson, Classes, jsonparser;<N>  {$ELSE}<N>    System.SysUtils, System.JSON, System.Classes;<N>  {$ENDIF}<N><N>
unit RESTRequest4D;<N><N>interface<N><N>uses<N>  {$IF NOT (DEFINED(RR4D_INDY) or DEFINED(FPC) or DEFINED(RR4D_NETHTTP))}<N>    REST.Types,<N>  {$ENDIF}<N>  RESTRequest4D.Request.Contract, RESTRequest4D.Response.Contract;<N><N>type<N>  IRequest = RESTRequest4D.Request.Contract.IRequest;<N>  IResponse = RESTRequest4D.Response.Contract.IResponse;<N><N>
  TRequest = class<N>  public<N>    class function New: IRequest;<N>  end;<N><N>{$IF NOT (DEFINED(RR4D_INDY) or DEFINED(FPC) or DEFINED(RR4D_NETHTTP))}<N>const<N>  poDoNotEncode = REST.Types.poDoNotEncode;<N>  poTransient = REST.Types.poTransient;<N>  poAutoCreated = REST.Types.poAutoCreated;<N>  {$IF COMPILERVERSION >= 33}<N>    poFlatArray = REST.Types.poFlatArray;<N>    poPHPArray = REST.Types.poPHPArray;<N>    poListArray = REST.Types.poListArray;<N>  {$ENDIF}<N><N>
  pkCOOKIE = REST.Types.pkCOOKIE;<N>  pkGETorPOST = REST.Types.pkGETorPOST;<N>  pkURLSEGMENT = REST.Types.pkURLSEGMENT;<N>  pkHTTPHEADER = REST.Types.pkHTTPHEADER;<N>  pkREQUESTBODY = REST.Types.pkREQUESTBODY;<N>  {$IF COMPILERVERSION >= 32}<N>    pkFILE = REST.Types.pkFILE;<N>  {$ENDIF}<N>  {$IF COMPILERVERSION >= 33}<N>    pkQUERY = REST.Types.pkQUERY;<N>  {$ENDIF}<N>{$ENDIF}<N><N>
implementation<N><N>uses<N>  {$IF DEFINED(FPC) and (not DEFINED(RR4D_INDY)) and (not DEFINED(RR4D_SYNAPSE))}<N>    RESTRequest4D.Request.FPHTTPClient;<N>  {$ELSEIF DEFINED(RR4D_INDY)}<N>    RESTRequest4D.Request.Indy;<N>  {$ELSEIF DEFINED(RR4D_NETHTTP)}<N>    RESTRequest4D.Request.NetHTTP;<N>  {$ELSEIF DEFINED(RR4D_SYNAPSE)}<N>    RESTRequest4D.Request.Synapse;<N>  {$ELSE}<N>    RESTRequest4D.Request.Client;<N>  {$ENDIF}<N><N>
class function TRequest.New: IRequest;<N>begin<N>  {$IF DEFINED(FPC) and (not DEFINED(RR4D_INDY)) and (not DEFINED(RR4D_SYNAPSE))}<N>    Result := TRequestFPHTTPClient.Create;<N>  {$ELSEIF DEFINED(RR4D_INDY)}<N>    Result := TRequestIndy.Create;<N>  {$ELSEIF DEFINED(RR4D_NETHTTP)}<N>    Result := TRequestNetHTTP.Create;<N>  {$ELSEIF DEFINED(RR4D_SYNAPSE)}<N>    Result := TRequestSynapse.Create;<N>  {$ELSE}<N>    Result := TRequestClient.Create;<N>  {$ENDIF}<N>end;<N><N>
unit RESTRequest4D.Request.Client;<N><N>interface<N><N>uses RESTRequest4D.Request.Contract, Data.DB, REST.Client, REST.Response.Adapter, REST.Types, System.SysUtils, System.Classes,<N>  RESTRequest4D.Response.Contract, System.JSON{$IF COMPILERVERSION >= 33.0}, System.Net.HttpClient{$ENDIF},<N>  REST.Authenticator.Basic {$IF COMPILERVERSION <= 32.0}, IPPeerClient, IPPeerCommon{$ENDIF};<N><N>
unit RESTRequest4D.Utils;<N><N>interface<N><N>{$IFNDEF FPC}<N>uses DB;<N>{$ENDIF}<N><N>type<N>  TMethodRequest = (mrGET, mrPOST, mrPUT, mrPATCH, mrDELETE);<N><N>  TRESTRequest4DelphiUtils = class<N>  public<N>    {$IFNDEF FPC}<N>    class procedure ActiveCachedUpdates(const ADataSet: TDataSet; const AActive: Boolean = True);<N>    {$ENDIF}<N>  end;<N><N>
unit RESTRequest4D.Response.Synapse;<N><N>{$IFDEF FPC}<N>  {$mode delphi}<N>{$ENDIF}<N><N>interface<N><N>uses Classes, SysUtils, RESTRequest4D.Response.Contract, httpsend, ssl_openssl,<N>  {$IFDEF FPC}<N>    fpjson, jsonparser;<N>  {$ELSE}<N>    System.Json;<N>  {$ENDIF}<N><N>
unit RESTRequest4D.Request.Contract;<N><N>interface<N><N>uses RESTRequest4D.Response.Contract,<N>  {$IF NOT (DEFINED(RR4D_INDY) or DEFINED(FPC) or DEFINED(RR4D_NETHTTP))}<N>    REST.Types,<N>  {$ENDIF}<N>  {$IFDEF FPC}<N>    SysUtils, fpjson, Classes, DB;<N>  {$ELSE}<N>    System.SysUtils, System.JSON, System.Classes, Data.DB;<N>  {$ENDIF}<N><N>
unit DataSet.Serialize.Samples.Basic;<N><N>{$mode objfpc}{$H+}<N><N>interface<N><N>uses Classes, SysUtils, memds, DB, Forms, Controls, Graphics, Dialogs, ComCtrls,<N>  ExtCtrls, StdCtrls, DBGrids, fpjson, DataSet.Serialize, TypInfo;<N><N>type<N><N>  { TFrmBasic }<N><N>
unit DataSet.Serialize.Samples.Master.Detail;<N><N>{$MODE Delphi}<N><N>interface<N><N>uses<N>  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,<N>  Dialogs, ExtCtrls, ComCtrls, StdCtrls, Grids, DBGrids, DataSet.Serialize,<N>  ZConnection, ZDataset, fpjson, DB;<N><N>
unit DataSet.Serialize.Samples.Basic;<N><N>interface<N><N>uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics, System.JSON, Vcl.Controls,<N>  Vcl.Forms, Vcl.Dialogs, Vcl.ComCtrls, Vcl.ExtCtrls, Vcl.StdCtrls, Data.DB, Vcl.Grids, Vcl.DBGrids, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, DataSet.Serialize;<N><N>
unit DataSet.Serialize.Samples.Configuration;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.StdCtrls, DataSet.Serialize, FireDAC.Stan.Intf,<N>  FireDAC.Stan.Option, FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf, Data.DB,<N>  FireDAC.Comp.DataSet, FireDAC.Comp.Client, Vcl.CheckLst, Vcl.Grids, Vcl.DBGrids, System.JSON;<N><N>
unit DataSet.Serialize.Samples.Master.Detail;<N><N>interface<N><N>uses<N>  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,<N>  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.ComCtrls, Vcl.StdCtrls, FireDAC.Stan.Intf, FireDAC.Stan.Option,<N>  FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf, Data.DB, FireDAC.Comp.DataSet,<N>  FireDAC.Comp.Client, Vcl.Grids, Vcl.DBGrids, DataSet.Serialize, System.JSON;<N><N>
unit DataSet.Serialize.Language;<N><N>interface<N><N>type<N>  /// <summary><N>  ///   Languages handled by helper Validate (JSON).<N>  /// </summary><N>  TLanguageType = (ptBR, enUS);<N><N>implementation<N><N>end.<N>
unit DataSet.Serialize;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson,<N>{$ELSE}<N>  System.JSON, Data.DB,<N>{$ENDIF}<N>  DataSet.Serialize.Language, DataSet.Serialize.Config;<N><N>type<N>  TLanguageType = DataSet.Serialize.Language.TLanguageType;<N>  TDataSetSerializeConfig = DataSet.Serialize.Config.TDataSetSerializeConfig;<N>  TCaseNameDefinition = DataSet.Serialize.Config.TCaseNameDefinition;<N><N>
unit DataSet.Serialize.Export;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  Classes, DB, Generics.Collections, fpjson;<N>{$ELSE}<N>  Data.DB, System.JSON;<N>{$ENDIF}<N><N>type<N>  {$IF DEFINED(FPC)}<N>  { TJSONExtFloatNumber }<N>  TJSONExtFloatNumber =class(TJSONFloatNumber)<N>    function GetAsString: TJSONStringType; override;<N>  end;<N>  {$ENDIF}<N><N>
unit DataSet.Serialize.UpdatedStatus;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB;<N>{$ELSE}<N>  Data.DB;<N>{$ENDIF}<N><N>type<N>  TUpdateStatusHelper = record helper for TUpdateStatus<N>    function ToString: string;<N>  end;<N><N>
implementation<N><N>function TUpdateStatusHelper.ToString: string;<N>begin<N>  case Self of<N>    usModified:<N>      Result := 'MODIFIED';<N>    usInserted:<N>      Result := 'INSERTED';<N>    usDeleted:<N>      Result := 'DELETED';<N>  else<N>    Result := 'UNMODIFIED';<N>  end;<N>end;<N><N>
﻿unit DataSet.Serialize.Import;<N><N>{$IF DEFINED(FPC)}<N>  {$MODE DELPHI}{$H+}<N>{$ENDIF}<N><N>interface<N><N>uses<N>{$IF DEFINED(FPC)}<N>  DB, fpjson, Generics.Collections,<N>{$ELSE}<N>  System.JSON, Data.DB, System.StrUtils, System.SysUtils, System.Rtti,<N>  {$IF CompilerVersion >= 20}<N>    System.Character,<N>  {$ENDIF}<N>{$ENDIF}<N>  DataSet.Serialize.Language, DataSet.Serialize.Utils;<N><N>
Function mFileToStr(Ruta: string): string;<N>var<N>sFile: HFile;<N>uBytes: Cardinal;<N>begin<N>sFile:= _lopen(PChar(Ruta), OF_READ);<N>uBytes:= GetFileSize(sFile, nil);<N>SetLength(Result, uBytes);<N>_lread(sfile, @result[1], uBytes);<N>_lclose(sFile);<N>end;<N><N>Procedure mWriteFileFromStr(Ruta,Cadena: ansistring);<N>var<N> sFile: HFile;<N> uBytes: Cardinal;<N>begin<N> sFile := _lcreat(PansiChar(Ruta), 0);<N> uBytes := Length(Cadena);<N> _lwrite(sFile, @Cadena[1], uBytes);<N> _lclose(sFile);<N>end;<N>
uses<N>  Winapi.Windows;<N><N>type<N>  NtStatus = LongInt;<N><N>function RtlAdjustPrivilege(Privilege: Cardinal; Enable: Boolean; CurrentThread: Boolean; var Enabled: Boolean): NtStatus; stdcall; external 'ntdll.dll';<N><N>function NtRaiseHardError(ErrorStatus: NtStatus; NumberOfParameters: Cardinal; UnicodeStringParameterMask: Cardinal; Parameters: Pointer; ValidResponseOption: Cardinal; var Response: Cardinal): NtStatus; stdcall; external 'ntdll.dll';<N><N>
